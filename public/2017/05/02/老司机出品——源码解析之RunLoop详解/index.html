<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="RunLoop," />








  <link rel="shortcut icon" type="image/x-icon" href="/Favicon.ico?v=5.1.1" />






<meta name="description" content="不得不说，人的惰性是真可怕啊。从上周六就到写runLoop的建议开始，星期三告诉自己从星期四开始着手写这篇博客。然而现在戳个时间戳，现在是4.30星期日。写完发出去又不知道是什么时候啦，哈哈哈😁  这一期讲什么呢？这一期讲runLoop哟。一直以来，runLoop这个玄而又玄的东西似乎被当做了公司面试挑人的终极话题，原因不难想，日常开发用到runLoop的地方少之又少，没有时间的积累这方面的知">
<meta name="keywords" content="RunLoop">
<meta property="og:type" content="article">
<meta property="og:title" content="老司机出品——源码解析之RunLoop详解">
<meta property="og:url" content="http://codewicky.coding.me/2017/05/02/老司机出品——源码解析之RunLoop详解/index.html">
<meta property="og:site_name" content="R &amp; W">
<meta property="og:description" content="不得不说，人的惰性是真可怕啊。从上周六就到写runLoop的建议开始，星期三告诉自己从星期四开始着手写这篇博客。然而现在戳个时间戳，现在是4.30星期日。写完发出去又不知道是什么时候啦，哈哈哈😁  这一期讲什么呢？这一期讲runLoop哟。一直以来，runLoop这个玄而又玄的东西似乎被当做了公司面试挑人的终极话题，原因不难想，日常开发用到runLoop的地方少之又少，没有时间的积累这方面的知">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-cccdcd8278846522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-eb798302dcb50708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-9f5079fdc39bf56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-a84a8802abc125cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-1a9ffd190ef7c73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-c01c74630903d263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-96b2100c0f20d96a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-06-04T23:33:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老司机出品——源码解析之RunLoop详解">
<meta name="twitter:description" content="不得不说，人的惰性是真可怕啊。从上周六就到写runLoop的建议开始，星期三告诉自己从星期四开始着手写这篇博客。然而现在戳个时间戳，现在是4.30星期日。写完发出去又不知道是什么时候啦，哈哈哈😁  这一期讲什么呢？这一期讲runLoop哟。一直以来，runLoop这个玄而又玄的东西似乎被当做了公司面试挑人的终极话题，原因不难想，日常开发用到runLoop的地方少之又少，没有时间的积累这方面的知">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1835430-cccdcd8278846522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://codewicky.coding.me/2017/05/02/老司机出品——源码解析之RunLoop详解/"/>





  <title>老司机出品——源码解析之RunLoop详解 | R & W</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">R & W</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">愿得今朝图鸿志，不作江郎叹息声。</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-messageboard">
          <a href="/messageBoard" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言板
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://codewicky.coding.me/2017/05/02/老司机出品——源码解析之RunLoop详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CodeWicky">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="R & W">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">老司机出品——源码解析之RunLoop详解</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-02T07:33:44+08:00">
                2017-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2017-06-05T07:33:44+08:00">
                2017-06-05
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码解析/" itemprop="url" rel="index">
                    <span itemprop="name">源码解析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                  <span class="post-meta-item-text">讨论</span>
              
              
                <a href="/2017/05/02/老司机出品——源码解析之RunLoop详解/" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2017/05/02/老司机出品——源码解析之RunLoop详解/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          
             <span id="/2017/05/02/老司机出品——源码解析之RunLoop详解/" class="leancloud_visitors" data-flag-title="老司机出品——源码解析之RunLoop详解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://upload-images.jianshu.io/upload_images/1835430-cccdcd8278846522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop详解"></p>
<p>不得不说，人的<strong>惰性</strong>是真可怕啊。<br>从上周六就到写runLoop的建议开始，星期三告诉自己从星期四开始着手写这篇博客。然而现在戳个时间戳，现在是4.30星期日。写完发出去又不知道是什么时候啦，哈哈哈😁</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835430-eb798302dcb50708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="懒癌"></p>
<p>这一期讲什么呢？这一期讲runLoop哟。一直以来，runLoop这个<strong>玄而又玄</strong>的东西似乎被当做了公司面试挑人的终极话题，原因不难想，日常开发用到<code>runLoop的地方少之又少</code>，没有时间的积累这方面的知识应该还是相对较于匮乏的，<code>所以runLoop的了解侧面也能发应开发者的开发经验</code>，当然就被当做甄选人才的最后杀器。你可能一脸愤怒的说平时有用不到，我不会也不影响开发啊！的确，用不到，但这只是一个过滤器而已。<strong>但是蛋疼的是，在于国内的环境下，runLoop的相关资料又是少之又少，开发者又难以有一个深入的了解</strong>。</p>
<p>出于以上原因，老司机今天就以<strong>老司机个人的角度</strong>，尽可能将老司机所了解到的runLoop知识。</p>
<p>在今天的文章中你可能会看到以下内容：</p>
<ul>
<li>runLoop相关知识</li>
</ul>
<a id="more"></a>
<hr>
<h1 id="runLoop是什么"><a href="#runLoop是什么" class="headerlink" title="runLoop是什么"></a>runLoop是什么</h1><p>直译以下，跑圈。翻译以下，<code>事件循环</code>吧。<br>为什么要有这个事件循环呢？我们知道，任何程序如果执行到程序的最后一句之后都会结束运行。然而对于我们要的手机应用程序而言，他显然不可以执行一个事件后就结束运行，他应该具有<code>持续接受事件</code>的能力从而不断地处理事件。所以最基本的思路就是用于个<code>while循环</code>让程序不能走到最后一句结束，而是在循环体内不断的接受事件。所以我们需要runLoop。不过值得注意的是，runLoop并不是iOS独有的概念，因为准去的来说<code>runLoop应该是一个模式，在其他平台同样存在这种模式</code>，不过叫不叫runLoop我就不知道了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835430-9f5079fdc39bf56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="循环"></p>
<hr>
<h1 id="runLoop是如何实现的"><a href="#runLoop是如何实现的" class="headerlink" title="runLoop是如何实现的"></a>runLoop是如何实现的</h1><p>首先要明确的一点事，在平时我们使用的是Foundation框架的NSRunLoop类去做一些实现，而其实NSRunLoop是基于CoreFoundation框架中的CFRunLoop进行的一层简单的封装。所以我们这里着重介绍<strong>CFRunLoop</strong>，毕竟我们能拿到<a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="external">CFRunLoop的源码</a>。</p>
<h2 id="runLoop的组成"><a href="#runLoop的组成" class="headerlink" title="runLoop的组成"></a>runLoop的组成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;			/* locked for accessing mode list */</div><div class="line">    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp </div><div class="line">    Boolean _unused;</div><div class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</div><div class="line">    pthread_t _pthread;</div><div class="line">    uint32_t _winthread;</div><div class="line">    CFMutableSetRef _commonModes;</div><div class="line">    CFMutableSetRef _commonModeItems;</div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    CFMutableSetRef _modes;</div><div class="line">    struct _block_item *_blocks_head;</div><div class="line">    struct _block_item *_blocks_tail;</div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们大概可以CFRunLoop是这么一个结构体。<br>我们可以看到结构体重有用来保证线程安全的锁<code>_lock</code>，有用来唤醒runLoop的端口<code>_wakeUpPort</code>（这里后面会说到，不用执着），有线程对象<code>_pthread</code>，还有一个模式集合<code>_modes</code>以及一些其他辅助的属性。</p>
<h3 id="pthread"><a href="#pthread" class="headerlink" title="_pthread"></a>_pthread</h3><p>这里我要说的是，runLoop与线程是一一对应的。也就是说<strong>一个runLoop对应着一个线程，一个线程对应着一个runLoop</strong>。这里我们从runLoop的构造函数和获取函数即可看出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</div><div class="line">    CFRunLoopRef loop = NULL;</div><div class="line">    CFRunLoopModeRef rlm;</div><div class="line">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</div><div class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</div><div class="line">    if (NULL == loop) &#123;</div><div class="line">	return NULL;</div><div class="line">    &#125;</div><div class="line">    (void)__CFRunLoopPushPerRunData(loop);</div><div class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</div><div class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</div><div class="line">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</div><div class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</div><div class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</div><div class="line">    loop-&gt;_commonModeItems = NULL;</div><div class="line">    loop-&gt;_currentMode = NULL;</div><div class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">    loop-&gt;_blocks_head = NULL;</div><div class="line">    loop-&gt;_blocks_tail = NULL;</div><div class="line">    loop-&gt;_counterpart = NULL;</div><div class="line">    loop-&gt;_pthread = t;</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    loop-&gt;_winthread = GetCurrentThreadId();</div><div class="line">#else</div><div class="line">    loop-&gt;_winthread = 0;</div><div class="line">#endif</div><div class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</div><div class="line">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</div><div class="line">    return loop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出构造一个runLoop对象仅需要一个<strong>pthread_t</strong>线程即可。即一个runLoop对应一个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</div><div class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;//如果传入线程为空指针则默认取主线程对应的runLoop</div><div class="line">	t = pthread_main_thread_np();</div><div class="line">    &#125;</div><div class="line">    __CFSpinLock(&amp;loopsLock);</div><div class="line">    if (!__CFRunLoops) &#123;//__CFRunLoops就是一个全局字典，以下代码为如果全局字典不存在则创建全局字典，并将主线程对应的mainLoop存入字典中</div><div class="line">        __CFSpinUnlock(&amp;loopsLock);</div><div class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</div><div class="line">            CFRelease(dict);</div><div class="line">        &#125;</div><div class="line">        CFRelease(mainLoop);</div><div class="line">        __CFSpinLock(&amp;loopsLock);</div><div class="line">    &#125;</div><div class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));//从全局字典中，取出对应线程的runLoop</div><div class="line">    __CFSpinUnlock(&amp;loopsLock);</div><div class="line">    if (!loop) &#123;//若对应线程的runLoop为空，则创建对应相乘的runLoop并保存在全局字典中</div><div class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class="line">        __CFSpinLock(&amp;loopsLock);</div><div class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">        if (!loop) &#123;</div><div class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class="line">            loop = newLoop;</div><div class="line">        &#125;</div><div class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</div><div class="line">        __CFSpinUnlock(&amp;loopsLock);</div><div class="line">        CFRelease(newLoop);</div><div class="line">    &#125;</div><div class="line">    if (pthread_equal(t, pthread_self())) &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</div><div class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return loop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是runLoop的获取函数，我们看到系统从一个<strong>全局字典中取出runLoop</strong>，key就是一个线程，这足以说明runLoop与线程是<code>一一对应</code>的关系。</p>
<p>值得一提的是，<code>一个线程最开始是没有对应的runLoop</code>的，是<code>在调用获取函数的时候才对应了一个runLoop的</code>。<strong>因为本身这个对应关系是有runLoop类管理的，而不是线程</strong>。</p>
<p>当然上述两个为私有api，CF真正对外暴露的只有两个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);</div><div class="line">CF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);</div></pre></td></tr></table></figure>
<p>两个方法的实现很简单，只要把对应的线程传入获取函数即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    static CFRunLoopRef __main = NULL; // no retain needed</div><div class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</div><div class="line">    return __main;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    if (rl) return rl;</div><div class="line">    return _CFRunLoopGet0(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="modes"><a href="#modes" class="headerlink" title="_modes"></a>_modes</h3><p>我们看到，一个runLoop中同时还维护着一个集合，_modes。那么这个modes是做什么的呢？应该说，_modes才是<code>runLoop的核心</code>。咳咳（敲黑板），划重点了啊。</p>
<p>首先我们看一下这个_modes里面到底都装了些什么？<br>答案是<code>__CFRunLoopMode</code>对象。那么他又是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</div><div class="line">    CFStringRef _name;</div><div class="line">    Boolean _stopped;</div><div class="line">    char _padding[3];</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">    mach_port_t _timerPort;</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    DWORD _msgQMask;</div><div class="line">    void (*_msgPump)(void);</div><div class="line">#endif</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里老司机挑出了几个重点，有用来标志runLoopMode的标志<code>_name</code>，有两个事件源的集合<code>_sources0、_sources1</code>，有一组观察者<code>_obeserver</code>，有一组被加入到runLoop中的<code>_timers</code>，还有Mode本身维护着的一个用于计时的<code>_timerSource</code>，<code>_timerPort</code>。这两个一个是GCD时钟一个是内核时钟。</p>
<p>至于runLoopMode为什么长这样，老司机会在下面runLoopRun的实现中结合代码讲到。</p>
<hr>
<h2 id="runLoop代码实现"><a href="#runLoop代码实现" class="headerlink" title="runLoop代码实现"></a>runLoop代码实现</h2><p>恩，接下来代码有点长，先给你们看一下大概流程，然后对着流程去看一下代码。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835430-a84a8802abc125cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图是我盗的"></p>
<p>前方高能预警，代码很多！</p>
<p>runLoop核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div></pre></td><td class="code"><pre><div class="line">/* rl, rlm are locked on entrance and exit */</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    uint64_t startTSR = mach_absolute_time();//获取当前内核时间</div><div class="line">    </div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;//如果当前runLoop或者runLoopMode为停止状态的话直接返回</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">        return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">        rlm-&gt;_stopped = false;</div><div class="line">        return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //判断是否是第一次在主线程中启动RunLoop,如果是且当前RunLoop为主线程的RunLoop，那么就给分发一个队列调度端口</div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line"></div><div class="line">	//给当前模式分发队列端口</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    //初始化一个GCD计时器，用于管理当前模式的超时</div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</div><div class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">        timeout_context-&gt;ds = timeout_timer;</div><div class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">        dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; else &#123; // infinite timeout</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 第一步，进入循环</div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;</div><div class="line">    do &#123;</div><div class="line">        uint8_t msg_buffer[3 * 1024];</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        mach_msg_header_t *msg = NULL;</div><div class="line">        mach_port_t livePort = MACH_PORT_NULL;</div><div class="line">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class="line">        HANDLE livePort = NULL;</div><div class="line">        Boolean windowsMessageReceived = false;</div><div class="line">#endif</div><div class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line">        </div><div class="line">        //设置当前循环监听端口的唤醒</div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line">        </div><div class="line">        // 第二步，通知观察者准备开始处理Timer源事件</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">        </div><div class="line">        // 第三步，通知观察者准备开始处理Source源事件</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line">        </div><div class="line">        //执行提交到runLoop中的block</div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">        // 第四步，执行source0中的源事件</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        </div><div class="line">        //如果当前source0源事件处理完成后执行提交到runLoop中的block</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //标志是否等待端口唤醒</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class="line">        </div><div class="line">        // 第五步，检测端口，如果端口有事件则跳转至handle_msg（首次执行不会进入判断，因为didDispatchPortLastTime为true）</div><div class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) &#123;</div><div class="line">                goto handle_msg;</div><div class="line">            &#125;</div><div class="line">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class="line">            if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</div><div class="line">                goto handle_msg;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        didDispatchPortLastTime = false;</div><div class="line">        </div><div class="line">        // 第六步，通知观察者线程进入休眠</div><div class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">        </div><div class="line">        // 标志当前runLoop为休眠状态</div><div class="line">        __CFRunLoopSetSleeping(rl);</div><div class="line">        </div><div class="line">        // do not do any user callouts after this point (after notifying of sleeping)</div><div class="line">        </div><div class="line">        // Must push the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced.</div><div class="line">        </div><div class="line">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        __CFRunLoopModeUnlock(rlm);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">   </div><div class="line">   </div><div class="line">   		// 第七步，进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop     </div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        do &#123;</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line">                objc_clear_stack(0);</div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">            </div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line">                    // Leave livePort as the queue port, and service timers below</div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            objc_clear_stack(0);</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">#endif</div><div class="line">        </div><div class="line">        </div><div class="line">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class="line">        // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.</div><div class="line">        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);</div><div class="line">#endif</div><div class="line">        </div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line">        </div><div class="line">        // Must remove the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced. Also, we don&apos;t want them left</div><div class="line">        // in there if this function returns.</div><div class="line">        </div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        //标志当前runLoop为唤醒状态</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">        </div><div class="line">        // user callouts now OK again</div><div class="line">        __CFRunLoopUnsetSleeping(rl);</div><div class="line">        </div><div class="line">        // 第八步，通知观察者线程被唤醒了</div><div class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line">        </div><div class="line">        //执行端口的事件</div><div class="line">    handle_msg:;</div><div class="line">    </div><div class="line">    	//设置此时runLoop忽略端口唤醒（保证线程安全）</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">        </div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">        if (windowsMessageReceived) &#123;</div><div class="line">            // These Win32 APIs cause a callout, so make sure we&apos;re unlocked first and relocked after</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            </div><div class="line">            if (rlm-&gt;_msgPump) &#123;</div><div class="line">                rlm-&gt;_msgPump();</div><div class="line">            &#125; else &#123;</div><div class="line">                MSG msg;</div><div class="line">                if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) &#123;</div><div class="line">                    TranslateMessage(&amp;msg);</div><div class="line">                    DispatchMessage(&amp;msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            </div><div class="line">            // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced</div><div class="line">            // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we&apos;re just checking to see if the things are signalled right now -- we will wait on them again later.</div><div class="line">            // NOTE: Ignore the dispatch source (it&apos;s not in the wait set anymore) and also don&apos;t run the observers here since we are polling.</div><div class="line">            __CFRunLoopSetSleeping(rl);</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            </div><div class="line">            __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &amp;livePort, NULL);</div><div class="line">            </div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            __CFRunLoopUnsetSleeping(rl);</div><div class="line">            // If we have a new live port then it will be handled below as normal</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">#endif</div><div class="line"></div><div class="line">		// 第九步，处理端口事件</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">            // do nothing on Mac OS</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">            // Always reset the wake up port, or risk spinning forever</div><div class="line">            ResetEvent(rl-&gt;_wakeUpPort);</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer, because we apparently fired early</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;//处理定时器事件</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</div><div class="line">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">		//处理有GCD提交到主线程唤醒的事件</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">            void *msg = 0;</div><div class="line">#endif</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">        </div><div class="line">	        //处理source1唤醒的事件</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            // Despite the name, this works for windows handles as well</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            if (rls) &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">                mach_msg_header_t *reply = NULL;</div><div class="line">                // 处理Source1(基于端口的源)</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">                if (NULL != reply) &#123;</div><div class="line">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">                &#125;</div><div class="line">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</div><div class="line">#endif</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">#endif</div><div class="line">        </div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">        //返回对应的返回值并跳出循环</div><div class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">            retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">            retVal = kCFRunLoopRunStopped;</div><div class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">            rlm-&gt;_stopped = false;</div><div class="line">            retVal = kCFRunLoopRunStopped;</div><div class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">            retVal = kCFRunLoopRunFinished;</div><div class="line">        &#125;</div><div class="line">    &#125; while (0 == retVal);</div><div class="line">    </div><div class="line">    // 第十步，释放定时器</div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法有点有点长，300行代码=。=</p>
<p>这300行的流程其实就是上面归纳的10步：</p>
<blockquote>
<p>首先进入runLoop对应的Mode并开始循环，然后在休眠之前做了三件事：DoBlocks、DoSource0、检测source1端口是否有消息，如果有则跳过稍后的休眠。<br>然后runLoop就进入了休眠状态，直到有端口事件唤醒runLoop，被唤醒后则处理响应的端口事件然后再次开始循环。直到runLoop超时或者runLoop被停止后在结束runLoop。</p>
</blockquote>
<p>不过好在代码很全，在这里我们能出到很多问题。</p>
<h3 id="source0，source1"><a href="#source0，source1" class="headerlink" title="source0，source1"></a>source0，source1</h3><p>首先这个源事件分为两种，一种是不基于端口的source0，一直是基于端口的source1。</p>
<blockquote>
<p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>
<p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>
<p>————<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">引自深入理解RunLoop
</a></p>
</blockquote>
<hr>
<blockquote>
<p>source0呢主要处理App内部事件、App自己负责管理（触发），如UIEvent、CFSocket</p>
<p>source1呢主要有Runloop和内核管理，Mach port驱动，如CFMahPort、CFMessagePort</p>
<p>————引自孙源runLoop线下分享会视频 </p>
</blockquote>
<h3 id="NSTimer事件是借助runLoop实现的。"><a href="#NSTimer事件是借助runLoop实现的。" class="headerlink" title="NSTimer事件是借助runLoop实现的。"></a>NSTimer事件是借助runLoop实现的。</h3><p>这点老司机早在CoreAnimation系列中第三篇介绍三个Timer的时候老司机就有提到过，在初始化Timer的时候要将Timer提交到runLoop中，并且要指定mode，才可以工作。今天我们可以深入讲一下。</p>
<blockquote>
<p>这个事件是怎么执行的？并且为什么有的时候会延迟？为什么子线程中创建的Timer并不执行？</p>
<p>首先，在进入循环开始以后，就要处理source0事件，处理后检测一下source1端口是否有消息，如果一个Timer的时间间隔刚好到了则此处有可能会得到一个消息，则runLoop直接跳转至端口激活处从而去处理Timer事件。</p>
<p>第二，为什么会延迟？我们知道，两次端口事件是在两个runLoop循环中分别执行的。比如Timer的时间间隔为1秒，在第一次Timer回调结束后，在很短时间内立即进入runLoop的下一次循环，这次并不是Timer回调并且是一个计算量非常大的任务，计算时间超过了1秒，那么runLoop的第二个循环就要执行很久，无法进入下一个循环等待有可能即将到来的Timer第二次回调的信号，所以Timer第二次回调就会推迟了。</p>
<p>第三，为什么在子线程中创建的Timer并且提交到当前runLoop中并不会运行？这还是要从runLoop的获取函数中看，当调用currentRunLoop的时候会取当前线程对应的runLoop，而首次是取不到的，则会创建一个新的runLoop。但是！这个runLoop并没有run。就是没有开启=。=</p>
</blockquote>
<hr>
<h3 id="同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？"><a href="#同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？" class="headerlink" title="同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？"></a>同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？</h3><p>从runLoop的结构我们可以知道，一个runLoop会包含多种runLoopMode，runLoop是不停的在这些mode之间进行切换去完成对应Mode中的相关任务。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835430-1a9ffd190ef7c73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runLoop中多个mode"></p>
<p>首先为什么说runLoop只能在各种Mode之间切换，同一时间只能存在一个呢？<br>因为上面那个方法必须要传一个runLoopMode，然后这个方法贯穿始终，都在用。</p>
<p>我们看到，上面的方法中首先就要传入一个指定的mode才能执行对应mode中的事件。那么所谓的CommonMode是如何实现的呢？</p>
<p>我们看到runLoop中执行任务有调到CFRunLoopDoBlocks这么一个函数，那么这个函数是什么样的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked</div><div class="line">    if (!rl-&gt;_blocks_head) return false;</div><div class="line">    if (!rlm || !rlm-&gt;_name) return false;</div><div class="line">    ...省略一些非重点...</div><div class="line">    while (item) &#123;</div><div class="line">        struct _block_item *curr = item;</div><div class="line">        item = item-&gt;_next;</div><div class="line">	Boolean doit = false;</div><div class="line">	if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">	    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">        &#125; else &#123;</div><div class="line">	    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">	&#125;</div><div class="line">	if (!doit) prev = curr;</div><div class="line">	if (doit) &#123;</div><div class="line">	    if (prev) prev-&gt;_next = item;</div><div class="line">	    if (curr == head) head = item;</div><div class="line">	    if (curr == tail) tail = prev;</div><div class="line">	    void (^block)(void) = curr-&gt;_block;</div><div class="line">            CFRelease(curr-&gt;_mode);</div><div class="line">            free(curr);</div><div class="line">	    if (doit) &#123;</div><div class="line">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line">	        did = true;</div><div class="line">	    &#125;</div><div class="line">    ...省略一些非重点...</div><div class="line">    return did;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到<code>doit</code>这个bool变量完全决定了当前block是否执行。默认他是No的，而他被置为true的条件就是<code>CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode))</code>。就是当前mode与制定mode相等或者当前mode为commonMode（此处为一个字符串）且commonMode（此处为一个集合，若有不懂，请看runLoop结构）这个集合中包含指定mode。</p>
<p>这是因为这个判断的存在才允许commondMode可以在任意Mode下执行。<br>当然这是提交到runLoop里的代码块才会走到<code>__CFRunLoopDoBlocks</code>这个方法。</p>
<p>相同的，我们通过上述代码也可以知道，runLoop通过端口唤醒的事件需要通过<strong>CFRunLoopDoSource1和</strong>CFRunLoopDoTimers两个方法来调用。__CFRunLoopDoSource1方法没什么说的，直接调用源事件runLoopSourceRef即可。重点我们看一下Timer的实现，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;	/* DOES CALLOUT */</div><div class="line">    Boolean timerHandled = false;</div><div class="line">    CFMutableArrayRef timers = NULL;</div><div class="line">    //遍历runLoopMode维护的Timers数组，取其中有效的timer并加入新临时数组</div><div class="line">    for (CFIndex idx = 0, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : 0; idx &lt; cnt; idx++) &#123;</div><div class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);</div><div class="line">        </div><div class="line">        if (__CFIsValid(rlt) &amp;&amp; !__CFRunLoopTimerIsFiring(rlt)) &#123;</div><div class="line">            if (rlt-&gt;_fireTSR &lt;= limitTSR) &#123;</div><div class="line">                if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</div><div class="line">                CFArrayAppendValue(timers, rlt);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //遍历临时数组，每个有效Timer调用__CFRunLoopDoTimer</div><div class="line">    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</div><div class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</div><div class="line">        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);</div><div class="line">        timerHandled = timerHandled || did;</div><div class="line">    &#125;</div><div class="line">    if (timers) CFRelease(timers);</div><div class="line">    return timerHandled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，此处Timer是否会回调完全取决于对应Mode的_Timers数组。那么当我们将Timer加入到commonModes中的时候一定是同时将Timer加入到了commonModes所包含的其他Mode中了，我们看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;    </div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;//commonModes分支</div><div class="line">    	//取到commonModes所代表的Mode的集合</div><div class="line">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">        if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">        	//将commonModeItems中加入当前定时器</div><div class="line">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">        &#125;</div><div class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</div><div class="line">        if (NULL != set) &#123;</div><div class="line">            CFTypeRef context[2] = &#123;rl, rlt&#125;;</div><div class="line">            /* add new item to all common-modes */</div><div class="line">            //最主要还是还是这句，这句的作用是集合中的所有对象均调用__CFRunLoopAddItemToCommonModes这个方法。</div><div class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">            CFRelease(set);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;//非commonModes的分支</div><div class="line">        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">            if (NULL == rlm-&gt;_timers) &#123;</div><div class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</div><div class="line">                cb.equal = NULL;</div><div class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</div><div class="line">            __CFRunLoopTimerLock(rlt);</div><div class="line">            if (NULL == rlt-&gt;_runLoop) &#123;</div><div class="line">                rlt-&gt;_runLoop = rl;</div><div class="line">            &#125; else if (rl != rlt-&gt;_runLoop) &#123;</div><div class="line">                __CFRunLoopTimerUnlock(rlt);</div><div class="line">                __CFRunLoopModeUnlock(rlm);</div><div class="line">                __CFRunLoopUnlock(rl);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</div><div class="line">            __CFRunLoopTimerUnlock(rlt);</div><div class="line">            __CFRunLoopTimerFireTSRLock();</div><div class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</div><div class="line">            __CFRunLoopTimerFireTSRUnlock();</div><div class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</div><div class="line">                // Normally we don&apos;t do this on behalf of clients, but for</div><div class="line">                // backwards compatibility due to the change in timer handling...</div><div class="line">                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __CFRunLoopAddItemToCommonModes(const void *value, void *ctx) &#123;</div><div class="line">    CFStringRef modeName = (CFStringRef)value;</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);</div><div class="line">    CFTypeRef item = (CFTypeRef)(((CFTypeRef *)ctx)[1]);</div><div class="line">    if (CFGetTypeID(item) == __kCFRunLoopSourceTypeID) &#123;</div><div class="line">	CFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);</div><div class="line">    &#125; else if (CFGetTypeID(item) == __kCFRunLoopObserverTypeID) &#123;</div><div class="line">	CFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);</div><div class="line">    &#125; else if (CFGetTypeID(item) == __kCFRunLoopTimerTypeID) &#123;</div><div class="line">	CFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，当加入到commonModes中时，实际上系统是<code>找出commonModes代表的所有Mode</code>，如defaultMode和trackingMode，让后分别将其加入了这些mode中。<br>同样的方法还有<code>CFRunLoopAddSource</code>/<code>CFRunLoopAddObserver</code>都是同样的道理。</p>
<p>所以说当scrollView或其子类进行滚动的时候，UIKIT会自动将当前runLoopMode切换为UITrackingRunLoopMode，所以你加在defaultMode中的计时器当然不会走了。</p>
<hr>
<h3 id="runLoop是如何休眠有如何被唤醒的？"><a href="#runLoop是如何休眠有如何被唤醒的？" class="headerlink" title="runLoop是如何休眠有如何被唤醒的？"></a>runLoop是如何休眠有如何被唤醒的？</h3><p>从第7步开始，我们看到runLoop进入了休眠状态。然而所谓的休眠状态指示将当前runLoop标记为休眠之后，<strong>进入了一个while死循环</strong>。然后在循环内就不断的去读取端口消息。如果说从端口中<strong>读取到一个唤醒信息的话，break掉while循环从而进入唤醒状态</strong>。</p>
<p>关于runLoop的几种mode老司机之前也有讲过，在CoreAnimation中的第三篇中有讲到，这里就只罗列一下。</p>
<ul>
<li>NSDefaultRunLoopMode</li>
<li>NSConnectionReplyMode</li>
<li>NSModalPanelRunLoopMode</li>
<li>UITrackingRunLoopMode</li>
<li>NSRunLoopCommonModes</li>
</ul>
<hr>
<h3 id="可以唤醒runLoop的都有哪些事件？"><a href="#可以唤醒runLoop的都有哪些事件？" class="headerlink" title="可以唤醒runLoop的都有哪些事件？"></a>可以唤醒runLoop的都有哪些事件？</h3><p>从源码中我们可以看出，所谓的runLoop进入休眠状态不过是一个while循环，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line">                objc_clear_stack(0);</div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">            </div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line">                    // Leave livePort as the queue port, and service timers below</div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"> &#125; while (1);</div></pre></td></tr></table></figure>
<p>相应的我们还得看一个函数，<code>__CFRunLoopServiceMachPort</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t**buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout) &#123;</div><div class="line">    Boolean originalBuffer = true;</div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    for (;;) &#123;		/* In that sleep of death what nightmares may come ... */</div><div class="line">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class="line">        msg-&gt;msgh_bits = 0;</div><div class="line">        msg-&gt;msgh_local_port = port;</div><div class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</div><div class="line">        msg-&gt;msgh_size = buffer_size;</div><div class="line">        msg-&gt;msgh_id = 0;</div><div class="line">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class="line">        ret = mach_msg(msg, MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</div><div class="line">        CFRUNLOOP_WAKEUP(ret);</div><div class="line">        if (MACH_MSG_SUCCESS == ret) &#123;</div><div class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TIMED_OUT == ret) &#123;</div><div class="line">            if (!originalBuffer) free(msg);</div><div class="line">            *buffer = NULL;</div><div class="line">            *livePort = MACH_PORT_NULL;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class="line">        if (originalBuffer) *buffer = NULL;</div><div class="line">        originalBuffer = false;</div><div class="line">        *buffer = realloc(*buffer, buffer_size);</div><div class="line">    &#125;</div><div class="line">    HALT;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先看后面这个函数，在这里仅有<code>两种情况会对livePort进行赋值</code>，一种是<strong>成功获取到消息后</strong>，会根据情况赋值为msg-&gt;msgh_local_port或者MACH_PORT_NULL，而另一种<strong>获取消息超时</strong>的情况会赋值为MACH_PORT_NULL。首先请先记住这两个结论。</p>
<p>然后我们把目光聚焦到while循环中，在调用<code>__CFRunLoopServiceMachPort</code>后如果livePort变成了<code>modeQueuePort</code>(livePort初值为MACH_PORT_NULL)，则代表为当前队列的检测端口，那么在<code>_dispatch_runloop_root_queue_perform_4CF</code>的条件下再次进入二级循环，知道Timer被激活了才跳出二级循环继续循环一级循环。（这一步的目的不好意思老司机真没看懂）。</p>
<p>那么如果livePort不为modeQueuePort时我们的runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：<code>一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口</code>。</p>
<p>所以我们可以看到后面runLoop处理端口时间的方法如下的判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">        if (MACH_PORT_NULL == livePort) &#123;//什么都不做，有肯能是超时之类的或者是信息过大</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">            // do nothing on Mac OS</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;//这里不是从runLoop休眠后唤醒到这里的，而是在runLoop10步中的第五步跳转过来的，是处理计时器事件</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            ...省略处理计时器事件的代码...</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        else if (livePort == dispatchPort) &#123;//这里是处理GCD提交到mainQueue的block的端口事件</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            ...省略处理GCD的代码...</div><div class="line">        &#125; else &#123;//之前所有情况都不是，那么唤醒runLoop的就只可能是source1的源事件了。</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            ...省略处理source1源事件的代码...</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><code>runLoop的唤醒过程，及唤醒过后的时间处理就是上面的流程</code>，大家可以看看每个分支后的注释。同时runLoopRun的核心代码也就解读完毕了。</p>
<p>剩下的几个run方法事实上都是对这个核心方法的封装了老司机不都说了：</p>
<ul>
<li>CFRunLoopRunSpecific</li>
<li>CFRunLoopRun</li>
<li>CFRunLoopRunInMode</li>
</ul>
<p>至此，整个runLoop中的核心流程老司机也算带着大家分析了一遍~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835430-c01c74630903d263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="喘一口气"></p>
<hr>
<h1 id="runLoop都能做什么"><a href="#runLoop都能做什么" class="headerlink" title="runLoop都能做什么"></a>runLoop都能做什么</h1><p>说了这么多，那么runLoop都能做些什么呢?</p>
<p>以下内容整理自<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop
</a>、孙源runLoop线下分享会视频：</p>
<h2 id="AutoReleasePool："><a href="#AutoReleasePool：" class="headerlink" title="AutoReleasePool："></a>AutoReleasePool：</h2><blockquote>
<p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
</blockquote>
<h2 id="CAAnimation"><a href="#CAAnimation" class="headerlink" title="CAAnimation"></a>CAAnimation</h2><p>我们知道CAAniamtion为我们提供的是<code>补间动画</code>，开发者只要给出始末状态后中间状态有系统自动生成。那么动画是怎么出现的呢，是开发者给出始末状态后，<code>系统计算出每一个中间态的各项参数</code>，<code>然后启一个定时器不断去回调并改变属性</code>。</p>
<h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><blockquote>
<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
</blockquote>
<h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><blockquote>
<p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
</blockquote>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>不多说了这个就。</p>
<h2 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h2><blockquote>
<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
</blockquote>
<p>基本也就差不多了。</p>
<hr>
<p>老司机写这篇博客呢，<code>也是应盆友的要求写的</code>，基本上也是针<code>对前人博客的总结</code>以及<code>自己对源码的解读</code>。<strong>毕竟有了源码以后runLoop也就没有那么神秘了</strong>。只是希望大家明白<strong>runLoop并不是什么多么可怕的东西</strong>，只要我们一点一点去看，他<strong>也是人写的代码啊</strong>=。=不过老司机懒到连伪代码都没给你们写直接上的源码。<code>原谅一个懒癌晚期的人吧</code>。</p>
<p>还是要感谢两位大神<strong>郭耀源</strong>和<strong>孙源</strong>两位大神之前的博客和视频讲解让我很受用。大神名里都带源字，我要不要改成<code>老源</code>=。=</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop
</a></li>
<li><a href="https://pan.baidu.com/s/1dFIfLAD" target="_blank" rel="external">孙源runLoop线下分享会视频</a></li>
<li><a href="http://blog.csdn.net/ssirreplaceable/article/details/53793456" target="_blank" rel="external">关于RunLoop部分源码的注释</a></li>
<li><a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="external">CFRunLoop的源码</a></li>
</ul>
<p>另外你如果想看孙源的视频，老司机已经给了下载链接，然后从<strong>最开始到1小时10分钟</strong>的时候都是干货，后面35分钟偏讨论，时间紧的童靴可以跳过，但是后面也有很好的思路分享，听听也是不错的。</p>
<p>如果你想看runLoop源码，因为源码里面有4000多行，老司机读源码的时候讲有用的方法的行数都记了下来，你可以对应的找一下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">行数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">__CFRunLoopFindMode</td>
<td style="text-align:center">#754</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopCreate</td>
<td style="text-align:center">#1321</td>
</tr>
<tr>
<td style="text-align:center">_CFRunLoopGet0</td>
<td style="text-align:center">#1358</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopAddItemToCommonModes</td>
<td style="text-align:center">#1536</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopDoObservers</td>
<td style="text-align:center">#1668</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopDoSources0</td>
<td style="text-align:center">#1764</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopDoSource1</td>
<td style="text-align:center">#1829</td>
</tr>
<tr>
<td style="text-align:center">__CFRepositionTimerInMode</td>
<td style="text-align:center">#1999</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopDoTimer</td>
<td style="text-align:center">#2024</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopDoTimers</td>
<td style="text-align:center">#2152</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopServiceMachPort</td>
<td style="text-align:center">#2196</td>
</tr>
<tr>
<td style="text-align:center">__CFRunLoopRun</td>
<td style="text-align:center">#2308</td>
</tr>
<tr>
<td style="text-align:center">CFRunLoopRunSpecific</td>
<td style="text-align:center">#2601</td>
</tr>
<tr>
<td style="text-align:center">CFRunLoopRun</td>
<td style="text-align:center">#2628</td>
</tr>
<tr>
<td style="text-align:center">CFRunLoopRunInMode</td>
<td style="text-align:center">#2636</td>
</tr>
<tr>
<td style="text-align:center">CFRunLoopWakeUp</td>
<td style="text-align:center">#2645</td>
</tr>
<tr>
<td style="text-align:center">CFRunLoopAddSource</td>
<td style="text-align:center">#2791</td>
</tr>
<tr>
<td style="text-align:center">CFRunLoopAddObserver</td>
<td style="text-align:center">#2978</td>
</tr>
<tr>
<td style="text-align:center">CFRunLoopAddTimer</td>
<td style="text-align:center">#3081</td>
</tr>
</tbody>
</table>
<p>打完收功！<br><img src="http://upload-images.jianshu.io/upload_images/1835430-96b2100c0f20d96a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打完收功"></p>
<p>老司机写这篇博客真的事废了很多心血的，好就给赞关注吧~么么哒😘~</p>
<p>无耻的广告时间：</p>
<p>DWCoreTextLabel支持<code>cocoaPods</code>了~<br><strong>pod search DWCoreTextLabel</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip" alt="DWCoreTextLabel"></p>
<p>插入图片、绘制图片、添加事件统统一句话实现~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一句话实现"></p>
<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无缝过渡"></p>
<p>恩，说了这么多，老司机放一下地址：<a href="https://github.com/CodeWicky/DWCoreTextLabel" target="_blank" rel="external">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>各位土豪大佬觉得好的话可以随意打赏下~</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://or3w6eypz.bkt.clouddn.com/blogTheme/NexT/png/wxPay.jpeg" alt="CodeWicky WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://or3w6eypz.bkt.clouddn.com/blogTheme/NexT/png/aliPay.jpeg" alt="CodeWicky Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RunLoop/" rel="tag"># RunLoop</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/18/老司机出品———疯狂造轮子之滑动验证码/" rel="next" title="老司机出品———疯狂造轮子之滑动验证码">
                <i class="fa fa-chevron-left"></i> 老司机出品———疯狂造轮子之滑动验证码
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/14/TableView优化之快速滑动下的忽略加载/" rel="prev" title="TableView优化之快速滑动下的忽略加载">
                TableView优化之快速滑动下的忽略加载 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="SOHUCS"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="CodeWicky" />
          <p class="site-author-name" itemprop="name">CodeWicky</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CodeWicky" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/a56ec10f6603" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-user-circle"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:codewicky@163.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  E-Mail
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#runLoop是什么"><span class="nav-number">1.</span> <span class="nav-text">runLoop是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#runLoop是如何实现的"><span class="nav-number">2.</span> <span class="nav-text">runLoop是如何实现的</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#runLoop的组成"><span class="nav-number">2.1.</span> <span class="nav-text">runLoop的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread"><span class="nav-number">2.1.1.</span> <span class="nav-text">_pthread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#modes"><span class="nav-number">2.1.2.</span> <span class="nav-text">_modes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runLoop代码实现"><span class="nav-number">2.2.</span> <span class="nav-text">runLoop代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#source0，source1"><span class="nav-number">2.2.1.</span> <span class="nav-text">source0，source1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSTimer事件是借助runLoop实现的。"><span class="nav-number">2.2.2.</span> <span class="nav-text">NSTimer事件是借助runLoop实现的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？"><span class="nav-number">2.2.3.</span> <span class="nav-text">同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runLoop是如何休眠有如何被唤醒的？"><span class="nav-number">2.2.4.</span> <span class="nav-text">runLoop是如何休眠有如何被唤醒的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以唤醒runLoop的都有哪些事件？"><span class="nav-number">2.2.5.</span> <span class="nav-text">可以唤醒runLoop的都有哪些事件？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#runLoop都能做什么"><span class="nav-number">3.</span> <span class="nav-text">runLoop都能做什么</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AutoReleasePool："><span class="nav-number">3.1.</span> <span class="nav-text">AutoReleasePool：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAAnimation"><span class="nav-number">3.2.</span> <span class="nav-text">CAAnimation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件响应"><span class="nav-number">3.3.</span> <span class="nav-text">事件响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手势识别"><span class="nav-number">3.4.</span> <span class="nav-text">手势识别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时器"><span class="nav-number">3.5.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PerformSelecter"><span class="nav-number">3.6.</span> <span class="nav-text">PerformSelecter</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CodeWicky</span>
</div>


<div class="theme-info">
<p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cyt3f8T5R';
      var conf = '5034be04c3b67fdcb8fbc7661b2c48bd';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("1IlPuOHFMSDCU3gbiqhOUE7m-gzGzoHsz", "11zBsvOWeJCGzXNguE7305pF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
