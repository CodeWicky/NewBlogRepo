{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Favicon.ico","path":"Favicon.ico","modified":1,"renderable":0},{"_id":"themes/NexT/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":0},{"_id":"themes/NexT/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/NexT/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/Favicon.ico","hash":"0fcc7e39549b82d073ba412afb01c46735b5e1a7","modified":1497064529000},{"_id":"themes/NexT/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1497064529000},{"_id":"themes/NexT/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1497064529000},{"_id":"themes/NexT/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1497064529000},{"_id":"themes/NexT/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1497064529000},{"_id":"themes/NexT/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1497064529000},{"_id":"themes/NexT/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1497064529000},{"_id":"themes/NexT/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1497064529000},{"_id":"themes/NexT/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1497064529000},{"_id":"themes/NexT/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1497064529000},{"_id":"themes/NexT/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1497064529000},{"_id":"themes/NexT/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1497064529000},{"_id":"themes/NexT/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1497064529000},{"_id":"themes/NexT/_config.yml","hash":"e666f73230b4906f4747b5141d8130212858ba25","modified":1497080227000},{"_id":"themes/NexT/bower.json","hash":"be0a430362cb73a7e3cf9ecf51a67edf8214b637","modified":1497064529000},{"_id":"themes/NexT/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1497064529000},{"_id":"themes/NexT/package.json","hash":"7e87b2621104b39a30488654c2a8a0c6a563574b","modified":1497064529000},{"_id":"source/_posts/老司机带你走进Core-Animation-之CADis.textClipping","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497092913000},{"_id":"source/_posts/CoreText实现图文混排.md","hash":"519b779ac4797d057990ac1de49b95eba0808ee7","modified":1497096250000},{"_id":"source/_posts/CoreText实现图文混排之文字环绕及点击算法.md","hash":"e00d8ec4003e203a1111f238c38a58c54c530eb7","modified":1497095042000},{"_id":"source/_posts/CoreText实现图文混排之点击事件.md","hash":"c6de0bb88af0b57c48cba12de00d6aca05419c60","modified":1497095870000},{"_id":"source/_posts/TableView优化之快速滑动下的忽略加载.md","hash":"b180433f3e10730e5a7da044c729b1387781ebe0","modified":1497094548000},{"_id":"source/_posts/TableView优化之高度缓存.md","hash":"892d4ee7ed135aecf2ea79d96faccd3d1145f255","modified":1497095418000},{"_id":"source/_posts/TableView加载图片的优化逻辑.md","hash":"6282d6cf7ba0f77b2152dc9599edc7f1d7803a62","modified":1497091863000},{"_id":"source/_posts/老司机出品———疯狂造轮子之图片异步下载类.md","hash":"ad6a837705306e49c664bb8b0db3784c2ca6ee3d","modified":1497093888000},{"_id":"source/_posts/老司机出品———疯狂造轮子之滑动验证码.md","hash":"b05039b8c61de599205525f8129684cefec25ca8","modified":1497094122000},{"_id":"source/_posts/老司机出品——包教包会之玩转正则表达式.md","hash":"b9029b670134a05ed7ee06ea980e78244cfcdf42","modified":1497093538000},{"_id":"source/_posts/老司机出品——源码解析之RunLoop详解.md","hash":"a62f778a494300efbbe011afef35a2753b99363e","modified":1497094754000},{"_id":"source/_posts/老司机出品——源码解析之从Block说开去.md","hash":"d065da2faf606fecb7d9f8f331979365ccd950d4","modified":1497091546000},{"_id":"source/_posts/老司机带你走进Core-Animation-之CAAnimation.md","hash":"eac73fad85b89c11eb55626104a74f41a1c2e220","modified":1497095324000},{"_id":"source/_posts/老司机带你走进Core-Animation-之CADisplayLink.md","hash":"5064165bf5c596dc69b2441395c551b0e70a3aa3","modified":1497092903000},{"_id":"source/_posts/老司机带你走进Core-Animation-之CAShapeLayer和CATextLayer.md","hash":"8f0e0b19a8fc371686a0c9c2d5ff2bd0817b491a","modified":1497092815000},{"_id":"source/_posts/老司机带你走进Core-Animation-之几种动画的简单应用.md","hash":"dd1beafef4b99dd6c7abe40ff6e127d00bc23694","modified":1497091277000},{"_id":"source/_posts/老司机带你走进Core-Animation-之图层的透视、渐变及复制.md","hash":"7529a9f35b5dcc967818b84a3f5ca78012ce0b92","modified":1497095169000},{"_id":"source/_posts/老司机带你走进Core-Animation-之粒子发射、TileLayer与异步绘制.md","hash":"b5468b278e0c11da61356321661179506819cad5","modified":1497091438000},{"_id":"source/_posts/老司机踩坑系列————中文排序.md","hash":"37d833c04edbdcf42f054aca2c8b8ce95d6b91aa","modified":1497094476000},{"_id":"source/categories/index.md","hash":"72efee095584bcbdced5eeff7406158d74d9da8e","modified":1497064529000},{"_id":"source/messageBoard/index.md","hash":"a1ce8fa9f6ff55d69fabea4f4ed0bbc5e554e067","modified":1497064529000},{"_id":"source/tags/index.md","hash":"0f070575952e04293abd6661d7add817d7266806","modified":1497064529000},{"_id":"themes/NexT/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1497064529000},{"_id":"themes/NexT/.github/ISSUE_TEMPLATE.md","hash":"fdd63b77472612337309eb93ec415a059b90756b","modified":1497064529000},{"_id":"themes/NexT/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1497064529000},{"_id":"themes/NexT/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1497064529000},{"_id":"themes/NexT/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1497064529000},{"_id":"themes/NexT/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1497064529000},{"_id":"themes/NexT/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1497064529000},{"_id":"themes/NexT/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1497064529000},{"_id":"themes/NexT/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1497064529000},{"_id":"themes/NexT/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1497064529000},{"_id":"themes/NexT/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1497064529000},{"_id":"themes/NexT/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1497064529000},{"_id":"themes/NexT/languages/zh-Hans.yml","hash":"fc93e7c9ee594878aa15526ab8d4a4b440b23db7","modified":1497064529000},{"_id":"themes/NexT/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1497064529000},{"_id":"themes/NexT/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1497064529000},{"_id":"themes/NexT/layout/_layout.swig","hash":"98910163f4bb2856692fdbb55d6e82233fb0c24e","modified":1497064529000},{"_id":"themes/NexT/layout/archive.swig","hash":"5de4dca06b05d99e4f6bad617a4b8f4f3592fb01","modified":1497064529000},{"_id":"themes/NexT/layout/category.swig","hash":"82e7bc278559b4335ad974659104eaaf04863032","modified":1497064529000},{"_id":"themes/NexT/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1497064529000},{"_id":"themes/NexT/layout/page.swig","hash":"baa667bc801349d5c4984c0f172973d3780400df","modified":1497064529000},{"_id":"themes/NexT/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1497064529000},{"_id":"themes/NexT/layout/schedule.swig","hash":"f93c53f6fd5c712584f6efba6f770c30fa8a3e80","modified":1497064529000},{"_id":"themes/NexT/layout/tag.swig","hash":"2e73ee478e981092ea9a5d10dd472a9461db395b","modified":1497064529000},{"_id":"themes/NexT/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1497064529000},{"_id":"themes/NexT/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1497064529000},{"_id":"themes/NexT/source/404.html","hash":"f88f67e6d1103aa53416de855b2a864ee14a58ea","modified":1497064529000},{"_id":"themes/NexT/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1497064529000},{"_id":"themes/NexT/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1497064529000},{"_id":"themes/NexT/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1497064529000},{"_id":"source/images/avatar.png","hash":"78a0a60708f4ad71edc298bb83b02e700e0fd6db","modified":1497064529000},{"_id":"themes/NexT/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497064529000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1497094411000},{"_id":"themes/NexT/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1497064529000},{"_id":"themes/NexT/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1497064529000},{"_id":"themes/NexT/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1497064529000},{"_id":"themes/NexT/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1497064529000},{"_id":"themes/NexT/layout/_macro/post.swig","hash":"c22e98868ab41dfb0dae6538e4750b230895a30f","modified":1497064529000},{"_id":"themes/NexT/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1497064529000},{"_id":"themes/NexT/layout/_macro/sidebar.swig","hash":"a2b213c1a7c37cd6e4749f2018371f4c1f4f0d23","modified":1497064529000},{"_id":"themes/NexT/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/comments.swig","hash":"1c7d3c975e499b9aa3119d6724b030b7b00fc87e","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/footer.swig","hash":"ad6925a5730119cfd9a4664f9c74aef0837beb6f","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/head.swig","hash":"6a7eb93d8aa7d4baa472890bd666b921f449d8af","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1497064529000},{"_id":"themes/NexT/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1497064529000},{"_id":"themes/NexT/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1497064529000},{"_id":"themes/NexT/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1497064529000},{"_id":"themes/NexT/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1497064529000},{"_id":"themes/NexT/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1497064529000},{"_id":"themes/NexT/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1497064529000},{"_id":"themes/NexT/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1497064529000},{"_id":"themes/NexT/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1497064529000},{"_id":"themes/NexT/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1497064529000},{"_id":"themes/NexT/scripts/tags/note.js","hash":"21b102db8a01c7b15ae2c0ea3ef3d4cf807ec6ed","modified":1497064529000},{"_id":"themes/NexT/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1497064529000},{"_id":"themes/NexT/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1497064529000},{"_id":"themes/NexT/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1497064529000},{"_id":"themes/NexT/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1497064529000},{"_id":"themes/NexT/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1497064529000},{"_id":"themes/NexT/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1497064529000},{"_id":"themes/NexT/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1497064529000},{"_id":"themes/NexT/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1497064529000},{"_id":"themes/NexT/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1497064529000},{"_id":"themes/NexT/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1497064529000},{"_id":"themes/NexT/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1497064529000},{"_id":"themes/NexT/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1497064529000},{"_id":"themes/NexT/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1497064529000},{"_id":"themes/NexT/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1497064529000},{"_id":"themes/NexT/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1497064529000},{"_id":"themes/NexT/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497064529000},{"_id":"themes/NexT/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497064529000},{"_id":"themes/NexT/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497064529000},{"_id":"themes/NexT/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497064529000},{"_id":"themes/NexT/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497064529000},{"_id":"themes/NexT/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497064529000},{"_id":"themes/NexT/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1497064529000},{"_id":"themes/NexT/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1497064529000},{"_id":"themes/NexT/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1497064529000},{"_id":"themes/NexT/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/comments/index.swig","hash":"abb92620197a16ed2c0775edf18a0f044a82256e","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/comments/livere.swig","hash":"1d0d01aaeb7bcde3671263d736718f8837c20182","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/search/localsearch.swig","hash":"1f349aa30dd1f7022f7d07a1f085eea5ace3f26d","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1497064529000},{"_id":"themes/NexT/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1497064529000},{"_id":"themes/NexT/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1497064529000},{"_id":"themes/NexT/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1497064529000},{"_id":"themes/NexT/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1497064529000},{"_id":"themes/NexT/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1497064529000},{"_id":"themes/NexT/source/css/_variables/base.styl","hash":"d6a793bcada68d4b6c58392546bc48a482e4a7d3","modified":1497064529000},{"_id":"themes/NexT/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1497064529000},{"_id":"themes/NexT/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1497064529000},{"_id":"themes/NexT/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1497064529000},{"_id":"themes/NexT/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1497064529000},{"_id":"themes/NexT/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1497064529000},{"_id":"themes/NexT/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1497064529000},{"_id":"themes/NexT/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1497064529000},{"_id":"themes/NexT/source/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1497064529000},{"_id":"themes/NexT/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1497064529000},{"_id":"themes/NexT/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1497064529000},{"_id":"themes/NexT/source/js/src/utils.js","hash":"b2ea56de27fddc6d9118051da384f781cd93951d","modified":1497064529000},{"_id":"themes/NexT/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1497064529000},{"_id":"themes/NexT/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"3587602ad777b031628bb5944864d1a4fcfea4ac","modified":1497064529000},{"_id":"themes/NexT/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1497064529000},{"_id":"themes/NexT/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1497064529000},{"_id":"themes/NexT/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1497064529000},{"_id":"themes/NexT/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1497064529000},{"_id":"themes/NexT/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1497064529000},{"_id":"themes/NexT/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1497064529000},{"_id":"themes/NexT/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1497064529000},{"_id":"themes/NexT/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1497064529000},{"_id":"themes/NexT/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1497064529000},{"_id":"themes/NexT/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1497064529000},{"_id":"themes/NexT/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1497064529000},{"_id":"themes/NexT/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1497064529000},{"_id":"themes/NexT/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1497064529000},{"_id":"themes/NexT/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1497064529000},{"_id":"themes/NexT/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1497064529000},{"_id":"themes/NexT/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1497064529000},{"_id":"themes/NexT/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1497064529000},{"_id":"themes/NexT/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1497064529000},{"_id":"themes/NexT/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1497064529000},{"_id":"themes/NexT/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1497064529000},{"_id":"themes/NexT/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1497064529000},{"_id":"themes/NexT/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1497064529000},{"_id":"themes/NexT/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1497064529000},{"_id":"themes/NexT/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1497064529000},{"_id":"themes/NexT/source/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1497064529000},{"_id":"themes/NexT/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1497064529000},{"_id":"themes/NexT/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1497064529000},{"_id":"themes/NexT/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1497064529000},{"_id":"themes/NexT/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1497064529000},{"_id":"themes/NexT/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1497064529000},{"_id":"themes/NexT/source/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1497064529000},{"_id":"themes/NexT/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1497064529000},{"_id":"themes/NexT/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-reward.styl","hash":"12c3579807fe1dedffdd423761b447a2c2352790","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/post/post.styl","hash":"468bc734f47209096588ef1a8e55e60a3b12aa63","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/tags/note.styl","hash":"dfc86d37f5b580977d82af6ef835082d09a0c499","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1497064529000},{"_id":"themes/NexT/source/css/_common/components/third-party/third-party.styl","hash":"bb3be8374c31c372ed0995bd8030d2b920d581de","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1497064529000},{"_id":"themes/NexT/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1497064529000},{"_id":"themes/NexT/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1497064529000},{"_id":"themes/NexT/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1497064529000},{"_id":"themes/NexT/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1497064529000},{"_id":"themes/NexT/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1497064529000},{"_id":"themes/NexT/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1497064529000},{"_id":"themes/NexT/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1497064529000},{"_id":"themes/NexT/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1497064529000},{"_id":"themes/NexT/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1497064529000},{"_id":"public/messageBoard/index.html","hash":"e2bf4bc8d712904c96b4283347789f1044f11aeb","modified":1497096324350},{"_id":"public/archives/2016/04/index.html","hash":"bf755791aeb5c7b2c35f82994033c45560e32379","modified":1497096324351},{"_id":"public/archives/2016/06/index.html","hash":"56cf1e9385a8c996555855a97aa3662147d72ed4","modified":1497096324351},{"_id":"public/archives/2016/10/index.html","hash":"d936e97e00a04c1aad8a5c88c1974f03a5c5d457","modified":1497096324351},{"_id":"public/archives/2016/11/index.html","hash":"f1048498e10c333ec7af02aac7518230ca8b6bfd","modified":1497096324351},{"_id":"public/archives/2017/03/index.html","hash":"568ca3d6a4ca4cc6c1741d3024b28fd39d6bcb88","modified":1497096324351},{"_id":"public/archives/2017/04/index.html","hash":"be6f515420516f12b58ef3dd01ba11ab4f446230","modified":1497096324351},{"_id":"public/archives/2017/06/index.html","hash":"d920ac518dcd83256d45db8e161a32534fa226e5","modified":1497096324351},{"_id":"public/categories/疯狂造轮子/index.html","hash":"b0a1bf8c60eedfacdc4e44858fea2c942543beae","modified":1497096324352},{"_id":"public/categories/正则表达式/index.html","hash":"8f69bc2a440eb866dbe376f7a3a616a6693e2587","modified":1497096324352},{"_id":"public/categories/踩坑系列/index.html","hash":"eeb2d42ca80ed7641998642b57199976fc783a94","modified":1497096324352},{"_id":"public/tags/忽略加载/index.html","hash":"60204756e9796ed2f7f8eebdb5c5a9d26926b5a4","modified":1497096324354},{"_id":"public/tags/图片环绕/index.html","hash":"2ffb07a6712e78a192114e1a62a266e2b1c7816f","modified":1497096324354},{"_id":"public/tags/高度缓存/index.html","hash":"d65bfbe055c5cca4b3594075c87680954e970584","modified":1497096324354},{"_id":"public/tags/TableView图片加载/index.html","hash":"9e5fbefc4d4118d28b9a7af238e4b95a0ffb970b","modified":1497096324354},{"_id":"public/tags/异步下载/index.html","hash":"89786be7c9941c4a5b5876e17de19b2866706fb6","modified":1497096324354},{"_id":"public/tags/SDWebImage/index.html","hash":"373f89aabd85fe35b14e7a519d910c3a10efa23d","modified":1497096324354},{"_id":"public/tags/滑动验证码/index.html","hash":"572c74031764712790acd357a4c5089a3d78bd9a","modified":1497096324354},{"_id":"public/tags/正则表达式/index.html","hash":"956930ee50e6fa3e2afc4f16f8b82393e9d88376","modified":1497096324354},{"_id":"public/tags/RunLoop/index.html","hash":"f4951708790b2a8b9400afd1d2b6139b97229aa6","modified":1497096324354},{"_id":"public/tags/Block/index.html","hash":"8e267cd406a368ea9d97fa66fca826553a274531","modified":1497096324354},{"_id":"public/tags/循环引用/index.html","hash":"b296a7866842ad940041703b67d63dc696771d49","modified":1497096324354},{"_id":"public/tags/计时器/index.html","hash":"bb2ba0cb950fabab3ce22efb1851603000b5acaf","modified":1497096324354},{"_id":"public/tags/CAShapeLayer/index.html","hash":"f0e496ec7469444db7a89636407be47b61c11643","modified":1497096324354},{"_id":"public/tags/CATextLayer/index.html","hash":"9d739557ac7cc9c387a14dca3d5a880b8737f096","modified":1497096324356},{"_id":"public/tags/动画/index.html","hash":"83b5f0be68cd4bce304cdf1ccfdb355e238f425c","modified":1497096324356},{"_id":"public/tags/图层效果/index.html","hash":"6a3969265a95f383135d482c2c09671274d0272e","modified":1497096324356},{"_id":"public/tags/粒子效果/index.html","hash":"2d5cb622b83601810ff071052d91d3f1e2727671","modified":1497096324356},{"_id":"public/tags/大图绘制/index.html","hash":"bd268e06d0fe8052b66575d66ec1f030a2495baa","modified":1497096324356},{"_id":"public/tags/异步绘制/index.html","hash":"18573e82fa30ebae40e6669798f78bb6af51b99d","modified":1497096324356},{"_id":"public/tags/中文排序/index.html","hash":"69e4fa5803f39acc883ced2936f9c2aa58418646","modified":1497096324356},{"_id":"public/categories/index.html","hash":"11ea0c7165b6381a9dee2c6dd2380f6560821b38","modified":1497096324356},{"_id":"public/tags/index.html","hash":"8a6f2c02dfc71b20979f9ed92756210cfef4231f","modified":1497096324356},{"_id":"public/2017/06/05/老司机出品——源码解析之从Block说开去/index.html","hash":"ffe301e20e6302ecd1517b80aa4c1d22f44b711c","modified":1497096324356},{"_id":"public/2017/05/14/TableView优化之快速滑动下的忽略加载/index.html","hash":"5422927da6344128ba674520ed5dedc079bdf42c","modified":1497096324356},{"_id":"public/2017/05/21/老司机踩坑系列————中文排序/index.html","hash":"9a5b8dce65d0a6a049d89c8af61c23a2aba5e1a0","modified":1497096324356},{"_id":"public/2017/05/02/老司机出品——源码解析之RunLoop详解/index.html","hash":"126f4d7e293f6837cc8f98364bf274fbb0e744e4","modified":1497096324356},{"_id":"public/2017/04/18/老司机出品———疯狂造轮子之滑动验证码/index.html","hash":"99820e1052d3851e99ebb2f42f7b4f52bce4b73f","modified":1497096324358},{"_id":"public/2017/03/07/老司机出品———疯狂造轮子之图片异步下载类/index.html","hash":"9888266d2410c6b9c3b4eb6c41d18e7a8c9e81bd","modified":1497096324358},{"_id":"public/2017/02/15/老司机出品——包教包会之玩转正则表达式/index.html","hash":"adcc1d4a4035343e5d6bda29fbc99de643739da7","modified":1497096324359},{"_id":"public/2017/02/12/老司机带你走进Core-Animation-之粒子发射、TileLayer与异步绘制/index.html","hash":"6e074bc72410bc19c290dec4fbe9e0c27f16492e","modified":1497096324359},{"_id":"public/2016/12/25/CoreText实现图文混排之文字环绕及点击算法/index.html","hash":"491dacbc7eef3539cd474610bc54e090658e0dea","modified":1497096324359},{"_id":"public/2016/12/21/老司机带你走进Core-Animation-之图层的透视、渐变及复制/index.html","hash":"391beec26defd05bb306e03881a449bde072345d","modified":1497096324359},{"_id":"public/2016/11/19/老司机带你走进Core-Animation-之CAShapeLayer和CATextLayer/index.html","hash":"94671c466ab3760aa8b1cd3d5642da91de55a854","modified":1497096324359},{"_id":"public/2016/10/17/老司机带你走进Core-Animation-之几种动画的简单应用/index.html","hash":"2e84af1c5a81e36fe2855b5a35aadcd684fa34c6","modified":1497096324359},{"_id":"public/2016/09/21/老司机带你走进Core-Animation-之CADisplayLink/index.html","hash":"99f0ec2f8b54f604680d14b7292eb732a9c0e495","modified":1497096324359},{"_id":"public/2016/09/06/老司机带你走进Core-Animation-之CAAnimation/index.html","hash":"21e5e6053db00ce516721274a777c9663a4a1156","modified":1497096324359},{"_id":"public/2016/06/04/TableView优化之高度缓存/index.html","hash":"e46b964a441221d7b01c9d78ebf8372743ee0d2d","modified":1497096324359},{"_id":"public/2016/05/17/CoreText实现图文混排之点击事件/index.html","hash":"079b831fe7e1e918968b612c42768ade335c51e5","modified":1497096324359},{"_id":"public/2016/05/15/CoreText实现图文混排/index.html","hash":"59cc9160d05045b97a62ac09af1dcbb7ba957672","modified":1497096324359},{"_id":"public/2016/04/16/TableView加载图片的优化逻辑/index.html","hash":"52064a923de98d26156abfc38cb4af2ba2b13f1b","modified":1497096324361},{"_id":"public/archives/index.html","hash":"0e5b867388e53fcdaa89149563556aa9b786d80b","modified":1497096324361},{"_id":"public/archives/page/2/index.html","hash":"b75ec6b9b94e20886f13b9755d523de07db5056b","modified":1497096324361},{"_id":"public/archives/2016/index.html","hash":"4e0fa80844bd602ca6bc5538c2edbd84cfc307e4","modified":1497096324362},{"_id":"public/archives/2016/05/index.html","hash":"048ece0d1fe834fa951f8d38c66efd7f0d40abd3","modified":1497096324362},{"_id":"public/archives/2016/09/index.html","hash":"72ff32d7e305b18bd86677a2ce84e03a8a625a9d","modified":1497096324362},{"_id":"public/archives/2016/12/index.html","hash":"ad03a86cb192dae6411888e427f48acbe2addb88","modified":1497096324362},{"_id":"public/archives/2017/index.html","hash":"921b1e41bd745963791e366ed7f3deec48f4f45b","modified":1497096324362},{"_id":"public/archives/2017/02/index.html","hash":"6241a6456d3317a476d8e7a738b967cefa542f5f","modified":1497096324362},{"_id":"public/archives/2017/05/index.html","hash":"b9ce927f2b88203dd9f6056cb2a80f2d1aca1834","modified":1497096324362},{"_id":"public/categories/图文混排/index.html","hash":"78bf5ae8609b2b1e73a25abde7634a46723601a3","modified":1497096324362},{"_id":"public/categories/性能优化/index.html","hash":"ea37b4fc2608cd4c47bda373a80ef7631ede2f9f","modified":1497096324362},{"_id":"public/categories/源码解析/index.html","hash":"6ec3a02840d37937ee39adfcfeb2e2ed6741abb2","modified":1497096324362},{"_id":"public/categories/核心动画/index.html","hash":"d9321b65b8bb37025f2167960bef43f468214c60","modified":1497096324363},{"_id":"public/index.html","hash":"d619911c469134dfea9a635c3666b58d68db3bfc","modified":1497096324363},{"_id":"public/page/2/index.html","hash":"a5fb268363aaccd61d4a49c1821b5c6fb7a409e8","modified":1497096324363},{"_id":"public/tags/CoreText/index.html","hash":"099889b76e8834432ad2f54fc266ed7d87262742","modified":1497096324364},{"_id":"public/tags/图文混排/index.html","hash":"aa8682d62b073ae4f8ba5aa351963f4765980809","modified":1497096324364},{"_id":"public/tags/TableView优化/index.html","hash":"6adff2ee13d8587b17316435148be6ed2e0b1cd1","modified":1497096324364},{"_id":"public/tags/点击事件/index.html","hash":"9b8562c3b10d01e694e72804e53f4d64b1406a7a","modified":1497096324364},{"_id":"public/tags/CAAnimation/index.html","hash":"b83a617cd2f806d00f7c0a67ed6035e8a3440d8b","modified":1497096324364},{"_id":"public/tags/核心动画/index.html","hash":"2c462559ea1ae03c87c087ce226790f922f87c50","modified":1497096324364},{"_id":"public/Favicon.ico","hash":"0fcc7e39549b82d073ba412afb01c46735b5e1a7","modified":1497096324384},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1497096324384},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1497096324384},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1497096324384},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1497096324384},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1497096324384},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1497096324384},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1497096324384},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1497096324384},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1497096324385},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1497096324385},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1497096324385},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1497096324385},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1497096324385},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1497096324385},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1497096324385},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1497096324386},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1497096324386},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1497096324386},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1497096324386},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1497096324386},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1497096324386},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1497096324386},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1497096324386},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1497096324386},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1497096324386},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1497096324387},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1497096324387},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1497096324387},{"_id":"public/images/avatar.png","hash":"78a0a60708f4ad71edc298bb83b02e700e0fd6db","modified":1497096324940},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1497096324942},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1497096324955},{"_id":"public/404.html","hash":"f88f67e6d1103aa53416de855b2a864ee14a58ea","modified":1497096324962},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1497096324962},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1497096324962},{"_id":"public/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1497096324962},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1497096324962},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1497096324962},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1497096324962},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1497096324962},{"_id":"public/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1497096324962},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1497096324962},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1497096324962},{"_id":"public/js/src/utils.js","hash":"b2ea56de27fddc6d9118051da384f781cd93951d","modified":1497096324962},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1497096324962},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"3587602ad777b031628bb5944864d1a4fcfea4ac","modified":1497096324962},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1497096324962},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1497096324962},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1497096324962},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1497096324962},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1497096324962},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1497096324962},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1497096324962},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1497096324962},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1497096324962},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1497096324962},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1497096324962},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1497096324962},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1497096324962},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1497096324963},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1497096324964},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1497096324964},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1497096324964},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1497096324964},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1497096324964},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1497096324965},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1497096324965},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1497096324965},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1497096324965},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1497096324965},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1497096324965},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1497096324965},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1497096324965},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1497096324965},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1497096324965},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1497096324965},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1497096324965},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1497096324965},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1497096324965},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1497096324965},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1497096324965},{"_id":"public/css/main.css","hash":"d7094dd9728e49d043ebc7169f8a112adc6e9bf2","modified":1497096324965},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1497096324965},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1497096324965},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1497096324965},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1497096324965},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1497096324965},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1497096324965},{"_id":"public/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1497096324965},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1497096324965},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1497096324966},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1497096324966},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1497096324966},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1497096324966},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1497096324966},{"_id":"public/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1497096324966},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1497096324966},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1497096324966},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1497096324966},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1497096324966},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1497096324966},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1497096324966},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1497096324966},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1497096324979}],"Category":[{"name":"图文混排","_id":"cj3r8htos0004jigb6cx4s2vs"},{"name":"性能优化","_id":"cj3r8htp3000ajigb985be3w3"},{"name":"源码解析","_id":"cj3r8htpp000tjigbip8jhg4s"},{"name":"疯狂造轮子","_id":"cj3r8htpt000zjigbz7peari8"},{"name":"正则表达式","_id":"cj3r8htq10015jigbn6ojj78t"},{"name":"核心动画","_id":"cj3r8htqa001kjigbs4w4b5un"},{"name":"踩坑系列","_id":"cj3r8htqk0029jigbgiwe4lcm"}],"Data":[],"Page":[{"title":"分类","date":"2017-06-07T08:38:35.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-06-07 16:38:35\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-06-10T03:15:29.000Z","path":"categories/index.html","layout":"page","_id":"cj3r8htoo0001jigb1qiudfar","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"留言板","date":"2017-06-08T02:19:14.000Z","_content":"","source":"messageBoard/index.md","raw":"---\ntitle: 留言板\ndate: 2017-06-08 10:19:14\n\n\n---\n","updated":"2017-06-10T03:15:29.000Z","path":"messageBoard/index.html","comments":1,"layout":"page","_id":"cj3r8htor0003jigbtitlzhxz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-06-07T08:01:04.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-06-07 16:01:04\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-06-10T03:15:29.000Z","path":"tags/index.html","layout":"page","_id":"cj3r8htow0007jigblla2jr90","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CoreText实现图文混排","layout":"post","date":"2016-05-14T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![CoreText实现图文混排](http://upload-images.jianshu.io/upload_images/1835430-07e7d10e9bb52c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [CoreText实现图文混排](http://www.jianshu.com/p/6db3289fb05d)\n- [CoreText实现图文混排之点击事件](http://www.jianshu.com/p/51c47329203e)\n- [CoreText实现图文混排之文字环绕及点击算法](http://www.jianshu.com/p/e154047b0f98)\n- - -\n也好久没来写博客了，主要是最近也工作了，手头的事有点多，一时间也就断了，闲下来了我就来补博客了，刚好最近也做了很多东西，放在这里也算给自己做个笔记吧。\n\n----------\n# CoreText\n最近公司做了一个项目，需要用到`图文混排`技术。于是呢就疯狂地在网上搜刮资料。  \n不过很不幸的是，百度的CoreText资料还是比较少滴，翻来覆去就那几个版本。  \n然而我又上不去谷歌，so，困难重重啊。  \n不过虽然资料少，不够前辈们给的贡献终于还是在我的努力下都被我消化了，然后我也来做个笔记。\n\n- - - - \n## CoreText的介绍\nCore Text 是基于 iOS 3.2+ 和 OSX 10.5+ 的一种能够对文本格式和文本布局进行精细控制的文本引擎。  \n它良好的结合了 UIKit 和 Core Graphics/Quartz：  \n\n\n\tUIKit 的 UILabel 允许你通过在 IB 中简单的拖曳添加文本，但你不能改变文本的颜色和其中的单词。  \n\tCore Graphics/Quartz几乎允许你做任何系统允许的事情，但你需要为每个字形计算位置，并画在屏幕上。\n\tCore Text 正结合了这两者！你可以完全控制位置、布局、类似文本大小和颜色这样的属性，而 Core Text 将帮你完善其它的东西——类似文本换行、字体呈现等等。\n\n以上就是对CoreText的介绍。\n\n<!-- more -->\n\n\n---------\n## 老司机对CoreText实现图文混排的一些理解\n\n老司机认为，图文混排中使用到的CoreText只是CoreText庞大体系中一个对富文本的**增强**的一部分。\n我个人想法啊，我读书少，理解的可能不到位，不过你咬我啊。\n\n恩，我又逗逼了一波，说好的大师气质呢，下面开始严肃了啊。\n\n严肃的就是iOS7新推出的类库`Textkit`，其实是在之前推出的`CoreText上的封装`，根据苹果的说法，他们开发了两年多才完成，而且他们在开发时候也将表情混排作为一个使用案例进行研究，所以要`实现表情混排将会非常容易`。\n\n苹果引入TextKit的目的并非要取代已有的CoreText框架，虽然`CoreText的主要作用也是用于文字的排版和渲染`，但它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，`从性能和易用性来考虑`，`最佳方案就是使用CoreText`。\n原理的东西学一学总没有坏处。因此，还是有必要去学一学CoreText的。  \n那我们开始学习吧。\n- - - - -\n# 富文本\n老司机说过，我要讲的只是用来增强富文本的那一部分，那么富文本怎么使用呢。\n\n富文本是什么呢？\n\n> 富文本格式(RTF)规范是为了便于在应用程序之间轻松转储格式化文本和图形的一种编码方法。\n现在，用户可以利用特定转换软件，在不同系统如MS-DOS、Windows、OS/2、Macintosh和Power Macintosh的应用程序之间转移字处理文档。\nRTF规范提供一种在不同的输出设备、操作环境和操作系统之间交换文本和图形的一种格式。\nRTF使用ANSI, PC-8, Macintosh, 或IBM PC字符集控制文档的表示法和格式化，包括屏幕显示和打印\n。凭借RTF规范，不同的操作系统和不同的软件程序创建的文档能够在这些操作系统和应用程序之间传递。\n将一个格式化的文件转换为RTF文件的软件称为RTF书写器。\nRTF书写器用于分离现有文本中的程序控制信息，并且生成一个包含文本和与之相关的RTF组的新文件。将RTF文件转换成格式化文件的软件则称为RTF阅读器。\n\n简单的说，附`带有每一个文字属性的字符串`，就是富文本。  \n在iOS中，我们有一个专门的类来处理富文本 `AttributeString`。  \n- - - \n## 富文本的基本使用方法\n  \n诶，标题越来越小了，都4个#号了，说明我扯远了啊。不过要想使用CoreText不会富文本还是不行啊。\n\n来吧。  \nAttributedString也分为`NSAttributedString`和`NSMutableAttributedString`两个类，类似于String，我就不赘述了。  \n富文本本质上没有什么难度，只要给指定的字符串附上指定的属性就好了。下面给出富文本的一些基本方法。  \n\n- -initWithString:`以NSString初始化一个富文本对象`  \n- -setAttributes:range:`为富文本中的一段范围添加一些属性`，第一个参数是个NSDictionary字典，第二个参数是NSRange。\n- -addAttribute:value:range:`添加一个属性`\n- -addAttributes:range:`添加多个属性`\n- -removeAttribute:range:`移除属性`\n额,老司机知道这么说不直观，来来来，上代码。  \n\n```\nNSDictionary * dic = @{NSFontAttributeName:[UIFont fontWithName:@\"Zapfino\" size:20],NSForegroundColorAttributeName:[UIColor redColor],NSUnderlineStyleAttributeName:@(NSUnderlineStyleSingle)};\n    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@\"0我是一个富文本，9听说我有很多属性，19I will try。32这里清除属性.\"];\n//    设置属性\n    [attributeStr setAttributes:dic range:NSMakeRange(0, attributeStr.length)];\n//    添加属性\n    [attributeStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(9, 10)];\n    [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor cyanColor] range:NSMakeRange(13, 13)];\n//    添加多个属性\n    NSDictionary * dicAdd = @{NSBackgroundColorAttributeName:[UIColor yellowColor],NSLigatureAttributeName:@1};\n    [attributeStr addAttributes:dicAdd range:NSMakeRange(19, 13)];\n//    移除属性\n    [attributeStr removeAttribute:NSFontAttributeName range:NSMakeRange(32, 9)];\n    UILabel * label = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 200, 400)];\n    label.numberOfLines = 0;\n    label.attributedText = attributeStr;\n```\n\n这里你要注意一下，给label的一定是给他的`attributedText`属性，你给text是不行的。   \n是不是用起来很简单，富文本，跟字典没什么区别么。\n\n----\n# CoreText绘制富文本\n\n是不是终于进入正题了。其实之所以说那么多，还是为了你看完就能保证会用啊，否则你不会富文本你自己还要查找富文本相关资料。\n\n**Come On！**\n\nCoreText实现图文混排其实就是在富文本中`插入一个空白的图片占位符`的富文本字符串，通过`代理设置相关的图片尺寸信息`，根据从富文本得到的frame`计算图片绘制的frame再绘制图片`这么一个过程。  \n\n先来整体代码\n\n## 全部代码\n\n```\n-(void)drawRect:(CGRect)rect\n{\n    [super drawRect:rect];\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);\n    CGContextScaleCTM(context, 1.0, -1.0);\n    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@\"\\n这里在测试图文混排，\\n我是一个富文本\"];\n    CTRunDelegateCallbacks callBacks;\n    memset(&callBacks,0,sizeof(CTRunDelegateCallbacks));\n    callBacks.version = kCTRunDelegateVersion1;\n    callBacks.getAscent = ascentCallBacks;\n    callBacks.getDescent = descentCallBacks;\n    callBacks.getWidth = widthCallBacks;\n    NSDictionary * dicPic = @{@\"height\":@129,@\"width\":@400};\n    CTRunDelegateRef delegate = CTRunDelegateCreate(& callBacks, (__bridge void *)dicPic);\n    unichar placeHolder = 0xFFFC;\n    NSString * placeHolderStr = [NSString stringWithCharacters:&placeHolder length:1];\n    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];\n    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);\n    CFRelease(delegate);\n    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];\n    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathAddRect(path, NULL, self.bounds);\n    NSInteger length = attributeStr.length;\n    CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);\n    CTFrameDraw(frame, context);\n    \n    UIImage * image = [UIImage imageNamed:@\"bd_logo1\"];\n    CGRect imgFrm = [self calculateImageRectWithFrame:frame];\n    CGContextDrawImage(context,imgFrm, image.CGImage);\n    CFRelease(frame);\n    CFRelease(path);\n    CFRelease(frameSetter);\n}\nstatic CGFloat ascentCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"height\"] floatValue];\n}\nstatic CGFloat descentCallBacks(void * ref)\n{\n    return 0;\n}\nstatic CGFloat widthCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"width\"] floatValue];\n}\n\n\n-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame\n{\n    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);\n    NSInteger count = [arrLines count];\n    CGPoint points[count];\n    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);\n    for (int i = 0; i < count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)arrLines[i];\n        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);\n        for (int j = 0; j < arrGlyphRun.count; j ++) {\n            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];\n            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];\n            if (delegate == nil) {\n                continue;\n            }\n            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);\n            if (![dic isKindOfClass:[NSDictionary class]]) {\n                continue;\n            }\n            CGPoint point = points[i];\n            CGFloat ascent;\n            CGFloat descent;\n            CGRect boundsRun;\n            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, &descent, NULL);\n            boundsRun.size.height = ascent + descent;\n            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);\n            boundsRun.origin.x = point.x + xOffset;\n            boundsRun.origin.y = point.y - descent;\n            CGPathRef path = CTFrameGetPath(frame);\n            CGRect colRect = CGPathGetBoundingBox(path);\n            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);\n            return imageBounds;\n        }\n    }\n    return CGRectZero;\n}\n```\n\n不瞒你说，我看着代码都烦，也怕，所以放心，老司机会一句一句给你解释的。\n- - - \n\n## 分段解析\n### 准备工作\n\n```\nCGContextRef context = UIGraphicsGetCurrentContext();\nCGContextSetTextMatrix(context, CGAffineTransformIdentity);    \nCGContextTranslateCTM(context, 0, self.bounds.size.height);\nCGContextScaleCTM(context, 1.0, -1.0);\n```\n先要来一个背景介绍哈\n\n    /*\n     coreText 起初是为OSX设计的，而OSX得坐标原点是左下角，y轴正方向朝上。iOS中坐标原点是左上角，y轴正方向向下。\n     若不进行坐标转换，则文字从下开始，还是倒着的\n     \t如下图(盗的图，别打我)\n     */\n     \n![系统坐标系](http://upload-images.jianshu.io/upload_images/1835430-597db8c1833bf0c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n\n\n这四句什么意思呢？  \n\n#### 获取上下文  \n```\nCGContextRef context = UIGraphicsGetCurrentContext();//获取当前绘制上下文\n```\n\n  \n为什么要回去上下文呢？因为我们所有的绘制操作都是在上下文上进行绘制的。 \n \n#### 坐标转换\n\n```\nCGContextSetTextMatrix(context, CGAffineTransformIdentity);//设置字形的变换矩阵为不做图形变换  \n    CGContextTranslateCTM(context, 0, self.bounds.size.height);//平移方法，将画布向上平移一个屏幕高  \n    CGContextScaleCTM(context, 1.0, -1.0);//缩放方法，x轴缩放系数为1，则不变，y轴缩放系数为-1，则相当于以x轴为轴旋转180度\n```\n\n正如之上的背景说的，coreText使用的是`系统坐标`，然而我们平时所接触的iOS的都是`屏幕坐标`，所以要将屏幕坐标系`转换`系统坐标系，这样才能与我们想想的坐标互相对应。  \n`事实上呢，这三句是翻转画布的固定写法，这三句你以后会经常看到的。`\n\n继续。\n- - -\n#### 图片的代理的设置\n\n> 事实上，图文混排就是在要插入图片的位置插入一个富文本类型的占位符。通过CTRUNDelegate设置图片\n\n```\nNSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@\"\\n这里在测试图文混排，\\n我是一个富文本\"];//这句不用我多说吧，最起码得有个富文本啊才能插入不是。\n/*\n 设置一个回调结构体，告诉代理该回调那些方法\n */\nCTRunDelegateCallbacks callBacks;//创建一个回调结构体，设置相关参数\nmemset(&callBacks,0,sizeof(CTRunDelegateCallbacks));//memset将已开辟内存空间 callbacks 的首 n 个字节的值设为值 0, 相当于对CTRunDelegateCallbacks内存空间初始化\ncallBacks.version = kCTRunDelegateVersion1;//设置回调版本，默认这个\ncallBacks.getAscent = ascentCallBacks;//设置图片顶部距离基线的距离\ncallBacks.getDescent = descentCallBacks;//设置图片底部距离基线的距离\ncallBacks.getWidth = widthCallBacks;//设置图片宽度\n```\n\n**注意了，这里经GreyLove提醒有重要改动，就是这里，添加了memset，码字的时候少忘码了一句话。怪我粗心，十分抱歉，我会通知每一个留言的同学。**\n\n\n为什么要设置一个回调结构体呢？\n因为coreText中大量的调用c的方法。`事实上你会发现大部分跟系统底层有关的都需要调c的方法。`所以设置代理要按照人家的方法来啊。\n\n看看这几句代码也很好懂，就是注释中写的意思。  \n后三句分别就是说当我需要走这些代理的时候都会走那些`代理方法`。  \n好吧，扯到这又要补充知识了。这个距离什么东西呢？\n![字形](http://upload-images.jianshu.io/upload_images/1835430-945506c609eeac5d.gif?imageMogr2/auto-orient/strip)\n\n对对，这呢就是一个CTRun的尺寸图，什么你问CTRun是啥？还没到那呢，后面会详细介绍。\n在这你只要知道，一会我们绘制图片的时候实际上实在一个CTRun中绘制这个图片，那么CTRun绘制的坐标系中，他会以`origin点作为原点`进行绘制。  \n`基线为过原点的x轴`，`ascent即为CTRun顶线距基线的距离`，`descent即为底线距基线的距离`。  \n我们绘制图片应该从原点开始绘制，图片的高度及宽度及CTRun的高度及宽度，我们`通过代理设置CTRun的尺寸间接设置图片的尺寸。`\n\n---\n\n```\n/*\n 创建一个代理\n*/\n    NSDictionary * dicPic = @{@\"height\":@129,@\"width\":@400};//创建一个图片尺寸的字典，初始化代理对象需要\n    CTRunDelegateRef delegate = CTRunDelegateCreate(& callBacks, (__bridge void *)dicPic);//创建代理\n```\n\n上面只是设置了回调结构体，然而我们还没有告诉这个代理我们要的`图片尺寸`。\n所以这句话就在`设置代理的时候绑定了一个返回图片尺寸的字典`。  \n事实上此处你可以`绑定任意对象`。此处你`绑定的对象既是回调方法中的参数ref`。\n  \n好吧就然说到这我就直接把那三个回调方法说了吧，放在一起比较好理解一些。 \n \n```\nstatic CGFloat ascentCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"height\"] floatValue];\n}\nstatic CGFloat descentCallBacks(void * ref)\n{\n    return 0;\n}\nstatic CGFloat widthCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"width\"] floatValue];\n}\n\n```\n\n上文说过，ref既是创建代理是绑定的对象。所以我们在这里，`从字典中分别取出图片的宽和高`。\n\n值得注意的是，由于是c的方法，所以也没有什么对象的概念。是一个`指针类型的数据`。不过oc的对象其实也就是c的结构体。我们可以通过类型转换获得oc中的字典。  \n`__bridge既是C的结构体转换成OC对象时需要的一个修饰词`。\n\n老司机敲字慢啊，敲到这都两个小时了，容我喝口水。  \n\n你们喝过红色的尖叫么？老司机喝了那种烟头泡的水之后`精神满满`的继续敲字。（那水超难喝，你可以挑战一下）  \n诶，说好的严肃呢？\n\n---\n#### 图片的插入\n首先创建一个富文本类型的图片占位符，绑定我们的代理\n\n```\nunichar placeHolder = 0xFFFC;//创建空白字符\n    NSString * placeHolderStr = [NSString stringWithCharacters:&placeHolder length:1];//已空白字符生成字符串\n    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];//用字符串初始化占位符的富文本\n    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);//给字符串中的范围中字符串设置代理\n    CFRelease(delegate);//释放（__bridge进行C与OC数据类型的转换，C为非ARC，需要手动管理）\n```\n这里富文本的知识上文中已经介绍过了。不过老司机猜你有三个疑问。  \n\n* 这个添加属性的方法怎么是这个样子的？  \n因为这里是添加CTRunDelegate这种数据类型，要用CoreText专门的方法，不过其实就是形式不同，作用一样的。\n* 为什么这里富文本类型转换的时候不用_bridge呢？老司机你不是说需要修饰词么？你是不是骗我？(markDown语法冲突我少打一个下划线)  \n真没有，事实上不是所有数据转换的时候都需要__bridge。你要问我怎么区分？那好我告诉你，C中就是传递指针的数据就不用。比如说字符串，数组。原因老司机现在解释不通，等我能组织好语言的。\n* 为什么还要释放？我是ARC环境啊  \n不好意思，我也是。不过为什么要释放呢？因为你进行了类型转换之后就不属于对象了，也不再归自动引用计数机制管理了，所以你得`手动管理`咯。\n- - -\n\n然后将占位符插入到我们的富文本中\n\n```\n[attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];//将占位符插入原富文本\n```\n此处我就不赘述了，富文本的知识你只要类比字典就好了。  \n至此，我们已经生成好了我们要的带有图片信息的富文本了，接下来我们只要在画布上`绘制`出来这个富文本就好了。\n- - -\n#### 绘制\n绘制呢，又分成两部分，`绘制文本`和`绘制图片`。你问我为什么还分成两个？\n\n因为富文本中你添加的图片只是一个`带有图片尺寸的空白占位符`啊，你绘制的时候他只会绘制出相应尺寸的空白占位符，所以什么也显示不了啊。  \n那怎么显示图片啊？拿到占位符的坐标，`在占位符的地方绘制相应大小的图片`就好了。恩，说到这，图文混排的原理已经说完了。\n\n先来绘制文本吧。\n- - -\n##### 绘制文本\n\n```\nCTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);//一个frame的工厂，负责生成frame\nCGMutablePathRef path = CGPathCreateMutable();//创建绘制区域\nCGPathAddRect(path, NULL, self.bounds);//添加绘制尺寸\nNSInteger length = attributeStr.length;\nCTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0,length), path, NULL);//工厂根据绘制区域及富文本（可选范围，多次设置）设置frame\nCTFrameDraw(frame, context);//根据frame绘制文字\n```\nframeSetter是根据富文本生成的一个frame生成的工厂，你可以`通过framesetter`以及你想要绘制的`富文本的范`围获取`该CTRun的frame`。  \n但是你需要注意的是，获取的frame是`仅绘制你所需要的那部分富文本的frame`。即当前情况下，你绘制范围定为（10，1），那么你得到的尺寸是只绘制（10，1）的尺寸，他应该从屏幕左上角开始（因为你改变了坐标系），而`不是当你绘制全部富文本时他该在的位置`。\n\n然后建立一会绘制的尺寸，实际上就是在指定你的`绘制范围`。  \n接着生成`整个富文本绘制所需要的frame`。因为范围是全部文本，所以获取的frame即为全部文本的frame(此处老司机希望你一定要搞清楚全部与指定范围获取的frame他们都是从左上角开始的，否则你会进入一个奇怪的误区，稍后会提到的)。  \n最后，根据你获得的frame，绘制`全部富文本`。\n- - -\n##### 绘制图片\n上面你已经绘制出文字，不过没有图片哦，接下来绘制图片。\n绘制图片用下面这个方法，通用的哦  \n\n```\nCGContextDrawImage(context,imgFrm, image.CGImage);//绘制图片\n```\n我们可以看到这个方法有三个参数，分别是`context，frame，以及image`。\n要什么就给他什么好咯，context和image都好说，context就是当前的上下文，最开始获得那个。image就是你要添加的那个图片，不过是`CGImage类型`。通过UIImage转出CGImage就好了，我们重点讲一下frame的获取。  \n\n###### frame的获取\n记得我之前说的误区么？这里我们要获得Image的frame，你有没有想过我们的frameSetter？\n\n我也想过，不过就像我说的，你单独用frameSetter求出的image的frame是不正确的，那是只绘制image而得的坐标，所以哪种方法不能用哦，要用下面的方法。    \n\n你们一定发现，我获取frame的方法单独写了一个方法，为什么呢？  \n1.将`代码分离`，方便修改。  \n2.最主要的是这部分代码到哪里都能用，达到`复用`效果。  \n\n```\nNSArray * arrLines = (NSArray *)CTFrameGetLines(frame);//根据frame获取需要绘制的线的数组\nNSInteger count = [arrLines count];//获取线的数量\nCGPoint points[count];//建立起点的数组（cgpoint类型为结构体，故用C语言的数组）\nCTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);//获取起点\n```\n第一句呢，获取绘制frame中的所有CTLine。CTLine，又不知道了吧，老司机又要无耻的盗图了。  \n![CTFrame组成](http://upload-images.jianshu.io/upload_images/1835430-823846a97a7b220e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n上面呢，我们能看到一个CTFrame绘制的原理。\n\n* CTLine 可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs\n* CTRun 或者叫做 Glyph Run，是一组共享想相同attributes（属性）的字形的集合体\n\n一个CTFrame有几个CTLine组成，有几行文字就有几行CTLine。一个CTLine有包含多个CTRun，一个CTRun是所有属性都相同的那部分富文本的绘制单元。所以CTRun是CTFrame的`基本绘制单元`。  \n接着说我们的代码。  \n为什么我获取的数组需要进行类型转换呢？因为CTFrameGetLines（）返回值是`CFArrayRef类型`的数据。就是一个c的数组类型吧，暂且先这么理解，所以需要转换。  \n\n那为什么不用__bridge呢？记得么，我说过，`本身就传地址的数据是不用桥接的`。就是这样。  \n然后获取数组的元素个数。有什么用呢，因为我们要用到每个CTLine的`原点坐标`进行计算。每个CTLine都有自己的origin。所以要生成一个`相同元素个数的数组去盛放origin对象`。  \n然后用CTFrameGetLineOrigins获取所有原点。  \n到此，我们计算frame的准备工作完成了。才完成准备工作。  \n- - -\n###### 计算frame\n思路呢，就是`遍历`我们的frame中的所有CTRun，`检查`他是不是我们绑定图片的那个，如果是，根据该CTRun所在CTLine的origin以及CTRun在CTLine中的横向偏移量`计算`出CTRun的原点，加上其尺寸即为该CTRun的尺寸。\n\n跟绕口令是的，不过就是这么个思路。\n\n```\nfor (int i = 0; i < count; i ++) {//遍历线的数组\n        CTLineRef line = (__bridge CTLineRef)arrLines[i];\n        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);//获取GlyphRun数组（GlyphRun：高效的字符绘制方案）\n        for (int j = 0; j < arrGlyphRun.count; j ++) {//遍历CTRun数组\n            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];//获取CTRun\n            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);//获取CTRun的属性\n            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];//获取代理\n            if (delegate == nil) {//非空\n                continue;\n            }\n            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);//判断代理字典\n            if (![dic isKindOfClass:[NSDictionary class]]) {\n                continue;\n            }\n            CGPoint point = points[i];//获取一个起点\n            CGFloat ascent;//获取上距\n            CGFloat descent;//获取下距\n            CGRect boundsRun;//创建一个frame\n            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, &descent, NULL);\n            boundsRun.size.height = ascent + descent;//取得高\n            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);//获取x偏移量\n            boundsRun.origin.x = point.x + xOffset;//point是行起点位置，加上每个字的偏移量得到每个字的x\n            boundsRun.origin.y = point.y - descent;//计算原点\n            CGPathRef path = CTFrameGetPath(frame);//获取绘制区域\n            CGRect colRect = CGPathGetBoundingBox(path);//获取剪裁区域边框\n            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);\n            return imageBounds;\n```\n\n有了上面的思路这里就很好理解了。  \n外层for循环呢，是为了`取到所有的CTLine`。  \n类型转换什么的我就不多说了，然后通过CTLineGetGlyphRuns获取一个CTLine中的`所有CTRun`。  \n里层for循环是检查每个CTRun。  \n通过CTRunGetAttributes拿到该`CTRun的所有属性`。  \n通过kvc取得属性中的`代理属性`。  \n接下来判断`代理属性是否为空`。因为图片的占位符我们是绑定了代理的，而文字没有。以此区分文字和图片。  \n如果代理不为空，通过CTRunDelegateGetRefCon取得生成`代理时绑定的对象`。`判断类型`是否是我们绑定的类型，`防止取得我们之前为其他的富文本绑定过代理`。  \n如果两条都符合，ok，这就是`我们要的那个CTRun`。  \n开始计算该`CTRun的frame`吧。  \n获取`原点`和获取`宽高`被。  \n通过`CTRunGetTypographicBounds`取得宽，ascent和descent。有了上面的介绍我们应该知道图片的高度就是ascent+descent了吧。  \n接下来获取原点。\nCTLineGetOffsetForStringIndex获取对应`CTRun的X偏移量`。\n取得对应CTLine的原点的Y，`减去图片的下边距才是图片的原点`，这点应该很好理解。  \n至此，我们已经获得了`图片的frame`了。因为只绑定了一个图片，所以直接return就好了，如果多张图片可以继续遍历返回数组。  \n获取到图片的frame，我们就可以绘制图片了，用上面介绍的方法。  \n- - -\n哦，别忘了手动释放你创建的对象哦。  \n\n```\nCFRelease(frame);\nCFRelease(path);\nCFRelease(frameSetter);\n```\n大功告成。\n\n----\n好了，至此你已经完成图片的绘制了。只要在ViewController里面引入你绘制CoreText文本的View正常的初始化添加子视图就可以了。\n\n好吧，这个教程我也是综合了很多资料写出来的。优势是在于我一句一句讲的，几乎每一句都告诉你原理了吧。\n\n恩，我也是在前人的基础上自己总结查阅出来的，难免夹杂着个人理解和部分偏颇，如果各位看官发现我写的有什么不对的地方欢迎与我联系，老司机的邮箱codewicky@163.com。\n\n原谅老司机逗逼的本质，严肃不起来。\n\n下面是一些参考资料：  \n[coreText方法，列的很全](http://blog.csdn.net/liliangchw/article/details/8261646)  \n[CTRun的详细介绍](http://www.docin.com/p-721844449.html)  \n[CTLine的详细介绍](http://blog.csdn.net/majiakun1/article/details/38140411)  \n[coreText基本原理及使用方法](http://www.tuicool.com/articles/FfYjim)  \n[图文混排的整体介绍](http://my.oschina.net/u/2361492/blog/526814)  \n[coreText使用方法](https://my.oschina.net/megan/blog/269042)\n\n你要是喜欢呢，麻烦你动一动你可爱的小手点击一下喜欢或者关注，毕竟老司机这么爱慕虚荣的人，而且老司机会经常更新的。\n\n\n最后，你问我为什么一直叫自己老司机？哦，因为嘿嘿嘿~~~\n\n哦，最后的最后，若果真有人转载的话，麻烦你注明出处。\n[http://www.jianshu.com/p/6db3289fb05d](http://www.jianshu.com/p/6db3289fb05d)\n","source":"_posts/CoreText实现图文混排.md","raw":"\n---\ntitle: CoreText实现图文混排\nlayout: post\ndate: 2016-05-15 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CoreText \n- 图文混排\ncategories: 图文混排\n\n---\n\n![CoreText实现图文混排](http://upload-images.jianshu.io/upload_images/1835430-07e7d10e9bb52c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [CoreText实现图文混排](http://www.jianshu.com/p/6db3289fb05d)\n- [CoreText实现图文混排之点击事件](http://www.jianshu.com/p/51c47329203e)\n- [CoreText实现图文混排之文字环绕及点击算法](http://www.jianshu.com/p/e154047b0f98)\n- - -\n也好久没来写博客了，主要是最近也工作了，手头的事有点多，一时间也就断了，闲下来了我就来补博客了，刚好最近也做了很多东西，放在这里也算给自己做个笔记吧。\n\n----------\n# CoreText\n最近公司做了一个项目，需要用到`图文混排`技术。于是呢就疯狂地在网上搜刮资料。  \n不过很不幸的是，百度的CoreText资料还是比较少滴，翻来覆去就那几个版本。  \n然而我又上不去谷歌，so，困难重重啊。  \n不过虽然资料少，不够前辈们给的贡献终于还是在我的努力下都被我消化了，然后我也来做个笔记。\n\n- - - - \n## CoreText的介绍\nCore Text 是基于 iOS 3.2+ 和 OSX 10.5+ 的一种能够对文本格式和文本布局进行精细控制的文本引擎。  \n它良好的结合了 UIKit 和 Core Graphics/Quartz：  \n\n\n\tUIKit 的 UILabel 允许你通过在 IB 中简单的拖曳添加文本，但你不能改变文本的颜色和其中的单词。  \n\tCore Graphics/Quartz几乎允许你做任何系统允许的事情，但你需要为每个字形计算位置，并画在屏幕上。\n\tCore Text 正结合了这两者！你可以完全控制位置、布局、类似文本大小和颜色这样的属性，而 Core Text 将帮你完善其它的东西——类似文本换行、字体呈现等等。\n\n以上就是对CoreText的介绍。\n\n<!-- more -->\n\n\n---------\n## 老司机对CoreText实现图文混排的一些理解\n\n老司机认为，图文混排中使用到的CoreText只是CoreText庞大体系中一个对富文本的**增强**的一部分。\n我个人想法啊，我读书少，理解的可能不到位，不过你咬我啊。\n\n恩，我又逗逼了一波，说好的大师气质呢，下面开始严肃了啊。\n\n严肃的就是iOS7新推出的类库`Textkit`，其实是在之前推出的`CoreText上的封装`，根据苹果的说法，他们开发了两年多才完成，而且他们在开发时候也将表情混排作为一个使用案例进行研究，所以要`实现表情混排将会非常容易`。\n\n苹果引入TextKit的目的并非要取代已有的CoreText框架，虽然`CoreText的主要作用也是用于文字的排版和渲染`，但它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，`从性能和易用性来考虑`，`最佳方案就是使用CoreText`。\n原理的东西学一学总没有坏处。因此，还是有必要去学一学CoreText的。  \n那我们开始学习吧。\n- - - - -\n# 富文本\n老司机说过，我要讲的只是用来增强富文本的那一部分，那么富文本怎么使用呢。\n\n富文本是什么呢？\n\n> 富文本格式(RTF)规范是为了便于在应用程序之间轻松转储格式化文本和图形的一种编码方法。\n现在，用户可以利用特定转换软件，在不同系统如MS-DOS、Windows、OS/2、Macintosh和Power Macintosh的应用程序之间转移字处理文档。\nRTF规范提供一种在不同的输出设备、操作环境和操作系统之间交换文本和图形的一种格式。\nRTF使用ANSI, PC-8, Macintosh, 或IBM PC字符集控制文档的表示法和格式化，包括屏幕显示和打印\n。凭借RTF规范，不同的操作系统和不同的软件程序创建的文档能够在这些操作系统和应用程序之间传递。\n将一个格式化的文件转换为RTF文件的软件称为RTF书写器。\nRTF书写器用于分离现有文本中的程序控制信息，并且生成一个包含文本和与之相关的RTF组的新文件。将RTF文件转换成格式化文件的软件则称为RTF阅读器。\n\n简单的说，附`带有每一个文字属性的字符串`，就是富文本。  \n在iOS中，我们有一个专门的类来处理富文本 `AttributeString`。  \n- - - \n## 富文本的基本使用方法\n  \n诶，标题越来越小了，都4个#号了，说明我扯远了啊。不过要想使用CoreText不会富文本还是不行啊。\n\n来吧。  \nAttributedString也分为`NSAttributedString`和`NSMutableAttributedString`两个类，类似于String，我就不赘述了。  \n富文本本质上没有什么难度，只要给指定的字符串附上指定的属性就好了。下面给出富文本的一些基本方法。  \n\n- -initWithString:`以NSString初始化一个富文本对象`  \n- -setAttributes:range:`为富文本中的一段范围添加一些属性`，第一个参数是个NSDictionary字典，第二个参数是NSRange。\n- -addAttribute:value:range:`添加一个属性`\n- -addAttributes:range:`添加多个属性`\n- -removeAttribute:range:`移除属性`\n额,老司机知道这么说不直观，来来来，上代码。  \n\n```\nNSDictionary * dic = @{NSFontAttributeName:[UIFont fontWithName:@\"Zapfino\" size:20],NSForegroundColorAttributeName:[UIColor redColor],NSUnderlineStyleAttributeName:@(NSUnderlineStyleSingle)};\n    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@\"0我是一个富文本，9听说我有很多属性，19I will try。32这里清除属性.\"];\n//    设置属性\n    [attributeStr setAttributes:dic range:NSMakeRange(0, attributeStr.length)];\n//    添加属性\n    [attributeStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(9, 10)];\n    [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor cyanColor] range:NSMakeRange(13, 13)];\n//    添加多个属性\n    NSDictionary * dicAdd = @{NSBackgroundColorAttributeName:[UIColor yellowColor],NSLigatureAttributeName:@1};\n    [attributeStr addAttributes:dicAdd range:NSMakeRange(19, 13)];\n//    移除属性\n    [attributeStr removeAttribute:NSFontAttributeName range:NSMakeRange(32, 9)];\n    UILabel * label = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 200, 400)];\n    label.numberOfLines = 0;\n    label.attributedText = attributeStr;\n```\n\n这里你要注意一下，给label的一定是给他的`attributedText`属性，你给text是不行的。   \n是不是用起来很简单，富文本，跟字典没什么区别么。\n\n----\n# CoreText绘制富文本\n\n是不是终于进入正题了。其实之所以说那么多，还是为了你看完就能保证会用啊，否则你不会富文本你自己还要查找富文本相关资料。\n\n**Come On！**\n\nCoreText实现图文混排其实就是在富文本中`插入一个空白的图片占位符`的富文本字符串，通过`代理设置相关的图片尺寸信息`，根据从富文本得到的frame`计算图片绘制的frame再绘制图片`这么一个过程。  \n\n先来整体代码\n\n## 全部代码\n\n```\n-(void)drawRect:(CGRect)rect\n{\n    [super drawRect:rect];\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);\n    CGContextScaleCTM(context, 1.0, -1.0);\n    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@\"\\n这里在测试图文混排，\\n我是一个富文本\"];\n    CTRunDelegateCallbacks callBacks;\n    memset(&callBacks,0,sizeof(CTRunDelegateCallbacks));\n    callBacks.version = kCTRunDelegateVersion1;\n    callBacks.getAscent = ascentCallBacks;\n    callBacks.getDescent = descentCallBacks;\n    callBacks.getWidth = widthCallBacks;\n    NSDictionary * dicPic = @{@\"height\":@129,@\"width\":@400};\n    CTRunDelegateRef delegate = CTRunDelegateCreate(& callBacks, (__bridge void *)dicPic);\n    unichar placeHolder = 0xFFFC;\n    NSString * placeHolderStr = [NSString stringWithCharacters:&placeHolder length:1];\n    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];\n    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);\n    CFRelease(delegate);\n    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];\n    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathAddRect(path, NULL, self.bounds);\n    NSInteger length = attributeStr.length;\n    CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);\n    CTFrameDraw(frame, context);\n    \n    UIImage * image = [UIImage imageNamed:@\"bd_logo1\"];\n    CGRect imgFrm = [self calculateImageRectWithFrame:frame];\n    CGContextDrawImage(context,imgFrm, image.CGImage);\n    CFRelease(frame);\n    CFRelease(path);\n    CFRelease(frameSetter);\n}\nstatic CGFloat ascentCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"height\"] floatValue];\n}\nstatic CGFloat descentCallBacks(void * ref)\n{\n    return 0;\n}\nstatic CGFloat widthCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"width\"] floatValue];\n}\n\n\n-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame\n{\n    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);\n    NSInteger count = [arrLines count];\n    CGPoint points[count];\n    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);\n    for (int i = 0; i < count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)arrLines[i];\n        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);\n        for (int j = 0; j < arrGlyphRun.count; j ++) {\n            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];\n            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];\n            if (delegate == nil) {\n                continue;\n            }\n            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);\n            if (![dic isKindOfClass:[NSDictionary class]]) {\n                continue;\n            }\n            CGPoint point = points[i];\n            CGFloat ascent;\n            CGFloat descent;\n            CGRect boundsRun;\n            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, &descent, NULL);\n            boundsRun.size.height = ascent + descent;\n            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);\n            boundsRun.origin.x = point.x + xOffset;\n            boundsRun.origin.y = point.y - descent;\n            CGPathRef path = CTFrameGetPath(frame);\n            CGRect colRect = CGPathGetBoundingBox(path);\n            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);\n            return imageBounds;\n        }\n    }\n    return CGRectZero;\n}\n```\n\n不瞒你说，我看着代码都烦，也怕，所以放心，老司机会一句一句给你解释的。\n- - - \n\n## 分段解析\n### 准备工作\n\n```\nCGContextRef context = UIGraphicsGetCurrentContext();\nCGContextSetTextMatrix(context, CGAffineTransformIdentity);    \nCGContextTranslateCTM(context, 0, self.bounds.size.height);\nCGContextScaleCTM(context, 1.0, -1.0);\n```\n先要来一个背景介绍哈\n\n    /*\n     coreText 起初是为OSX设计的，而OSX得坐标原点是左下角，y轴正方向朝上。iOS中坐标原点是左上角，y轴正方向向下。\n     若不进行坐标转换，则文字从下开始，还是倒着的\n     \t如下图(盗的图，别打我)\n     */\n     \n![系统坐标系](http://upload-images.jianshu.io/upload_images/1835430-597db8c1833bf0c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n\n\n这四句什么意思呢？  \n\n#### 获取上下文  \n```\nCGContextRef context = UIGraphicsGetCurrentContext();//获取当前绘制上下文\n```\n\n  \n为什么要回去上下文呢？因为我们所有的绘制操作都是在上下文上进行绘制的。 \n \n#### 坐标转换\n\n```\nCGContextSetTextMatrix(context, CGAffineTransformIdentity);//设置字形的变换矩阵为不做图形变换  \n    CGContextTranslateCTM(context, 0, self.bounds.size.height);//平移方法，将画布向上平移一个屏幕高  \n    CGContextScaleCTM(context, 1.0, -1.0);//缩放方法，x轴缩放系数为1，则不变，y轴缩放系数为-1，则相当于以x轴为轴旋转180度\n```\n\n正如之上的背景说的，coreText使用的是`系统坐标`，然而我们平时所接触的iOS的都是`屏幕坐标`，所以要将屏幕坐标系`转换`系统坐标系，这样才能与我们想想的坐标互相对应。  \n`事实上呢，这三句是翻转画布的固定写法，这三句你以后会经常看到的。`\n\n继续。\n- - -\n#### 图片的代理的设置\n\n> 事实上，图文混排就是在要插入图片的位置插入一个富文本类型的占位符。通过CTRUNDelegate设置图片\n\n```\nNSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@\"\\n这里在测试图文混排，\\n我是一个富文本\"];//这句不用我多说吧，最起码得有个富文本啊才能插入不是。\n/*\n 设置一个回调结构体，告诉代理该回调那些方法\n */\nCTRunDelegateCallbacks callBacks;//创建一个回调结构体，设置相关参数\nmemset(&callBacks,0,sizeof(CTRunDelegateCallbacks));//memset将已开辟内存空间 callbacks 的首 n 个字节的值设为值 0, 相当于对CTRunDelegateCallbacks内存空间初始化\ncallBacks.version = kCTRunDelegateVersion1;//设置回调版本，默认这个\ncallBacks.getAscent = ascentCallBacks;//设置图片顶部距离基线的距离\ncallBacks.getDescent = descentCallBacks;//设置图片底部距离基线的距离\ncallBacks.getWidth = widthCallBacks;//设置图片宽度\n```\n\n**注意了，这里经GreyLove提醒有重要改动，就是这里，添加了memset，码字的时候少忘码了一句话。怪我粗心，十分抱歉，我会通知每一个留言的同学。**\n\n\n为什么要设置一个回调结构体呢？\n因为coreText中大量的调用c的方法。`事实上你会发现大部分跟系统底层有关的都需要调c的方法。`所以设置代理要按照人家的方法来啊。\n\n看看这几句代码也很好懂，就是注释中写的意思。  \n后三句分别就是说当我需要走这些代理的时候都会走那些`代理方法`。  \n好吧，扯到这又要补充知识了。这个距离什么东西呢？\n![字形](http://upload-images.jianshu.io/upload_images/1835430-945506c609eeac5d.gif?imageMogr2/auto-orient/strip)\n\n对对，这呢就是一个CTRun的尺寸图，什么你问CTRun是啥？还没到那呢，后面会详细介绍。\n在这你只要知道，一会我们绘制图片的时候实际上实在一个CTRun中绘制这个图片，那么CTRun绘制的坐标系中，他会以`origin点作为原点`进行绘制。  \n`基线为过原点的x轴`，`ascent即为CTRun顶线距基线的距离`，`descent即为底线距基线的距离`。  \n我们绘制图片应该从原点开始绘制，图片的高度及宽度及CTRun的高度及宽度，我们`通过代理设置CTRun的尺寸间接设置图片的尺寸。`\n\n---\n\n```\n/*\n 创建一个代理\n*/\n    NSDictionary * dicPic = @{@\"height\":@129,@\"width\":@400};//创建一个图片尺寸的字典，初始化代理对象需要\n    CTRunDelegateRef delegate = CTRunDelegateCreate(& callBacks, (__bridge void *)dicPic);//创建代理\n```\n\n上面只是设置了回调结构体，然而我们还没有告诉这个代理我们要的`图片尺寸`。\n所以这句话就在`设置代理的时候绑定了一个返回图片尺寸的字典`。  \n事实上此处你可以`绑定任意对象`。此处你`绑定的对象既是回调方法中的参数ref`。\n  \n好吧就然说到这我就直接把那三个回调方法说了吧，放在一起比较好理解一些。 \n \n```\nstatic CGFloat ascentCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"height\"] floatValue];\n}\nstatic CGFloat descentCallBacks(void * ref)\n{\n    return 0;\n}\nstatic CGFloat widthCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"width\"] floatValue];\n}\n\n```\n\n上文说过，ref既是创建代理是绑定的对象。所以我们在这里，`从字典中分别取出图片的宽和高`。\n\n值得注意的是，由于是c的方法，所以也没有什么对象的概念。是一个`指针类型的数据`。不过oc的对象其实也就是c的结构体。我们可以通过类型转换获得oc中的字典。  \n`__bridge既是C的结构体转换成OC对象时需要的一个修饰词`。\n\n老司机敲字慢啊，敲到这都两个小时了，容我喝口水。  \n\n你们喝过红色的尖叫么？老司机喝了那种烟头泡的水之后`精神满满`的继续敲字。（那水超难喝，你可以挑战一下）  \n诶，说好的严肃呢？\n\n---\n#### 图片的插入\n首先创建一个富文本类型的图片占位符，绑定我们的代理\n\n```\nunichar placeHolder = 0xFFFC;//创建空白字符\n    NSString * placeHolderStr = [NSString stringWithCharacters:&placeHolder length:1];//已空白字符生成字符串\n    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];//用字符串初始化占位符的富文本\n    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);//给字符串中的范围中字符串设置代理\n    CFRelease(delegate);//释放（__bridge进行C与OC数据类型的转换，C为非ARC，需要手动管理）\n```\n这里富文本的知识上文中已经介绍过了。不过老司机猜你有三个疑问。  \n\n* 这个添加属性的方法怎么是这个样子的？  \n因为这里是添加CTRunDelegate这种数据类型，要用CoreText专门的方法，不过其实就是形式不同，作用一样的。\n* 为什么这里富文本类型转换的时候不用_bridge呢？老司机你不是说需要修饰词么？你是不是骗我？(markDown语法冲突我少打一个下划线)  \n真没有，事实上不是所有数据转换的时候都需要__bridge。你要问我怎么区分？那好我告诉你，C中就是传递指针的数据就不用。比如说字符串，数组。原因老司机现在解释不通，等我能组织好语言的。\n* 为什么还要释放？我是ARC环境啊  \n不好意思，我也是。不过为什么要释放呢？因为你进行了类型转换之后就不属于对象了，也不再归自动引用计数机制管理了，所以你得`手动管理`咯。\n- - -\n\n然后将占位符插入到我们的富文本中\n\n```\n[attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];//将占位符插入原富文本\n```\n此处我就不赘述了，富文本的知识你只要类比字典就好了。  \n至此，我们已经生成好了我们要的带有图片信息的富文本了，接下来我们只要在画布上`绘制`出来这个富文本就好了。\n- - -\n#### 绘制\n绘制呢，又分成两部分，`绘制文本`和`绘制图片`。你问我为什么还分成两个？\n\n因为富文本中你添加的图片只是一个`带有图片尺寸的空白占位符`啊，你绘制的时候他只会绘制出相应尺寸的空白占位符，所以什么也显示不了啊。  \n那怎么显示图片啊？拿到占位符的坐标，`在占位符的地方绘制相应大小的图片`就好了。恩，说到这，图文混排的原理已经说完了。\n\n先来绘制文本吧。\n- - -\n##### 绘制文本\n\n```\nCTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);//一个frame的工厂，负责生成frame\nCGMutablePathRef path = CGPathCreateMutable();//创建绘制区域\nCGPathAddRect(path, NULL, self.bounds);//添加绘制尺寸\nNSInteger length = attributeStr.length;\nCTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0,length), path, NULL);//工厂根据绘制区域及富文本（可选范围，多次设置）设置frame\nCTFrameDraw(frame, context);//根据frame绘制文字\n```\nframeSetter是根据富文本生成的一个frame生成的工厂，你可以`通过framesetter`以及你想要绘制的`富文本的范`围获取`该CTRun的frame`。  \n但是你需要注意的是，获取的frame是`仅绘制你所需要的那部分富文本的frame`。即当前情况下，你绘制范围定为（10，1），那么你得到的尺寸是只绘制（10，1）的尺寸，他应该从屏幕左上角开始（因为你改变了坐标系），而`不是当你绘制全部富文本时他该在的位置`。\n\n然后建立一会绘制的尺寸，实际上就是在指定你的`绘制范围`。  \n接着生成`整个富文本绘制所需要的frame`。因为范围是全部文本，所以获取的frame即为全部文本的frame(此处老司机希望你一定要搞清楚全部与指定范围获取的frame他们都是从左上角开始的，否则你会进入一个奇怪的误区，稍后会提到的)。  \n最后，根据你获得的frame，绘制`全部富文本`。\n- - -\n##### 绘制图片\n上面你已经绘制出文字，不过没有图片哦，接下来绘制图片。\n绘制图片用下面这个方法，通用的哦  \n\n```\nCGContextDrawImage(context,imgFrm, image.CGImage);//绘制图片\n```\n我们可以看到这个方法有三个参数，分别是`context，frame，以及image`。\n要什么就给他什么好咯，context和image都好说，context就是当前的上下文，最开始获得那个。image就是你要添加的那个图片，不过是`CGImage类型`。通过UIImage转出CGImage就好了，我们重点讲一下frame的获取。  \n\n###### frame的获取\n记得我之前说的误区么？这里我们要获得Image的frame，你有没有想过我们的frameSetter？\n\n我也想过，不过就像我说的，你单独用frameSetter求出的image的frame是不正确的，那是只绘制image而得的坐标，所以哪种方法不能用哦，要用下面的方法。    \n\n你们一定发现，我获取frame的方法单独写了一个方法，为什么呢？  \n1.将`代码分离`，方便修改。  \n2.最主要的是这部分代码到哪里都能用，达到`复用`效果。  \n\n```\nNSArray * arrLines = (NSArray *)CTFrameGetLines(frame);//根据frame获取需要绘制的线的数组\nNSInteger count = [arrLines count];//获取线的数量\nCGPoint points[count];//建立起点的数组（cgpoint类型为结构体，故用C语言的数组）\nCTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);//获取起点\n```\n第一句呢，获取绘制frame中的所有CTLine。CTLine，又不知道了吧，老司机又要无耻的盗图了。  \n![CTFrame组成](http://upload-images.jianshu.io/upload_images/1835430-823846a97a7b220e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n上面呢，我们能看到一个CTFrame绘制的原理。\n\n* CTLine 可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs\n* CTRun 或者叫做 Glyph Run，是一组共享想相同attributes（属性）的字形的集合体\n\n一个CTFrame有几个CTLine组成，有几行文字就有几行CTLine。一个CTLine有包含多个CTRun，一个CTRun是所有属性都相同的那部分富文本的绘制单元。所以CTRun是CTFrame的`基本绘制单元`。  \n接着说我们的代码。  \n为什么我获取的数组需要进行类型转换呢？因为CTFrameGetLines（）返回值是`CFArrayRef类型`的数据。就是一个c的数组类型吧，暂且先这么理解，所以需要转换。  \n\n那为什么不用__bridge呢？记得么，我说过，`本身就传地址的数据是不用桥接的`。就是这样。  \n然后获取数组的元素个数。有什么用呢，因为我们要用到每个CTLine的`原点坐标`进行计算。每个CTLine都有自己的origin。所以要生成一个`相同元素个数的数组去盛放origin对象`。  \n然后用CTFrameGetLineOrigins获取所有原点。  \n到此，我们计算frame的准备工作完成了。才完成准备工作。  \n- - -\n###### 计算frame\n思路呢，就是`遍历`我们的frame中的所有CTRun，`检查`他是不是我们绑定图片的那个，如果是，根据该CTRun所在CTLine的origin以及CTRun在CTLine中的横向偏移量`计算`出CTRun的原点，加上其尺寸即为该CTRun的尺寸。\n\n跟绕口令是的，不过就是这么个思路。\n\n```\nfor (int i = 0; i < count; i ++) {//遍历线的数组\n        CTLineRef line = (__bridge CTLineRef)arrLines[i];\n        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);//获取GlyphRun数组（GlyphRun：高效的字符绘制方案）\n        for (int j = 0; j < arrGlyphRun.count; j ++) {//遍历CTRun数组\n            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];//获取CTRun\n            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);//获取CTRun的属性\n            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];//获取代理\n            if (delegate == nil) {//非空\n                continue;\n            }\n            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);//判断代理字典\n            if (![dic isKindOfClass:[NSDictionary class]]) {\n                continue;\n            }\n            CGPoint point = points[i];//获取一个起点\n            CGFloat ascent;//获取上距\n            CGFloat descent;//获取下距\n            CGRect boundsRun;//创建一个frame\n            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, &descent, NULL);\n            boundsRun.size.height = ascent + descent;//取得高\n            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);//获取x偏移量\n            boundsRun.origin.x = point.x + xOffset;//point是行起点位置，加上每个字的偏移量得到每个字的x\n            boundsRun.origin.y = point.y - descent;//计算原点\n            CGPathRef path = CTFrameGetPath(frame);//获取绘制区域\n            CGRect colRect = CGPathGetBoundingBox(path);//获取剪裁区域边框\n            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);\n            return imageBounds;\n```\n\n有了上面的思路这里就很好理解了。  \n外层for循环呢，是为了`取到所有的CTLine`。  \n类型转换什么的我就不多说了，然后通过CTLineGetGlyphRuns获取一个CTLine中的`所有CTRun`。  \n里层for循环是检查每个CTRun。  \n通过CTRunGetAttributes拿到该`CTRun的所有属性`。  \n通过kvc取得属性中的`代理属性`。  \n接下来判断`代理属性是否为空`。因为图片的占位符我们是绑定了代理的，而文字没有。以此区分文字和图片。  \n如果代理不为空，通过CTRunDelegateGetRefCon取得生成`代理时绑定的对象`。`判断类型`是否是我们绑定的类型，`防止取得我们之前为其他的富文本绑定过代理`。  \n如果两条都符合，ok，这就是`我们要的那个CTRun`。  \n开始计算该`CTRun的frame`吧。  \n获取`原点`和获取`宽高`被。  \n通过`CTRunGetTypographicBounds`取得宽，ascent和descent。有了上面的介绍我们应该知道图片的高度就是ascent+descent了吧。  \n接下来获取原点。\nCTLineGetOffsetForStringIndex获取对应`CTRun的X偏移量`。\n取得对应CTLine的原点的Y，`减去图片的下边距才是图片的原点`，这点应该很好理解。  \n至此，我们已经获得了`图片的frame`了。因为只绑定了一个图片，所以直接return就好了，如果多张图片可以继续遍历返回数组。  \n获取到图片的frame，我们就可以绘制图片了，用上面介绍的方法。  \n- - -\n哦，别忘了手动释放你创建的对象哦。  \n\n```\nCFRelease(frame);\nCFRelease(path);\nCFRelease(frameSetter);\n```\n大功告成。\n\n----\n好了，至此你已经完成图片的绘制了。只要在ViewController里面引入你绘制CoreText文本的View正常的初始化添加子视图就可以了。\n\n好吧，这个教程我也是综合了很多资料写出来的。优势是在于我一句一句讲的，几乎每一句都告诉你原理了吧。\n\n恩，我也是在前人的基础上自己总结查阅出来的，难免夹杂着个人理解和部分偏颇，如果各位看官发现我写的有什么不对的地方欢迎与我联系，老司机的邮箱codewicky@163.com。\n\n原谅老司机逗逼的本质，严肃不起来。\n\n下面是一些参考资料：  \n[coreText方法，列的很全](http://blog.csdn.net/liliangchw/article/details/8261646)  \n[CTRun的详细介绍](http://www.docin.com/p-721844449.html)  \n[CTLine的详细介绍](http://blog.csdn.net/majiakun1/article/details/38140411)  \n[coreText基本原理及使用方法](http://www.tuicool.com/articles/FfYjim)  \n[图文混排的整体介绍](http://my.oschina.net/u/2361492/blog/526814)  \n[coreText使用方法](https://my.oschina.net/megan/blog/269042)\n\n你要是喜欢呢，麻烦你动一动你可爱的小手点击一下喜欢或者关注，毕竟老司机这么爱慕虚荣的人，而且老司机会经常更新的。\n\n\n最后，你问我为什么一直叫自己老司机？哦，因为嘿嘿嘿~~~\n\n哦，最后的最后，若果真有人转载的话，麻烦你注明出处。\n[http://www.jianshu.com/p/6db3289fb05d](http://www.jianshu.com/p/6db3289fb05d)\n","slug":"CoreText实现图文混排","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htoh0000jigbmprt3xdn","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-07e7d10e9bb52c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CoreText实现图文混排\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排</a></li>\n<li><a href=\"http://www.jianshu.com/p/51c47329203e\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之点击事件</a></li>\n<li><a href=\"http://www.jianshu.com/p/e154047b0f98\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之文字环绕及点击算法</a></li>\n</ul>\n<hr>\n<p>也好久没来写博客了，主要是最近也工作了，手头的事有点多，一时间也就断了，闲下来了我就来补博客了，刚好最近也做了很多东西，放在这里也算给自己做个笔记吧。</p>\n<hr>\n<h1 id=\"CoreText\"><a href=\"#CoreText\" class=\"headerlink\" title=\"CoreText\"></a>CoreText</h1><p>最近公司做了一个项目，需要用到<code>图文混排</code>技术。于是呢就疯狂地在网上搜刮资料。<br>不过很不幸的是，百度的CoreText资料还是比较少滴，翻来覆去就那几个版本。<br>然而我又上不去谷歌，so，困难重重啊。<br>不过虽然资料少，不够前辈们给的贡献终于还是在我的努力下都被我消化了，然后我也来做个笔记。</p>\n<hr>\n<h2 id=\"CoreText的介绍\"><a href=\"#CoreText的介绍\" class=\"headerlink\" title=\"CoreText的介绍\"></a>CoreText的介绍</h2><p>Core Text 是基于 iOS 3.2+ 和 OSX 10.5+ 的一种能够对文本格式和文本布局进行精细控制的文本引擎。<br>它良好的结合了 UIKit 和 Core Graphics/Quartz：  </p>\n<pre><code>UIKit 的 UILabel 允许你通过在 IB 中简单的拖曳添加文本，但你不能改变文本的颜色和其中的单词。  \nCore Graphics/Quartz几乎允许你做任何系统允许的事情，但你需要为每个字形计算位置，并画在屏幕上。\nCore Text 正结合了这两者！你可以完全控制位置、布局、类似文本大小和颜色这样的属性，而 Core Text 将帮你完善其它的东西——类似文本换行、字体呈现等等。\n</code></pre><p>以上就是对CoreText的介绍。</p>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"老司机对CoreText实现图文混排的一些理解\"><a href=\"#老司机对CoreText实现图文混排的一些理解\" class=\"headerlink\" title=\"老司机对CoreText实现图文混排的一些理解\"></a>老司机对CoreText实现图文混排的一些理解</h2><p>老司机认为，图文混排中使用到的CoreText只是CoreText庞大体系中一个对富文本的<strong>增强</strong>的一部分。<br>我个人想法啊，我读书少，理解的可能不到位，不过你咬我啊。</p>\n<p>恩，我又逗逼了一波，说好的大师气质呢，下面开始严肃了啊。</p>\n<p>严肃的就是iOS7新推出的类库<code>Textkit</code>，其实是在之前推出的<code>CoreText上的封装</code>，根据苹果的说法，他们开发了两年多才完成，而且他们在开发时候也将表情混排作为一个使用案例进行研究，所以要<code>实现表情混排将会非常容易</code>。</p>\n<p>苹果引入TextKit的目的并非要取代已有的CoreText框架，虽然<code>CoreText的主要作用也是用于文字的排版和渲染</code>，但它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，<code>从性能和易用性来考虑</code>，<code>最佳方案就是使用CoreText</code>。<br>原理的东西学一学总没有坏处。因此，还是有必要去学一学CoreText的。<br>那我们开始学习吧。</p>\n<hr>\n<h1 id=\"富文本\"><a href=\"#富文本\" class=\"headerlink\" title=\"富文本\"></a>富文本</h1><p>老司机说过，我要讲的只是用来增强富文本的那一部分，那么富文本怎么使用呢。</p>\n<p>富文本是什么呢？</p>\n<blockquote>\n<p>富文本格式(RTF)规范是为了便于在应用程序之间轻松转储格式化文本和图形的一种编码方法。<br>现在，用户可以利用特定转换软件，在不同系统如MS-DOS、Windows、OS/2、Macintosh和Power Macintosh的应用程序之间转移字处理文档。<br>RTF规范提供一种在不同的输出设备、操作环境和操作系统之间交换文本和图形的一种格式。<br>RTF使用ANSI, PC-8, Macintosh, 或IBM PC字符集控制文档的表示法和格式化，包括屏幕显示和打印<br>。凭借RTF规范，不同的操作系统和不同的软件程序创建的文档能够在这些操作系统和应用程序之间传递。<br>将一个格式化的文件转换为RTF文件的软件称为RTF书写器。<br>RTF书写器用于分离现有文本中的程序控制信息，并且生成一个包含文本和与之相关的RTF组的新文件。将RTF文件转换成格式化文件的软件则称为RTF阅读器。</p>\n</blockquote>\n<p>简单的说，附<code>带有每一个文字属性的字符串</code>，就是富文本。<br>在iOS中，我们有一个专门的类来处理富文本 <code>AttributeString</code>。  </p>\n<hr>\n<h2 id=\"富文本的基本使用方法\"><a href=\"#富文本的基本使用方法\" class=\"headerlink\" title=\"富文本的基本使用方法\"></a>富文本的基本使用方法</h2><p>诶，标题越来越小了，都4个#号了，说明我扯远了啊。不过要想使用CoreText不会富文本还是不行啊。</p>\n<p>来吧。<br>AttributedString也分为<code>NSAttributedString</code>和<code>NSMutableAttributedString</code>两个类，类似于String，我就不赘述了。<br>富文本本质上没有什么难度，只要给指定的字符串附上指定的属性就好了。下面给出富文本的一些基本方法。  </p>\n<ul>\n<li>-initWithString:<code>以NSString初始化一个富文本对象</code>  </li>\n<li>-setAttributes:range:<code>为富文本中的一段范围添加一些属性</code>，第一个参数是个NSDictionary字典，第二个参数是NSRange。</li>\n<li>-addAttribute:value:range:<code>添加一个属性</code></li>\n<li>-addAttributes:range:<code>添加多个属性</code></li>\n<li>-removeAttribute:range:<code>移除属性</code><br>额,老司机知道这么说不直观，来来来，上代码。  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSDictionary * dic = @&#123;NSFontAttributeName:[UIFont fontWithName:@&quot;Zapfino&quot; size:20],NSForegroundColorAttributeName:[UIColor redColor],NSUnderlineStyleAttributeName:@(NSUnderlineStyleSingle)&#125;;</div><div class=\"line\">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;0我是一个富文本，9听说我有很多属性，19I will try。32这里清除属性.&quot;];</div><div class=\"line\">//    设置属性</div><div class=\"line\">    [attributeStr setAttributes:dic range:NSMakeRange(0, attributeStr.length)];</div><div class=\"line\">//    添加属性</div><div class=\"line\">    [attributeStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(9, 10)];</div><div class=\"line\">    [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor cyanColor] range:NSMakeRange(13, 13)];</div><div class=\"line\">//    添加多个属性</div><div class=\"line\">    NSDictionary * dicAdd = @&#123;NSBackgroundColorAttributeName:[UIColor yellowColor],NSLigatureAttributeName:@1&#125;;</div><div class=\"line\">    [attributeStr addAttributes:dicAdd range:NSMakeRange(19, 13)];</div><div class=\"line\">//    移除属性</div><div class=\"line\">    [attributeStr removeAttribute:NSFontAttributeName range:NSMakeRange(32, 9)];</div><div class=\"line\">    UILabel * label = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 200, 400)];</div><div class=\"line\">    label.numberOfLines = 0;</div><div class=\"line\">    label.attributedText = attributeStr;</div></pre></td></tr></table></figure>\n<p>这里你要注意一下，给label的一定是给他的<code>attributedText</code>属性，你给text是不行的。<br>是不是用起来很简单，富文本，跟字典没什么区别么。</p>\n<hr>\n<h1 id=\"CoreText绘制富文本\"><a href=\"#CoreText绘制富文本\" class=\"headerlink\" title=\"CoreText绘制富文本\"></a>CoreText绘制富文本</h1><p>是不是终于进入正题了。其实之所以说那么多，还是为了你看完就能保证会用啊，否则你不会富文本你自己还要查找富文本相关资料。</p>\n<p><strong>Come On！</strong></p>\n<p>CoreText实现图文混排其实就是在富文本中<code>插入一个空白的图片占位符</code>的富文本字符串，通过<code>代理设置相关的图片尺寸信息</code>，根据从富文本得到的frame<code>计算图片绘制的frame再绘制图片</code>这么一个过程。  </p>\n<p>先来整体代码</p>\n<h2 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)drawRect:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    [super drawRect:rect];</div><div class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</div><div class=\"line\">    CGContextScaleCTM(context, 1.0, -1.0);</div><div class=\"line\">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;\\n这里在测试图文混排，\\n我是一个富文本&quot;];</div><div class=\"line\">    CTRunDelegateCallbacks callBacks;</div><div class=\"line\">    memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks));</div><div class=\"line\">    callBacks.version = kCTRunDelegateVersion1;</div><div class=\"line\">    callBacks.getAscent = ascentCallBacks;</div><div class=\"line\">    callBacks.getDescent = descentCallBacks;</div><div class=\"line\">    callBacks.getWidth = widthCallBacks;</div><div class=\"line\">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@129,@&quot;width&quot;:@400&#125;;</div><div class=\"line\">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</div><div class=\"line\">    unichar placeHolder = 0xFFFC;</div><div class=\"line\">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</div><div class=\"line\">    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</div><div class=\"line\">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</div><div class=\"line\">    CFRelease(delegate);</div><div class=\"line\">    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];</div><div class=\"line\">    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</div><div class=\"line\">    CGMutablePathRef path = CGPathCreateMutable();</div><div class=\"line\">    CGPathAddRect(path, NULL, self.bounds);</div><div class=\"line\">    NSInteger length = attributeStr.length;</div><div class=\"line\">    CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);</div><div class=\"line\">    CTFrameDraw(frame, context);</div><div class=\"line\">    </div><div class=\"line\">    UIImage * image = [UIImage imageNamed:@&quot;bd_logo1&quot;];</div><div class=\"line\">    CGRect imgFrm = [self calculateImageRectWithFrame:frame];</div><div class=\"line\">    CGContextDrawImage(context,imgFrm, image.CGImage);</div><div class=\"line\">    CFRelease(frame);</div><div class=\"line\">    CFRelease(path);</div><div class=\"line\">    CFRelease(frameSetter);</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat ascentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat descentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat widthCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame</div><div class=\"line\">&#123;</div><div class=\"line\">    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</div><div class=\"line\">    NSInteger count = [arrLines count];</div><div class=\"line\">    CGPoint points[count];</div><div class=\"line\">    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</div><div class=\"line\">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</div><div class=\"line\">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</div><div class=\"line\">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</div><div class=\"line\">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</div><div class=\"line\">            if (delegate == nil) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);</div><div class=\"line\">            if (![dic isKindOfClass:[NSDictionary class]]) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            CGPoint point = points[i];</div><div class=\"line\">            CGFloat ascent;</div><div class=\"line\">            CGFloat descent;</div><div class=\"line\">            CGRect boundsRun;</div><div class=\"line\">            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</div><div class=\"line\">            boundsRun.size.height = ascent + descent;</div><div class=\"line\">            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</div><div class=\"line\">            boundsRun.origin.x = point.x + xOffset;</div><div class=\"line\">            boundsRun.origin.y = point.y - descent;</div><div class=\"line\">            CGPathRef path = CTFrameGetPath(frame);</div><div class=\"line\">            CGRect colRect = CGPathGetBoundingBox(path);</div><div class=\"line\">            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class=\"line\">            return imageBounds;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return CGRectZero;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不瞒你说，我看着代码都烦，也怕，所以放心，老司机会一句一句给你解释的。</p>\n<hr>\n<h2 id=\"分段解析\"><a href=\"#分段解析\" class=\"headerlink\" title=\"分段解析\"></a>分段解析</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">CGContextSetTextMatrix(context, CGAffineTransformIdentity);    </div><div class=\"line\">CGContextTranslateCTM(context, 0, self.bounds.size.height);</div><div class=\"line\">CGContextScaleCTM(context, 1.0, -1.0);</div></pre></td></tr></table></figure>\n<p>先要来一个背景介绍哈</p>\n<pre><code>/*\n coreText 起初是为OSX设计的，而OSX得坐标原点是左下角，y轴正方向朝上。iOS中坐标原点是左上角，y轴正方向向下。\n 若不进行坐标转换，则文字从下开始，还是倒着的\n     如下图(盗的图，别打我)\n */\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-597db8c1833bf0c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"系统坐标系\">  </p>\n<p>这四句什么意思呢？  </p>\n<h4 id=\"获取上下文\"><a href=\"#获取上下文\" class=\"headerlink\" title=\"获取上下文\"></a>获取上下文</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGContextRef context = UIGraphicsGetCurrentContext();//获取当前绘制上下文</div></pre></td></tr></table></figure>\n<p>为什么要回去上下文呢？因为我们所有的绘制操作都是在上下文上进行绘制的。 </p>\n<h4 id=\"坐标转换\"><a href=\"#坐标转换\" class=\"headerlink\" title=\"坐标转换\"></a>坐标转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGContextSetTextMatrix(context, CGAffineTransformIdentity);//设置字形的变换矩阵为不做图形变换  </div><div class=\"line\">    CGContextTranslateCTM(context, 0, self.bounds.size.height);//平移方法，将画布向上平移一个屏幕高  </div><div class=\"line\">    CGContextScaleCTM(context, 1.0, -1.0);//缩放方法，x轴缩放系数为1，则不变，y轴缩放系数为-1，则相当于以x轴为轴旋转180度</div></pre></td></tr></table></figure>\n<p>正如之上的背景说的，coreText使用的是<code>系统坐标</code>，然而我们平时所接触的iOS的都是<code>屏幕坐标</code>，所以要将屏幕坐标系<code>转换</code>系统坐标系，这样才能与我们想想的坐标互相对应。<br><code>事实上呢，这三句是翻转画布的固定写法，这三句你以后会经常看到的。</code></p>\n<p>继续。</p>\n<hr>\n<h4 id=\"图片的代理的设置\"><a href=\"#图片的代理的设置\" class=\"headerlink\" title=\"图片的代理的设置\"></a>图片的代理的设置</h4><blockquote>\n<p>事实上，图文混排就是在要插入图片的位置插入一个富文本类型的占位符。通过CTRUNDelegate设置图片</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;\\n这里在测试图文混排，\\n我是一个富文本&quot;];//这句不用我多说吧，最起码得有个富文本啊才能插入不是。</div><div class=\"line\">/*</div><div class=\"line\"> 设置一个回调结构体，告诉代理该回调那些方法</div><div class=\"line\"> */</div><div class=\"line\">CTRunDelegateCallbacks callBacks;//创建一个回调结构体，设置相关参数</div><div class=\"line\">memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks));//memset将已开辟内存空间 callbacks 的首 n 个字节的值设为值 0, 相当于对CTRunDelegateCallbacks内存空间初始化</div><div class=\"line\">callBacks.version = kCTRunDelegateVersion1;//设置回调版本，默认这个</div><div class=\"line\">callBacks.getAscent = ascentCallBacks;//设置图片顶部距离基线的距离</div><div class=\"line\">callBacks.getDescent = descentCallBacks;//设置图片底部距离基线的距离</div><div class=\"line\">callBacks.getWidth = widthCallBacks;//设置图片宽度</div></pre></td></tr></table></figure>\n<p><strong>注意了，这里经GreyLove提醒有重要改动，就是这里，添加了memset，码字的时候少忘码了一句话。怪我粗心，十分抱歉，我会通知每一个留言的同学。</strong></p>\n<p>为什么要设置一个回调结构体呢？<br>因为coreText中大量的调用c的方法。<code>事实上你会发现大部分跟系统底层有关的都需要调c的方法。</code>所以设置代理要按照人家的方法来啊。</p>\n<p>看看这几句代码也很好懂，就是注释中写的意思。<br>后三句分别就是说当我需要走这些代理的时候都会走那些<code>代理方法</code>。<br>好吧，扯到这又要补充知识了。这个距离什么东西呢？<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-945506c609eeac5d.gif?imageMogr2/auto-orient/strip\" alt=\"字形\"></p>\n<p>对对，这呢就是一个CTRun的尺寸图，什么你问CTRun是啥？还没到那呢，后面会详细介绍。<br>在这你只要知道，一会我们绘制图片的时候实际上实在一个CTRun中绘制这个图片，那么CTRun绘制的坐标系中，他会以<code>origin点作为原点</code>进行绘制。<br><code>基线为过原点的x轴</code>，<code>ascent即为CTRun顶线距基线的距离</code>，<code>descent即为底线距基线的距离</code>。<br>我们绘制图片应该从原点开始绘制，图片的高度及宽度及CTRun的高度及宽度，我们<code>通过代理设置CTRun的尺寸间接设置图片的尺寸。</code></p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\"> 创建一个代理</div><div class=\"line\">*/</div><div class=\"line\">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@129,@&quot;width&quot;:@400&#125;;//创建一个图片尺寸的字典，初始化代理对象需要</div><div class=\"line\">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);//创建代理</div></pre></td></tr></table></figure>\n<p>上面只是设置了回调结构体，然而我们还没有告诉这个代理我们要的<code>图片尺寸</code>。<br>所以这句话就在<code>设置代理的时候绑定了一个返回图片尺寸的字典</code>。<br>事实上此处你可以<code>绑定任意对象</code>。此处你<code>绑定的对象既是回调方法中的参数ref</code>。</p>\n<p>好吧就然说到这我就直接把那三个回调方法说了吧，放在一起比较好理解一些。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static CGFloat ascentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat descentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat widthCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上文说过，ref既是创建代理是绑定的对象。所以我们在这里，<code>从字典中分别取出图片的宽和高</code>。</p>\n<p>值得注意的是，由于是c的方法，所以也没有什么对象的概念。是一个<code>指针类型的数据</code>。不过oc的对象其实也就是c的结构体。我们可以通过类型转换获得oc中的字典。<br><code>__bridge既是C的结构体转换成OC对象时需要的一个修饰词</code>。</p>\n<p>老司机敲字慢啊，敲到这都两个小时了，容我喝口水。  </p>\n<p>你们喝过红色的尖叫么？老司机喝了那种烟头泡的水之后<code>精神满满</code>的继续敲字。（那水超难喝，你可以挑战一下）<br>诶，说好的严肃呢？</p>\n<hr>\n<h4 id=\"图片的插入\"><a href=\"#图片的插入\" class=\"headerlink\" title=\"图片的插入\"></a>图片的插入</h4><p>首先创建一个富文本类型的图片占位符，绑定我们的代理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">unichar placeHolder = 0xFFFC;//创建空白字符</div><div class=\"line\">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];//已空白字符生成字符串</div><div class=\"line\">    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];//用字符串初始化占位符的富文本</div><div class=\"line\">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);//给字符串中的范围中字符串设置代理</div><div class=\"line\">    CFRelease(delegate);//释放（__bridge进行C与OC数据类型的转换，C为非ARC，需要手动管理）</div></pre></td></tr></table></figure>\n<p>这里富文本的知识上文中已经介绍过了。不过老司机猜你有三个疑问。  </p>\n<ul>\n<li>这个添加属性的方法怎么是这个样子的？<br>因为这里是添加CTRunDelegate这种数据类型，要用CoreText专门的方法，不过其实就是形式不同，作用一样的。</li>\n<li>为什么这里富文本类型转换的时候不用_bridge呢？老司机你不是说需要修饰词么？你是不是骗我？(markDown语法冲突我少打一个下划线)<br>真没有，事实上不是所有数据转换的时候都需要__bridge。你要问我怎么区分？那好我告诉你，C中就是传递指针的数据就不用。比如说字符串，数组。原因老司机现在解释不通，等我能组织好语言的。</li>\n<li>为什么还要释放？我是ARC环境啊<br>不好意思，我也是。不过为什么要释放呢？因为你进行了类型转换之后就不属于对象了，也不再归自动引用计数机制管理了，所以你得<code>手动管理</code>咯。</li>\n</ul>\n<hr>\n<p>然后将占位符插入到我们的富文本中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];//将占位符插入原富文本</div></pre></td></tr></table></figure>\n<p>此处我就不赘述了，富文本的知识你只要类比字典就好了。<br>至此，我们已经生成好了我们要的带有图片信息的富文本了，接下来我们只要在画布上<code>绘制</code>出来这个富文本就好了。</p>\n<hr>\n<h4 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h4><p>绘制呢，又分成两部分，<code>绘制文本</code>和<code>绘制图片</code>。你问我为什么还分成两个？</p>\n<p>因为富文本中你添加的图片只是一个<code>带有图片尺寸的空白占位符</code>啊，你绘制的时候他只会绘制出相应尺寸的空白占位符，所以什么也显示不了啊。<br>那怎么显示图片啊？拿到占位符的坐标，<code>在占位符的地方绘制相应大小的图片</code>就好了。恩，说到这，图文混排的原理已经说完了。</p>\n<p>先来绘制文本吧。</p>\n<hr>\n<h5 id=\"绘制文本\"><a href=\"#绘制文本\" class=\"headerlink\" title=\"绘制文本\"></a>绘制文本</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);//一个frame的工厂，负责生成frame</div><div class=\"line\">CGMutablePathRef path = CGPathCreateMutable();//创建绘制区域</div><div class=\"line\">CGPathAddRect(path, NULL, self.bounds);//添加绘制尺寸</div><div class=\"line\">NSInteger length = attributeStr.length;</div><div class=\"line\">CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0,length), path, NULL);//工厂根据绘制区域及富文本（可选范围，多次设置）设置frame</div><div class=\"line\">CTFrameDraw(frame, context);//根据frame绘制文字</div></pre></td></tr></table></figure>\n<p>frameSetter是根据富文本生成的一个frame生成的工厂，你可以<code>通过framesetter</code>以及你想要绘制的<code>富文本的范</code>围获取<code>该CTRun的frame</code>。<br>但是你需要注意的是，获取的frame是<code>仅绘制你所需要的那部分富文本的frame</code>。即当前情况下，你绘制范围定为（10，1），那么你得到的尺寸是只绘制（10，1）的尺寸，他应该从屏幕左上角开始（因为你改变了坐标系），而<code>不是当你绘制全部富文本时他该在的位置</code>。</p>\n<p>然后建立一会绘制的尺寸，实际上就是在指定你的<code>绘制范围</code>。<br>接着生成<code>整个富文本绘制所需要的frame</code>。因为范围是全部文本，所以获取的frame即为全部文本的frame(此处老司机希望你一定要搞清楚全部与指定范围获取的frame他们都是从左上角开始的，否则你会进入一个奇怪的误区，稍后会提到的)。<br>最后，根据你获得的frame，绘制<code>全部富文本</code>。</p>\n<hr>\n<h5 id=\"绘制图片\"><a href=\"#绘制图片\" class=\"headerlink\" title=\"绘制图片\"></a>绘制图片</h5><p>上面你已经绘制出文字，不过没有图片哦，接下来绘制图片。<br>绘制图片用下面这个方法，通用的哦  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGContextDrawImage(context,imgFrm, image.CGImage);//绘制图片</div></pre></td></tr></table></figure>\n<p>我们可以看到这个方法有三个参数，分别是<code>context，frame，以及image</code>。<br>要什么就给他什么好咯，context和image都好说，context就是当前的上下文，最开始获得那个。image就是你要添加的那个图片，不过是<code>CGImage类型</code>。通过UIImage转出CGImage就好了，我们重点讲一下frame的获取。  </p>\n<h6 id=\"frame的获取\"><a href=\"#frame的获取\" class=\"headerlink\" title=\"frame的获取\"></a>frame的获取</h6><p>记得我之前说的误区么？这里我们要获得Image的frame，你有没有想过我们的frameSetter？</p>\n<p>我也想过，不过就像我说的，你单独用frameSetter求出的image的frame是不正确的，那是只绘制image而得的坐标，所以哪种方法不能用哦，要用下面的方法。    </p>\n<p>你们一定发现，我获取frame的方法单独写了一个方法，为什么呢？<br>1.将<code>代码分离</code>，方便修改。<br>2.最主要的是这部分代码到哪里都能用，达到<code>复用</code>效果。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);//根据frame获取需要绘制的线的数组</div><div class=\"line\">NSInteger count = [arrLines count];//获取线的数量</div><div class=\"line\">CGPoint points[count];//建立起点的数组（cgpoint类型为结构体，故用C语言的数组）</div><div class=\"line\">CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);//获取起点</div></pre></td></tr></table></figure>\n<p>第一句呢，获取绘制frame中的所有CTLine。CTLine，又不知道了吧，老司机又要无耻的盗图了。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-823846a97a7b220e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CTFrame组成\"><br>上面呢，我们能看到一个CTFrame绘制的原理。</p>\n<ul>\n<li>CTLine 可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs</li>\n<li>CTRun 或者叫做 Glyph Run，是一组共享想相同attributes（属性）的字形的集合体</li>\n</ul>\n<p>一个CTFrame有几个CTLine组成，有几行文字就有几行CTLine。一个CTLine有包含多个CTRun，一个CTRun是所有属性都相同的那部分富文本的绘制单元。所以CTRun是CTFrame的<code>基本绘制单元</code>。<br>接着说我们的代码。<br>为什么我获取的数组需要进行类型转换呢？因为CTFrameGetLines（）返回值是<code>CFArrayRef类型</code>的数据。就是一个c的数组类型吧，暂且先这么理解，所以需要转换。  </p>\n<p>那为什么不用__bridge呢？记得么，我说过，<code>本身就传地址的数据是不用桥接的</code>。就是这样。<br>然后获取数组的元素个数。有什么用呢，因为我们要用到每个CTLine的<code>原点坐标</code>进行计算。每个CTLine都有自己的origin。所以要生成一个<code>相同元素个数的数组去盛放origin对象</code>。<br>然后用CTFrameGetLineOrigins获取所有原点。<br>到此，我们计算frame的准备工作完成了。才完成准备工作。  </p>\n<hr>\n<h6 id=\"计算frame\"><a href=\"#计算frame\" class=\"headerlink\" title=\"计算frame\"></a>计算frame</h6><p>思路呢，就是<code>遍历</code>我们的frame中的所有CTRun，<code>检查</code>他是不是我们绑定图片的那个，如果是，根据该CTRun所在CTLine的origin以及CTRun在CTLine中的横向偏移量<code>计算</code>出CTRun的原点，加上其尺寸即为该CTRun的尺寸。</p>\n<p>跟绕口令是的，不过就是这么个思路。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; count; i ++) &#123;//遍历线的数组</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</div><div class=\"line\">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);//获取GlyphRun数组（GlyphRun：高效的字符绘制方案）</div><div class=\"line\">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;//遍历CTRun数组</div><div class=\"line\">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];//获取CTRun</div><div class=\"line\">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);//获取CTRun的属性</div><div class=\"line\">            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];//获取代理</div><div class=\"line\">            if (delegate == nil) &#123;//非空</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);//判断代理字典</div><div class=\"line\">            if (![dic isKindOfClass:[NSDictionary class]]) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            CGPoint point = points[i];//获取一个起点</div><div class=\"line\">            CGFloat ascent;//获取上距</div><div class=\"line\">            CGFloat descent;//获取下距</div><div class=\"line\">            CGRect boundsRun;//创建一个frame</div><div class=\"line\">            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</div><div class=\"line\">            boundsRun.size.height = ascent + descent;//取得高</div><div class=\"line\">            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);//获取x偏移量</div><div class=\"line\">            boundsRun.origin.x = point.x + xOffset;//point是行起点位置，加上每个字的偏移量得到每个字的x</div><div class=\"line\">            boundsRun.origin.y = point.y - descent;//计算原点</div><div class=\"line\">            CGPathRef path = CTFrameGetPath(frame);//获取绘制区域</div><div class=\"line\">            CGRect colRect = CGPathGetBoundingBox(path);//获取剪裁区域边框</div><div class=\"line\">            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class=\"line\">            return imageBounds;</div></pre></td></tr></table></figure>\n<p>有了上面的思路这里就很好理解了。<br>外层for循环呢，是为了<code>取到所有的CTLine</code>。<br>类型转换什么的我就不多说了，然后通过CTLineGetGlyphRuns获取一个CTLine中的<code>所有CTRun</code>。<br>里层for循环是检查每个CTRun。<br>通过CTRunGetAttributes拿到该<code>CTRun的所有属性</code>。<br>通过kvc取得属性中的<code>代理属性</code>。<br>接下来判断<code>代理属性是否为空</code>。因为图片的占位符我们是绑定了代理的，而文字没有。以此区分文字和图片。<br>如果代理不为空，通过CTRunDelegateGetRefCon取得生成<code>代理时绑定的对象</code>。<code>判断类型</code>是否是我们绑定的类型，<code>防止取得我们之前为其他的富文本绑定过代理</code>。<br>如果两条都符合，ok，这就是<code>我们要的那个CTRun</code>。<br>开始计算该<code>CTRun的frame</code>吧。<br>获取<code>原点</code>和获取<code>宽高</code>被。<br>通过<code>CTRunGetTypographicBounds</code>取得宽，ascent和descent。有了上面的介绍我们应该知道图片的高度就是ascent+descent了吧。<br>接下来获取原点。<br>CTLineGetOffsetForStringIndex获取对应<code>CTRun的X偏移量</code>。<br>取得对应CTLine的原点的Y，<code>减去图片的下边距才是图片的原点</code>，这点应该很好理解。<br>至此，我们已经获得了<code>图片的frame</code>了。因为只绑定了一个图片，所以直接return就好了，如果多张图片可以继续遍历返回数组。<br>获取到图片的frame，我们就可以绘制图片了，用上面介绍的方法。  </p>\n<hr>\n<p>哦，别忘了手动释放你创建的对象哦。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRelease(frame);</div><div class=\"line\">CFRelease(path);</div><div class=\"line\">CFRelease(frameSetter);</div></pre></td></tr></table></figure>\n<p>大功告成。</p>\n<hr>\n<p>好了，至此你已经完成图片的绘制了。只要在ViewController里面引入你绘制CoreText文本的View正常的初始化添加子视图就可以了。</p>\n<p>好吧，这个教程我也是综合了很多资料写出来的。优势是在于我一句一句讲的，几乎每一句都告诉你原理了吧。</p>\n<p>恩，我也是在前人的基础上自己总结查阅出来的，难免夹杂着个人理解和部分偏颇，如果各位看官发现我写的有什么不对的地方欢迎与我联系，老司机的邮箱codewicky@163.com。</p>\n<p>原谅老司机逗逼的本质，严肃不起来。</p>\n<p>下面是一些参考资料：<br><a href=\"http://blog.csdn.net/liliangchw/article/details/8261646\" target=\"_blank\" rel=\"external\">coreText方法，列的很全</a><br><a href=\"http://www.docin.com/p-721844449.html\" target=\"_blank\" rel=\"external\">CTRun的详细介绍</a><br><a href=\"http://blog.csdn.net/majiakun1/article/details/38140411\" target=\"_blank\" rel=\"external\">CTLine的详细介绍</a><br><a href=\"http://www.tuicool.com/articles/FfYjim\" target=\"_blank\" rel=\"external\">coreText基本原理及使用方法</a><br><a href=\"http://my.oschina.net/u/2361492/blog/526814\" target=\"_blank\" rel=\"external\">图文混排的整体介绍</a><br><a href=\"https://my.oschina.net/megan/blog/269042\" target=\"_blank\" rel=\"external\">coreText使用方法</a></p>\n<p>你要是喜欢呢，麻烦你动一动你可爱的小手点击一下喜欢或者关注，毕竟老司机这么爱慕虚荣的人，而且老司机会经常更新的。</p>\n<p>最后，你问我为什么一直叫自己老司机？哦，因为嘿嘿嘿~~~</p>\n<p>哦，最后的最后，若果真有人转载的话，麻烦你注明出处。<br><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/6db3289fb05d</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-07e7d10e9bb52c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CoreText实现图文混排\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排</a></li>\n<li><a href=\"http://www.jianshu.com/p/51c47329203e\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之点击事件</a></li>\n<li><a href=\"http://www.jianshu.com/p/e154047b0f98\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之文字环绕及点击算法</a></li>\n</ul>\n<hr>\n<p>也好久没来写博客了，主要是最近也工作了，手头的事有点多，一时间也就断了，闲下来了我就来补博客了，刚好最近也做了很多东西，放在这里也算给自己做个笔记吧。</p>\n<hr>\n<h1 id=\"CoreText\"><a href=\"#CoreText\" class=\"headerlink\" title=\"CoreText\"></a>CoreText</h1><p>最近公司做了一个项目，需要用到<code>图文混排</code>技术。于是呢就疯狂地在网上搜刮资料。<br>不过很不幸的是，百度的CoreText资料还是比较少滴，翻来覆去就那几个版本。<br>然而我又上不去谷歌，so，困难重重啊。<br>不过虽然资料少，不够前辈们给的贡献终于还是在我的努力下都被我消化了，然后我也来做个笔记。</p>\n<hr>\n<h2 id=\"CoreText的介绍\"><a href=\"#CoreText的介绍\" class=\"headerlink\" title=\"CoreText的介绍\"></a>CoreText的介绍</h2><p>Core Text 是基于 iOS 3.2+ 和 OSX 10.5+ 的一种能够对文本格式和文本布局进行精细控制的文本引擎。<br>它良好的结合了 UIKit 和 Core Graphics/Quartz：  </p>\n<pre><code>UIKit 的 UILabel 允许你通过在 IB 中简单的拖曳添加文本，但你不能改变文本的颜色和其中的单词。  \nCore Graphics/Quartz几乎允许你做任何系统允许的事情，但你需要为每个字形计算位置，并画在屏幕上。\nCore Text 正结合了这两者！你可以完全控制位置、布局、类似文本大小和颜色这样的属性，而 Core Text 将帮你完善其它的东西——类似文本换行、字体呈现等等。\n</code></pre><p>以上就是对CoreText的介绍。</p>","more":"<hr>\n<h2 id=\"老司机对CoreText实现图文混排的一些理解\"><a href=\"#老司机对CoreText实现图文混排的一些理解\" class=\"headerlink\" title=\"老司机对CoreText实现图文混排的一些理解\"></a>老司机对CoreText实现图文混排的一些理解</h2><p>老司机认为，图文混排中使用到的CoreText只是CoreText庞大体系中一个对富文本的<strong>增强</strong>的一部分。<br>我个人想法啊，我读书少，理解的可能不到位，不过你咬我啊。</p>\n<p>恩，我又逗逼了一波，说好的大师气质呢，下面开始严肃了啊。</p>\n<p>严肃的就是iOS7新推出的类库<code>Textkit</code>，其实是在之前推出的<code>CoreText上的封装</code>，根据苹果的说法，他们开发了两年多才完成，而且他们在开发时候也将表情混排作为一个使用案例进行研究，所以要<code>实现表情混排将会非常容易</code>。</p>\n<p>苹果引入TextKit的目的并非要取代已有的CoreText框架，虽然<code>CoreText的主要作用也是用于文字的排版和渲染</code>，但它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，<code>从性能和易用性来考虑</code>，<code>最佳方案就是使用CoreText</code>。<br>原理的东西学一学总没有坏处。因此，还是有必要去学一学CoreText的。<br>那我们开始学习吧。</p>\n<hr>\n<h1 id=\"富文本\"><a href=\"#富文本\" class=\"headerlink\" title=\"富文本\"></a>富文本</h1><p>老司机说过，我要讲的只是用来增强富文本的那一部分，那么富文本怎么使用呢。</p>\n<p>富文本是什么呢？</p>\n<blockquote>\n<p>富文本格式(RTF)规范是为了便于在应用程序之间轻松转储格式化文本和图形的一种编码方法。<br>现在，用户可以利用特定转换软件，在不同系统如MS-DOS、Windows、OS/2、Macintosh和Power Macintosh的应用程序之间转移字处理文档。<br>RTF规范提供一种在不同的输出设备、操作环境和操作系统之间交换文本和图形的一种格式。<br>RTF使用ANSI, PC-8, Macintosh, 或IBM PC字符集控制文档的表示法和格式化，包括屏幕显示和打印<br>。凭借RTF规范，不同的操作系统和不同的软件程序创建的文档能够在这些操作系统和应用程序之间传递。<br>将一个格式化的文件转换为RTF文件的软件称为RTF书写器。<br>RTF书写器用于分离现有文本中的程序控制信息，并且生成一个包含文本和与之相关的RTF组的新文件。将RTF文件转换成格式化文件的软件则称为RTF阅读器。</p>\n</blockquote>\n<p>简单的说，附<code>带有每一个文字属性的字符串</code>，就是富文本。<br>在iOS中，我们有一个专门的类来处理富文本 <code>AttributeString</code>。  </p>\n<hr>\n<h2 id=\"富文本的基本使用方法\"><a href=\"#富文本的基本使用方法\" class=\"headerlink\" title=\"富文本的基本使用方法\"></a>富文本的基本使用方法</h2><p>诶，标题越来越小了，都4个#号了，说明我扯远了啊。不过要想使用CoreText不会富文本还是不行啊。</p>\n<p>来吧。<br>AttributedString也分为<code>NSAttributedString</code>和<code>NSMutableAttributedString</code>两个类，类似于String，我就不赘述了。<br>富文本本质上没有什么难度，只要给指定的字符串附上指定的属性就好了。下面给出富文本的一些基本方法。  </p>\n<ul>\n<li>-initWithString:<code>以NSString初始化一个富文本对象</code>  </li>\n<li>-setAttributes:range:<code>为富文本中的一段范围添加一些属性</code>，第一个参数是个NSDictionary字典，第二个参数是NSRange。</li>\n<li>-addAttribute:value:range:<code>添加一个属性</code></li>\n<li>-addAttributes:range:<code>添加多个属性</code></li>\n<li>-removeAttribute:range:<code>移除属性</code><br>额,老司机知道这么说不直观，来来来，上代码。  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSDictionary * dic = @&#123;NSFontAttributeName:[UIFont fontWithName:@&quot;Zapfino&quot; size:20],NSForegroundColorAttributeName:[UIColor redColor],NSUnderlineStyleAttributeName:@(NSUnderlineStyleSingle)&#125;;</div><div class=\"line\">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;0我是一个富文本，9听说我有很多属性，19I will try。32这里清除属性.&quot;];</div><div class=\"line\">//    设置属性</div><div class=\"line\">    [attributeStr setAttributes:dic range:NSMakeRange(0, attributeStr.length)];</div><div class=\"line\">//    添加属性</div><div class=\"line\">    [attributeStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(9, 10)];</div><div class=\"line\">    [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor cyanColor] range:NSMakeRange(13, 13)];</div><div class=\"line\">//    添加多个属性</div><div class=\"line\">    NSDictionary * dicAdd = @&#123;NSBackgroundColorAttributeName:[UIColor yellowColor],NSLigatureAttributeName:@1&#125;;</div><div class=\"line\">    [attributeStr addAttributes:dicAdd range:NSMakeRange(19, 13)];</div><div class=\"line\">//    移除属性</div><div class=\"line\">    [attributeStr removeAttribute:NSFontAttributeName range:NSMakeRange(32, 9)];</div><div class=\"line\">    UILabel * label = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 200, 400)];</div><div class=\"line\">    label.numberOfLines = 0;</div><div class=\"line\">    label.attributedText = attributeStr;</div></pre></td></tr></table></figure>\n<p>这里你要注意一下，给label的一定是给他的<code>attributedText</code>属性，你给text是不行的。<br>是不是用起来很简单，富文本，跟字典没什么区别么。</p>\n<hr>\n<h1 id=\"CoreText绘制富文本\"><a href=\"#CoreText绘制富文本\" class=\"headerlink\" title=\"CoreText绘制富文本\"></a>CoreText绘制富文本</h1><p>是不是终于进入正题了。其实之所以说那么多，还是为了你看完就能保证会用啊，否则你不会富文本你自己还要查找富文本相关资料。</p>\n<p><strong>Come On！</strong></p>\n<p>CoreText实现图文混排其实就是在富文本中<code>插入一个空白的图片占位符</code>的富文本字符串，通过<code>代理设置相关的图片尺寸信息</code>，根据从富文本得到的frame<code>计算图片绘制的frame再绘制图片</code>这么一个过程。  </p>\n<p>先来整体代码</p>\n<h2 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)drawRect:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    [super drawRect:rect];</div><div class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</div><div class=\"line\">    CGContextScaleCTM(context, 1.0, -1.0);</div><div class=\"line\">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;\\n这里在测试图文混排，\\n我是一个富文本&quot;];</div><div class=\"line\">    CTRunDelegateCallbacks callBacks;</div><div class=\"line\">    memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks));</div><div class=\"line\">    callBacks.version = kCTRunDelegateVersion1;</div><div class=\"line\">    callBacks.getAscent = ascentCallBacks;</div><div class=\"line\">    callBacks.getDescent = descentCallBacks;</div><div class=\"line\">    callBacks.getWidth = widthCallBacks;</div><div class=\"line\">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@129,@&quot;width&quot;:@400&#125;;</div><div class=\"line\">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</div><div class=\"line\">    unichar placeHolder = 0xFFFC;</div><div class=\"line\">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</div><div class=\"line\">    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</div><div class=\"line\">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</div><div class=\"line\">    CFRelease(delegate);</div><div class=\"line\">    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];</div><div class=\"line\">    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</div><div class=\"line\">    CGMutablePathRef path = CGPathCreateMutable();</div><div class=\"line\">    CGPathAddRect(path, NULL, self.bounds);</div><div class=\"line\">    NSInteger length = attributeStr.length;</div><div class=\"line\">    CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);</div><div class=\"line\">    CTFrameDraw(frame, context);</div><div class=\"line\">    </div><div class=\"line\">    UIImage * image = [UIImage imageNamed:@&quot;bd_logo1&quot;];</div><div class=\"line\">    CGRect imgFrm = [self calculateImageRectWithFrame:frame];</div><div class=\"line\">    CGContextDrawImage(context,imgFrm, image.CGImage);</div><div class=\"line\">    CFRelease(frame);</div><div class=\"line\">    CFRelease(path);</div><div class=\"line\">    CFRelease(frameSetter);</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat ascentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat descentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat widthCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame</div><div class=\"line\">&#123;</div><div class=\"line\">    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</div><div class=\"line\">    NSInteger count = [arrLines count];</div><div class=\"line\">    CGPoint points[count];</div><div class=\"line\">    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</div><div class=\"line\">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</div><div class=\"line\">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</div><div class=\"line\">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</div><div class=\"line\">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</div><div class=\"line\">            if (delegate == nil) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);</div><div class=\"line\">            if (![dic isKindOfClass:[NSDictionary class]]) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            CGPoint point = points[i];</div><div class=\"line\">            CGFloat ascent;</div><div class=\"line\">            CGFloat descent;</div><div class=\"line\">            CGRect boundsRun;</div><div class=\"line\">            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</div><div class=\"line\">            boundsRun.size.height = ascent + descent;</div><div class=\"line\">            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</div><div class=\"line\">            boundsRun.origin.x = point.x + xOffset;</div><div class=\"line\">            boundsRun.origin.y = point.y - descent;</div><div class=\"line\">            CGPathRef path = CTFrameGetPath(frame);</div><div class=\"line\">            CGRect colRect = CGPathGetBoundingBox(path);</div><div class=\"line\">            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class=\"line\">            return imageBounds;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return CGRectZero;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不瞒你说，我看着代码都烦，也怕，所以放心，老司机会一句一句给你解释的。</p>\n<hr>\n<h2 id=\"分段解析\"><a href=\"#分段解析\" class=\"headerlink\" title=\"分段解析\"></a>分段解析</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">CGContextSetTextMatrix(context, CGAffineTransformIdentity);    </div><div class=\"line\">CGContextTranslateCTM(context, 0, self.bounds.size.height);</div><div class=\"line\">CGContextScaleCTM(context, 1.0, -1.0);</div></pre></td></tr></table></figure>\n<p>先要来一个背景介绍哈</p>\n<pre><code>/*\n coreText 起初是为OSX设计的，而OSX得坐标原点是左下角，y轴正方向朝上。iOS中坐标原点是左上角，y轴正方向向下。\n 若不进行坐标转换，则文字从下开始，还是倒着的\n     如下图(盗的图，别打我)\n */\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-597db8c1833bf0c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"系统坐标系\">  </p>\n<p>这四句什么意思呢？  </p>\n<h4 id=\"获取上下文\"><a href=\"#获取上下文\" class=\"headerlink\" title=\"获取上下文\"></a>获取上下文</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGContextRef context = UIGraphicsGetCurrentContext();//获取当前绘制上下文</div></pre></td></tr></table></figure>\n<p>为什么要回去上下文呢？因为我们所有的绘制操作都是在上下文上进行绘制的。 </p>\n<h4 id=\"坐标转换\"><a href=\"#坐标转换\" class=\"headerlink\" title=\"坐标转换\"></a>坐标转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGContextSetTextMatrix(context, CGAffineTransformIdentity);//设置字形的变换矩阵为不做图形变换  </div><div class=\"line\">    CGContextTranslateCTM(context, 0, self.bounds.size.height);//平移方法，将画布向上平移一个屏幕高  </div><div class=\"line\">    CGContextScaleCTM(context, 1.0, -1.0);//缩放方法，x轴缩放系数为1，则不变，y轴缩放系数为-1，则相当于以x轴为轴旋转180度</div></pre></td></tr></table></figure>\n<p>正如之上的背景说的，coreText使用的是<code>系统坐标</code>，然而我们平时所接触的iOS的都是<code>屏幕坐标</code>，所以要将屏幕坐标系<code>转换</code>系统坐标系，这样才能与我们想想的坐标互相对应。<br><code>事实上呢，这三句是翻转画布的固定写法，这三句你以后会经常看到的。</code></p>\n<p>继续。</p>\n<hr>\n<h4 id=\"图片的代理的设置\"><a href=\"#图片的代理的设置\" class=\"headerlink\" title=\"图片的代理的设置\"></a>图片的代理的设置</h4><blockquote>\n<p>事实上，图文混排就是在要插入图片的位置插入一个富文本类型的占位符。通过CTRUNDelegate设置图片</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;\\n这里在测试图文混排，\\n我是一个富文本&quot;];//这句不用我多说吧，最起码得有个富文本啊才能插入不是。</div><div class=\"line\">/*</div><div class=\"line\"> 设置一个回调结构体，告诉代理该回调那些方法</div><div class=\"line\"> */</div><div class=\"line\">CTRunDelegateCallbacks callBacks;//创建一个回调结构体，设置相关参数</div><div class=\"line\">memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks));//memset将已开辟内存空间 callbacks 的首 n 个字节的值设为值 0, 相当于对CTRunDelegateCallbacks内存空间初始化</div><div class=\"line\">callBacks.version = kCTRunDelegateVersion1;//设置回调版本，默认这个</div><div class=\"line\">callBacks.getAscent = ascentCallBacks;//设置图片顶部距离基线的距离</div><div class=\"line\">callBacks.getDescent = descentCallBacks;//设置图片底部距离基线的距离</div><div class=\"line\">callBacks.getWidth = widthCallBacks;//设置图片宽度</div></pre></td></tr></table></figure>\n<p><strong>注意了，这里经GreyLove提醒有重要改动，就是这里，添加了memset，码字的时候少忘码了一句话。怪我粗心，十分抱歉，我会通知每一个留言的同学。</strong></p>\n<p>为什么要设置一个回调结构体呢？<br>因为coreText中大量的调用c的方法。<code>事实上你会发现大部分跟系统底层有关的都需要调c的方法。</code>所以设置代理要按照人家的方法来啊。</p>\n<p>看看这几句代码也很好懂，就是注释中写的意思。<br>后三句分别就是说当我需要走这些代理的时候都会走那些<code>代理方法</code>。<br>好吧，扯到这又要补充知识了。这个距离什么东西呢？<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-945506c609eeac5d.gif?imageMogr2/auto-orient/strip\" alt=\"字形\"></p>\n<p>对对，这呢就是一个CTRun的尺寸图，什么你问CTRun是啥？还没到那呢，后面会详细介绍。<br>在这你只要知道，一会我们绘制图片的时候实际上实在一个CTRun中绘制这个图片，那么CTRun绘制的坐标系中，他会以<code>origin点作为原点</code>进行绘制。<br><code>基线为过原点的x轴</code>，<code>ascent即为CTRun顶线距基线的距离</code>，<code>descent即为底线距基线的距离</code>。<br>我们绘制图片应该从原点开始绘制，图片的高度及宽度及CTRun的高度及宽度，我们<code>通过代理设置CTRun的尺寸间接设置图片的尺寸。</code></p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\"> 创建一个代理</div><div class=\"line\">*/</div><div class=\"line\">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@129,@&quot;width&quot;:@400&#125;;//创建一个图片尺寸的字典，初始化代理对象需要</div><div class=\"line\">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);//创建代理</div></pre></td></tr></table></figure>\n<p>上面只是设置了回调结构体，然而我们还没有告诉这个代理我们要的<code>图片尺寸</code>。<br>所以这句话就在<code>设置代理的时候绑定了一个返回图片尺寸的字典</code>。<br>事实上此处你可以<code>绑定任意对象</code>。此处你<code>绑定的对象既是回调方法中的参数ref</code>。</p>\n<p>好吧就然说到这我就直接把那三个回调方法说了吧，放在一起比较好理解一些。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static CGFloat ascentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat descentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat widthCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上文说过，ref既是创建代理是绑定的对象。所以我们在这里，<code>从字典中分别取出图片的宽和高</code>。</p>\n<p>值得注意的是，由于是c的方法，所以也没有什么对象的概念。是一个<code>指针类型的数据</code>。不过oc的对象其实也就是c的结构体。我们可以通过类型转换获得oc中的字典。<br><code>__bridge既是C的结构体转换成OC对象时需要的一个修饰词</code>。</p>\n<p>老司机敲字慢啊，敲到这都两个小时了，容我喝口水。  </p>\n<p>你们喝过红色的尖叫么？老司机喝了那种烟头泡的水之后<code>精神满满</code>的继续敲字。（那水超难喝，你可以挑战一下）<br>诶，说好的严肃呢？</p>\n<hr>\n<h4 id=\"图片的插入\"><a href=\"#图片的插入\" class=\"headerlink\" title=\"图片的插入\"></a>图片的插入</h4><p>首先创建一个富文本类型的图片占位符，绑定我们的代理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">unichar placeHolder = 0xFFFC;//创建空白字符</div><div class=\"line\">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];//已空白字符生成字符串</div><div class=\"line\">    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];//用字符串初始化占位符的富文本</div><div class=\"line\">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);//给字符串中的范围中字符串设置代理</div><div class=\"line\">    CFRelease(delegate);//释放（__bridge进行C与OC数据类型的转换，C为非ARC，需要手动管理）</div></pre></td></tr></table></figure>\n<p>这里富文本的知识上文中已经介绍过了。不过老司机猜你有三个疑问。  </p>\n<ul>\n<li>这个添加属性的方法怎么是这个样子的？<br>因为这里是添加CTRunDelegate这种数据类型，要用CoreText专门的方法，不过其实就是形式不同，作用一样的。</li>\n<li>为什么这里富文本类型转换的时候不用_bridge呢？老司机你不是说需要修饰词么？你是不是骗我？(markDown语法冲突我少打一个下划线)<br>真没有，事实上不是所有数据转换的时候都需要__bridge。你要问我怎么区分？那好我告诉你，C中就是传递指针的数据就不用。比如说字符串，数组。原因老司机现在解释不通，等我能组织好语言的。</li>\n<li>为什么还要释放？我是ARC环境啊<br>不好意思，我也是。不过为什么要释放呢？因为你进行了类型转换之后就不属于对象了，也不再归自动引用计数机制管理了，所以你得<code>手动管理</code>咯。</li>\n</ul>\n<hr>\n<p>然后将占位符插入到我们的富文本中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];//将占位符插入原富文本</div></pre></td></tr></table></figure>\n<p>此处我就不赘述了，富文本的知识你只要类比字典就好了。<br>至此，我们已经生成好了我们要的带有图片信息的富文本了，接下来我们只要在画布上<code>绘制</code>出来这个富文本就好了。</p>\n<hr>\n<h4 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h4><p>绘制呢，又分成两部分，<code>绘制文本</code>和<code>绘制图片</code>。你问我为什么还分成两个？</p>\n<p>因为富文本中你添加的图片只是一个<code>带有图片尺寸的空白占位符</code>啊，你绘制的时候他只会绘制出相应尺寸的空白占位符，所以什么也显示不了啊。<br>那怎么显示图片啊？拿到占位符的坐标，<code>在占位符的地方绘制相应大小的图片</code>就好了。恩，说到这，图文混排的原理已经说完了。</p>\n<p>先来绘制文本吧。</p>\n<hr>\n<h5 id=\"绘制文本\"><a href=\"#绘制文本\" class=\"headerlink\" title=\"绘制文本\"></a>绘制文本</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);//一个frame的工厂，负责生成frame</div><div class=\"line\">CGMutablePathRef path = CGPathCreateMutable();//创建绘制区域</div><div class=\"line\">CGPathAddRect(path, NULL, self.bounds);//添加绘制尺寸</div><div class=\"line\">NSInteger length = attributeStr.length;</div><div class=\"line\">CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0,length), path, NULL);//工厂根据绘制区域及富文本（可选范围，多次设置）设置frame</div><div class=\"line\">CTFrameDraw(frame, context);//根据frame绘制文字</div></pre></td></tr></table></figure>\n<p>frameSetter是根据富文本生成的一个frame生成的工厂，你可以<code>通过framesetter</code>以及你想要绘制的<code>富文本的范</code>围获取<code>该CTRun的frame</code>。<br>但是你需要注意的是，获取的frame是<code>仅绘制你所需要的那部分富文本的frame</code>。即当前情况下，你绘制范围定为（10，1），那么你得到的尺寸是只绘制（10，1）的尺寸，他应该从屏幕左上角开始（因为你改变了坐标系），而<code>不是当你绘制全部富文本时他该在的位置</code>。</p>\n<p>然后建立一会绘制的尺寸，实际上就是在指定你的<code>绘制范围</code>。<br>接着生成<code>整个富文本绘制所需要的frame</code>。因为范围是全部文本，所以获取的frame即为全部文本的frame(此处老司机希望你一定要搞清楚全部与指定范围获取的frame他们都是从左上角开始的，否则你会进入一个奇怪的误区，稍后会提到的)。<br>最后，根据你获得的frame，绘制<code>全部富文本</code>。</p>\n<hr>\n<h5 id=\"绘制图片\"><a href=\"#绘制图片\" class=\"headerlink\" title=\"绘制图片\"></a>绘制图片</h5><p>上面你已经绘制出文字，不过没有图片哦，接下来绘制图片。<br>绘制图片用下面这个方法，通用的哦  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGContextDrawImage(context,imgFrm, image.CGImage);//绘制图片</div></pre></td></tr></table></figure>\n<p>我们可以看到这个方法有三个参数，分别是<code>context，frame，以及image</code>。<br>要什么就给他什么好咯，context和image都好说，context就是当前的上下文，最开始获得那个。image就是你要添加的那个图片，不过是<code>CGImage类型</code>。通过UIImage转出CGImage就好了，我们重点讲一下frame的获取。  </p>\n<h6 id=\"frame的获取\"><a href=\"#frame的获取\" class=\"headerlink\" title=\"frame的获取\"></a>frame的获取</h6><p>记得我之前说的误区么？这里我们要获得Image的frame，你有没有想过我们的frameSetter？</p>\n<p>我也想过，不过就像我说的，你单独用frameSetter求出的image的frame是不正确的，那是只绘制image而得的坐标，所以哪种方法不能用哦，要用下面的方法。    </p>\n<p>你们一定发现，我获取frame的方法单独写了一个方法，为什么呢？<br>1.将<code>代码分离</code>，方便修改。<br>2.最主要的是这部分代码到哪里都能用，达到<code>复用</code>效果。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);//根据frame获取需要绘制的线的数组</div><div class=\"line\">NSInteger count = [arrLines count];//获取线的数量</div><div class=\"line\">CGPoint points[count];//建立起点的数组（cgpoint类型为结构体，故用C语言的数组）</div><div class=\"line\">CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);//获取起点</div></pre></td></tr></table></figure>\n<p>第一句呢，获取绘制frame中的所有CTLine。CTLine，又不知道了吧，老司机又要无耻的盗图了。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-823846a97a7b220e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CTFrame组成\"><br>上面呢，我们能看到一个CTFrame绘制的原理。</p>\n<ul>\n<li>CTLine 可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs</li>\n<li>CTRun 或者叫做 Glyph Run，是一组共享想相同attributes（属性）的字形的集合体</li>\n</ul>\n<p>一个CTFrame有几个CTLine组成，有几行文字就有几行CTLine。一个CTLine有包含多个CTRun，一个CTRun是所有属性都相同的那部分富文本的绘制单元。所以CTRun是CTFrame的<code>基本绘制单元</code>。<br>接着说我们的代码。<br>为什么我获取的数组需要进行类型转换呢？因为CTFrameGetLines（）返回值是<code>CFArrayRef类型</code>的数据。就是一个c的数组类型吧，暂且先这么理解，所以需要转换。  </p>\n<p>那为什么不用__bridge呢？记得么，我说过，<code>本身就传地址的数据是不用桥接的</code>。就是这样。<br>然后获取数组的元素个数。有什么用呢，因为我们要用到每个CTLine的<code>原点坐标</code>进行计算。每个CTLine都有自己的origin。所以要生成一个<code>相同元素个数的数组去盛放origin对象</code>。<br>然后用CTFrameGetLineOrigins获取所有原点。<br>到此，我们计算frame的准备工作完成了。才完成准备工作。  </p>\n<hr>\n<h6 id=\"计算frame\"><a href=\"#计算frame\" class=\"headerlink\" title=\"计算frame\"></a>计算frame</h6><p>思路呢，就是<code>遍历</code>我们的frame中的所有CTRun，<code>检查</code>他是不是我们绑定图片的那个，如果是，根据该CTRun所在CTLine的origin以及CTRun在CTLine中的横向偏移量<code>计算</code>出CTRun的原点，加上其尺寸即为该CTRun的尺寸。</p>\n<p>跟绕口令是的，不过就是这么个思路。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; count; i ++) &#123;//遍历线的数组</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</div><div class=\"line\">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);//获取GlyphRun数组（GlyphRun：高效的字符绘制方案）</div><div class=\"line\">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;//遍历CTRun数组</div><div class=\"line\">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];//获取CTRun</div><div class=\"line\">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);//获取CTRun的属性</div><div class=\"line\">            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];//获取代理</div><div class=\"line\">            if (delegate == nil) &#123;//非空</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);//判断代理字典</div><div class=\"line\">            if (![dic isKindOfClass:[NSDictionary class]]) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            CGPoint point = points[i];//获取一个起点</div><div class=\"line\">            CGFloat ascent;//获取上距</div><div class=\"line\">            CGFloat descent;//获取下距</div><div class=\"line\">            CGRect boundsRun;//创建一个frame</div><div class=\"line\">            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</div><div class=\"line\">            boundsRun.size.height = ascent + descent;//取得高</div><div class=\"line\">            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);//获取x偏移量</div><div class=\"line\">            boundsRun.origin.x = point.x + xOffset;//point是行起点位置，加上每个字的偏移量得到每个字的x</div><div class=\"line\">            boundsRun.origin.y = point.y - descent;//计算原点</div><div class=\"line\">            CGPathRef path = CTFrameGetPath(frame);//获取绘制区域</div><div class=\"line\">            CGRect colRect = CGPathGetBoundingBox(path);//获取剪裁区域边框</div><div class=\"line\">            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class=\"line\">            return imageBounds;</div></pre></td></tr></table></figure>\n<p>有了上面的思路这里就很好理解了。<br>外层for循环呢，是为了<code>取到所有的CTLine</code>。<br>类型转换什么的我就不多说了，然后通过CTLineGetGlyphRuns获取一个CTLine中的<code>所有CTRun</code>。<br>里层for循环是检查每个CTRun。<br>通过CTRunGetAttributes拿到该<code>CTRun的所有属性</code>。<br>通过kvc取得属性中的<code>代理属性</code>。<br>接下来判断<code>代理属性是否为空</code>。因为图片的占位符我们是绑定了代理的，而文字没有。以此区分文字和图片。<br>如果代理不为空，通过CTRunDelegateGetRefCon取得生成<code>代理时绑定的对象</code>。<code>判断类型</code>是否是我们绑定的类型，<code>防止取得我们之前为其他的富文本绑定过代理</code>。<br>如果两条都符合，ok，这就是<code>我们要的那个CTRun</code>。<br>开始计算该<code>CTRun的frame</code>吧。<br>获取<code>原点</code>和获取<code>宽高</code>被。<br>通过<code>CTRunGetTypographicBounds</code>取得宽，ascent和descent。有了上面的介绍我们应该知道图片的高度就是ascent+descent了吧。<br>接下来获取原点。<br>CTLineGetOffsetForStringIndex获取对应<code>CTRun的X偏移量</code>。<br>取得对应CTLine的原点的Y，<code>减去图片的下边距才是图片的原点</code>，这点应该很好理解。<br>至此，我们已经获得了<code>图片的frame</code>了。因为只绑定了一个图片，所以直接return就好了，如果多张图片可以继续遍历返回数组。<br>获取到图片的frame，我们就可以绘制图片了，用上面介绍的方法。  </p>\n<hr>\n<p>哦，别忘了手动释放你创建的对象哦。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRelease(frame);</div><div class=\"line\">CFRelease(path);</div><div class=\"line\">CFRelease(frameSetter);</div></pre></td></tr></table></figure>\n<p>大功告成。</p>\n<hr>\n<p>好了，至此你已经完成图片的绘制了。只要在ViewController里面引入你绘制CoreText文本的View正常的初始化添加子视图就可以了。</p>\n<p>好吧，这个教程我也是综合了很多资料写出来的。优势是在于我一句一句讲的，几乎每一句都告诉你原理了吧。</p>\n<p>恩，我也是在前人的基础上自己总结查阅出来的，难免夹杂着个人理解和部分偏颇，如果各位看官发现我写的有什么不对的地方欢迎与我联系，老司机的邮箱codewicky@163.com。</p>\n<p>原谅老司机逗逼的本质，严肃不起来。</p>\n<p>下面是一些参考资料：<br><a href=\"http://blog.csdn.net/liliangchw/article/details/8261646\" target=\"_blank\" rel=\"external\">coreText方法，列的很全</a><br><a href=\"http://www.docin.com/p-721844449.html\" target=\"_blank\" rel=\"external\">CTRun的详细介绍</a><br><a href=\"http://blog.csdn.net/majiakun1/article/details/38140411\" target=\"_blank\" rel=\"external\">CTLine的详细介绍</a><br><a href=\"http://www.tuicool.com/articles/FfYjim\" target=\"_blank\" rel=\"external\">coreText基本原理及使用方法</a><br><a href=\"http://my.oschina.net/u/2361492/blog/526814\" target=\"_blank\" rel=\"external\">图文混排的整体介绍</a><br><a href=\"https://my.oschina.net/megan/blog/269042\" target=\"_blank\" rel=\"external\">coreText使用方法</a></p>\n<p>你要是喜欢呢，麻烦你动一动你可爱的小手点击一下喜欢或者关注，毕竟老司机这么爱慕虚荣的人，而且老司机会经常更新的。</p>\n<p>最后，你问我为什么一直叫自己老司机？哦，因为嘿嘿嘿~~~</p>\n<p>哦，最后的最后，若果真有人转载的话，麻烦你注明出处。<br><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/6db3289fb05d</a></p>"},{"title":"TableView优化之快速滑动下的忽略加载","layout":"post","date":"2017-05-13T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![TableView优化之快速滑动下的忽略加载](http://upload-images.jianshu.io/upload_images/1835430-13da7ca8ce7602d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n系列文章：\n\n- [TableView优化之高度缓存功能](http://www.jianshu.com/p/2b192257276f)\n\n- [TableView优化之加载图片的优化逻辑](http://www.jianshu.com/p/328e503900d0)\n\n- [TableView优化之快速滑动下的忽略加载](http://www.jianshu.com/p/0b020518de5e)\n\n\n- - -\n\n最近在搞什么，所以就顺手写点什么咯~\n\n这两天一直在搞一个TableView的工具类，因为觉得这个东西写完可以一劳永逸，所以就去搞了一下，主要是有助于TableView的快捷开发。没什么好废话的了，直接说事吧=。=\n\n在今天的博客中你可能会看到：\n- VVeboTableView中Cell加载逻辑的解析\n- TableView代码解耦的基本思路\n\n恩，东西不多，一点一点说~\n\n<!-- more -->\n\n- - -  \n### VVeboTableView\n其实这是VVebo项目中作者分享剥离的一个Demo，来告诉我们他是怎么优化TableView的流畅性的。\n\n那么VVebo是什么呢？看名字你就猜吧，像不像微博，是的，它就是一款新浪微博的第三方客户端，当年还是有很多人追捧的，不过后来新浪逐渐收回开发接口导致很多功能无法实现就把VVebo给坑了。\n\n那么为什么VVebo使用率那么高呢？一方面是当时新浪微博客户端的确不行，另一方面VVebo简约的风格和流畅的体验俘获了一大批用户。所以今天我们就来探究一下他是如何做到TableView的丝滑体验的。\n\n首先你可以在[这里现在一份源码](https://github.com/johnil/VVeboTableViewDemo)，毕竟源码面前没有秘密。\n\n在老司机看来，作者最有效的优化分为4部分：\n\n- TableViewCell圆角优化\n- 缓存行高\n- 相对固定的图片及文字采用CoreText绘制\n- TableView加载数据逻辑优化\n- - -\n\n#### 圆角\n这部分作者的优化很简单，**他没有画圆角！**圆角是TableViewCell的帧率杀手大家都知道吧，所以人家根本就没有画圆角。他是怎么做的呢？`覆盖了与背景色同色的圆角图片`，简单粗暴，果然是个心机boy。\n\n不过关于圆角的优化，还是有更好的解决办法的，[在这里](http://www.jianshu.com/p/f970872fdc22)。不想看的话我给你总结一下，就两点：\n- 别冤枉cornerRadius，问题不在它。而**在于maskToBounds**。普通的UIView绘制圆角时并不需要maskToBounds属性。也就是普通的视图圆角对卡顿没有影响。\n- 既然有普通就有特殊：UIImageView和UILabel以及我还没有发现的=。=对于UIImage的处理建议先借助CoreGraphic处理图片吧，**直接绘制一个带圆角的图片给ImageView吧**。对于Label没有太好的优化方案，是在不行只能CoreText了。其实你会发现，UILable这个控件对中文**十！分！不！友！好！**很多细节上中文跟英文或者字符会有很大的差异，但是你有不能不用他，好气哦=。=\n\n- - -\n#### 缓存行高\n这部分内容老司机在上一期讲述过不定高cell行高缓存的必要性及缓存的方法，这里不再赘述。\n- - -\n#### CoreText绘制文本\n首先，复杂的`层级关系同样会给cell在绘制时添加很大的负担`，这点是毋庸置疑的，所以VVebo的作者选择了将一些相对重复性很大的视图选择使用CoreText和CoreGraphic技术直接绘制在一个视图上，这样就`减少了视图的层级`，为流畅性又添了一份可能。CoreText绘制文本的和图片的技术你可以在老司机的[CoreText实现图文混排系列](http://www.jianshu.com/p/6db3289fb05d)中得到详细的实现方法，想看的去看吧。\n- - -\n#### TableView加载数据逻辑优化\n到现在为止终于要讲点之前没有说过的了=。=\n\n说以下主体思路，VVebo的作者认为，**当用户快速滑动的时候，事实上他对滑动过程中的内容是不关心的**，他只关心滚动结束处的内容，那么用户不关心的内容她就选择了不加载。\n\n这是他的主体思路，来看下这部分的实现代码：\n\n```\n- (void)drawCell:(VVeboTableViewCell *)cell withIndexPath:(NSIndexPath *)indexPath{\n    NSDictionary *data = [datas objectAtIndex:indexPath.row];\n    cell.selectionStyle = UITableViewCellSelectionStyleNone;\n    //清除cell内容，解决复用问题\n    [cell clear];\n    cell.data = data;\n  //判断如果needLoadArr中含有需要加载的indexPath而当前indexPath又不在其中的时候，则不绘制cell直接返回\n    if (needLoadArr.count>0&&[needLoadArr indexOfObject:indexPath]==NSNotFound) {\n        [cell clear];\n        return;\n    }\n  //判断如果scrollToToping为真的时候（及点击状态栏快速回到TableView顶部的时候）不绘制cell\n    if (scrollToToping) {\n        return;\n    }\n    //上面都没问题的话，绘制cell\n    [cell draw];\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\"];\n    if (cell==nil) {\n        cell = [[VVeboTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault\n                                         reuseIdentifier:@\"cell\"];\n    }\n    [self drawCell:cell withIndexPath:indexPath];\n    return cell;\n}\n\n- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{\n    [needLoadArr removeAllObjects];\n}\n\n//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。\n- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset{\n//取出滚动停止时展示的第一个cell的indexPath\n    NSIndexPath *ip = [self indexPathForRowAtPoint:CGPointMake(0, targetContentOffset->y)];\n//取出当前展示的第一个cell的indexPath\n    NSIndexPath *cip = [[self indexPathsForVisibleRows] firstObject];\n    NSInteger skipCount = 8;\n//如果两者之间差距很大则认为滑动速度很快，中间用户都不关心，直接把滚动停止时的展示的cell加入到needLoadArr数组中\n    if (labs(cip.row-ip.row)>skipCount) {\n        NSArray *temp = [self indexPathsForRowsInRect:CGRectMake(0, targetContentOffset->y, self.width, self.height)];\n        NSMutableArray *arr = [NSMutableArray arrayWithArray:temp];\n//根据滚动方向在前或后额外添加三个需要展示的cell，这样看起来好像更加平滑的样子\n        if (velocity.y<0) {\n            NSIndexPath *indexPath = [temp lastObject];\n            if (indexPath.row+3<datas.count) {\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+1 inSection:0]];\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+2 inSection:0]];\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+3 inSection:0]];\n            }\n        } else {\n            NSIndexPath *indexPath = [temp firstObject];\n            if (indexPath.row>3) {\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:0]];\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:0]];\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:0]];\n            }\n        }\n        [needLoadArr addObjectsFromArray:arr];\n    }\n}\n\n- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView{\n    scrollToToping = YES;\n    return YES;\n}\n\n- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView{\n    scrollToToping = NO;\n    [self loadContent];\n}\n\n- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView{\n    scrollToToping = NO;\n    [self loadContent];\n}\n\n//用户触摸时第一时间加载内容\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{\n    if (!scrollToToping) {\n        [needLoadArr removeAllObjects];\n        [self loadContent];\n    }\n    return [super hitTest:point withEvent:event];\n}\n\n- (void)loadContent{\n    if (scrollToToping) {\n        return;\n    }\n    if (self.indexPathsForVisibleRows.count<=0) {\n        return;\n    }\n    if (self.visibleCells&&self.visibleCells.count>0) {\n        for (id temp in [self.visibleCells copy]) {\n            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;\n            [cell draw];\n        }\n    }\n}\n```\n\n其实是就100行代码，思路还是很清晰明了的。作者主要是通过\n`-drawCell:withIndexPath:`这个方法来控制cell的绘制行为的。我们看看他做了什么？\n\n首先他**cell调用了clear方法**，这是VVeboTableViewCell中作者自己实现的方法，用于清除cell上面展示的内容，这样可以**避免因cell重用而导致没有绘制**的cell会显示之前的内容的问题。然后是判断**needLoadArr**中是否包含有当前indexPath，若没有返回。继续判断当前TableView是否处于**快速回到顶部的过程中**，如果是的话也不绘制。**最后上述条件都满足的时候再进行cell的绘制**。\n\n所以重点来了，needLoadArr什么时候添加的元素？如何获取到TableView快速回到顶部的时间点？\n\n>第二点好说，点击状态栏的时候，TableView会询问代理  `- scrollViewShouldScrollToTop:         `只有返回YES的时候才会快速回到顶部，这时我们可以在这捕获到这个状态。但是可以看到作者并没有在这选择添加顶部可能要展示的cell进needLoadArr数组，那么当他滚动到顶部的时候我们要将顶部的cell进行直接更新，所以通过`- scrollViewDidEndScrollingAnimation:`和`- scrollViewShouldScrollToTop:`两个代理拿到到达顶部的状态后直接更新当前cell。\n\n回过头来我们说下第一点，needLoadArr是怎么操作呢？\n我们知道我们是要判断TableView快速滑动，那我们怎么拿到这个行为呢？要知道没有什么代理是直接反应滚动速度的，这里作者很取巧的用到了`-scrollViewWillEndDragging:withVelocity:targetContentOffset:`这个代理。\n这个代理在手指即将结束拖动的时候出发，他会告诉外界当前的速度及这次会滚动到的位置。\n\n>所以作者在这里判断了目标位置与当前位置相差间隔，如果很大的话则认为中间内容不需加载，直接添加目标位置的内容进入数组。\n\n恩，以上就是VVebo作者对数据加载逻辑的优化。\n\n这是依靠着上述四点，VVebo才获得了完美的滑动体验，其`思路也是我们开发中可以学习和借鉴的`。\n\n- - -\n### TableView解耦\n这部分内容也不是什么新鲜事，也是比较靠谱的一个思路。当然了这部分内容不是对性能的优化，而是对代码的优化。\n\n天天写TableView里面的代理是不是很烦人啊，**千篇一律又不能不写**。所以想一个方法只写一次以后拿来直接用吧=。=\n\n\n![效果图](http://upload-images.jianshu.io/upload_images/1835430-3b67fb2cbb3cdccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![真机不卡！真机不卡！真机不卡！重要的事情说三遍](http://upload-images.jianshu.io/upload_images/1835430-88033ea7bfde7ee3.gif?imageMogr2/auto-orient/strip)\n\n\n放一个效果图，老司机写的控制器里面看不到任何一个TableView代理然而还是能正常显示并实现很多功能。\n\n但是代码怎么可能不写，只是我在别的地方写过了，并且花了大把时间进行解耦，让每一个TableView都能拿来就直接使用。\n\n那么这个解耦的类我们要怎么写呢？\n\n好的，我们来新建一个文件。\n![helper类](http://upload-images.jianshu.io/upload_images/1835430-690063c9d0cecc7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个类只需要一个属性，是一个数组。就是你平常写TableView的时候的数据源。\n\n然后在.m中我们就可以像平常写TableView一样在这里面写代理了。\n\n![假装写了两个代理](http://upload-images.jianshu.io/upload_images/1835430-eb7262ea8c5d87f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n无视我的cell和model，嫌累没创建=。=\n\n最后在VC中把TableView的dataSource设成Helper就好了。\n\n\n![无视我这代码，我就是给你展现个逻辑，细写嫌累](http://upload-images.jianshu.io/upload_images/1835430-8d9a3f231a8ac39d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**重点是别忘了持有helper类**。tableView对dataSource是弱引用，如果不持有helper就被释放了。\n就是这么一个思路。的确该写你都写了，不过好处就是你以后把helper类拿到另一个工程还可以直接用。\n\n恩，思路就是这么简单的一个思路，不过你可以把你的helper类写的功能更加丰富一些。比如说我的helper类。老司机添加了**高度缓存、滚动优化**等优化功能，并且对**选择、展示动画、无数据占位图**等常用功能都进行了支持。而且老司机也在不断的丰富helper类的功能。\n\n只放一个版本更新记录吧，代码放不下=。=\n>/**\n DWTableViewHelper\n TableView工具类\n 抽出TableView代理，减小VC压力，添加常用代理映射\n \n> version 1.0.0\n 添加常用代理映射\n 添加helper基础属性\n \n> version 1.0.1\n 去除注册，改为更适用的重用模式\n \n> version 1.0.2\n 添加多分组模式\n \n> version 1.0.3\n 添加选择模式及相关api\n \n> version 1.0.4\n 添加helper设置cell类型及复用标识\n \n> version 1.0.5\n 将cell的基础属性提出协议，helper与model同时遵守协议\n \n> version 1.0.6\n 修正占位视图展示时机，提供两个刷新列表扩展方法，提供展示、隐藏占位图接口\n \n> version 1.0.7\n 添加选则模式下单选多选控制\n \n> version 1.0.8\n 补充组头视图、尾视图行高代理映射并简化代理链\n \n> version 1.0.9\n cell基类添加父类实现强制调用宏、断言中给出未能加载的cell类名\n \n> version 1.1.0\n 改变cell划线机制，改为系统分割线，添加分割线归0方法\n 添加自动行高计算并缓存\n cell添加xib支持\n 修复选择模式选中后关闭再次开启选择同一个无法选中bug\n 更换去除选择背景方式，解决与选择模式的冲突\n 映射所有代理\n \n> version 1.1.1\n 添加自适应模式最小行高限制及最大行高设置\n 添加数据源的容错机制，但这并不是你故意写错的理由=。=\n 添加屏幕判断，当位置方向时，默认返回竖屏\n 额外补充动画代理、支持CAAnimation及DWAnimation\n \n> version 1.1.2\n 展示动画逻辑修改，DWAnimation动画展示方法替换\n \n> version 1.1.3\n 滚动优化模式添加\n 高速忽略模式完成\n 懒加载模式完成\n 懒加载模式动画隐藏，更加平滑，修复刷新bug。\n 有没有美工妹子给切几张占位图。。我做的图太丑了。。\n \n> */\n\n是的，所以说你玩去那可以**写一个什么都能做的Helper**。\n\n正如我最开始的效果图。如果你想看看我还对Helper做了什么你可以去我的仓库上面看[DWTableViewHelper](https://github.com/CodeWicky/DWTableViewHelper)。\n\n你想直接用也可以，你可以去GitHub上面直接托一份，也可以用cocoaPods集成：\n```\n      pod 'DWTableViewHelper', '~> 1.1.2'\n```\nDWTableViewHelper类当前为1.1.2版本，滚动优化在1.1.3版本pod还没有发，因为在测试看有没有什么bug，而且老司机做的图有的丑，急需会美工的妹子帮我切两张图，汉子也行，`愿意帮忙的私信我`=。=\n\n如果你想看看老司机的所有pods项目的话，你也可以打开终端，输入\n```\npod search wicky\n```\n\n\n![pod search wicky](http://upload-images.jianshu.io/upload_images/1835430-8a2f5542d40a2965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最后，双击666，加波关注，点波star，老铁没毛病！\n![老铁没毛病](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1494754370835&di=3edf2dea5efdf9b4da0427f1d1a69b16&imgtype=0&src=http%3A%2F%2Fnews.k618.cn%2Fsociety%2F201703%2FW020170325684515461265.png)\n","source":"_posts/TableView优化之快速滑动下的忽略加载.md","raw":"---\n\ntitle: TableView优化之快速滑动下的忽略加载\nlayout: post\ndate: 2017-05-14 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- TableView优化 \n- 忽略加载 \ncategories: 性能优化\n\n---\n\n![TableView优化之快速滑动下的忽略加载](http://upload-images.jianshu.io/upload_images/1835430-13da7ca8ce7602d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n系列文章：\n\n- [TableView优化之高度缓存功能](http://www.jianshu.com/p/2b192257276f)\n\n- [TableView优化之加载图片的优化逻辑](http://www.jianshu.com/p/328e503900d0)\n\n- [TableView优化之快速滑动下的忽略加载](http://www.jianshu.com/p/0b020518de5e)\n\n\n- - -\n\n最近在搞什么，所以就顺手写点什么咯~\n\n这两天一直在搞一个TableView的工具类，因为觉得这个东西写完可以一劳永逸，所以就去搞了一下，主要是有助于TableView的快捷开发。没什么好废话的了，直接说事吧=。=\n\n在今天的博客中你可能会看到：\n- VVeboTableView中Cell加载逻辑的解析\n- TableView代码解耦的基本思路\n\n恩，东西不多，一点一点说~\n\n<!-- more -->\n\n- - -  \n### VVeboTableView\n其实这是VVebo项目中作者分享剥离的一个Demo，来告诉我们他是怎么优化TableView的流畅性的。\n\n那么VVebo是什么呢？看名字你就猜吧，像不像微博，是的，它就是一款新浪微博的第三方客户端，当年还是有很多人追捧的，不过后来新浪逐渐收回开发接口导致很多功能无法实现就把VVebo给坑了。\n\n那么为什么VVebo使用率那么高呢？一方面是当时新浪微博客户端的确不行，另一方面VVebo简约的风格和流畅的体验俘获了一大批用户。所以今天我们就来探究一下他是如何做到TableView的丝滑体验的。\n\n首先你可以在[这里现在一份源码](https://github.com/johnil/VVeboTableViewDemo)，毕竟源码面前没有秘密。\n\n在老司机看来，作者最有效的优化分为4部分：\n\n- TableViewCell圆角优化\n- 缓存行高\n- 相对固定的图片及文字采用CoreText绘制\n- TableView加载数据逻辑优化\n- - -\n\n#### 圆角\n这部分作者的优化很简单，**他没有画圆角！**圆角是TableViewCell的帧率杀手大家都知道吧，所以人家根本就没有画圆角。他是怎么做的呢？`覆盖了与背景色同色的圆角图片`，简单粗暴，果然是个心机boy。\n\n不过关于圆角的优化，还是有更好的解决办法的，[在这里](http://www.jianshu.com/p/f970872fdc22)。不想看的话我给你总结一下，就两点：\n- 别冤枉cornerRadius，问题不在它。而**在于maskToBounds**。普通的UIView绘制圆角时并不需要maskToBounds属性。也就是普通的视图圆角对卡顿没有影响。\n- 既然有普通就有特殊：UIImageView和UILabel以及我还没有发现的=。=对于UIImage的处理建议先借助CoreGraphic处理图片吧，**直接绘制一个带圆角的图片给ImageView吧**。对于Label没有太好的优化方案，是在不行只能CoreText了。其实你会发现，UILable这个控件对中文**十！分！不！友！好！**很多细节上中文跟英文或者字符会有很大的差异，但是你有不能不用他，好气哦=。=\n\n- - -\n#### 缓存行高\n这部分内容老司机在上一期讲述过不定高cell行高缓存的必要性及缓存的方法，这里不再赘述。\n- - -\n#### CoreText绘制文本\n首先，复杂的`层级关系同样会给cell在绘制时添加很大的负担`，这点是毋庸置疑的，所以VVebo的作者选择了将一些相对重复性很大的视图选择使用CoreText和CoreGraphic技术直接绘制在一个视图上，这样就`减少了视图的层级`，为流畅性又添了一份可能。CoreText绘制文本的和图片的技术你可以在老司机的[CoreText实现图文混排系列](http://www.jianshu.com/p/6db3289fb05d)中得到详细的实现方法，想看的去看吧。\n- - -\n#### TableView加载数据逻辑优化\n到现在为止终于要讲点之前没有说过的了=。=\n\n说以下主体思路，VVebo的作者认为，**当用户快速滑动的时候，事实上他对滑动过程中的内容是不关心的**，他只关心滚动结束处的内容，那么用户不关心的内容她就选择了不加载。\n\n这是他的主体思路，来看下这部分的实现代码：\n\n```\n- (void)drawCell:(VVeboTableViewCell *)cell withIndexPath:(NSIndexPath *)indexPath{\n    NSDictionary *data = [datas objectAtIndex:indexPath.row];\n    cell.selectionStyle = UITableViewCellSelectionStyleNone;\n    //清除cell内容，解决复用问题\n    [cell clear];\n    cell.data = data;\n  //判断如果needLoadArr中含有需要加载的indexPath而当前indexPath又不在其中的时候，则不绘制cell直接返回\n    if (needLoadArr.count>0&&[needLoadArr indexOfObject:indexPath]==NSNotFound) {\n        [cell clear];\n        return;\n    }\n  //判断如果scrollToToping为真的时候（及点击状态栏快速回到TableView顶部的时候）不绘制cell\n    if (scrollToToping) {\n        return;\n    }\n    //上面都没问题的话，绘制cell\n    [cell draw];\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\"];\n    if (cell==nil) {\n        cell = [[VVeboTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault\n                                         reuseIdentifier:@\"cell\"];\n    }\n    [self drawCell:cell withIndexPath:indexPath];\n    return cell;\n}\n\n- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{\n    [needLoadArr removeAllObjects];\n}\n\n//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。\n- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset{\n//取出滚动停止时展示的第一个cell的indexPath\n    NSIndexPath *ip = [self indexPathForRowAtPoint:CGPointMake(0, targetContentOffset->y)];\n//取出当前展示的第一个cell的indexPath\n    NSIndexPath *cip = [[self indexPathsForVisibleRows] firstObject];\n    NSInteger skipCount = 8;\n//如果两者之间差距很大则认为滑动速度很快，中间用户都不关心，直接把滚动停止时的展示的cell加入到needLoadArr数组中\n    if (labs(cip.row-ip.row)>skipCount) {\n        NSArray *temp = [self indexPathsForRowsInRect:CGRectMake(0, targetContentOffset->y, self.width, self.height)];\n        NSMutableArray *arr = [NSMutableArray arrayWithArray:temp];\n//根据滚动方向在前或后额外添加三个需要展示的cell，这样看起来好像更加平滑的样子\n        if (velocity.y<0) {\n            NSIndexPath *indexPath = [temp lastObject];\n            if (indexPath.row+3<datas.count) {\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+1 inSection:0]];\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+2 inSection:0]];\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+3 inSection:0]];\n            }\n        } else {\n            NSIndexPath *indexPath = [temp firstObject];\n            if (indexPath.row>3) {\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:0]];\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:0]];\n                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:0]];\n            }\n        }\n        [needLoadArr addObjectsFromArray:arr];\n    }\n}\n\n- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView{\n    scrollToToping = YES;\n    return YES;\n}\n\n- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView{\n    scrollToToping = NO;\n    [self loadContent];\n}\n\n- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView{\n    scrollToToping = NO;\n    [self loadContent];\n}\n\n//用户触摸时第一时间加载内容\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{\n    if (!scrollToToping) {\n        [needLoadArr removeAllObjects];\n        [self loadContent];\n    }\n    return [super hitTest:point withEvent:event];\n}\n\n- (void)loadContent{\n    if (scrollToToping) {\n        return;\n    }\n    if (self.indexPathsForVisibleRows.count<=0) {\n        return;\n    }\n    if (self.visibleCells&&self.visibleCells.count>0) {\n        for (id temp in [self.visibleCells copy]) {\n            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;\n            [cell draw];\n        }\n    }\n}\n```\n\n其实是就100行代码，思路还是很清晰明了的。作者主要是通过\n`-drawCell:withIndexPath:`这个方法来控制cell的绘制行为的。我们看看他做了什么？\n\n首先他**cell调用了clear方法**，这是VVeboTableViewCell中作者自己实现的方法，用于清除cell上面展示的内容，这样可以**避免因cell重用而导致没有绘制**的cell会显示之前的内容的问题。然后是判断**needLoadArr**中是否包含有当前indexPath，若没有返回。继续判断当前TableView是否处于**快速回到顶部的过程中**，如果是的话也不绘制。**最后上述条件都满足的时候再进行cell的绘制**。\n\n所以重点来了，needLoadArr什么时候添加的元素？如何获取到TableView快速回到顶部的时间点？\n\n>第二点好说，点击状态栏的时候，TableView会询问代理  `- scrollViewShouldScrollToTop:         `只有返回YES的时候才会快速回到顶部，这时我们可以在这捕获到这个状态。但是可以看到作者并没有在这选择添加顶部可能要展示的cell进needLoadArr数组，那么当他滚动到顶部的时候我们要将顶部的cell进行直接更新，所以通过`- scrollViewDidEndScrollingAnimation:`和`- scrollViewShouldScrollToTop:`两个代理拿到到达顶部的状态后直接更新当前cell。\n\n回过头来我们说下第一点，needLoadArr是怎么操作呢？\n我们知道我们是要判断TableView快速滑动，那我们怎么拿到这个行为呢？要知道没有什么代理是直接反应滚动速度的，这里作者很取巧的用到了`-scrollViewWillEndDragging:withVelocity:targetContentOffset:`这个代理。\n这个代理在手指即将结束拖动的时候出发，他会告诉外界当前的速度及这次会滚动到的位置。\n\n>所以作者在这里判断了目标位置与当前位置相差间隔，如果很大的话则认为中间内容不需加载，直接添加目标位置的内容进入数组。\n\n恩，以上就是VVebo作者对数据加载逻辑的优化。\n\n这是依靠着上述四点，VVebo才获得了完美的滑动体验，其`思路也是我们开发中可以学习和借鉴的`。\n\n- - -\n### TableView解耦\n这部分内容也不是什么新鲜事，也是比较靠谱的一个思路。当然了这部分内容不是对性能的优化，而是对代码的优化。\n\n天天写TableView里面的代理是不是很烦人啊，**千篇一律又不能不写**。所以想一个方法只写一次以后拿来直接用吧=。=\n\n\n![效果图](http://upload-images.jianshu.io/upload_images/1835430-3b67fb2cbb3cdccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![真机不卡！真机不卡！真机不卡！重要的事情说三遍](http://upload-images.jianshu.io/upload_images/1835430-88033ea7bfde7ee3.gif?imageMogr2/auto-orient/strip)\n\n\n放一个效果图，老司机写的控制器里面看不到任何一个TableView代理然而还是能正常显示并实现很多功能。\n\n但是代码怎么可能不写，只是我在别的地方写过了，并且花了大把时间进行解耦，让每一个TableView都能拿来就直接使用。\n\n那么这个解耦的类我们要怎么写呢？\n\n好的，我们来新建一个文件。\n![helper类](http://upload-images.jianshu.io/upload_images/1835430-690063c9d0cecc7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个类只需要一个属性，是一个数组。就是你平常写TableView的时候的数据源。\n\n然后在.m中我们就可以像平常写TableView一样在这里面写代理了。\n\n![假装写了两个代理](http://upload-images.jianshu.io/upload_images/1835430-eb7262ea8c5d87f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n无视我的cell和model，嫌累没创建=。=\n\n最后在VC中把TableView的dataSource设成Helper就好了。\n\n\n![无视我这代码，我就是给你展现个逻辑，细写嫌累](http://upload-images.jianshu.io/upload_images/1835430-8d9a3f231a8ac39d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**重点是别忘了持有helper类**。tableView对dataSource是弱引用，如果不持有helper就被释放了。\n就是这么一个思路。的确该写你都写了，不过好处就是你以后把helper类拿到另一个工程还可以直接用。\n\n恩，思路就是这么简单的一个思路，不过你可以把你的helper类写的功能更加丰富一些。比如说我的helper类。老司机添加了**高度缓存、滚动优化**等优化功能，并且对**选择、展示动画、无数据占位图**等常用功能都进行了支持。而且老司机也在不断的丰富helper类的功能。\n\n只放一个版本更新记录吧，代码放不下=。=\n>/**\n DWTableViewHelper\n TableView工具类\n 抽出TableView代理，减小VC压力，添加常用代理映射\n \n> version 1.0.0\n 添加常用代理映射\n 添加helper基础属性\n \n> version 1.0.1\n 去除注册，改为更适用的重用模式\n \n> version 1.0.2\n 添加多分组模式\n \n> version 1.0.3\n 添加选择模式及相关api\n \n> version 1.0.4\n 添加helper设置cell类型及复用标识\n \n> version 1.0.5\n 将cell的基础属性提出协议，helper与model同时遵守协议\n \n> version 1.0.6\n 修正占位视图展示时机，提供两个刷新列表扩展方法，提供展示、隐藏占位图接口\n \n> version 1.0.7\n 添加选则模式下单选多选控制\n \n> version 1.0.8\n 补充组头视图、尾视图行高代理映射并简化代理链\n \n> version 1.0.9\n cell基类添加父类实现强制调用宏、断言中给出未能加载的cell类名\n \n> version 1.1.0\n 改变cell划线机制，改为系统分割线，添加分割线归0方法\n 添加自动行高计算并缓存\n cell添加xib支持\n 修复选择模式选中后关闭再次开启选择同一个无法选中bug\n 更换去除选择背景方式，解决与选择模式的冲突\n 映射所有代理\n \n> version 1.1.1\n 添加自适应模式最小行高限制及最大行高设置\n 添加数据源的容错机制，但这并不是你故意写错的理由=。=\n 添加屏幕判断，当位置方向时，默认返回竖屏\n 额外补充动画代理、支持CAAnimation及DWAnimation\n \n> version 1.1.2\n 展示动画逻辑修改，DWAnimation动画展示方法替换\n \n> version 1.1.3\n 滚动优化模式添加\n 高速忽略模式完成\n 懒加载模式完成\n 懒加载模式动画隐藏，更加平滑，修复刷新bug。\n 有没有美工妹子给切几张占位图。。我做的图太丑了。。\n \n> */\n\n是的，所以说你玩去那可以**写一个什么都能做的Helper**。\n\n正如我最开始的效果图。如果你想看看我还对Helper做了什么你可以去我的仓库上面看[DWTableViewHelper](https://github.com/CodeWicky/DWTableViewHelper)。\n\n你想直接用也可以，你可以去GitHub上面直接托一份，也可以用cocoaPods集成：\n```\n      pod 'DWTableViewHelper', '~> 1.1.2'\n```\nDWTableViewHelper类当前为1.1.2版本，滚动优化在1.1.3版本pod还没有发，因为在测试看有没有什么bug，而且老司机做的图有的丑，急需会美工的妹子帮我切两张图，汉子也行，`愿意帮忙的私信我`=。=\n\n如果你想看看老司机的所有pods项目的话，你也可以打开终端，输入\n```\npod search wicky\n```\n\n\n![pod search wicky](http://upload-images.jianshu.io/upload_images/1835430-8a2f5542d40a2965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最后，双击666，加波关注，点波star，老铁没毛病！\n![老铁没毛病](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1494754370835&di=3edf2dea5efdf9b4da0427f1d1a69b16&imgtype=0&src=http%3A%2F%2Fnews.k618.cn%2Fsociety%2F201703%2FW020170325684515461265.png)\n","slug":"TableView优化之快速滑动下的忽略加载","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htop0002jigbo556pkai","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-13da7ca8ce7602d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TableView优化之快速滑动下的忽略加载\"></p>\n<p>系列文章：</p>\n<ul>\n<li><p><a href=\"http://www.jianshu.com/p/2b192257276f\" target=\"_blank\" rel=\"external\">TableView优化之高度缓存功能</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/328e503900d0\" target=\"_blank\" rel=\"external\">TableView优化之加载图片的优化逻辑</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/0b020518de5e\" target=\"_blank\" rel=\"external\">TableView优化之快速滑动下的忽略加载</a></p>\n</li>\n</ul>\n<hr>\n<p>最近在搞什么，所以就顺手写点什么咯~</p>\n<p>这两天一直在搞一个TableView的工具类，因为觉得这个东西写完可以一劳永逸，所以就去搞了一下，主要是有助于TableView的快捷开发。没什么好废话的了，直接说事吧=。=</p>\n<p>在今天的博客中你可能会看到：</p>\n<ul>\n<li>VVeboTableView中Cell加载逻辑的解析</li>\n<li>TableView代码解耦的基本思路</li>\n</ul>\n<p>恩，东西不多，一点一点说~</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"VVeboTableView\"><a href=\"#VVeboTableView\" class=\"headerlink\" title=\"VVeboTableView\"></a>VVeboTableView</h3><p>其实这是VVebo项目中作者分享剥离的一个Demo，来告诉我们他是怎么优化TableView的流畅性的。</p>\n<p>那么VVebo是什么呢？看名字你就猜吧，像不像微博，是的，它就是一款新浪微博的第三方客户端，当年还是有很多人追捧的，不过后来新浪逐渐收回开发接口导致很多功能无法实现就把VVebo给坑了。</p>\n<p>那么为什么VVebo使用率那么高呢？一方面是当时新浪微博客户端的确不行，另一方面VVebo简约的风格和流畅的体验俘获了一大批用户。所以今天我们就来探究一下他是如何做到TableView的丝滑体验的。</p>\n<p>首先你可以在<a href=\"https://github.com/johnil/VVeboTableViewDemo\" target=\"_blank\" rel=\"external\">这里现在一份源码</a>，毕竟源码面前没有秘密。</p>\n<p>在老司机看来，作者最有效的优化分为4部分：</p>\n<ul>\n<li>TableViewCell圆角优化</li>\n<li>缓存行高</li>\n<li>相对固定的图片及文字采用CoreText绘制</li>\n<li>TableView加载数据逻辑优化</li>\n</ul>\n<hr>\n<h4 id=\"圆角\"><a href=\"#圆角\" class=\"headerlink\" title=\"圆角\"></a>圆角</h4><p>这部分作者的优化很简单，<strong>他没有画圆角！</strong>圆角是TableViewCell的帧率杀手大家都知道吧，所以人家根本就没有画圆角。他是怎么做的呢？<code>覆盖了与背景色同色的圆角图片</code>，简单粗暴，果然是个心机boy。</p>\n<p>不过关于圆角的优化，还是有更好的解决办法的，<a href=\"http://www.jianshu.com/p/f970872fdc22\" target=\"_blank\" rel=\"external\">在这里</a>。不想看的话我给你总结一下，就两点：</p>\n<ul>\n<li>别冤枉cornerRadius，问题不在它。而<strong>在于maskToBounds</strong>。普通的UIView绘制圆角时并不需要maskToBounds属性。也就是普通的视图圆角对卡顿没有影响。</li>\n<li>既然有普通就有特殊：UIImageView和UILabel以及我还没有发现的=。=对于UIImage的处理建议先借助CoreGraphic处理图片吧，<strong>直接绘制一个带圆角的图片给ImageView吧</strong>。对于Label没有太好的优化方案，是在不行只能CoreText了。其实你会发现，UILable这个控件对中文<strong>十！分！不！友！好！</strong>很多细节上中文跟英文或者字符会有很大的差异，但是你有不能不用他，好气哦=。=</li>\n</ul>\n<hr>\n<h4 id=\"缓存行高\"><a href=\"#缓存行高\" class=\"headerlink\" title=\"缓存行高\"></a>缓存行高</h4><p>这部分内容老司机在上一期讲述过不定高cell行高缓存的必要性及缓存的方法，这里不再赘述。</p>\n<hr>\n<h4 id=\"CoreText绘制文本\"><a href=\"#CoreText绘制文本\" class=\"headerlink\" title=\"CoreText绘制文本\"></a>CoreText绘制文本</h4><p>首先，复杂的<code>层级关系同样会给cell在绘制时添加很大的负担</code>，这点是毋庸置疑的，所以VVebo的作者选择了将一些相对重复性很大的视图选择使用CoreText和CoreGraphic技术直接绘制在一个视图上，这样就<code>减少了视图的层级</code>，为流畅性又添了一份可能。CoreText绘制文本的和图片的技术你可以在老司机的<a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排系列</a>中得到详细的实现方法，想看的去看吧。</p>\n<hr>\n<h4 id=\"TableView加载数据逻辑优化\"><a href=\"#TableView加载数据逻辑优化\" class=\"headerlink\" title=\"TableView加载数据逻辑优化\"></a>TableView加载数据逻辑优化</h4><p>到现在为止终于要讲点之前没有说过的了=。=</p>\n<p>说以下主体思路，VVebo的作者认为，<strong>当用户快速滑动的时候，事实上他对滑动过程中的内容是不关心的</strong>，他只关心滚动结束处的内容，那么用户不关心的内容她就选择了不加载。</p>\n<p>这是他的主体思路，来看下这部分的实现代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawCell:(VVeboTableViewCell *)cell withIndexPath:(NSIndexPath *)indexPath&#123;</div><div class=\"line\">    NSDictionary *data = [datas objectAtIndex:indexPath.row];</div><div class=\"line\">    cell.selectionStyle = UITableViewCellSelectionStyleNone;</div><div class=\"line\">    //清除cell内容，解决复用问题</div><div class=\"line\">    [cell clear];</div><div class=\"line\">    cell.data = data;</div><div class=\"line\">  //判断如果needLoadArr中含有需要加载的indexPath而当前indexPath又不在其中的时候，则不绘制cell直接返回</div><div class=\"line\">    if (needLoadArr.count&gt;0&amp;&amp;[needLoadArr indexOfObject:indexPath]==NSNotFound) &#123;</div><div class=\"line\">        [cell clear];</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">  //判断如果scrollToToping为真的时候（及点击状态栏快速回到TableView顶部的时候）不绘制cell</div><div class=\"line\">    if (scrollToToping) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //上面都没问题的话，绘制cell</div><div class=\"line\">    [cell draw];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class=\"line\">    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];</div><div class=\"line\">    if (cell==nil) &#123;</div><div class=\"line\">        cell = [[VVeboTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault</div><div class=\"line\">                                         reuseIdentifier:@&quot;cell&quot;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self drawCell:cell withIndexPath:indexPath];</div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123;</div><div class=\"line\">    [needLoadArr removeAllObjects];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</div><div class=\"line\">- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123;</div><div class=\"line\">//取出滚动停止时展示的第一个cell的indexPath</div><div class=\"line\">    NSIndexPath *ip = [self indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)];</div><div class=\"line\">//取出当前展示的第一个cell的indexPath</div><div class=\"line\">    NSIndexPath *cip = [[self indexPathsForVisibleRows] firstObject];</div><div class=\"line\">    NSInteger skipCount = 8;</div><div class=\"line\">//如果两者之间差距很大则认为滑动速度很快，中间用户都不关心，直接把滚动停止时的展示的cell加入到needLoadArr数组中</div><div class=\"line\">    if (labs(cip.row-ip.row)&gt;skipCount) &#123;</div><div class=\"line\">        NSArray *temp = [self indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, self.width, self.height)];</div><div class=\"line\">        NSMutableArray *arr = [NSMutableArray arrayWithArray:temp];</div><div class=\"line\">//根据滚动方向在前或后额外添加三个需要展示的cell，这样看起来好像更加平滑的样子</div><div class=\"line\">        if (velocity.y&lt;0) &#123;</div><div class=\"line\">            NSIndexPath *indexPath = [temp lastObject];</div><div class=\"line\">            if (indexPath.row+3&lt;datas.count) &#123;</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+1 inSection:0]];</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+2 inSection:0]];</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+3 inSection:0]];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            NSIndexPath *indexPath = [temp firstObject];</div><div class=\"line\">            if (indexPath.row&gt;3) &#123;</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:0]];</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:0]];</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:0]];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        [needLoadArr addObjectsFromArray:arr];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView&#123;</div><div class=\"line\">    scrollToToping = YES;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView&#123;</div><div class=\"line\">    scrollToToping = NO;</div><div class=\"line\">    [self loadContent];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView&#123;</div><div class=\"line\">    scrollToToping = NO;</div><div class=\"line\">    [self loadContent];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//用户触摸时第一时间加载内容</div><div class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</div><div class=\"line\">    if (!scrollToToping) &#123;</div><div class=\"line\">        [needLoadArr removeAllObjects];</div><div class=\"line\">        [self loadContent];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super hitTest:point withEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)loadContent&#123;</div><div class=\"line\">    if (scrollToToping) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.indexPathsForVisibleRows.count&lt;=0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.visibleCells&amp;&amp;self.visibleCells.count&gt;0) &#123;</div><div class=\"line\">        for (id temp in [self.visibleCells copy]) &#123;</div><div class=\"line\">            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;</div><div class=\"line\">            [cell draw];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实是就100行代码，思路还是很清晰明了的。作者主要是通过<br><code>-drawCell:withIndexPath:</code>这个方法来控制cell的绘制行为的。我们看看他做了什么？</p>\n<p>首先他<strong>cell调用了clear方法</strong>，这是VVeboTableViewCell中作者自己实现的方法，用于清除cell上面展示的内容，这样可以<strong>避免因cell重用而导致没有绘制</strong>的cell会显示之前的内容的问题。然后是判断<strong>needLoadArr</strong>中是否包含有当前indexPath，若没有返回。继续判断当前TableView是否处于<strong>快速回到顶部的过程中</strong>，如果是的话也不绘制。<strong>最后上述条件都满足的时候再进行cell的绘制</strong>。</p>\n<p>所以重点来了，needLoadArr什么时候添加的元素？如何获取到TableView快速回到顶部的时间点？</p>\n<blockquote>\n<p>第二点好说，点击状态栏的时候，TableView会询问代理  <code>- scrollViewShouldScrollToTop:</code>只有返回YES的时候才会快速回到顶部，这时我们可以在这捕获到这个状态。但是可以看到作者并没有在这选择添加顶部可能要展示的cell进needLoadArr数组，那么当他滚动到顶部的时候我们要将顶部的cell进行直接更新，所以通过<code>- scrollViewDidEndScrollingAnimation:</code>和<code>- scrollViewShouldScrollToTop:</code>两个代理拿到到达顶部的状态后直接更新当前cell。</p>\n</blockquote>\n<p>回过头来我们说下第一点，needLoadArr是怎么操作呢？<br>我们知道我们是要判断TableView快速滑动，那我们怎么拿到这个行为呢？要知道没有什么代理是直接反应滚动速度的，这里作者很取巧的用到了<code>-scrollViewWillEndDragging:withVelocity:targetContentOffset:</code>这个代理。<br>这个代理在手指即将结束拖动的时候出发，他会告诉外界当前的速度及这次会滚动到的位置。</p>\n<blockquote>\n<p>所以作者在这里判断了目标位置与当前位置相差间隔，如果很大的话则认为中间内容不需加载，直接添加目标位置的内容进入数组。</p>\n</blockquote>\n<p>恩，以上就是VVebo作者对数据加载逻辑的优化。</p>\n<p>这是依靠着上述四点，VVebo才获得了完美的滑动体验，其<code>思路也是我们开发中可以学习和借鉴的</code>。</p>\n<hr>\n<h3 id=\"TableView解耦\"><a href=\"#TableView解耦\" class=\"headerlink\" title=\"TableView解耦\"></a>TableView解耦</h3><p>这部分内容也不是什么新鲜事，也是比较靠谱的一个思路。当然了这部分内容不是对性能的优化，而是对代码的优化。</p>\n<p>天天写TableView里面的代理是不是很烦人啊，<strong>千篇一律又不能不写</strong>。所以想一个方法只写一次以后拿来直接用吧=。=</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-3b67fb2cbb3cdccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果图\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-88033ea7bfde7ee3.gif?imageMogr2/auto-orient/strip\" alt=\"真机不卡！真机不卡！真机不卡！重要的事情说三遍\"></p>\n<p>放一个效果图，老司机写的控制器里面看不到任何一个TableView代理然而还是能正常显示并实现很多功能。</p>\n<p>但是代码怎么可能不写，只是我在别的地方写过了，并且花了大把时间进行解耦，让每一个TableView都能拿来就直接使用。</p>\n<p>那么这个解耦的类我们要怎么写呢？</p>\n<p>好的，我们来新建一个文件。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-690063c9d0cecc7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"helper类\"></p>\n<p>这个类只需要一个属性，是一个数组。就是你平常写TableView的时候的数据源。</p>\n<p>然后在.m中我们就可以像平常写TableView一样在这里面写代理了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-eb7262ea8c5d87f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"假装写了两个代理\"></p>\n<p>无视我的cell和model，嫌累没创建=。=</p>\n<p>最后在VC中把TableView的dataSource设成Helper就好了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-8d9a3f231a8ac39d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无视我这代码，我就是给你展现个逻辑，细写嫌累\"></p>\n<p><strong>重点是别忘了持有helper类</strong>。tableView对dataSource是弱引用，如果不持有helper就被释放了。<br>就是这么一个思路。的确该写你都写了，不过好处就是你以后把helper类拿到另一个工程还可以直接用。</p>\n<p>恩，思路就是这么简单的一个思路，不过你可以把你的helper类写的功能更加丰富一些。比如说我的helper类。老司机添加了<strong>高度缓存、滚动优化</strong>等优化功能，并且对<strong>选择、展示动画、无数据占位图</strong>等常用功能都进行了支持。而且老司机也在不断的丰富helper类的功能。</p>\n<p>只放一个版本更新记录吧，代码放不下=。=</p>\n<blockquote>\n<p>/**<br> DWTableViewHelper<br> TableView工具类<br> 抽出TableView代理，减小VC压力，添加常用代理映射</p>\n<p>version 1.0.0<br> 添加常用代理映射<br> 添加helper基础属性</p>\n<p>version 1.0.1<br> 去除注册，改为更适用的重用模式</p>\n<p>version 1.0.2<br> 添加多分组模式</p>\n<p>version 1.0.3<br> 添加选择模式及相关api</p>\n<p>version 1.0.4<br> 添加helper设置cell类型及复用标识</p>\n<p>version 1.0.5<br> 将cell的基础属性提出协议，helper与model同时遵守协议</p>\n<p>version 1.0.6<br> 修正占位视图展示时机，提供两个刷新列表扩展方法，提供展示、隐藏占位图接口</p>\n<p>version 1.0.7<br> 添加选则模式下单选多选控制</p>\n<p>version 1.0.8<br> 补充组头视图、尾视图行高代理映射并简化代理链</p>\n<p>version 1.0.9<br> cell基类添加父类实现强制调用宏、断言中给出未能加载的cell类名</p>\n<p>version 1.1.0<br> 改变cell划线机制，改为系统分割线，添加分割线归0方法<br> 添加自动行高计算并缓存<br> cell添加xib支持<br> 修复选择模式选中后关闭再次开启选择同一个无法选中bug<br> 更换去除选择背景方式，解决与选择模式的冲突<br> 映射所有代理</p>\n<p>version 1.1.1<br> 添加自适应模式最小行高限制及最大行高设置<br> 添加数据源的容错机制，但这并不是你故意写错的理由=。=<br> 添加屏幕判断，当位置方向时，默认返回竖屏<br> 额外补充动画代理、支持CAAnimation及DWAnimation</p>\n<p>version 1.1.2<br> 展示动画逻辑修改，DWAnimation动画展示方法替换</p>\n<p>version 1.1.3<br> 滚动优化模式添加<br> 高速忽略模式完成<br> 懒加载模式完成<br> 懒加载模式动画隐藏，更加平滑，修复刷新bug。<br> 有没有美工妹子给切几张占位图。。我做的图太丑了。。</p>\n<p>*/</p>\n</blockquote>\n<p>是的，所以说你玩去那可以<strong>写一个什么都能做的Helper</strong>。</p>\n<p>正如我最开始的效果图。如果你想看看我还对Helper做了什么你可以去我的仓库上面看<a href=\"https://github.com/CodeWicky/DWTableViewHelper\" target=\"_blank\" rel=\"external\">DWTableViewHelper</a>。</p>\n<p>你想直接用也可以，你可以去GitHub上面直接托一份，也可以用cocoaPods集成：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;DWTableViewHelper&apos;, &apos;~&gt; 1.1.2&apos;</div></pre></td></tr></table></figure></p>\n<p>DWTableViewHelper类当前为1.1.2版本，滚动优化在1.1.3版本pod还没有发，因为在测试看有没有什么bug，而且老司机做的图有的丑，急需会美工的妹子帮我切两张图，汉子也行，<code>愿意帮忙的私信我</code>=。=</p>\n<p>如果你想看看老司机的所有pods项目的话，你也可以打开终端，输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search wicky</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-8a2f5542d40a2965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"pod search wicky\"></p>\n<p>最后，双击666，加波关注，点波star，老铁没毛病！<br><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1494754370835&amp;di=3edf2dea5efdf9b4da0427f1d1a69b16&amp;imgtype=0&amp;src=http%3A%2F%2Fnews.k618.cn%2Fsociety%2F201703%2FW020170325684515461265.png\" alt=\"老铁没毛病\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-13da7ca8ce7602d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TableView优化之快速滑动下的忽略加载\"></p>\n<p>系列文章：</p>\n<ul>\n<li><p><a href=\"http://www.jianshu.com/p/2b192257276f\" target=\"_blank\" rel=\"external\">TableView优化之高度缓存功能</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/328e503900d0\" target=\"_blank\" rel=\"external\">TableView优化之加载图片的优化逻辑</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/0b020518de5e\" target=\"_blank\" rel=\"external\">TableView优化之快速滑动下的忽略加载</a></p>\n</li>\n</ul>\n<hr>\n<p>最近在搞什么，所以就顺手写点什么咯~</p>\n<p>这两天一直在搞一个TableView的工具类，因为觉得这个东西写完可以一劳永逸，所以就去搞了一下，主要是有助于TableView的快捷开发。没什么好废话的了，直接说事吧=。=</p>\n<p>在今天的博客中你可能会看到：</p>\n<ul>\n<li>VVeboTableView中Cell加载逻辑的解析</li>\n<li>TableView代码解耦的基本思路</li>\n</ul>\n<p>恩，东西不多，一点一点说~</p>","more":"<hr>\n<h3 id=\"VVeboTableView\"><a href=\"#VVeboTableView\" class=\"headerlink\" title=\"VVeboTableView\"></a>VVeboTableView</h3><p>其实这是VVebo项目中作者分享剥离的一个Demo，来告诉我们他是怎么优化TableView的流畅性的。</p>\n<p>那么VVebo是什么呢？看名字你就猜吧，像不像微博，是的，它就是一款新浪微博的第三方客户端，当年还是有很多人追捧的，不过后来新浪逐渐收回开发接口导致很多功能无法实现就把VVebo给坑了。</p>\n<p>那么为什么VVebo使用率那么高呢？一方面是当时新浪微博客户端的确不行，另一方面VVebo简约的风格和流畅的体验俘获了一大批用户。所以今天我们就来探究一下他是如何做到TableView的丝滑体验的。</p>\n<p>首先你可以在<a href=\"https://github.com/johnil/VVeboTableViewDemo\" target=\"_blank\" rel=\"external\">这里现在一份源码</a>，毕竟源码面前没有秘密。</p>\n<p>在老司机看来，作者最有效的优化分为4部分：</p>\n<ul>\n<li>TableViewCell圆角优化</li>\n<li>缓存行高</li>\n<li>相对固定的图片及文字采用CoreText绘制</li>\n<li>TableView加载数据逻辑优化</li>\n</ul>\n<hr>\n<h4 id=\"圆角\"><a href=\"#圆角\" class=\"headerlink\" title=\"圆角\"></a>圆角</h4><p>这部分作者的优化很简单，<strong>他没有画圆角！</strong>圆角是TableViewCell的帧率杀手大家都知道吧，所以人家根本就没有画圆角。他是怎么做的呢？<code>覆盖了与背景色同色的圆角图片</code>，简单粗暴，果然是个心机boy。</p>\n<p>不过关于圆角的优化，还是有更好的解决办法的，<a href=\"http://www.jianshu.com/p/f970872fdc22\" target=\"_blank\" rel=\"external\">在这里</a>。不想看的话我给你总结一下，就两点：</p>\n<ul>\n<li>别冤枉cornerRadius，问题不在它。而<strong>在于maskToBounds</strong>。普通的UIView绘制圆角时并不需要maskToBounds属性。也就是普通的视图圆角对卡顿没有影响。</li>\n<li>既然有普通就有特殊：UIImageView和UILabel以及我还没有发现的=。=对于UIImage的处理建议先借助CoreGraphic处理图片吧，<strong>直接绘制一个带圆角的图片给ImageView吧</strong>。对于Label没有太好的优化方案，是在不行只能CoreText了。其实你会发现，UILable这个控件对中文<strong>十！分！不！友！好！</strong>很多细节上中文跟英文或者字符会有很大的差异，但是你有不能不用他，好气哦=。=</li>\n</ul>\n<hr>\n<h4 id=\"缓存行高\"><a href=\"#缓存行高\" class=\"headerlink\" title=\"缓存行高\"></a>缓存行高</h4><p>这部分内容老司机在上一期讲述过不定高cell行高缓存的必要性及缓存的方法，这里不再赘述。</p>\n<hr>\n<h4 id=\"CoreText绘制文本\"><a href=\"#CoreText绘制文本\" class=\"headerlink\" title=\"CoreText绘制文本\"></a>CoreText绘制文本</h4><p>首先，复杂的<code>层级关系同样会给cell在绘制时添加很大的负担</code>，这点是毋庸置疑的，所以VVebo的作者选择了将一些相对重复性很大的视图选择使用CoreText和CoreGraphic技术直接绘制在一个视图上，这样就<code>减少了视图的层级</code>，为流畅性又添了一份可能。CoreText绘制文本的和图片的技术你可以在老司机的<a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排系列</a>中得到详细的实现方法，想看的去看吧。</p>\n<hr>\n<h4 id=\"TableView加载数据逻辑优化\"><a href=\"#TableView加载数据逻辑优化\" class=\"headerlink\" title=\"TableView加载数据逻辑优化\"></a>TableView加载数据逻辑优化</h4><p>到现在为止终于要讲点之前没有说过的了=。=</p>\n<p>说以下主体思路，VVebo的作者认为，<strong>当用户快速滑动的时候，事实上他对滑动过程中的内容是不关心的</strong>，他只关心滚动结束处的内容，那么用户不关心的内容她就选择了不加载。</p>\n<p>这是他的主体思路，来看下这部分的实现代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawCell:(VVeboTableViewCell *)cell withIndexPath:(NSIndexPath *)indexPath&#123;</div><div class=\"line\">    NSDictionary *data = [datas objectAtIndex:indexPath.row];</div><div class=\"line\">    cell.selectionStyle = UITableViewCellSelectionStyleNone;</div><div class=\"line\">    //清除cell内容，解决复用问题</div><div class=\"line\">    [cell clear];</div><div class=\"line\">    cell.data = data;</div><div class=\"line\">  //判断如果needLoadArr中含有需要加载的indexPath而当前indexPath又不在其中的时候，则不绘制cell直接返回</div><div class=\"line\">    if (needLoadArr.count&gt;0&amp;&amp;[needLoadArr indexOfObject:indexPath]==NSNotFound) &#123;</div><div class=\"line\">        [cell clear];</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">  //判断如果scrollToToping为真的时候（及点击状态栏快速回到TableView顶部的时候）不绘制cell</div><div class=\"line\">    if (scrollToToping) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //上面都没问题的话，绘制cell</div><div class=\"line\">    [cell draw];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class=\"line\">    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];</div><div class=\"line\">    if (cell==nil) &#123;</div><div class=\"line\">        cell = [[VVeboTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault</div><div class=\"line\">                                         reuseIdentifier:@&quot;cell&quot;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self drawCell:cell withIndexPath:indexPath];</div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123;</div><div class=\"line\">    [needLoadArr removeAllObjects];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</div><div class=\"line\">- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123;</div><div class=\"line\">//取出滚动停止时展示的第一个cell的indexPath</div><div class=\"line\">    NSIndexPath *ip = [self indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)];</div><div class=\"line\">//取出当前展示的第一个cell的indexPath</div><div class=\"line\">    NSIndexPath *cip = [[self indexPathsForVisibleRows] firstObject];</div><div class=\"line\">    NSInteger skipCount = 8;</div><div class=\"line\">//如果两者之间差距很大则认为滑动速度很快，中间用户都不关心，直接把滚动停止时的展示的cell加入到needLoadArr数组中</div><div class=\"line\">    if (labs(cip.row-ip.row)&gt;skipCount) &#123;</div><div class=\"line\">        NSArray *temp = [self indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, self.width, self.height)];</div><div class=\"line\">        NSMutableArray *arr = [NSMutableArray arrayWithArray:temp];</div><div class=\"line\">//根据滚动方向在前或后额外添加三个需要展示的cell，这样看起来好像更加平滑的样子</div><div class=\"line\">        if (velocity.y&lt;0) &#123;</div><div class=\"line\">            NSIndexPath *indexPath = [temp lastObject];</div><div class=\"line\">            if (indexPath.row+3&lt;datas.count) &#123;</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+1 inSection:0]];</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+2 inSection:0]];</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+3 inSection:0]];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            NSIndexPath *indexPath = [temp firstObject];</div><div class=\"line\">            if (indexPath.row&gt;3) &#123;</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:0]];</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:0]];</div><div class=\"line\">                [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:0]];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        [needLoadArr addObjectsFromArray:arr];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView&#123;</div><div class=\"line\">    scrollToToping = YES;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView&#123;</div><div class=\"line\">    scrollToToping = NO;</div><div class=\"line\">    [self loadContent];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView&#123;</div><div class=\"line\">    scrollToToping = NO;</div><div class=\"line\">    [self loadContent];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//用户触摸时第一时间加载内容</div><div class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</div><div class=\"line\">    if (!scrollToToping) &#123;</div><div class=\"line\">        [needLoadArr removeAllObjects];</div><div class=\"line\">        [self loadContent];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super hitTest:point withEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)loadContent&#123;</div><div class=\"line\">    if (scrollToToping) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.indexPathsForVisibleRows.count&lt;=0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.visibleCells&amp;&amp;self.visibleCells.count&gt;0) &#123;</div><div class=\"line\">        for (id temp in [self.visibleCells copy]) &#123;</div><div class=\"line\">            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;</div><div class=\"line\">            [cell draw];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实是就100行代码，思路还是很清晰明了的。作者主要是通过<br><code>-drawCell:withIndexPath:</code>这个方法来控制cell的绘制行为的。我们看看他做了什么？</p>\n<p>首先他<strong>cell调用了clear方法</strong>，这是VVeboTableViewCell中作者自己实现的方法，用于清除cell上面展示的内容，这样可以<strong>避免因cell重用而导致没有绘制</strong>的cell会显示之前的内容的问题。然后是判断<strong>needLoadArr</strong>中是否包含有当前indexPath，若没有返回。继续判断当前TableView是否处于<strong>快速回到顶部的过程中</strong>，如果是的话也不绘制。<strong>最后上述条件都满足的时候再进行cell的绘制</strong>。</p>\n<p>所以重点来了，needLoadArr什么时候添加的元素？如何获取到TableView快速回到顶部的时间点？</p>\n<blockquote>\n<p>第二点好说，点击状态栏的时候，TableView会询问代理  <code>- scrollViewShouldScrollToTop:</code>只有返回YES的时候才会快速回到顶部，这时我们可以在这捕获到这个状态。但是可以看到作者并没有在这选择添加顶部可能要展示的cell进needLoadArr数组，那么当他滚动到顶部的时候我们要将顶部的cell进行直接更新，所以通过<code>- scrollViewDidEndScrollingAnimation:</code>和<code>- scrollViewShouldScrollToTop:</code>两个代理拿到到达顶部的状态后直接更新当前cell。</p>\n</blockquote>\n<p>回过头来我们说下第一点，needLoadArr是怎么操作呢？<br>我们知道我们是要判断TableView快速滑动，那我们怎么拿到这个行为呢？要知道没有什么代理是直接反应滚动速度的，这里作者很取巧的用到了<code>-scrollViewWillEndDragging:withVelocity:targetContentOffset:</code>这个代理。<br>这个代理在手指即将结束拖动的时候出发，他会告诉外界当前的速度及这次会滚动到的位置。</p>\n<blockquote>\n<p>所以作者在这里判断了目标位置与当前位置相差间隔，如果很大的话则认为中间内容不需加载，直接添加目标位置的内容进入数组。</p>\n</blockquote>\n<p>恩，以上就是VVebo作者对数据加载逻辑的优化。</p>\n<p>这是依靠着上述四点，VVebo才获得了完美的滑动体验，其<code>思路也是我们开发中可以学习和借鉴的</code>。</p>\n<hr>\n<h3 id=\"TableView解耦\"><a href=\"#TableView解耦\" class=\"headerlink\" title=\"TableView解耦\"></a>TableView解耦</h3><p>这部分内容也不是什么新鲜事，也是比较靠谱的一个思路。当然了这部分内容不是对性能的优化，而是对代码的优化。</p>\n<p>天天写TableView里面的代理是不是很烦人啊，<strong>千篇一律又不能不写</strong>。所以想一个方法只写一次以后拿来直接用吧=。=</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-3b67fb2cbb3cdccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果图\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-88033ea7bfde7ee3.gif?imageMogr2/auto-orient/strip\" alt=\"真机不卡！真机不卡！真机不卡！重要的事情说三遍\"></p>\n<p>放一个效果图，老司机写的控制器里面看不到任何一个TableView代理然而还是能正常显示并实现很多功能。</p>\n<p>但是代码怎么可能不写，只是我在别的地方写过了，并且花了大把时间进行解耦，让每一个TableView都能拿来就直接使用。</p>\n<p>那么这个解耦的类我们要怎么写呢？</p>\n<p>好的，我们来新建一个文件。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-690063c9d0cecc7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"helper类\"></p>\n<p>这个类只需要一个属性，是一个数组。就是你平常写TableView的时候的数据源。</p>\n<p>然后在.m中我们就可以像平常写TableView一样在这里面写代理了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-eb7262ea8c5d87f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"假装写了两个代理\"></p>\n<p>无视我的cell和model，嫌累没创建=。=</p>\n<p>最后在VC中把TableView的dataSource设成Helper就好了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-8d9a3f231a8ac39d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无视我这代码，我就是给你展现个逻辑，细写嫌累\"></p>\n<p><strong>重点是别忘了持有helper类</strong>。tableView对dataSource是弱引用，如果不持有helper就被释放了。<br>就是这么一个思路。的确该写你都写了，不过好处就是你以后把helper类拿到另一个工程还可以直接用。</p>\n<p>恩，思路就是这么简单的一个思路，不过你可以把你的helper类写的功能更加丰富一些。比如说我的helper类。老司机添加了<strong>高度缓存、滚动优化</strong>等优化功能，并且对<strong>选择、展示动画、无数据占位图</strong>等常用功能都进行了支持。而且老司机也在不断的丰富helper类的功能。</p>\n<p>只放一个版本更新记录吧，代码放不下=。=</p>\n<blockquote>\n<p>/**<br> DWTableViewHelper<br> TableView工具类<br> 抽出TableView代理，减小VC压力，添加常用代理映射</p>\n<p>version 1.0.0<br> 添加常用代理映射<br> 添加helper基础属性</p>\n<p>version 1.0.1<br> 去除注册，改为更适用的重用模式</p>\n<p>version 1.0.2<br> 添加多分组模式</p>\n<p>version 1.0.3<br> 添加选择模式及相关api</p>\n<p>version 1.0.4<br> 添加helper设置cell类型及复用标识</p>\n<p>version 1.0.5<br> 将cell的基础属性提出协议，helper与model同时遵守协议</p>\n<p>version 1.0.6<br> 修正占位视图展示时机，提供两个刷新列表扩展方法，提供展示、隐藏占位图接口</p>\n<p>version 1.0.7<br> 添加选则模式下单选多选控制</p>\n<p>version 1.0.8<br> 补充组头视图、尾视图行高代理映射并简化代理链</p>\n<p>version 1.0.9<br> cell基类添加父类实现强制调用宏、断言中给出未能加载的cell类名</p>\n<p>version 1.1.0<br> 改变cell划线机制，改为系统分割线，添加分割线归0方法<br> 添加自动行高计算并缓存<br> cell添加xib支持<br> 修复选择模式选中后关闭再次开启选择同一个无法选中bug<br> 更换去除选择背景方式，解决与选择模式的冲突<br> 映射所有代理</p>\n<p>version 1.1.1<br> 添加自适应模式最小行高限制及最大行高设置<br> 添加数据源的容错机制，但这并不是你故意写错的理由=。=<br> 添加屏幕判断，当位置方向时，默认返回竖屏<br> 额外补充动画代理、支持CAAnimation及DWAnimation</p>\n<p>version 1.1.2<br> 展示动画逻辑修改，DWAnimation动画展示方法替换</p>\n<p>version 1.1.3<br> 滚动优化模式添加<br> 高速忽略模式完成<br> 懒加载模式完成<br> 懒加载模式动画隐藏，更加平滑，修复刷新bug。<br> 有没有美工妹子给切几张占位图。。我做的图太丑了。。</p>\n<p>*/</p>\n</blockquote>\n<p>是的，所以说你玩去那可以<strong>写一个什么都能做的Helper</strong>。</p>\n<p>正如我最开始的效果图。如果你想看看我还对Helper做了什么你可以去我的仓库上面看<a href=\"https://github.com/CodeWicky/DWTableViewHelper\" target=\"_blank\" rel=\"external\">DWTableViewHelper</a>。</p>\n<p>你想直接用也可以，你可以去GitHub上面直接托一份，也可以用cocoaPods集成：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;DWTableViewHelper&apos;, &apos;~&gt; 1.1.2&apos;</div></pre></td></tr></table></figure></p>\n<p>DWTableViewHelper类当前为1.1.2版本，滚动优化在1.1.3版本pod还没有发，因为在测试看有没有什么bug，而且老司机做的图有的丑，急需会美工的妹子帮我切两张图，汉子也行，<code>愿意帮忙的私信我</code>=。=</p>\n<p>如果你想看看老司机的所有pods项目的话，你也可以打开终端，输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search wicky</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-8a2f5542d40a2965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"pod search wicky\"></p>\n<p>最后，双击666，加波关注，点波star，老铁没毛病！<br><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1494754370835&amp;di=3edf2dea5efdf9b4da0427f1d1a69b16&amp;imgtype=0&amp;src=http%3A%2F%2Fnews.k618.cn%2Fsociety%2F201703%2FW020170325684515461265.png\" alt=\"老铁没毛病\"></p>"},{"title":"CoreText实现图文混排之点击事件","layout":"post","date":"2016-05-16T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![CoreText实现图文混排之点击事件](http://upload-images.jianshu.io/upload_images/1835430-1e81a37668cb04ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n系列文章：\n\n- [CoreText实现图文混排](http://www.jianshu.com/p/6db3289fb05d)\n- [CoreText实现图文混排之点击事件](http://www.jianshu.com/p/51c47329203e)\n- [CoreText实现图文混排之文字环绕及点击算法](http://www.jianshu.com/p/e154047b0f98)\n- - -\n今天呢，我们继续把CoreText图文混排的`点击事件`补充上，这样我们的图文混排也算是圆满了。\n\n<!-- more -->\n\n\n哦，上一篇的链接在这里\n[CoreText实现图文混排](http://www.jianshu.com/p/6db3289fb05d)。所有需要用到的`准备知识`都在上一篇，没有赶上车的朋友可以去补个票~\n\n上正文。\n- - - \n## 全部代码\n我们知道，CoreText是基于UIView去绘制的，那么既然有UIView，就有\n\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event方法，我们呢，就是基于这个方法去做点击事件的。\n\n```\n通过touchBegan方法拿到当前点击到的点，然后通过坐标判断这个点是否在某段文字上，如果在则触发对应事件。\n```\n上面呢就是主要思路。接下来呢，我们来详细讲解一下。还是老规矩，先上代码。\n\n```\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    UITouch * touch = [touches anyObject];\n    CGPoint location = [self systemPointFromScreenPoint:[touch locationInView:self]];\n    if ([self checkIsClickOnImgWithPoint:location]) {\n            return;\n    }\n    [self ClickOnStrWithPoint:location];\n}\n\n-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location\n{\n    if ([self isFrame:_imgFrm containsPoint:location]) {\n    \tNSLog(@\"您点击到了图片\");\n        return YES;\n    }\n    return NO;\n}\n\n-(void)ClickOnStrWithPoint:(CGPoint)location\n{\n    NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);\n    CFRange ranges[lines.count];\n    CGPoint origins[lines.count];\n    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);\n    for (int i = 0; i < lines.count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)lines[i];\n        CFRange range = CTLineGetStringRange(line);\n        ranges[i] = range;\n    }\n    for (int i = 0; i < _length; i ++) {\n        long maxLoc;\n        int lineNum;\n        for (int j = 0; j < lines.count; j ++) {\n            CFRange range = ranges[j];\n            maxLoc = range.location + range.length - 1;\n            if (i <= maxLoc) {\n                lineNum = j;\n                break;\n            }\n        }\n        CTLineRef line = (__bridge CTLineRef)lines[lineNum];        CGPoint origin = origins[lineNum];\n        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];\n        if ([self isFrame:CTRunFrame containsPoint:location]) {  \n            NSLog(@\"您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。\",i,lineNum + 1);//点击到文字，然而没有响应的处理。可以做其他处理\n            return;\n        }\n    }\n    NSLog(@\"您没有点击到文字\");\n}\n\n-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range\n{\n    if ((index <= range.location + range.length - 1) && (index >= range.location)) {\n        return YES;\n    }\n    return NO;\n}\n\n-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin\n{\n    return CGPointMake(origin.x, self.bounds.size.height - origin.y);\n}\n\n-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point\n{\n    return CGRectContainsPoint(frame, point);\n}\n\n-(CGRect)frameForCTRunWithIndex:(NSInteger)index\n                         CTLine:(CTLineRef)line\n                         origin:(CGPoint)origin\n{\n    CGFloat offsetX = CTLineGetOffsetForStringIndex(line, index, NULL);\n    CGFloat offsexX2 = CTLineGetOffsetForStringIndex(line, index + 1, NULL);\n    offsetX += origin.x;\n    offsexX2 += origin.x;\n    CGFloat offsetY = origin.y;\n    CGFloat lineAscent;\n    CGFloat lineDescent;\n    NSArray * runs = (__bridge NSArray *)CTLineGetGlyphRuns(line);\n    CTRunRef runCurrent;\n    for (int k = 0; k < runs.count; k ++) {\n        CTRunRef run = (__bridge CTRunRef)runs[k];\n        CFRange range = CTRunGetStringRange(run);\n        NSRange rangeOC = NSMakeRange(range.location, range.length);\n        if ([self isIndex:index inRange:rangeOC]) {\n            runCurrent = run;\n            break;\n        }\n    }\n    CTRunGetTypographicBounds(runCurrent, CFRangeMake(0, 0), &lineAscent, &lineDescent, NULL);\n    CGFloat height = lineAscent + lineDescent;\n    return CGRectMake(offsetX, offsetY, offsexX2 - offsetX, height);\n}\n```\n看上去也挺多的，我们还是分段讲解吧。\n- - -\n## 分段解析\n### -touchesBegan\n之所以把他放在首位，是因为他作为整个view响应点击事件的`入口`扮演者十分重要的角色。\n\n他负责`接收点击事件`，根据条件将点击事件`分发给不同的对象`去执行相应的响应。\n\n```\n///点击方法\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    UITouch * touch = [touches anyObject];\n    CGPoint location = [self systemPointFromScreenPoint:[touch locationInView:self]];//获取点击位置的系统坐标\n    if ([self checkIsClickOnImgWithPoint:location]) {//检查是否点击在图片上，如果在，优先响应图片事件\n        return;\n    }\n    [self ClickOnStrWithPoint:location];//响应字符串事件\n}\n```\n这里老司机还是要解释一下，为什么我要设置成优先响应图片的事件呢？\n\n是这样的，在我们使用的过程中，大部分的场景是如下过程：\n\n- 给整段富文本添加属性，事件等\n- 插入图片\n- 给图片设置点击事件\n\n\n\n正是因为这样，我们可以看出逻辑上图片的响应事件的优先级明显是要高于文字的。即使是一段`文字范围我们赋值了文字的响应事件`，然后在范围中插入了图片并且赋予了图片响应事件，我们往往是`希望图片响应其自己的事件`。同时，不知道你们是否还记得[上一趟车](http://www.jianshu.com/p/6db3289fb05d)我们已经求出了图片的frame，如果优先判断出点击的是图片的话将会`减少很多计算量`，`提高运行效率`。所以我这里将图片的响应优先级定义的高于文字，不过根据需要我们可以定义不同的响应优先级。\n\n搞明白这一点以后，其实逻辑就很简单了。\n\n- 首先呢，先取出当前点击的到屏幕坐标的点。\n- 将屏幕坐标转换为系统坐标（不懂得同学快去上一节补课）\n- 判断是否点击在图片上\n- 如果未点击图片执行点击文字\n- - -\n### 获取点击坐标\n-touchesBegan事件给我们提供了touches这么一个集合。里面装满了UITouch对象。\n\n因为集合是无序的，所以我们通过anyObject取出其中的一个UITouch对象。\nUITouch对象的locationInView是专门用来给出UITouch对象在某个View中的坐标的方法，因此我们可以用这个方法来求出当前点击位置的系统坐标。这段比较基础，想画个重点都不知道画哪。\n- - -\n### 坐标转换\n这里用到了第一个工具方法（老司机习惯把写好的方法分类，这些中间方法老司机习惯叫他们工具方法），-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin。\n\n简单的说一句，因为屏幕坐标与系统坐标的不同，我们要将坐标系`统一成系统坐标`，这样才能计算，所以才有了这个坐标转换的方法。其实很简单\n\n```\n///坐标转换\n/*\n 将屏幕坐标转换为系统坐标\n */\n-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin\n{\n    return CGPointMake(origin.x, self.bounds.size.height - origin.y);\n}\n```\n上一讲有坐标系的图，这里我就不细讲了。直接进入下一话题。\n- - -\n### 点击图片判断\n第二个工具方法\n\n-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location\n\n```\n///图片点击检查\n/*\n 遍历图片frame的数组与点击位置比较，如果在\n 范围内则响应的数组中取出对应响应并执行，返\n 回yes，否则返回no\n */\n-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location\n{\n    if ([self isFrame:_imgFrm containsPoint:location]) {\n    \tNSLog(@\"您点击到了图片\");\n        return YES;\n    }\n    return NO;\n}\n```\n这里呢，我们用到了第三个工具方法，顺便就说了吧\n\n\n-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point\n\n```\n///点包含检测\n-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point\n{\n    return CGRectContainsPoint(frame, point);\n}\n```\n事实上也是调用了系统的一个方法`CGRectContainsPoint()`。这个方法两个参数，一个是frame，一个是point。可以返回point是否在frame中。\n\n不过还是有一点需要注意的。由于`传入的point是系统坐标`（本例中），所以frame我们一定要`传入系统坐标系下的frame`才能正确对应。\n\n这里老司机偷了个懒，直接把上一讲中求得的图片frame改成了一个实例变量，这样在这里的方法中我就能直接调用了。这只是个demo，所以我就怎么方便怎么来了，实际使用中，你可以`把frame保存在数组或字典中`。你问我怎么在数组或字典中保存一个frame这样的结构体？恩，有一个系统类叫`NSValue`，专门针对这种结构体。\n\n如果-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point返回YES则说明在图片范围内，则`响应图片的点击事件`，\n\n`并且-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location返回YES`，否则返回NO。\n\n回到上一层，如果-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location返回YES，则说明`点击的是图片并且已经执行完响应事件`，`直接return结束方法即可`。否则则继续检查是否点击到了文字。\n- - -\n### 点击文字判断\n\n终于进入重中之重了，点击文字的逻辑了，不过你也别害怕，如果你对上一讲的讲解有了一定的理解的话，这里将变得简单一些。\n\n![逻辑图](http://upload-images.jianshu.io/upload_images/1835430-c25b68eae4815985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n///字符串点击检查\n/*\n 实际上接受所有非图片的点击事件，将字符串的每个\n 字符取出与点击位置比较，若在范围内则点击到文字\n ，进而检测对应的文字是否响应事件，若存在响应\n */\n-(void)ClickOnStrWithPoint:(CGPoint)location\n{\n    NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);//获取所有CTLine\n    CFRange ranges[lines.count];//初始化范围数组\n    CGPoint origins[lines.count];//初始化原点数组\n    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);//获取所有CTLine的原点\n    for (int i = 0; i < lines.count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)lines[i];\n        CFRange range = CTLineGetStringRange(line);\n        ranges[i] = range;\n    }//获取所有CTLine的Range\n    for (int i = 0; i < _length; i ++) {//逐字检查\n        long maxLoc;\n        int lineNum;\n        for (int j = 0; j < lines.count; j ++) {//获取对应字符所在CTLine的index\n            CFRange range = ranges[j];\n            maxLoc = range.location + range.length - 1;\n            if (i <= maxLoc) {\n                lineNum = j;\n                break;\n            }\n        }\n        CTLineRef line = (__bridge CTLineRef)lines[lineNum];//取到字符对应的CTLine\n        CGPoint origin = origins[lineNum];\n        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];//计算对应字符的frame\n        if ([self isFrame:CTRunFrame containsPoint:location]) {//如果点击位置在字符范围内，响应时间，跳出循环\n            NSLog(@\"您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。\",i,lineNum + 1);//点击到文字，然而没有响应的处理。可以做其他处理\n            return;\n        }\n    }\n    NSLog(@\"您没有点击到文字\");//没有点击到文字，可以做其他处理\n}\n```\n看上去很多是吧？有没有怕怕的。\n\n仔细看你会发现，有很多代码跟昨天的有相似之处，就是这样，因为这里也`遍历`了每一个CTRun，只不过更加细化到`CTRun中的每个字`。\n\n#### 获取CTLine\n\n```\nNSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);//获取所有CTLine\n    CFRange ranges[lines.count];//初始化范围数组\n    CGPoint origins[lines.count];//初始化原点数组\n    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);//获取所有CTLine的原点\n```\n这四句我就不多说了，获取所有CTLine和其原点。\n\n#### 获取CTLine所表示范围\n\n```\nfor (int i = 0; i < lines.count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)lines[i];\n        CFRange range = CTLineGetStringRange(line);\n        ranges[i] = range;\n    }//获取所有CTLine的Range\n```\n获取每个CTLine中包含的富文本`在整串富文本中的范围`。将所有CTLine中字符串的范围保存下来放入数组备用。\n\n#### 获取CTRun\n\n```\nfor (int i = 0; i < _length; i ++)\n```\n这个for循环用来遍历富文本中的`每一个字符`。下面的代码都是在for循环中的循环体。\n\n```\nfor (int j = 0; j < lines.count; j ++) {//获取对应字符所在CTLine的index\n            CFRange range = ranges[j];\n            maxLoc = range.location + range.length - 1;\n            if (i <= maxLoc) {\n                lineNum = j;\n                break;\n            }\n        }\n```\n这里又是一层循环，通过当前`字符序号i`与每个`CTLine包含字符的范围`比较来求得当前`计算的是哪个CTLine中的字符`。\n\n```\nCTLineRef line = (__bridge CTLineRef)lines[lineNum];//取到字符对应的CTLine\n        CGPoint origin = origins[lineNum];\n        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];//计算对应字符的frame\n```\n\n#### 计算CTRun的frame\n取得当前字符所在的CTLine并取得该CTLine的原点，同时通过这里的第五个工具方法\n\n-(CGRect)frameForCTRunWithIndex:(NSInteger)index\n                         CTLine:(CTLineRef)line\n                         origin:(CGPoint)origin\n                         \n计算当前字符的frame。\n分解讲一下这个方法\n\n```\n///字符frame计算\n/*\n 返回索引字符的frame\n \n index：索引\n line：索引字符所在CTLine\n origin：line的起点\n*/\n-(CGRect)frameForCTRunWithIndex:(NSInteger)index\n                         CTLine:(CTLineRef)line\n                         origin:(CGPoint)origin\n{\n    CGFloat offsetX = CTLineGetOffsetForStringIndex(line, index, NULL);//获取字符起点相对于CTLine的原点的偏移量\n    CGFloat offsexX2 = CTLineGetOffsetForStringIndex(line, index + 1, NULL);//获取下一个字符的偏移量，两者之间即为字符X范围\n    offsetX += origin.x;\n    offsexX2 += origin.x;//坐标转换，将点的CTLine坐标转换至系统坐标\n    CGFloat offsetY = origin.y;//取到CTLine的起点Y\n    CGFloat lineAscent;//初始化上下边距的变量\n    CGFloat lineDescent;\n    NSArray * runs = (__bridge NSArray *)CTLineGetGlyphRuns(line);//获取所有CTRun\n    CTRunRef runCurrent;\n    for (int k = 0; k < runs.count; k ++) {//获取当前点击的CTRun\n        CTRunRef run = (__bridge CTRunRef)runs[k];\n        CFRange range = CTRunGetStringRange(run);\n        NSRange rangeOC = NSMakeRange(range.location, range.length);\n        if ([self isIndex:index inRange:rangeOC]) {\n            runCurrent = run;\n            break;\n        }\n    }\n    CTRunGetTypographicBounds(runCurrent, CFRangeMake(0, 0), &lineAscent, &lineDescent, NULL);//计算当前点击的CTRun高度\n    offsetY -= lineDescent;\n    CGFloat height = lineAscent + lineDescent;\n    return CGRectMake(offsetX, offsetY, offsexX2 - offsetX, height);//返回一个字符的Frame\n}\n```\n根据注释就能很轻易的看懂这段代码，不过可能有几个方法不熟悉，我来介绍下。\n\n- CTLineGetOffsetForStringIndex(,,)\n\n获取一行文字中，`指定charIndex字符相对x原点的偏移量`，返回值与第三个参数同为一个值。`如果charIndex超出一行的字符长度则反回最大长度结束位置的偏移量`，如一行文字共有17个字符，哪么返回的是第18个字符的起始偏移，即第17个偏移+第17个字符占有的宽度=第18个起始位置的偏移。因此想求一行字符所占的像素长度时，就可以使用此函数，将charIndex设置为大于字符长度即可。\n\n因为求得的坐标是相对于CTLine原点的偏移量，因此我们要加上CTLine原点的x坐标`获得该点的绝对坐标`。\n\n- CTLineGetGlyphRuns()昨天有介绍过，拿到CTLine中的所有CTRun。\n\n- CTRunGetStringRange()获得CTRun在富文本中的范围\n- CTRunGetTypographicBounds(,,,,)获得对应CTRun的尺寸信息\n\n#### 判断点击的文字\n\n中间用了第六个工具方法\n\n-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range\n\n```\n///范围检测\n/*\n 范围内返回yes，否则返回no\n */\n-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range\n{\n    if ((index <= range.location + range.length - 1) && (index >= range.location)) {\n        return YES;\n    }\n    return NO;\n}\n```\n这个代码很简单我就不多说了。\n\n通过以上方法，你就拿到了`每一个字符的frame`了。\n\n可以返回至上一层了=。=喘了一口气。。。\n\n接受到字符的frame，还是`判断点击位置是否在frame中`，如果在，则响应点击事件并结束方法。如果没有不在任何一个字符的frame内，则说明没有点击到文字，执行相应的点击事件。\n\n大工告成，到了这里，CoreText做图文混排的点击事件也算是完成了。\n\n最后放一张效果图吧。\n![大萌神镇楼](http://upload-images.jianshu.io/upload_images/1835430-6557831b9e067768.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- - -\n\n呐，了却一桩心事。。。\n\n你要是喜欢呢，麻烦你动一动你可爱的小手点击一下喜欢或者关注，毕竟老司机这么爱慕虚荣的人，而且老司机会经常更新的。\n\n哦，这段代码是我自己的解决方案，所以要转载的同学，一定要注明出处哦，这次是一定哦。貌似你不注明我也拦不住你。。。啧啧啧。。。\n[http://www.jianshu.com/p/51c47329203e](http://www.jianshu.com/p/51c47329203e)\n\n参考资料：\n\n无\n\n2016年05月16日23点52分\n\n老司机Wicky\n","source":"_posts/CoreText实现图文混排之点击事件.md","raw":"\n---\ntitle: CoreText实现图文混排之点击事件\nlayout: post\ndate: 2016-05-17 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CoreText \n- 图文混排\n- 点击事件\ncategories: 图文混排\n\n---\n\n![CoreText实现图文混排之点击事件](http://upload-images.jianshu.io/upload_images/1835430-1e81a37668cb04ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n系列文章：\n\n- [CoreText实现图文混排](http://www.jianshu.com/p/6db3289fb05d)\n- [CoreText实现图文混排之点击事件](http://www.jianshu.com/p/51c47329203e)\n- [CoreText实现图文混排之文字环绕及点击算法](http://www.jianshu.com/p/e154047b0f98)\n- - -\n今天呢，我们继续把CoreText图文混排的`点击事件`补充上，这样我们的图文混排也算是圆满了。\n\n<!-- more -->\n\n\n哦，上一篇的链接在这里\n[CoreText实现图文混排](http://www.jianshu.com/p/6db3289fb05d)。所有需要用到的`准备知识`都在上一篇，没有赶上车的朋友可以去补个票~\n\n上正文。\n- - - \n## 全部代码\n我们知道，CoreText是基于UIView去绘制的，那么既然有UIView，就有\n\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event方法，我们呢，就是基于这个方法去做点击事件的。\n\n```\n通过touchBegan方法拿到当前点击到的点，然后通过坐标判断这个点是否在某段文字上，如果在则触发对应事件。\n```\n上面呢就是主要思路。接下来呢，我们来详细讲解一下。还是老规矩，先上代码。\n\n```\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    UITouch * touch = [touches anyObject];\n    CGPoint location = [self systemPointFromScreenPoint:[touch locationInView:self]];\n    if ([self checkIsClickOnImgWithPoint:location]) {\n            return;\n    }\n    [self ClickOnStrWithPoint:location];\n}\n\n-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location\n{\n    if ([self isFrame:_imgFrm containsPoint:location]) {\n    \tNSLog(@\"您点击到了图片\");\n        return YES;\n    }\n    return NO;\n}\n\n-(void)ClickOnStrWithPoint:(CGPoint)location\n{\n    NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);\n    CFRange ranges[lines.count];\n    CGPoint origins[lines.count];\n    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);\n    for (int i = 0; i < lines.count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)lines[i];\n        CFRange range = CTLineGetStringRange(line);\n        ranges[i] = range;\n    }\n    for (int i = 0; i < _length; i ++) {\n        long maxLoc;\n        int lineNum;\n        for (int j = 0; j < lines.count; j ++) {\n            CFRange range = ranges[j];\n            maxLoc = range.location + range.length - 1;\n            if (i <= maxLoc) {\n                lineNum = j;\n                break;\n            }\n        }\n        CTLineRef line = (__bridge CTLineRef)lines[lineNum];        CGPoint origin = origins[lineNum];\n        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];\n        if ([self isFrame:CTRunFrame containsPoint:location]) {  \n            NSLog(@\"您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。\",i,lineNum + 1);//点击到文字，然而没有响应的处理。可以做其他处理\n            return;\n        }\n    }\n    NSLog(@\"您没有点击到文字\");\n}\n\n-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range\n{\n    if ((index <= range.location + range.length - 1) && (index >= range.location)) {\n        return YES;\n    }\n    return NO;\n}\n\n-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin\n{\n    return CGPointMake(origin.x, self.bounds.size.height - origin.y);\n}\n\n-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point\n{\n    return CGRectContainsPoint(frame, point);\n}\n\n-(CGRect)frameForCTRunWithIndex:(NSInteger)index\n                         CTLine:(CTLineRef)line\n                         origin:(CGPoint)origin\n{\n    CGFloat offsetX = CTLineGetOffsetForStringIndex(line, index, NULL);\n    CGFloat offsexX2 = CTLineGetOffsetForStringIndex(line, index + 1, NULL);\n    offsetX += origin.x;\n    offsexX2 += origin.x;\n    CGFloat offsetY = origin.y;\n    CGFloat lineAscent;\n    CGFloat lineDescent;\n    NSArray * runs = (__bridge NSArray *)CTLineGetGlyphRuns(line);\n    CTRunRef runCurrent;\n    for (int k = 0; k < runs.count; k ++) {\n        CTRunRef run = (__bridge CTRunRef)runs[k];\n        CFRange range = CTRunGetStringRange(run);\n        NSRange rangeOC = NSMakeRange(range.location, range.length);\n        if ([self isIndex:index inRange:rangeOC]) {\n            runCurrent = run;\n            break;\n        }\n    }\n    CTRunGetTypographicBounds(runCurrent, CFRangeMake(0, 0), &lineAscent, &lineDescent, NULL);\n    CGFloat height = lineAscent + lineDescent;\n    return CGRectMake(offsetX, offsetY, offsexX2 - offsetX, height);\n}\n```\n看上去也挺多的，我们还是分段讲解吧。\n- - -\n## 分段解析\n### -touchesBegan\n之所以把他放在首位，是因为他作为整个view响应点击事件的`入口`扮演者十分重要的角色。\n\n他负责`接收点击事件`，根据条件将点击事件`分发给不同的对象`去执行相应的响应。\n\n```\n///点击方法\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    UITouch * touch = [touches anyObject];\n    CGPoint location = [self systemPointFromScreenPoint:[touch locationInView:self]];//获取点击位置的系统坐标\n    if ([self checkIsClickOnImgWithPoint:location]) {//检查是否点击在图片上，如果在，优先响应图片事件\n        return;\n    }\n    [self ClickOnStrWithPoint:location];//响应字符串事件\n}\n```\n这里老司机还是要解释一下，为什么我要设置成优先响应图片的事件呢？\n\n是这样的，在我们使用的过程中，大部分的场景是如下过程：\n\n- 给整段富文本添加属性，事件等\n- 插入图片\n- 给图片设置点击事件\n\n\n\n正是因为这样，我们可以看出逻辑上图片的响应事件的优先级明显是要高于文字的。即使是一段`文字范围我们赋值了文字的响应事件`，然后在范围中插入了图片并且赋予了图片响应事件，我们往往是`希望图片响应其自己的事件`。同时，不知道你们是否还记得[上一趟车](http://www.jianshu.com/p/6db3289fb05d)我们已经求出了图片的frame，如果优先判断出点击的是图片的话将会`减少很多计算量`，`提高运行效率`。所以我这里将图片的响应优先级定义的高于文字，不过根据需要我们可以定义不同的响应优先级。\n\n搞明白这一点以后，其实逻辑就很简单了。\n\n- 首先呢，先取出当前点击的到屏幕坐标的点。\n- 将屏幕坐标转换为系统坐标（不懂得同学快去上一节补课）\n- 判断是否点击在图片上\n- 如果未点击图片执行点击文字\n- - -\n### 获取点击坐标\n-touchesBegan事件给我们提供了touches这么一个集合。里面装满了UITouch对象。\n\n因为集合是无序的，所以我们通过anyObject取出其中的一个UITouch对象。\nUITouch对象的locationInView是专门用来给出UITouch对象在某个View中的坐标的方法，因此我们可以用这个方法来求出当前点击位置的系统坐标。这段比较基础，想画个重点都不知道画哪。\n- - -\n### 坐标转换\n这里用到了第一个工具方法（老司机习惯把写好的方法分类，这些中间方法老司机习惯叫他们工具方法），-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin。\n\n简单的说一句，因为屏幕坐标与系统坐标的不同，我们要将坐标系`统一成系统坐标`，这样才能计算，所以才有了这个坐标转换的方法。其实很简单\n\n```\n///坐标转换\n/*\n 将屏幕坐标转换为系统坐标\n */\n-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin\n{\n    return CGPointMake(origin.x, self.bounds.size.height - origin.y);\n}\n```\n上一讲有坐标系的图，这里我就不细讲了。直接进入下一话题。\n- - -\n### 点击图片判断\n第二个工具方法\n\n-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location\n\n```\n///图片点击检查\n/*\n 遍历图片frame的数组与点击位置比较，如果在\n 范围内则响应的数组中取出对应响应并执行，返\n 回yes，否则返回no\n */\n-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location\n{\n    if ([self isFrame:_imgFrm containsPoint:location]) {\n    \tNSLog(@\"您点击到了图片\");\n        return YES;\n    }\n    return NO;\n}\n```\n这里呢，我们用到了第三个工具方法，顺便就说了吧\n\n\n-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point\n\n```\n///点包含检测\n-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point\n{\n    return CGRectContainsPoint(frame, point);\n}\n```\n事实上也是调用了系统的一个方法`CGRectContainsPoint()`。这个方法两个参数，一个是frame，一个是point。可以返回point是否在frame中。\n\n不过还是有一点需要注意的。由于`传入的point是系统坐标`（本例中），所以frame我们一定要`传入系统坐标系下的frame`才能正确对应。\n\n这里老司机偷了个懒，直接把上一讲中求得的图片frame改成了一个实例变量，这样在这里的方法中我就能直接调用了。这只是个demo，所以我就怎么方便怎么来了，实际使用中，你可以`把frame保存在数组或字典中`。你问我怎么在数组或字典中保存一个frame这样的结构体？恩，有一个系统类叫`NSValue`，专门针对这种结构体。\n\n如果-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point返回YES则说明在图片范围内，则`响应图片的点击事件`，\n\n`并且-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location返回YES`，否则返回NO。\n\n回到上一层，如果-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location返回YES，则说明`点击的是图片并且已经执行完响应事件`，`直接return结束方法即可`。否则则继续检查是否点击到了文字。\n- - -\n### 点击文字判断\n\n终于进入重中之重了，点击文字的逻辑了，不过你也别害怕，如果你对上一讲的讲解有了一定的理解的话，这里将变得简单一些。\n\n![逻辑图](http://upload-images.jianshu.io/upload_images/1835430-c25b68eae4815985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n///字符串点击检查\n/*\n 实际上接受所有非图片的点击事件，将字符串的每个\n 字符取出与点击位置比较，若在范围内则点击到文字\n ，进而检测对应的文字是否响应事件，若存在响应\n */\n-(void)ClickOnStrWithPoint:(CGPoint)location\n{\n    NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);//获取所有CTLine\n    CFRange ranges[lines.count];//初始化范围数组\n    CGPoint origins[lines.count];//初始化原点数组\n    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);//获取所有CTLine的原点\n    for (int i = 0; i < lines.count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)lines[i];\n        CFRange range = CTLineGetStringRange(line);\n        ranges[i] = range;\n    }//获取所有CTLine的Range\n    for (int i = 0; i < _length; i ++) {//逐字检查\n        long maxLoc;\n        int lineNum;\n        for (int j = 0; j < lines.count; j ++) {//获取对应字符所在CTLine的index\n            CFRange range = ranges[j];\n            maxLoc = range.location + range.length - 1;\n            if (i <= maxLoc) {\n                lineNum = j;\n                break;\n            }\n        }\n        CTLineRef line = (__bridge CTLineRef)lines[lineNum];//取到字符对应的CTLine\n        CGPoint origin = origins[lineNum];\n        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];//计算对应字符的frame\n        if ([self isFrame:CTRunFrame containsPoint:location]) {//如果点击位置在字符范围内，响应时间，跳出循环\n            NSLog(@\"您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。\",i,lineNum + 1);//点击到文字，然而没有响应的处理。可以做其他处理\n            return;\n        }\n    }\n    NSLog(@\"您没有点击到文字\");//没有点击到文字，可以做其他处理\n}\n```\n看上去很多是吧？有没有怕怕的。\n\n仔细看你会发现，有很多代码跟昨天的有相似之处，就是这样，因为这里也`遍历`了每一个CTRun，只不过更加细化到`CTRun中的每个字`。\n\n#### 获取CTLine\n\n```\nNSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);//获取所有CTLine\n    CFRange ranges[lines.count];//初始化范围数组\n    CGPoint origins[lines.count];//初始化原点数组\n    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);//获取所有CTLine的原点\n```\n这四句我就不多说了，获取所有CTLine和其原点。\n\n#### 获取CTLine所表示范围\n\n```\nfor (int i = 0; i < lines.count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)lines[i];\n        CFRange range = CTLineGetStringRange(line);\n        ranges[i] = range;\n    }//获取所有CTLine的Range\n```\n获取每个CTLine中包含的富文本`在整串富文本中的范围`。将所有CTLine中字符串的范围保存下来放入数组备用。\n\n#### 获取CTRun\n\n```\nfor (int i = 0; i < _length; i ++)\n```\n这个for循环用来遍历富文本中的`每一个字符`。下面的代码都是在for循环中的循环体。\n\n```\nfor (int j = 0; j < lines.count; j ++) {//获取对应字符所在CTLine的index\n            CFRange range = ranges[j];\n            maxLoc = range.location + range.length - 1;\n            if (i <= maxLoc) {\n                lineNum = j;\n                break;\n            }\n        }\n```\n这里又是一层循环，通过当前`字符序号i`与每个`CTLine包含字符的范围`比较来求得当前`计算的是哪个CTLine中的字符`。\n\n```\nCTLineRef line = (__bridge CTLineRef)lines[lineNum];//取到字符对应的CTLine\n        CGPoint origin = origins[lineNum];\n        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];//计算对应字符的frame\n```\n\n#### 计算CTRun的frame\n取得当前字符所在的CTLine并取得该CTLine的原点，同时通过这里的第五个工具方法\n\n-(CGRect)frameForCTRunWithIndex:(NSInteger)index\n                         CTLine:(CTLineRef)line\n                         origin:(CGPoint)origin\n                         \n计算当前字符的frame。\n分解讲一下这个方法\n\n```\n///字符frame计算\n/*\n 返回索引字符的frame\n \n index：索引\n line：索引字符所在CTLine\n origin：line的起点\n*/\n-(CGRect)frameForCTRunWithIndex:(NSInteger)index\n                         CTLine:(CTLineRef)line\n                         origin:(CGPoint)origin\n{\n    CGFloat offsetX = CTLineGetOffsetForStringIndex(line, index, NULL);//获取字符起点相对于CTLine的原点的偏移量\n    CGFloat offsexX2 = CTLineGetOffsetForStringIndex(line, index + 1, NULL);//获取下一个字符的偏移量，两者之间即为字符X范围\n    offsetX += origin.x;\n    offsexX2 += origin.x;//坐标转换，将点的CTLine坐标转换至系统坐标\n    CGFloat offsetY = origin.y;//取到CTLine的起点Y\n    CGFloat lineAscent;//初始化上下边距的变量\n    CGFloat lineDescent;\n    NSArray * runs = (__bridge NSArray *)CTLineGetGlyphRuns(line);//获取所有CTRun\n    CTRunRef runCurrent;\n    for (int k = 0; k < runs.count; k ++) {//获取当前点击的CTRun\n        CTRunRef run = (__bridge CTRunRef)runs[k];\n        CFRange range = CTRunGetStringRange(run);\n        NSRange rangeOC = NSMakeRange(range.location, range.length);\n        if ([self isIndex:index inRange:rangeOC]) {\n            runCurrent = run;\n            break;\n        }\n    }\n    CTRunGetTypographicBounds(runCurrent, CFRangeMake(0, 0), &lineAscent, &lineDescent, NULL);//计算当前点击的CTRun高度\n    offsetY -= lineDescent;\n    CGFloat height = lineAscent + lineDescent;\n    return CGRectMake(offsetX, offsetY, offsexX2 - offsetX, height);//返回一个字符的Frame\n}\n```\n根据注释就能很轻易的看懂这段代码，不过可能有几个方法不熟悉，我来介绍下。\n\n- CTLineGetOffsetForStringIndex(,,)\n\n获取一行文字中，`指定charIndex字符相对x原点的偏移量`，返回值与第三个参数同为一个值。`如果charIndex超出一行的字符长度则反回最大长度结束位置的偏移量`，如一行文字共有17个字符，哪么返回的是第18个字符的起始偏移，即第17个偏移+第17个字符占有的宽度=第18个起始位置的偏移。因此想求一行字符所占的像素长度时，就可以使用此函数，将charIndex设置为大于字符长度即可。\n\n因为求得的坐标是相对于CTLine原点的偏移量，因此我们要加上CTLine原点的x坐标`获得该点的绝对坐标`。\n\n- CTLineGetGlyphRuns()昨天有介绍过，拿到CTLine中的所有CTRun。\n\n- CTRunGetStringRange()获得CTRun在富文本中的范围\n- CTRunGetTypographicBounds(,,,,)获得对应CTRun的尺寸信息\n\n#### 判断点击的文字\n\n中间用了第六个工具方法\n\n-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range\n\n```\n///范围检测\n/*\n 范围内返回yes，否则返回no\n */\n-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range\n{\n    if ((index <= range.location + range.length - 1) && (index >= range.location)) {\n        return YES;\n    }\n    return NO;\n}\n```\n这个代码很简单我就不多说了。\n\n通过以上方法，你就拿到了`每一个字符的frame`了。\n\n可以返回至上一层了=。=喘了一口气。。。\n\n接受到字符的frame，还是`判断点击位置是否在frame中`，如果在，则响应点击事件并结束方法。如果没有不在任何一个字符的frame内，则说明没有点击到文字，执行相应的点击事件。\n\n大工告成，到了这里，CoreText做图文混排的点击事件也算是完成了。\n\n最后放一张效果图吧。\n![大萌神镇楼](http://upload-images.jianshu.io/upload_images/1835430-6557831b9e067768.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- - -\n\n呐，了却一桩心事。。。\n\n你要是喜欢呢，麻烦你动一动你可爱的小手点击一下喜欢或者关注，毕竟老司机这么爱慕虚荣的人，而且老司机会经常更新的。\n\n哦，这段代码是我自己的解决方案，所以要转载的同学，一定要注明出处哦，这次是一定哦。貌似你不注明我也拦不住你。。。啧啧啧。。。\n[http://www.jianshu.com/p/51c47329203e](http://www.jianshu.com/p/51c47329203e)\n\n参考资料：\n\n无\n\n2016年05月16日23点52分\n\n老司机Wicky\n","slug":"CoreText实现图文混排之点击事件","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htov0006jigb4lvtsvtn","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1e81a37668cb04ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CoreText实现图文混排之点击事件\"><br>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排</a></li>\n<li><a href=\"http://www.jianshu.com/p/51c47329203e\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之点击事件</a></li>\n<li><a href=\"http://www.jianshu.com/p/e154047b0f98\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之文字环绕及点击算法</a></li>\n</ul>\n<hr>\n<p>今天呢，我们继续把CoreText图文混排的<code>点击事件</code>补充上，这样我们的图文混排也算是圆满了。</p>\n<a id=\"more\"></a>\n<p>哦，上一篇的链接在这里<br><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排</a>。所有需要用到的<code>准备知识</code>都在上一篇，没有赶上车的朋友可以去补个票~</p>\n<p>上正文。</p>\n<hr>\n<h2 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h2><p>我们知道，CoreText是基于UIView去绘制的，那么既然有UIView，就有</p>\n<p>-(void)touchesBegan:(NSSet<uitouch *=\"\"> <em>)touches withEvent:(UIEvent </em>)event方法，我们呢，就是基于这个方法去做点击事件的。</uitouch></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">通过touchBegan方法拿到当前点击到的点，然后通过坐标判断这个点是否在某段文字上，如果在则触发对应事件。</div></pre></td></tr></table></figure>\n<p>上面呢就是主要思路。接下来呢，我们来详细讲解一下。还是老规矩，先上代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    UITouch * touch = [touches anyObject];</div><div class=\"line\">    CGPoint location = [self systemPointFromScreenPoint:[touch locationInView:self]];</div><div class=\"line\">    if ([self checkIsClickOnImgWithPoint:location]) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self ClickOnStrWithPoint:location];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location</div><div class=\"line\">&#123;</div><div class=\"line\">    if ([self isFrame:_imgFrm containsPoint:location]) &#123;</div><div class=\"line\">    \tNSLog(@&quot;您点击到了图片&quot;);</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)ClickOnStrWithPoint:(CGPoint)location</div><div class=\"line\">&#123;</div><div class=\"line\">    NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);</div><div class=\"line\">    CFRange ranges[lines.count];</div><div class=\"line\">    CGPoint origins[lines.count];</div><div class=\"line\">    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);</div><div class=\"line\">    for (int i = 0; i &lt; lines.count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[i];</div><div class=\"line\">        CFRange range = CTLineGetStringRange(line);</div><div class=\"line\">        ranges[i] = range;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (int i = 0; i &lt; _length; i ++) &#123;</div><div class=\"line\">        long maxLoc;</div><div class=\"line\">        int lineNum;</div><div class=\"line\">        for (int j = 0; j &lt; lines.count; j ++) &#123;</div><div class=\"line\">            CFRange range = ranges[j];</div><div class=\"line\">            maxLoc = range.location + range.length - 1;</div><div class=\"line\">            if (i &lt;= maxLoc) &#123;</div><div class=\"line\">                lineNum = j;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[lineNum];        CGPoint origin = origins[lineNum];</div><div class=\"line\">        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];</div><div class=\"line\">        if ([self isFrame:CTRunFrame containsPoint:location]) &#123;  </div><div class=\"line\">            NSLog(@&quot;您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。&quot;,i,lineNum + 1);//点击到文字，然而没有响应的处理。可以做其他处理</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;您没有点击到文字&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range</div><div class=\"line\">&#123;</div><div class=\"line\">    if ((index &lt;= range.location + range.length - 1) &amp;&amp; (index &gt;= range.location)) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGPointMake(origin.x, self.bounds.size.height - origin.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGRectContainsPoint(frame, point);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGRect)frameForCTRunWithIndex:(NSInteger)index</div><div class=\"line\">                         CTLine:(CTLineRef)line</div><div class=\"line\">                         origin:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat offsetX = CTLineGetOffsetForStringIndex(line, index, NULL);</div><div class=\"line\">    CGFloat offsexX2 = CTLineGetOffsetForStringIndex(line, index + 1, NULL);</div><div class=\"line\">    offsetX += origin.x;</div><div class=\"line\">    offsexX2 += origin.x;</div><div class=\"line\">    CGFloat offsetY = origin.y;</div><div class=\"line\">    CGFloat lineAscent;</div><div class=\"line\">    CGFloat lineDescent;</div><div class=\"line\">    NSArray * runs = (__bridge NSArray *)CTLineGetGlyphRuns(line);</div><div class=\"line\">    CTRunRef runCurrent;</div><div class=\"line\">    for (int k = 0; k &lt; runs.count; k ++) &#123;</div><div class=\"line\">        CTRunRef run = (__bridge CTRunRef)runs[k];</div><div class=\"line\">        CFRange range = CTRunGetStringRange(run);</div><div class=\"line\">        NSRange rangeOC = NSMakeRange(range.location, range.length);</div><div class=\"line\">        if ([self isIndex:index inRange:rangeOC]) &#123;</div><div class=\"line\">            runCurrent = run;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CTRunGetTypographicBounds(runCurrent, CFRangeMake(0, 0), &amp;lineAscent, &amp;lineDescent, NULL);</div><div class=\"line\">    CGFloat height = lineAscent + lineDescent;</div><div class=\"line\">    return CGRectMake(offsetX, offsetY, offsexX2 - offsetX, height);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看上去也挺多的，我们还是分段讲解吧。</p>\n<hr>\n<h2 id=\"分段解析\"><a href=\"#分段解析\" class=\"headerlink\" title=\"分段解析\"></a>分段解析</h2><h3 id=\"touchesBegan\"><a href=\"#touchesBegan\" class=\"headerlink\" title=\"-touchesBegan\"></a>-touchesBegan</h3><p>之所以把他放在首位，是因为他作为整个view响应点击事件的<code>入口</code>扮演者十分重要的角色。</p>\n<p>他负责<code>接收点击事件</code>，根据条件将点击事件<code>分发给不同的对象</code>去执行相应的响应。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">///点击方法</div><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    UITouch * touch = [touches anyObject];</div><div class=\"line\">    CGPoint location = [self systemPointFromScreenPoint:[touch locationInView:self]];//获取点击位置的系统坐标</div><div class=\"line\">    if ([self checkIsClickOnImgWithPoint:location]) &#123;//检查是否点击在图片上，如果在，优先响应图片事件</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self ClickOnStrWithPoint:location];//响应字符串事件</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里老司机还是要解释一下，为什么我要设置成优先响应图片的事件呢？</p>\n<p>是这样的，在我们使用的过程中，大部分的场景是如下过程：</p>\n<ul>\n<li>给整段富文本添加属性，事件等</li>\n<li>插入图片</li>\n<li>给图片设置点击事件</li>\n</ul>\n<p>正是因为这样，我们可以看出逻辑上图片的响应事件的优先级明显是要高于文字的。即使是一段<code>文字范围我们赋值了文字的响应事件</code>，然后在范围中插入了图片并且赋予了图片响应事件，我们往往是<code>希望图片响应其自己的事件</code>。同时，不知道你们是否还记得<a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">上一趟车</a>我们已经求出了图片的frame，如果优先判断出点击的是图片的话将会<code>减少很多计算量</code>，<code>提高运行效率</code>。所以我这里将图片的响应优先级定义的高于文字，不过根据需要我们可以定义不同的响应优先级。</p>\n<p>搞明白这一点以后，其实逻辑就很简单了。</p>\n<ul>\n<li>首先呢，先取出当前点击的到屏幕坐标的点。</li>\n<li>将屏幕坐标转换为系统坐标（不懂得同学快去上一节补课）</li>\n<li>判断是否点击在图片上</li>\n<li>如果未点击图片执行点击文字</li>\n</ul>\n<hr>\n<h3 id=\"获取点击坐标\"><a href=\"#获取点击坐标\" class=\"headerlink\" title=\"获取点击坐标\"></a>获取点击坐标</h3><p>-touchesBegan事件给我们提供了touches这么一个集合。里面装满了UITouch对象。</p>\n<p>因为集合是无序的，所以我们通过anyObject取出其中的一个UITouch对象。<br>UITouch对象的locationInView是专门用来给出UITouch对象在某个View中的坐标的方法，因此我们可以用这个方法来求出当前点击位置的系统坐标。这段比较基础，想画个重点都不知道画哪。</p>\n<hr>\n<h3 id=\"坐标转换\"><a href=\"#坐标转换\" class=\"headerlink\" title=\"坐标转换\"></a>坐标转换</h3><p>这里用到了第一个工具方法（老司机习惯把写好的方法分类，这些中间方法老司机习惯叫他们工具方法），-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin。</p>\n<p>简单的说一句，因为屏幕坐标与系统坐标的不同，我们要将坐标系<code>统一成系统坐标</code>，这样才能计算，所以才有了这个坐标转换的方法。其实很简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">///坐标转换</div><div class=\"line\">/*</div><div class=\"line\"> 将屏幕坐标转换为系统坐标</div><div class=\"line\"> */</div><div class=\"line\">-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGPointMake(origin.x, self.bounds.size.height - origin.y);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上一讲有坐标系的图，这里我就不细讲了。直接进入下一话题。</p>\n<hr>\n<h3 id=\"点击图片判断\"><a href=\"#点击图片判断\" class=\"headerlink\" title=\"点击图片判断\"></a>点击图片判断</h3><p>第二个工具方法</p>\n<p>-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">///图片点击检查</div><div class=\"line\">/*</div><div class=\"line\"> 遍历图片frame的数组与点击位置比较，如果在</div><div class=\"line\"> 范围内则响应的数组中取出对应响应并执行，返</div><div class=\"line\"> 回yes，否则返回no</div><div class=\"line\"> */</div><div class=\"line\">-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location</div><div class=\"line\">&#123;</div><div class=\"line\">    if ([self isFrame:_imgFrm containsPoint:location]) &#123;</div><div class=\"line\">    \tNSLog(@&quot;您点击到了图片&quot;);</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里呢，我们用到了第三个工具方法，顺便就说了吧</p>\n<p>-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">///点包含检测</div><div class=\"line\">-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGRectContainsPoint(frame, point);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上也是调用了系统的一个方法<code>CGRectContainsPoint()</code>。这个方法两个参数，一个是frame，一个是point。可以返回point是否在frame中。</p>\n<p>不过还是有一点需要注意的。由于<code>传入的point是系统坐标</code>（本例中），所以frame我们一定要<code>传入系统坐标系下的frame</code>才能正确对应。</p>\n<p>这里老司机偷了个懒，直接把上一讲中求得的图片frame改成了一个实例变量，这样在这里的方法中我就能直接调用了。这只是个demo，所以我就怎么方便怎么来了，实际使用中，你可以<code>把frame保存在数组或字典中</code>。你问我怎么在数组或字典中保存一个frame这样的结构体？恩，有一个系统类叫<code>NSValue</code>，专门针对这种结构体。</p>\n<p>如果-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point返回YES则说明在图片范围内，则<code>响应图片的点击事件</code>，</p>\n<p><code>并且-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location返回YES</code>，否则返回NO。</p>\n<p>回到上一层，如果-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location返回YES，则说明<code>点击的是图片并且已经执行完响应事件</code>，<code>直接return结束方法即可</code>。否则则继续检查是否点击到了文字。</p>\n<hr>\n<h3 id=\"点击文字判断\"><a href=\"#点击文字判断\" class=\"headerlink\" title=\"点击文字判断\"></a>点击文字判断</h3><p>终于进入重中之重了，点击文字的逻辑了，不过你也别害怕，如果你对上一讲的讲解有了一定的理解的话，这里将变得简单一些。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-c25b68eae4815985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"逻辑图\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">///字符串点击检查</div><div class=\"line\">/*</div><div class=\"line\"> 实际上接受所有非图片的点击事件，将字符串的每个</div><div class=\"line\"> 字符取出与点击位置比较，若在范围内则点击到文字</div><div class=\"line\"> ，进而检测对应的文字是否响应事件，若存在响应</div><div class=\"line\"> */</div><div class=\"line\">-(void)ClickOnStrWithPoint:(CGPoint)location</div><div class=\"line\">&#123;</div><div class=\"line\">    NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);//获取所有CTLine</div><div class=\"line\">    CFRange ranges[lines.count];//初始化范围数组</div><div class=\"line\">    CGPoint origins[lines.count];//初始化原点数组</div><div class=\"line\">    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);//获取所有CTLine的原点</div><div class=\"line\">    for (int i = 0; i &lt; lines.count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[i];</div><div class=\"line\">        CFRange range = CTLineGetStringRange(line);</div><div class=\"line\">        ranges[i] = range;</div><div class=\"line\">    &#125;//获取所有CTLine的Range</div><div class=\"line\">    for (int i = 0; i &lt; _length; i ++) &#123;//逐字检查</div><div class=\"line\">        long maxLoc;</div><div class=\"line\">        int lineNum;</div><div class=\"line\">        for (int j = 0; j &lt; lines.count; j ++) &#123;//获取对应字符所在CTLine的index</div><div class=\"line\">            CFRange range = ranges[j];</div><div class=\"line\">            maxLoc = range.location + range.length - 1;</div><div class=\"line\">            if (i &lt;= maxLoc) &#123;</div><div class=\"line\">                lineNum = j;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[lineNum];//取到字符对应的CTLine</div><div class=\"line\">        CGPoint origin = origins[lineNum];</div><div class=\"line\">        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];//计算对应字符的frame</div><div class=\"line\">        if ([self isFrame:CTRunFrame containsPoint:location]) &#123;//如果点击位置在字符范围内，响应时间，跳出循环</div><div class=\"line\">            NSLog(@&quot;您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。&quot;,i,lineNum + 1);//点击到文字，然而没有响应的处理。可以做其他处理</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;您没有点击到文字&quot;);//没有点击到文字，可以做其他处理</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>看上去很多是吧？有没有怕怕的。</p>\n<p>仔细看你会发现，有很多代码跟昨天的有相似之处，就是这样，因为这里也<code>遍历</code>了每一个CTRun，只不过更加细化到<code>CTRun中的每个字</code>。</p>\n<h4 id=\"获取CTLine\"><a href=\"#获取CTLine\" class=\"headerlink\" title=\"获取CTLine\"></a>获取CTLine</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);//获取所有CTLine</div><div class=\"line\">    CFRange ranges[lines.count];//初始化范围数组</div><div class=\"line\">    CGPoint origins[lines.count];//初始化原点数组</div><div class=\"line\">    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);//获取所有CTLine的原点</div></pre></td></tr></table></figure>\n<p>这四句我就不多说了，获取所有CTLine和其原点。</p>\n<h4 id=\"获取CTLine所表示范围\"><a href=\"#获取CTLine所表示范围\" class=\"headerlink\" title=\"获取CTLine所表示范围\"></a>获取CTLine所表示范围</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; lines.count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[i];</div><div class=\"line\">        CFRange range = CTLineGetStringRange(line);</div><div class=\"line\">        ranges[i] = range;</div><div class=\"line\">    &#125;//获取所有CTLine的Range</div></pre></td></tr></table></figure>\n<p>获取每个CTLine中包含的富文本<code>在整串富文本中的范围</code>。将所有CTLine中字符串的范围保存下来放入数组备用。</p>\n<h4 id=\"获取CTRun\"><a href=\"#获取CTRun\" class=\"headerlink\" title=\"获取CTRun\"></a>获取CTRun</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; _length; i ++)</div></pre></td></tr></table></figure>\n<p>这个for循环用来遍历富文本中的<code>每一个字符</code>。下面的代码都是在for循环中的循环体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j = 0; j &lt; lines.count; j ++) &#123;//获取对应字符所在CTLine的index</div><div class=\"line\">            CFRange range = ranges[j];</div><div class=\"line\">            maxLoc = range.location + range.length - 1;</div><div class=\"line\">            if (i &lt;= maxLoc) &#123;</div><div class=\"line\">                lineNum = j;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>这里又是一层循环，通过当前<code>字符序号i</code>与每个<code>CTLine包含字符的范围</code>比较来求得当前<code>计算的是哪个CTLine中的字符</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CTLineRef line = (__bridge CTLineRef)lines[lineNum];//取到字符对应的CTLine</div><div class=\"line\">        CGPoint origin = origins[lineNum];</div><div class=\"line\">        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];//计算对应字符的frame</div></pre></td></tr></table></figure>\n<h4 id=\"计算CTRun的frame\"><a href=\"#计算CTRun的frame\" class=\"headerlink\" title=\"计算CTRun的frame\"></a>计算CTRun的frame</h4><p>取得当前字符所在的CTLine并取得该CTLine的原点，同时通过这里的第五个工具方法</p>\n<p>-(CGRect)frameForCTRunWithIndex:(NSInteger)index<br>                         CTLine:(CTLineRef)line<br>                         origin:(CGPoint)origin</p>\n<p>计算当前字符的frame。<br>分解讲一下这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">///字符frame计算</div><div class=\"line\">/*</div><div class=\"line\"> 返回索引字符的frame</div><div class=\"line\"> </div><div class=\"line\"> index：索引</div><div class=\"line\"> line：索引字符所在CTLine</div><div class=\"line\"> origin：line的起点</div><div class=\"line\">*/</div><div class=\"line\">-(CGRect)frameForCTRunWithIndex:(NSInteger)index</div><div class=\"line\">                         CTLine:(CTLineRef)line</div><div class=\"line\">                         origin:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat offsetX = CTLineGetOffsetForStringIndex(line, index, NULL);//获取字符起点相对于CTLine的原点的偏移量</div><div class=\"line\">    CGFloat offsexX2 = CTLineGetOffsetForStringIndex(line, index + 1, NULL);//获取下一个字符的偏移量，两者之间即为字符X范围</div><div class=\"line\">    offsetX += origin.x;</div><div class=\"line\">    offsexX2 += origin.x;//坐标转换，将点的CTLine坐标转换至系统坐标</div><div class=\"line\">    CGFloat offsetY = origin.y;//取到CTLine的起点Y</div><div class=\"line\">    CGFloat lineAscent;//初始化上下边距的变量</div><div class=\"line\">    CGFloat lineDescent;</div><div class=\"line\">    NSArray * runs = (__bridge NSArray *)CTLineGetGlyphRuns(line);//获取所有CTRun</div><div class=\"line\">    CTRunRef runCurrent;</div><div class=\"line\">    for (int k = 0; k &lt; runs.count; k ++) &#123;//获取当前点击的CTRun</div><div class=\"line\">        CTRunRef run = (__bridge CTRunRef)runs[k];</div><div class=\"line\">        CFRange range = CTRunGetStringRange(run);</div><div class=\"line\">        NSRange rangeOC = NSMakeRange(range.location, range.length);</div><div class=\"line\">        if ([self isIndex:index inRange:rangeOC]) &#123;</div><div class=\"line\">            runCurrent = run;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CTRunGetTypographicBounds(runCurrent, CFRangeMake(0, 0), &amp;lineAscent, &amp;lineDescent, NULL);//计算当前点击的CTRun高度</div><div class=\"line\">    offsetY -= lineDescent;</div><div class=\"line\">    CGFloat height = lineAscent + lineDescent;</div><div class=\"line\">    return CGRectMake(offsetX, offsetY, offsexX2 - offsetX, height);//返回一个字符的Frame</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据注释就能很轻易的看懂这段代码，不过可能有几个方法不熟悉，我来介绍下。</p>\n<ul>\n<li>CTLineGetOffsetForStringIndex(,,)</li>\n</ul>\n<p>获取一行文字中，<code>指定charIndex字符相对x原点的偏移量</code>，返回值与第三个参数同为一个值。<code>如果charIndex超出一行的字符长度则反回最大长度结束位置的偏移量</code>，如一行文字共有17个字符，哪么返回的是第18个字符的起始偏移，即第17个偏移+第17个字符占有的宽度=第18个起始位置的偏移。因此想求一行字符所占的像素长度时，就可以使用此函数，将charIndex设置为大于字符长度即可。</p>\n<p>因为求得的坐标是相对于CTLine原点的偏移量，因此我们要加上CTLine原点的x坐标<code>获得该点的绝对坐标</code>。</p>\n<ul>\n<li><p>CTLineGetGlyphRuns()昨天有介绍过，拿到CTLine中的所有CTRun。</p>\n</li>\n<li><p>CTRunGetStringRange()获得CTRun在富文本中的范围</p>\n</li>\n<li>CTRunGetTypographicBounds(,,,,)获得对应CTRun的尺寸信息</li>\n</ul>\n<h4 id=\"判断点击的文字\"><a href=\"#判断点击的文字\" class=\"headerlink\" title=\"判断点击的文字\"></a>判断点击的文字</h4><p>中间用了第六个工具方法</p>\n<p>-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">///范围检测</div><div class=\"line\">/*</div><div class=\"line\"> 范围内返回yes，否则返回no</div><div class=\"line\"> */</div><div class=\"line\">-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range</div><div class=\"line\">&#123;</div><div class=\"line\">    if ((index &lt;= range.location + range.length - 1) &amp;&amp; (index &gt;= range.location)) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个代码很简单我就不多说了。</p>\n<p>通过以上方法，你就拿到了<code>每一个字符的frame</code>了。</p>\n<p>可以返回至上一层了=。=喘了一口气。。。</p>\n<p>接受到字符的frame，还是<code>判断点击位置是否在frame中</code>，如果在，则响应点击事件并结束方法。如果没有不在任何一个字符的frame内，则说明没有点击到文字，执行相应的点击事件。</p>\n<p>大工告成，到了这里，CoreText做图文混排的点击事件也算是完成了。</p>\n<p>最后放一张效果图吧。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6557831b9e067768.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"大萌神镇楼\"></p>\n<hr>\n<p>呐，了却一桩心事。。。</p>\n<p>你要是喜欢呢，麻烦你动一动你可爱的小手点击一下喜欢或者关注，毕竟老司机这么爱慕虚荣的人，而且老司机会经常更新的。</p>\n<p>哦，这段代码是我自己的解决方案，所以要转载的同学，一定要注明出处哦，这次是一定哦。貌似你不注明我也拦不住你。。。啧啧啧。。。<br><a href=\"http://www.jianshu.com/p/51c47329203e\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/51c47329203e</a></p>\n<p>参考资料：</p>\n<p>无</p>\n<p>2016年05月16日23点52分</p>\n<p>老司机Wicky</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1e81a37668cb04ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CoreText实现图文混排之点击事件\"><br>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排</a></li>\n<li><a href=\"http://www.jianshu.com/p/51c47329203e\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之点击事件</a></li>\n<li><a href=\"http://www.jianshu.com/p/e154047b0f98\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之文字环绕及点击算法</a></li>\n</ul>\n<hr>\n<p>今天呢，我们继续把CoreText图文混排的<code>点击事件</code>补充上，这样我们的图文混排也算是圆满了。</p>","more":"<p>哦，上一篇的链接在这里<br><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排</a>。所有需要用到的<code>准备知识</code>都在上一篇，没有赶上车的朋友可以去补个票~</p>\n<p>上正文。</p>\n<hr>\n<h2 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h2><p>我们知道，CoreText是基于UIView去绘制的，那么既然有UIView，就有</p>\n<p>-(void)touchesBegan:(NSSet<uitouch *=\"\"> <em>)touches withEvent:(UIEvent </em>)event方法，我们呢，就是基于这个方法去做点击事件的。</uitouch></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">通过touchBegan方法拿到当前点击到的点，然后通过坐标判断这个点是否在某段文字上，如果在则触发对应事件。</div></pre></td></tr></table></figure>\n<p>上面呢就是主要思路。接下来呢，我们来详细讲解一下。还是老规矩，先上代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    UITouch * touch = [touches anyObject];</div><div class=\"line\">    CGPoint location = [self systemPointFromScreenPoint:[touch locationInView:self]];</div><div class=\"line\">    if ([self checkIsClickOnImgWithPoint:location]) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self ClickOnStrWithPoint:location];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location</div><div class=\"line\">&#123;</div><div class=\"line\">    if ([self isFrame:_imgFrm containsPoint:location]) &#123;</div><div class=\"line\">    \tNSLog(@&quot;您点击到了图片&quot;);</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)ClickOnStrWithPoint:(CGPoint)location</div><div class=\"line\">&#123;</div><div class=\"line\">    NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);</div><div class=\"line\">    CFRange ranges[lines.count];</div><div class=\"line\">    CGPoint origins[lines.count];</div><div class=\"line\">    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);</div><div class=\"line\">    for (int i = 0; i &lt; lines.count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[i];</div><div class=\"line\">        CFRange range = CTLineGetStringRange(line);</div><div class=\"line\">        ranges[i] = range;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (int i = 0; i &lt; _length; i ++) &#123;</div><div class=\"line\">        long maxLoc;</div><div class=\"line\">        int lineNum;</div><div class=\"line\">        for (int j = 0; j &lt; lines.count; j ++) &#123;</div><div class=\"line\">            CFRange range = ranges[j];</div><div class=\"line\">            maxLoc = range.location + range.length - 1;</div><div class=\"line\">            if (i &lt;= maxLoc) &#123;</div><div class=\"line\">                lineNum = j;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[lineNum];        CGPoint origin = origins[lineNum];</div><div class=\"line\">        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];</div><div class=\"line\">        if ([self isFrame:CTRunFrame containsPoint:location]) &#123;  </div><div class=\"line\">            NSLog(@&quot;您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。&quot;,i,lineNum + 1);//点击到文字，然而没有响应的处理。可以做其他处理</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;您没有点击到文字&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range</div><div class=\"line\">&#123;</div><div class=\"line\">    if ((index &lt;= range.location + range.length - 1) &amp;&amp; (index &gt;= range.location)) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGPointMake(origin.x, self.bounds.size.height - origin.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGRectContainsPoint(frame, point);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGRect)frameForCTRunWithIndex:(NSInteger)index</div><div class=\"line\">                         CTLine:(CTLineRef)line</div><div class=\"line\">                         origin:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat offsetX = CTLineGetOffsetForStringIndex(line, index, NULL);</div><div class=\"line\">    CGFloat offsexX2 = CTLineGetOffsetForStringIndex(line, index + 1, NULL);</div><div class=\"line\">    offsetX += origin.x;</div><div class=\"line\">    offsexX2 += origin.x;</div><div class=\"line\">    CGFloat offsetY = origin.y;</div><div class=\"line\">    CGFloat lineAscent;</div><div class=\"line\">    CGFloat lineDescent;</div><div class=\"line\">    NSArray * runs = (__bridge NSArray *)CTLineGetGlyphRuns(line);</div><div class=\"line\">    CTRunRef runCurrent;</div><div class=\"line\">    for (int k = 0; k &lt; runs.count; k ++) &#123;</div><div class=\"line\">        CTRunRef run = (__bridge CTRunRef)runs[k];</div><div class=\"line\">        CFRange range = CTRunGetStringRange(run);</div><div class=\"line\">        NSRange rangeOC = NSMakeRange(range.location, range.length);</div><div class=\"line\">        if ([self isIndex:index inRange:rangeOC]) &#123;</div><div class=\"line\">            runCurrent = run;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CTRunGetTypographicBounds(runCurrent, CFRangeMake(0, 0), &amp;lineAscent, &amp;lineDescent, NULL);</div><div class=\"line\">    CGFloat height = lineAscent + lineDescent;</div><div class=\"line\">    return CGRectMake(offsetX, offsetY, offsexX2 - offsetX, height);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看上去也挺多的，我们还是分段讲解吧。</p>\n<hr>\n<h2 id=\"分段解析\"><a href=\"#分段解析\" class=\"headerlink\" title=\"分段解析\"></a>分段解析</h2><h3 id=\"touchesBegan\"><a href=\"#touchesBegan\" class=\"headerlink\" title=\"-touchesBegan\"></a>-touchesBegan</h3><p>之所以把他放在首位，是因为他作为整个view响应点击事件的<code>入口</code>扮演者十分重要的角色。</p>\n<p>他负责<code>接收点击事件</code>，根据条件将点击事件<code>分发给不同的对象</code>去执行相应的响应。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">///点击方法</div><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    UITouch * touch = [touches anyObject];</div><div class=\"line\">    CGPoint location = [self systemPointFromScreenPoint:[touch locationInView:self]];//获取点击位置的系统坐标</div><div class=\"line\">    if ([self checkIsClickOnImgWithPoint:location]) &#123;//检查是否点击在图片上，如果在，优先响应图片事件</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self ClickOnStrWithPoint:location];//响应字符串事件</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里老司机还是要解释一下，为什么我要设置成优先响应图片的事件呢？</p>\n<p>是这样的，在我们使用的过程中，大部分的场景是如下过程：</p>\n<ul>\n<li>给整段富文本添加属性，事件等</li>\n<li>插入图片</li>\n<li>给图片设置点击事件</li>\n</ul>\n<p>正是因为这样，我们可以看出逻辑上图片的响应事件的优先级明显是要高于文字的。即使是一段<code>文字范围我们赋值了文字的响应事件</code>，然后在范围中插入了图片并且赋予了图片响应事件，我们往往是<code>希望图片响应其自己的事件</code>。同时，不知道你们是否还记得<a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">上一趟车</a>我们已经求出了图片的frame，如果优先判断出点击的是图片的话将会<code>减少很多计算量</code>，<code>提高运行效率</code>。所以我这里将图片的响应优先级定义的高于文字，不过根据需要我们可以定义不同的响应优先级。</p>\n<p>搞明白这一点以后，其实逻辑就很简单了。</p>\n<ul>\n<li>首先呢，先取出当前点击的到屏幕坐标的点。</li>\n<li>将屏幕坐标转换为系统坐标（不懂得同学快去上一节补课）</li>\n<li>判断是否点击在图片上</li>\n<li>如果未点击图片执行点击文字</li>\n</ul>\n<hr>\n<h3 id=\"获取点击坐标\"><a href=\"#获取点击坐标\" class=\"headerlink\" title=\"获取点击坐标\"></a>获取点击坐标</h3><p>-touchesBegan事件给我们提供了touches这么一个集合。里面装满了UITouch对象。</p>\n<p>因为集合是无序的，所以我们通过anyObject取出其中的一个UITouch对象。<br>UITouch对象的locationInView是专门用来给出UITouch对象在某个View中的坐标的方法，因此我们可以用这个方法来求出当前点击位置的系统坐标。这段比较基础，想画个重点都不知道画哪。</p>\n<hr>\n<h3 id=\"坐标转换\"><a href=\"#坐标转换\" class=\"headerlink\" title=\"坐标转换\"></a>坐标转换</h3><p>这里用到了第一个工具方法（老司机习惯把写好的方法分类，这些中间方法老司机习惯叫他们工具方法），-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin。</p>\n<p>简单的说一句，因为屏幕坐标与系统坐标的不同，我们要将坐标系<code>统一成系统坐标</code>，这样才能计算，所以才有了这个坐标转换的方法。其实很简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">///坐标转换</div><div class=\"line\">/*</div><div class=\"line\"> 将屏幕坐标转换为系统坐标</div><div class=\"line\"> */</div><div class=\"line\">-(CGPoint)systemPointFromScreenPoint:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGPointMake(origin.x, self.bounds.size.height - origin.y);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上一讲有坐标系的图，这里我就不细讲了。直接进入下一话题。</p>\n<hr>\n<h3 id=\"点击图片判断\"><a href=\"#点击图片判断\" class=\"headerlink\" title=\"点击图片判断\"></a>点击图片判断</h3><p>第二个工具方法</p>\n<p>-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">///图片点击检查</div><div class=\"line\">/*</div><div class=\"line\"> 遍历图片frame的数组与点击位置比较，如果在</div><div class=\"line\"> 范围内则响应的数组中取出对应响应并执行，返</div><div class=\"line\"> 回yes，否则返回no</div><div class=\"line\"> */</div><div class=\"line\">-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location</div><div class=\"line\">&#123;</div><div class=\"line\">    if ([self isFrame:_imgFrm containsPoint:location]) &#123;</div><div class=\"line\">    \tNSLog(@&quot;您点击到了图片&quot;);</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里呢，我们用到了第三个工具方法，顺便就说了吧</p>\n<p>-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">///点包含检测</div><div class=\"line\">-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGRectContainsPoint(frame, point);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上也是调用了系统的一个方法<code>CGRectContainsPoint()</code>。这个方法两个参数，一个是frame，一个是point。可以返回point是否在frame中。</p>\n<p>不过还是有一点需要注意的。由于<code>传入的point是系统坐标</code>（本例中），所以frame我们一定要<code>传入系统坐标系下的frame</code>才能正确对应。</p>\n<p>这里老司机偷了个懒，直接把上一讲中求得的图片frame改成了一个实例变量，这样在这里的方法中我就能直接调用了。这只是个demo，所以我就怎么方便怎么来了，实际使用中，你可以<code>把frame保存在数组或字典中</code>。你问我怎么在数组或字典中保存一个frame这样的结构体？恩，有一个系统类叫<code>NSValue</code>，专门针对这种结构体。</p>\n<p>如果-(BOOL)isFrame:(CGRect)frame containsPoint:(CGPoint)point返回YES则说明在图片范围内，则<code>响应图片的点击事件</code>，</p>\n<p><code>并且-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location返回YES</code>，否则返回NO。</p>\n<p>回到上一层，如果-(BOOL)checkIsClickOnImgWithPoint:(CGPoint)location返回YES，则说明<code>点击的是图片并且已经执行完响应事件</code>，<code>直接return结束方法即可</code>。否则则继续检查是否点击到了文字。</p>\n<hr>\n<h3 id=\"点击文字判断\"><a href=\"#点击文字判断\" class=\"headerlink\" title=\"点击文字判断\"></a>点击文字判断</h3><p>终于进入重中之重了，点击文字的逻辑了，不过你也别害怕，如果你对上一讲的讲解有了一定的理解的话，这里将变得简单一些。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-c25b68eae4815985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"逻辑图\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">///字符串点击检查</div><div class=\"line\">/*</div><div class=\"line\"> 实际上接受所有非图片的点击事件，将字符串的每个</div><div class=\"line\"> 字符取出与点击位置比较，若在范围内则点击到文字</div><div class=\"line\"> ，进而检测对应的文字是否响应事件，若存在响应</div><div class=\"line\"> */</div><div class=\"line\">-(void)ClickOnStrWithPoint:(CGPoint)location</div><div class=\"line\">&#123;</div><div class=\"line\">    NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);//获取所有CTLine</div><div class=\"line\">    CFRange ranges[lines.count];//初始化范围数组</div><div class=\"line\">    CGPoint origins[lines.count];//初始化原点数组</div><div class=\"line\">    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);//获取所有CTLine的原点</div><div class=\"line\">    for (int i = 0; i &lt; lines.count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[i];</div><div class=\"line\">        CFRange range = CTLineGetStringRange(line);</div><div class=\"line\">        ranges[i] = range;</div><div class=\"line\">    &#125;//获取所有CTLine的Range</div><div class=\"line\">    for (int i = 0; i &lt; _length; i ++) &#123;//逐字检查</div><div class=\"line\">        long maxLoc;</div><div class=\"line\">        int lineNum;</div><div class=\"line\">        for (int j = 0; j &lt; lines.count; j ++) &#123;//获取对应字符所在CTLine的index</div><div class=\"line\">            CFRange range = ranges[j];</div><div class=\"line\">            maxLoc = range.location + range.length - 1;</div><div class=\"line\">            if (i &lt;= maxLoc) &#123;</div><div class=\"line\">                lineNum = j;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[lineNum];//取到字符对应的CTLine</div><div class=\"line\">        CGPoint origin = origins[lineNum];</div><div class=\"line\">        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];//计算对应字符的frame</div><div class=\"line\">        if ([self isFrame:CTRunFrame containsPoint:location]) &#123;//如果点击位置在字符范围内，响应时间，跳出循环</div><div class=\"line\">            NSLog(@&quot;您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。&quot;,i,lineNum + 1);//点击到文字，然而没有响应的处理。可以做其他处理</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;您没有点击到文字&quot;);//没有点击到文字，可以做其他处理</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>看上去很多是吧？有没有怕怕的。</p>\n<p>仔细看你会发现，有很多代码跟昨天的有相似之处，就是这样，因为这里也<code>遍历</code>了每一个CTRun，只不过更加细化到<code>CTRun中的每个字</code>。</p>\n<h4 id=\"获取CTLine\"><a href=\"#获取CTLine\" class=\"headerlink\" title=\"获取CTLine\"></a>获取CTLine</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray * lines = (NSArray *)CTFrameGetLines(self.data.ctFrame);//获取所有CTLine</div><div class=\"line\">    CFRange ranges[lines.count];//初始化范围数组</div><div class=\"line\">    CGPoint origins[lines.count];//初始化原点数组</div><div class=\"line\">    CTFrameGetLineOrigins(_frame, CFRangeMake(0, 0), origins);//获取所有CTLine的原点</div></pre></td></tr></table></figure>\n<p>这四句我就不多说了，获取所有CTLine和其原点。</p>\n<h4 id=\"获取CTLine所表示范围\"><a href=\"#获取CTLine所表示范围\" class=\"headerlink\" title=\"获取CTLine所表示范围\"></a>获取CTLine所表示范围</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; lines.count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)lines[i];</div><div class=\"line\">        CFRange range = CTLineGetStringRange(line);</div><div class=\"line\">        ranges[i] = range;</div><div class=\"line\">    &#125;//获取所有CTLine的Range</div></pre></td></tr></table></figure>\n<p>获取每个CTLine中包含的富文本<code>在整串富文本中的范围</code>。将所有CTLine中字符串的范围保存下来放入数组备用。</p>\n<h4 id=\"获取CTRun\"><a href=\"#获取CTRun\" class=\"headerlink\" title=\"获取CTRun\"></a>获取CTRun</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; _length; i ++)</div></pre></td></tr></table></figure>\n<p>这个for循环用来遍历富文本中的<code>每一个字符</code>。下面的代码都是在for循环中的循环体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j = 0; j &lt; lines.count; j ++) &#123;//获取对应字符所在CTLine的index</div><div class=\"line\">            CFRange range = ranges[j];</div><div class=\"line\">            maxLoc = range.location + range.length - 1;</div><div class=\"line\">            if (i &lt;= maxLoc) &#123;</div><div class=\"line\">                lineNum = j;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>这里又是一层循环，通过当前<code>字符序号i</code>与每个<code>CTLine包含字符的范围</code>比较来求得当前<code>计算的是哪个CTLine中的字符</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CTLineRef line = (__bridge CTLineRef)lines[lineNum];//取到字符对应的CTLine</div><div class=\"line\">        CGPoint origin = origins[lineNum];</div><div class=\"line\">        CGRect CTRunFrame = [self frameForCTRunWithIndex:i CTLine:line origin:origin];//计算对应字符的frame</div></pre></td></tr></table></figure>\n<h4 id=\"计算CTRun的frame\"><a href=\"#计算CTRun的frame\" class=\"headerlink\" title=\"计算CTRun的frame\"></a>计算CTRun的frame</h4><p>取得当前字符所在的CTLine并取得该CTLine的原点，同时通过这里的第五个工具方法</p>\n<p>-(CGRect)frameForCTRunWithIndex:(NSInteger)index<br>                         CTLine:(CTLineRef)line<br>                         origin:(CGPoint)origin</p>\n<p>计算当前字符的frame。<br>分解讲一下这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">///字符frame计算</div><div class=\"line\">/*</div><div class=\"line\"> 返回索引字符的frame</div><div class=\"line\"> </div><div class=\"line\"> index：索引</div><div class=\"line\"> line：索引字符所在CTLine</div><div class=\"line\"> origin：line的起点</div><div class=\"line\">*/</div><div class=\"line\">-(CGRect)frameForCTRunWithIndex:(NSInteger)index</div><div class=\"line\">                         CTLine:(CTLineRef)line</div><div class=\"line\">                         origin:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat offsetX = CTLineGetOffsetForStringIndex(line, index, NULL);//获取字符起点相对于CTLine的原点的偏移量</div><div class=\"line\">    CGFloat offsexX2 = CTLineGetOffsetForStringIndex(line, index + 1, NULL);//获取下一个字符的偏移量，两者之间即为字符X范围</div><div class=\"line\">    offsetX += origin.x;</div><div class=\"line\">    offsexX2 += origin.x;//坐标转换，将点的CTLine坐标转换至系统坐标</div><div class=\"line\">    CGFloat offsetY = origin.y;//取到CTLine的起点Y</div><div class=\"line\">    CGFloat lineAscent;//初始化上下边距的变量</div><div class=\"line\">    CGFloat lineDescent;</div><div class=\"line\">    NSArray * runs = (__bridge NSArray *)CTLineGetGlyphRuns(line);//获取所有CTRun</div><div class=\"line\">    CTRunRef runCurrent;</div><div class=\"line\">    for (int k = 0; k &lt; runs.count; k ++) &#123;//获取当前点击的CTRun</div><div class=\"line\">        CTRunRef run = (__bridge CTRunRef)runs[k];</div><div class=\"line\">        CFRange range = CTRunGetStringRange(run);</div><div class=\"line\">        NSRange rangeOC = NSMakeRange(range.location, range.length);</div><div class=\"line\">        if ([self isIndex:index inRange:rangeOC]) &#123;</div><div class=\"line\">            runCurrent = run;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CTRunGetTypographicBounds(runCurrent, CFRangeMake(0, 0), &amp;lineAscent, &amp;lineDescent, NULL);//计算当前点击的CTRun高度</div><div class=\"line\">    offsetY -= lineDescent;</div><div class=\"line\">    CGFloat height = lineAscent + lineDescent;</div><div class=\"line\">    return CGRectMake(offsetX, offsetY, offsexX2 - offsetX, height);//返回一个字符的Frame</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据注释就能很轻易的看懂这段代码，不过可能有几个方法不熟悉，我来介绍下。</p>\n<ul>\n<li>CTLineGetOffsetForStringIndex(,,)</li>\n</ul>\n<p>获取一行文字中，<code>指定charIndex字符相对x原点的偏移量</code>，返回值与第三个参数同为一个值。<code>如果charIndex超出一行的字符长度则反回最大长度结束位置的偏移量</code>，如一行文字共有17个字符，哪么返回的是第18个字符的起始偏移，即第17个偏移+第17个字符占有的宽度=第18个起始位置的偏移。因此想求一行字符所占的像素长度时，就可以使用此函数，将charIndex设置为大于字符长度即可。</p>\n<p>因为求得的坐标是相对于CTLine原点的偏移量，因此我们要加上CTLine原点的x坐标<code>获得该点的绝对坐标</code>。</p>\n<ul>\n<li><p>CTLineGetGlyphRuns()昨天有介绍过，拿到CTLine中的所有CTRun。</p>\n</li>\n<li><p>CTRunGetStringRange()获得CTRun在富文本中的范围</p>\n</li>\n<li>CTRunGetTypographicBounds(,,,,)获得对应CTRun的尺寸信息</li>\n</ul>\n<h4 id=\"判断点击的文字\"><a href=\"#判断点击的文字\" class=\"headerlink\" title=\"判断点击的文字\"></a>判断点击的文字</h4><p>中间用了第六个工具方法</p>\n<p>-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">///范围检测</div><div class=\"line\">/*</div><div class=\"line\"> 范围内返回yes，否则返回no</div><div class=\"line\"> */</div><div class=\"line\">-(BOOL)isIndex:(NSInteger)index inRange:(NSRange)range</div><div class=\"line\">&#123;</div><div class=\"line\">    if ((index &lt;= range.location + range.length - 1) &amp;&amp; (index &gt;= range.location)) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个代码很简单我就不多说了。</p>\n<p>通过以上方法，你就拿到了<code>每一个字符的frame</code>了。</p>\n<p>可以返回至上一层了=。=喘了一口气。。。</p>\n<p>接受到字符的frame，还是<code>判断点击位置是否在frame中</code>，如果在，则响应点击事件并结束方法。如果没有不在任何一个字符的frame内，则说明没有点击到文字，执行相应的点击事件。</p>\n<p>大工告成，到了这里，CoreText做图文混排的点击事件也算是完成了。</p>\n<p>最后放一张效果图吧。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6557831b9e067768.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"大萌神镇楼\"></p>\n<hr>\n<p>呐，了却一桩心事。。。</p>\n<p>你要是喜欢呢，麻烦你动一动你可爱的小手点击一下喜欢或者关注，毕竟老司机这么爱慕虚荣的人，而且老司机会经常更新的。</p>\n<p>哦，这段代码是我自己的解决方案，所以要转载的同学，一定要注明出处哦，这次是一定哦。貌似你不注明我也拦不住你。。。啧啧啧。。。<br><a href=\"http://www.jianshu.com/p/51c47329203e\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/51c47329203e</a></p>\n<p>参考资料：</p>\n<p>无</p>\n<p>2016年05月16日23点52分</p>\n<p>老司机Wicky</p>"},{"title":"CoreText实现图文混排之文字环绕及点击算法","layout":"post","date":"2016-12-24T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![CoreText实现图文混排之文字环绕及点击算法](http://upload-images.jianshu.io/upload_images/1835430-80b2fc8677bcd42f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n- [CoreText实现图文混排](http://www.jianshu.com/p/6db3289fb05d)\n- [CoreText实现图文混排之点击事件](http://www.jianshu.com/p/51c47329203e)\n- [CoreText实现图文混排之文字环绕及点击算法](http://www.jianshu.com/p/e154047b0f98)\n\n- - -\n\n在这篇文章中你可以看到以下内容：\n\n- 图片环绕的实现方式\n- 点击事件获取的优化算法\n\n<!-- more -->\n\n\n- - -\n终于我来完成我CoreText图文混排的最后一章了。\n\n先说一下我为什么会来补发这一章呢？\n> \n1.老司机最开始没有留demo，以至于这个博客老司机从发出来到现在整整维护了半年了=。=其实博客里面就是全部代码，但是宝宝们任性的要demo。\n>\n2.时间长了，阅读量也上去了，老司机觉得自己有必要对粉丝们负责了\n>\n3.有很多同学询问是否能做出文字环绕的效果，老司机之前的确也没有写过，这一篇是要补上的。\n>\n4.关于点击事件，老司机在第二篇文章中有提到过一个思路，是每次遍历所有CTRun去做的。后期老司机考虑到遍历的实现效率似乎有些低，所以老司机研究了一下，重新整理思路，优化了一下算法。\n\n基于以上原因，以及一个`阴谋`，老司机又来更文了。\n\n![劳资回来了](http://upload-images.jianshu.io/upload_images/1835430-6e1368fd36b6e027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n\n看了本篇博客，老司机能够帮你实现如下效果\n\n\n![CoreText](http://upload-images.jianshu.io/upload_images/1835430-e44f7e218a059e4b.gif?imageMogr2/auto-orient/strip)\n\n\n这篇博客是以前两篇博客作为知识铺垫的，如果没有看过前两篇博客的童靴建议你去[补票](http://www.jianshu.com/p/6db3289fb05d)。当然本身你就了解CoreText相关知识的话也可以直接看本篇文章。\n\n\n\n- - -\n### 全部代码\n优化算法以后，代码有些许改变，不过主体思路是一致的。下面是全部代码。\n\n```\n@interface CoreTextV ()\n{\n    CTFrameRef _frame;\n    NSInteger _length;\n    CGRect _imgFrm;\n    NSMutableArray * arrText;\n}\n@end\n@implementation CoreTextV\n\n-(void)drawRect:(CGRect)rect\n{\n    [super drawRect:rect];\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);\n    CGContextScaleCTM(context, 1.0, -1.0);\n    arrText = [NSMutableArray array];\n    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\"];\n    [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor whiteColor] range:NSMakeRange(0, attributeStr.length)];\n    CTRunDelegateCallbacks callBacks;\n    memset(&callBacks, 0, sizeof(CTRunDelegateCallbacks));\n    callBacks.version = kCTRunDelegateVersion1;    \t callBacks.getAscent = ascentCallBacks;    \tcallBacks.getDescent = descentCallBacks;    \tcallBacks.getWidth = widthCallBacks;\n    NSDictionary * dicPic = @{@\"height\":@90,@\"width\":@160};\n    CTRunDelegateRef delegate = CTRunDelegateCreate(& callBacks, (__bridge void *)dicPic);\n    unichar placeHolder = 0xFFFC;\n    NSString * placeHolderStr = [NSString stringWithCharacters:&placeHolder length:1];\n    NSMutableAttributedString * placeHolderAttrStr = \t[[NSMutableAttributedString alloc] initWithString:placeHolderStr];\n    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);    CFRelease(delegate);\n    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:300];\n    NSDictionary * activeAttr = @{NSForegroundColorAttributeName:[UIColor redColor],@\"click\":NSStringFromSelector(@selector(click))};\n    [attributeStr addAttributes:activeAttr range:NSMakeRange(100, 30)];\n    \n    [attributeStr addAttributes:activeAttr range:NSMakeRange(400, 100)];\n\n    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);\n    UIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];\n    UIBezierPath * cirP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 200)];\n    [path appendPath:cirP];\n    _length = attributeStr.length;\n    _frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, _length), path.CGPath, NULL);\n    CTFrameDraw(_frame, context);\n    \n    UIImage * image = [UIImage imageNamed:@\"1.jpg\"];\n    [self handleActiveRectWithFrame:_frame];\n    CGContextDrawImage(context,_imgFrm, image.CGImage);\n    \n    CGContextDrawImage(context, cirP.bounds, [[UIImage imageNamed:@\"1.jpg\"] dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)].CGImage);\n    CFRelease(_frame);\n    CFRelease(frameSetter);\n}\n\nstatic CGFloat ascentCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"height\"] floatValue];\n}\nstatic CGFloat descentCallBacks(void * ref)\n{\n    return 0;\n}\nstatic CGFloat widthCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"width\"] floatValue];\n}\n\n\n-(void)handleActiveRectWithFrame:(CTFrameRef)frame\n{\n    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);\n    NSInteger count = [arrLines count];\n    CGPoint points[count];\n    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);\n    for (int i = 0; i < count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)arrLines[i];\n        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);\n        for (int j = 0; j < arrGlyphRun.count; j ++) {\n            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];\n            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);\n            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];\n            CGPoint point = points[i];\n            if (delegate == nil) {\n                NSString * string = attributes[@\"click\"];\n                if (string) {\n                    [arrText addObject:[NSValue valueWithCGRect:[self getLocWithFrame:frame CTLine:line CTRun:run origin:point]]];\n                }\n                continue;\n            }\n            NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate);\n            if (![metaDic isKindOfClass:[NSDictionary class]]) {\n                continue;\n            }\n            _imgFrm = [self getLocWithFrame:frame CTLine:line CTRun:run origin:point];\n        }\n    }\n}\n\n-(CGRect)getLocWithFrame:(CTFrameRef)frame CTLine:(CTLineRef)line CTRun:(CTRunRef)run origin:(CGPoint)origin\n{\n    CGFloat ascent;\n    CGFloat descent;\n    CGRect boundsRun;\n    boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, &descent, NULL);\n    boundsRun.size.height = ascent + descent;\n    CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);\n    boundsRun.origin.x = origin.x + xOffset; \n    boundsRun.origin.y = origin.y - descent;\n    CGPathRef path = CTFrameGetPath(frame);\n    CGRect colRect = CGPathGetBoundingBox(path); \n    CGRect deleteBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);\n    return deleteBounds;\n}\n\n-(CGRect)convertRectFromLoc:(CGRect)rect\n{\n    return CGRectMake(rect.origin.x, self.bounds.size.height - rect.origin.y - rect.size.height, rect.size.width, rect.size.height);\n}\n\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    UITouch * touch = [touches anyObject];\n    CGPoint location = [touch locationInView:self];\n    CGRect imageFrmToScreen = [self convertRectFromLoc:_imgFrm];\n    if (CGRectContainsPoint(imageFrmToScreen, location)) {\n        [[[UIAlertView alloc] initWithTitle:nil message:@\"你点击了图片\" delegate:nil cancelButtonTitle:@\"好的\" otherButtonTitles:nil] show];\n        return;\n    }\n    [arrText enumerateObjectsUsingBlock:^(NSValue * rectV, NSUInteger idx, BOOL * _Nonnull stop) {\n        CGRect textFrmToScreen = [self convertRectFromLoc:[rectV CGRectValue]];\n        if (CGRectContainsPoint(textFrmToScreen, location)) {\n            [self click];\n            *stop = YES;\n        }\n    }];\n}\n\n-(void)click\n{\n    [[[UIAlertView alloc] initWithTitle:nil message:@\"你点击了文字\" delegate:nil cancelButtonTitle:@\"好的\" otherButtonTitles:nil] show];\n}\n@end\n\n```\n\n只关心结果或者着急写项目的童靴看到这里就足够了，因为所有代码都在，想找demo的话就去文章末尾找吧。因为接下来老司机要`开始扯淡了`。。。跟你们讲讲一切的`实现思路`。\n- - -\n###图片环绕的实现方式\n\n由于我只是给个demo，所以一切代码均从简写。`实际过程中，代码应进行封装分块。`\n\n我们将视线集中到`drawRect`方法中吧。\n\n之前的文章老司机讲过，我们在drawRect中绘制文本的时候主要是`根据Path去绘制`的。\n\n```\nUIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];\nUIBezierPath * cirP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 200)];\n[path appendPath:cirP];\n_length = attributeStr.length;\n_frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, _length), path.CGPath, NULL);\nCTFrameDraw(_frame, context);\n```\n\n我们可以看到，我们是以path和frameSetter去生成我们绘制文本的frame的。所以说，只要在这个地方我们`传入的path中将特殊区域排除`我们获得的`frame就不包含该区域`，从而`绘制的文本也不会在该区域中绘制`。\n\n所以说上述的代码你看到的应该是这样子的文字区域\n\n\n![排除文字区域](http://upload-images.jianshu.io/upload_images/1835430-b9e2009892b5bff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这里你可能会有个疑问，问什么我cirP的rect是CGRectMake(100, 100, 100, 200)，这个排除的区域却在那里。这里你还记得老司机在第一篇文章里就说过`屏幕坐标系统跟系统坐标系统的区别`呢，原因就在这。\n\n也就是说，到了这里，我们只要绘制出这个椭圆形的图片就可以了。这你可能需要借助老司机之前写好的工具类，在这个仓库里的[DWImageUtils](https://github.com/CodeWicky/-Tools)就是了。如果好用记得给我个**`star`**吧。\n\n有了这个工具类，你就可以这样生成`椭圆图片`了\n> [image dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)]\n> \n\n有了图片了，情况基本就变成了我们熟悉的状况了，绘制图片\n\n>  CGContextDrawImage(context, cirP.bounds, [[UIImage imageNamed:@\"1.jpg\"] dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)].CGImage);\n> \n\n至此，我们就绘制出环绕的文本了。也算真正的实现所谓的图文混排了。\n\n- - - \n### 点击事件获取的优化算法\n\n首先老司机来讲一下目前老司机了解到的几种获取点击事件的方式。\n\n#### CTLineGetStringIndexForPosition\n\n主流方式就是当前大部分基于CoreText封装的富文本展示类（包括`TTTAttributedLabel`、`NIAttributedLabel`和`FTCoreTextView`）中使用的方法 `CTLineGetStringIndexForPosition`。这个方法是`获取当前点在所在文字处于当前绘制文本的索引值`。事实上如果没有一些其他因素的话，能使用这个方法是最简便快捷的。然而老司机为什么没有使用这个方法去获取点击事件呢？请看下面的动图👇\n\n\n![CTLineGetStringIndexForPosition](http://upload-images.jianshu.io/upload_images/1835430-d6a8b77cf8ee04fd.gif?imageMogr2/auto-orient/strip)\n\n\n这里老司机是以TTTAttributedLabel为样本做了一个点击事件的Demo。\n\n先明确一点，有下划线的区域应该为实际点击响应区域。可以看到，`实际的响应区域相比预期响应区域x坐标会整体向左偏移一定区域`。\n\n实际使用中CTLineGetStringIndexForPosition这个方法获取一个字的index范围是`这个字前面大概半个字开始到这个字中间的位置`。从这个字的中间到这个字的后半个字就会获得下一个字的index。举个例子：（勾选的勾字index应该为0，当点击勾字左半部分的时候返回0，右半部分返回1）。\n\n老司机查阅了很多资料，有的资料说这个方法在当有段前缩进或者首行缩进的时候，并不准确，不会跟着缩进而进行偏移。然而老司机在将段前缩进设为0仍然有这个问题。老司机也不知道具体问题在哪，然而老司机有强迫症的不能允许这`半个字的误差`，所以老司机当时决定不用这个方法，自己另辟蹊径。就有了老司机当时的遍历每个CTRun的算法。\n\n多说一句，CTLineGetStringIndexForPosition这个方法还有另一个作用还是很好用的。`这个方法最好的用处就是判断一行CTLine最多容纳多少的字符，只需把这个point的x位置调很大（超过CTFrame path的宽度）就可以了`。\n\n#### 遍历CTRun比较法\n\n老司机当时觉得半个字的误差实在是难以容忍，所以老司机舍近求远想出了这套`遍历CTRun`的算法。因为执行效率上一个屏幕内能展示的文字所包含的CTRun的数量在遍历过程中并不会造成过多的性能浪费，所以老司机当时也没有在意。\n\n直到后来老司机的项目中由于要尽量少的使用三方SDK，所以自告奋勇的把自己写的coreText的可点击label引入到工程里面。然而项目经理看了源码后表示虽然他没用过CoreText，但是遍历真的很蛋疼，决定引入一个TTT。老司机的心情瞬间跌入谷底。`老司机当即决定，我要优化算法`。\n\n#### 计算并缓存法\n\n之所以说优化算法，没有说不用遍历是因为CoreText就那么些东西，获取图片的_frame还是需要遍历整个CTFrame中的所有CTRun的。所以老司机花了整整一个礼拜也`没找到替代遍历的方法`。\n\n终于有一天，感受到了月亮的召唤，老司机`变！身！了！`\n\n\n![变身了](http://upload-images.jianshu.io/upload_images/1835430-23cd1c8301471fbe.gif?imageMogr2/auto-orient/strip)\n\n\n顺便想到了一个思路，`避免不了遍历我就只遍历一次就好了`。一次遍历中拿到所有活动图片和活动文字的frame，然后事情就简单多了，按照点击图片的处理方式处理文字就好了。\n\n所以老司机就想了一个办法期望在遍历的时候可以拿到活动文字的特征点，从而获取活动范围。老司机顺理成章的就`给想要添加点击事件的活动文本加了click这么一个属性`。（demo中老司机就随便写了，实际要慎重考虑叫什么名字不会被觉得太Low😂）\n\n其实实现上的思路很简单，只是之前没想到，`感谢月亮的召唤吧`还是。\n\n\n![关我毛事](http://upload-images.jianshu.io/upload_images/1835430-fc2c885752867d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n```\nNSDictionary * activeAttr = @{NSForegroundColorAttributeName:[UIColor redColor],@\"click\":NSStringFromSelector(@selector(click))};\n[attributeStr addAttributes:activeAttr range:NSMakeRange(100, 30)];\n[attributeStr addAttributes:activeAttr range:NSMakeRange(400, 100)];\n```\n这里老司机很随意的添加了一个click属性。\n\n```\n[arrText addObject:[NSValue valueWithCGRect:[self getLocWithFrame:frame CTLine:line CTRun:run origin:point]]];\n```\n然后这里老司机就把活动文本的frame计算出来了。\n\n思路就是这么简单。本着一年内保证售后服务的原则，老司机会给在前两篇博客中要demo的童鞋再发一份最新的demo通知新算法。\n\n另外老司机这里要提醒你一点的就是，`文字frame不同于获取图片的frame`。由于`图片`是在一个空白占位符上绘制文字，`所以一定是以一个CTRun进行绘制的`。但是第一篇文章中老司机说过，`每个CTRun是所有具有相同属性的连续同行文字的集合`。针对CTRun的特性，我们不难想到，文字由于可能出现两行，也有可能会活动文本的字体字号等其他属性不尽相同导致`一段文字由两个CTRun进行绘制`，所以不能单纯的保存一个frame，而是`要以一个数组容纳他`。再通过一些逻辑将不同的活动文本区别开来。由于是demo所以一切从简老司机没有说怎么区分活动文本，给个思路，就是你给click属性`绑定的value就可以用作区分`（这句好拗口）。至此，全部的文字点击及图片点击事件的大体思路讲述完毕。\n\n- - -\n为了吸取教训，这次老司机会留下demo。恩，也要去前两篇通知他们第三篇有demo。\n### [去这里下载demo](https://pan.baidu.com/s/1skQN7Md)\n\n然后，\n\n广告时间了：\n\n痛定思痛的老司机写了一个真正支持图文混排点击事件的Label控件。你可以实现如下的效果。\n\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n\n\n![爱你哟](http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- - - \n文章到最后都是一样的，喜欢点赞吧~关注吧~乖~话说老司机超爱兔子的~\n\n![乖](http://upload-images.jianshu.io/upload_images/1835430-1fd05923725b25f6.gif?imageMogr2/auto-orient/strip)\n","source":"_posts/CoreText实现图文混排之文字环绕及点击算法.md","raw":"\n---\ntitle: CoreText实现图文混排之文字环绕及点击算法\nlayout: post\ndate: 2016-12-25 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CoreText \n- 图文混排\n- 点击事件\n- 图片环绕 \ncategories: 图文混排\n\n---\n\n![CoreText实现图文混排之文字环绕及点击算法](http://upload-images.jianshu.io/upload_images/1835430-80b2fc8677bcd42f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n- [CoreText实现图文混排](http://www.jianshu.com/p/6db3289fb05d)\n- [CoreText实现图文混排之点击事件](http://www.jianshu.com/p/51c47329203e)\n- [CoreText实现图文混排之文字环绕及点击算法](http://www.jianshu.com/p/e154047b0f98)\n\n- - -\n\n在这篇文章中你可以看到以下内容：\n\n- 图片环绕的实现方式\n- 点击事件获取的优化算法\n\n<!-- more -->\n\n\n- - -\n终于我来完成我CoreText图文混排的最后一章了。\n\n先说一下我为什么会来补发这一章呢？\n> \n1.老司机最开始没有留demo，以至于这个博客老司机从发出来到现在整整维护了半年了=。=其实博客里面就是全部代码，但是宝宝们任性的要demo。\n>\n2.时间长了，阅读量也上去了，老司机觉得自己有必要对粉丝们负责了\n>\n3.有很多同学询问是否能做出文字环绕的效果，老司机之前的确也没有写过，这一篇是要补上的。\n>\n4.关于点击事件，老司机在第二篇文章中有提到过一个思路，是每次遍历所有CTRun去做的。后期老司机考虑到遍历的实现效率似乎有些低，所以老司机研究了一下，重新整理思路，优化了一下算法。\n\n基于以上原因，以及一个`阴谋`，老司机又来更文了。\n\n![劳资回来了](http://upload-images.jianshu.io/upload_images/1835430-6e1368fd36b6e027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n\n看了本篇博客，老司机能够帮你实现如下效果\n\n\n![CoreText](http://upload-images.jianshu.io/upload_images/1835430-e44f7e218a059e4b.gif?imageMogr2/auto-orient/strip)\n\n\n这篇博客是以前两篇博客作为知识铺垫的，如果没有看过前两篇博客的童靴建议你去[补票](http://www.jianshu.com/p/6db3289fb05d)。当然本身你就了解CoreText相关知识的话也可以直接看本篇文章。\n\n\n\n- - -\n### 全部代码\n优化算法以后，代码有些许改变，不过主体思路是一致的。下面是全部代码。\n\n```\n@interface CoreTextV ()\n{\n    CTFrameRef _frame;\n    NSInteger _length;\n    CGRect _imgFrm;\n    NSMutableArray * arrText;\n}\n@end\n@implementation CoreTextV\n\n-(void)drawRect:(CGRect)rect\n{\n    [super drawRect:rect];\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);\n    CGContextScaleCTM(context, 1.0, -1.0);\n    arrText = [NSMutableArray array];\n    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\"];\n    [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor whiteColor] range:NSMakeRange(0, attributeStr.length)];\n    CTRunDelegateCallbacks callBacks;\n    memset(&callBacks, 0, sizeof(CTRunDelegateCallbacks));\n    callBacks.version = kCTRunDelegateVersion1;    \t callBacks.getAscent = ascentCallBacks;    \tcallBacks.getDescent = descentCallBacks;    \tcallBacks.getWidth = widthCallBacks;\n    NSDictionary * dicPic = @{@\"height\":@90,@\"width\":@160};\n    CTRunDelegateRef delegate = CTRunDelegateCreate(& callBacks, (__bridge void *)dicPic);\n    unichar placeHolder = 0xFFFC;\n    NSString * placeHolderStr = [NSString stringWithCharacters:&placeHolder length:1];\n    NSMutableAttributedString * placeHolderAttrStr = \t[[NSMutableAttributedString alloc] initWithString:placeHolderStr];\n    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);    CFRelease(delegate);\n    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:300];\n    NSDictionary * activeAttr = @{NSForegroundColorAttributeName:[UIColor redColor],@\"click\":NSStringFromSelector(@selector(click))};\n    [attributeStr addAttributes:activeAttr range:NSMakeRange(100, 30)];\n    \n    [attributeStr addAttributes:activeAttr range:NSMakeRange(400, 100)];\n\n    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);\n    UIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];\n    UIBezierPath * cirP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 200)];\n    [path appendPath:cirP];\n    _length = attributeStr.length;\n    _frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, _length), path.CGPath, NULL);\n    CTFrameDraw(_frame, context);\n    \n    UIImage * image = [UIImage imageNamed:@\"1.jpg\"];\n    [self handleActiveRectWithFrame:_frame];\n    CGContextDrawImage(context,_imgFrm, image.CGImage);\n    \n    CGContextDrawImage(context, cirP.bounds, [[UIImage imageNamed:@\"1.jpg\"] dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)].CGImage);\n    CFRelease(_frame);\n    CFRelease(frameSetter);\n}\n\nstatic CGFloat ascentCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"height\"] floatValue];\n}\nstatic CGFloat descentCallBacks(void * ref)\n{\n    return 0;\n}\nstatic CGFloat widthCallBacks(void * ref)\n{\n    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@\"width\"] floatValue];\n}\n\n\n-(void)handleActiveRectWithFrame:(CTFrameRef)frame\n{\n    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);\n    NSInteger count = [arrLines count];\n    CGPoint points[count];\n    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);\n    for (int i = 0; i < count; i ++) {\n        CTLineRef line = (__bridge CTLineRef)arrLines[i];\n        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);\n        for (int j = 0; j < arrGlyphRun.count; j ++) {\n            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];\n            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);\n            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];\n            CGPoint point = points[i];\n            if (delegate == nil) {\n                NSString * string = attributes[@\"click\"];\n                if (string) {\n                    [arrText addObject:[NSValue valueWithCGRect:[self getLocWithFrame:frame CTLine:line CTRun:run origin:point]]];\n                }\n                continue;\n            }\n            NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate);\n            if (![metaDic isKindOfClass:[NSDictionary class]]) {\n                continue;\n            }\n            _imgFrm = [self getLocWithFrame:frame CTLine:line CTRun:run origin:point];\n        }\n    }\n}\n\n-(CGRect)getLocWithFrame:(CTFrameRef)frame CTLine:(CTLineRef)line CTRun:(CTRunRef)run origin:(CGPoint)origin\n{\n    CGFloat ascent;\n    CGFloat descent;\n    CGRect boundsRun;\n    boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, &descent, NULL);\n    boundsRun.size.height = ascent + descent;\n    CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);\n    boundsRun.origin.x = origin.x + xOffset; \n    boundsRun.origin.y = origin.y - descent;\n    CGPathRef path = CTFrameGetPath(frame);\n    CGRect colRect = CGPathGetBoundingBox(path); \n    CGRect deleteBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);\n    return deleteBounds;\n}\n\n-(CGRect)convertRectFromLoc:(CGRect)rect\n{\n    return CGRectMake(rect.origin.x, self.bounds.size.height - rect.origin.y - rect.size.height, rect.size.width, rect.size.height);\n}\n\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    UITouch * touch = [touches anyObject];\n    CGPoint location = [touch locationInView:self];\n    CGRect imageFrmToScreen = [self convertRectFromLoc:_imgFrm];\n    if (CGRectContainsPoint(imageFrmToScreen, location)) {\n        [[[UIAlertView alloc] initWithTitle:nil message:@\"你点击了图片\" delegate:nil cancelButtonTitle:@\"好的\" otherButtonTitles:nil] show];\n        return;\n    }\n    [arrText enumerateObjectsUsingBlock:^(NSValue * rectV, NSUInteger idx, BOOL * _Nonnull stop) {\n        CGRect textFrmToScreen = [self convertRectFromLoc:[rectV CGRectValue]];\n        if (CGRectContainsPoint(textFrmToScreen, location)) {\n            [self click];\n            *stop = YES;\n        }\n    }];\n}\n\n-(void)click\n{\n    [[[UIAlertView alloc] initWithTitle:nil message:@\"你点击了文字\" delegate:nil cancelButtonTitle:@\"好的\" otherButtonTitles:nil] show];\n}\n@end\n\n```\n\n只关心结果或者着急写项目的童靴看到这里就足够了，因为所有代码都在，想找demo的话就去文章末尾找吧。因为接下来老司机要`开始扯淡了`。。。跟你们讲讲一切的`实现思路`。\n- - -\n###图片环绕的实现方式\n\n由于我只是给个demo，所以一切代码均从简写。`实际过程中，代码应进行封装分块。`\n\n我们将视线集中到`drawRect`方法中吧。\n\n之前的文章老司机讲过，我们在drawRect中绘制文本的时候主要是`根据Path去绘制`的。\n\n```\nUIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];\nUIBezierPath * cirP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 200)];\n[path appendPath:cirP];\n_length = attributeStr.length;\n_frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, _length), path.CGPath, NULL);\nCTFrameDraw(_frame, context);\n```\n\n我们可以看到，我们是以path和frameSetter去生成我们绘制文本的frame的。所以说，只要在这个地方我们`传入的path中将特殊区域排除`我们获得的`frame就不包含该区域`，从而`绘制的文本也不会在该区域中绘制`。\n\n所以说上述的代码你看到的应该是这样子的文字区域\n\n\n![排除文字区域](http://upload-images.jianshu.io/upload_images/1835430-b9e2009892b5bff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这里你可能会有个疑问，问什么我cirP的rect是CGRectMake(100, 100, 100, 200)，这个排除的区域却在那里。这里你还记得老司机在第一篇文章里就说过`屏幕坐标系统跟系统坐标系统的区别`呢，原因就在这。\n\n也就是说，到了这里，我们只要绘制出这个椭圆形的图片就可以了。这你可能需要借助老司机之前写好的工具类，在这个仓库里的[DWImageUtils](https://github.com/CodeWicky/-Tools)就是了。如果好用记得给我个**`star`**吧。\n\n有了这个工具类，你就可以这样生成`椭圆图片`了\n> [image dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)]\n> \n\n有了图片了，情况基本就变成了我们熟悉的状况了，绘制图片\n\n>  CGContextDrawImage(context, cirP.bounds, [[UIImage imageNamed:@\"1.jpg\"] dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)].CGImage);\n> \n\n至此，我们就绘制出环绕的文本了。也算真正的实现所谓的图文混排了。\n\n- - - \n### 点击事件获取的优化算法\n\n首先老司机来讲一下目前老司机了解到的几种获取点击事件的方式。\n\n#### CTLineGetStringIndexForPosition\n\n主流方式就是当前大部分基于CoreText封装的富文本展示类（包括`TTTAttributedLabel`、`NIAttributedLabel`和`FTCoreTextView`）中使用的方法 `CTLineGetStringIndexForPosition`。这个方法是`获取当前点在所在文字处于当前绘制文本的索引值`。事实上如果没有一些其他因素的话，能使用这个方法是最简便快捷的。然而老司机为什么没有使用这个方法去获取点击事件呢？请看下面的动图👇\n\n\n![CTLineGetStringIndexForPosition](http://upload-images.jianshu.io/upload_images/1835430-d6a8b77cf8ee04fd.gif?imageMogr2/auto-orient/strip)\n\n\n这里老司机是以TTTAttributedLabel为样本做了一个点击事件的Demo。\n\n先明确一点，有下划线的区域应该为实际点击响应区域。可以看到，`实际的响应区域相比预期响应区域x坐标会整体向左偏移一定区域`。\n\n实际使用中CTLineGetStringIndexForPosition这个方法获取一个字的index范围是`这个字前面大概半个字开始到这个字中间的位置`。从这个字的中间到这个字的后半个字就会获得下一个字的index。举个例子：（勾选的勾字index应该为0，当点击勾字左半部分的时候返回0，右半部分返回1）。\n\n老司机查阅了很多资料，有的资料说这个方法在当有段前缩进或者首行缩进的时候，并不准确，不会跟着缩进而进行偏移。然而老司机在将段前缩进设为0仍然有这个问题。老司机也不知道具体问题在哪，然而老司机有强迫症的不能允许这`半个字的误差`，所以老司机当时决定不用这个方法，自己另辟蹊径。就有了老司机当时的遍历每个CTRun的算法。\n\n多说一句，CTLineGetStringIndexForPosition这个方法还有另一个作用还是很好用的。`这个方法最好的用处就是判断一行CTLine最多容纳多少的字符，只需把这个point的x位置调很大（超过CTFrame path的宽度）就可以了`。\n\n#### 遍历CTRun比较法\n\n老司机当时觉得半个字的误差实在是难以容忍，所以老司机舍近求远想出了这套`遍历CTRun`的算法。因为执行效率上一个屏幕内能展示的文字所包含的CTRun的数量在遍历过程中并不会造成过多的性能浪费，所以老司机当时也没有在意。\n\n直到后来老司机的项目中由于要尽量少的使用三方SDK，所以自告奋勇的把自己写的coreText的可点击label引入到工程里面。然而项目经理看了源码后表示虽然他没用过CoreText，但是遍历真的很蛋疼，决定引入一个TTT。老司机的心情瞬间跌入谷底。`老司机当即决定，我要优化算法`。\n\n#### 计算并缓存法\n\n之所以说优化算法，没有说不用遍历是因为CoreText就那么些东西，获取图片的_frame还是需要遍历整个CTFrame中的所有CTRun的。所以老司机花了整整一个礼拜也`没找到替代遍历的方法`。\n\n终于有一天，感受到了月亮的召唤，老司机`变！身！了！`\n\n\n![变身了](http://upload-images.jianshu.io/upload_images/1835430-23cd1c8301471fbe.gif?imageMogr2/auto-orient/strip)\n\n\n顺便想到了一个思路，`避免不了遍历我就只遍历一次就好了`。一次遍历中拿到所有活动图片和活动文字的frame，然后事情就简单多了，按照点击图片的处理方式处理文字就好了。\n\n所以老司机就想了一个办法期望在遍历的时候可以拿到活动文字的特征点，从而获取活动范围。老司机顺理成章的就`给想要添加点击事件的活动文本加了click这么一个属性`。（demo中老司机就随便写了，实际要慎重考虑叫什么名字不会被觉得太Low😂）\n\n其实实现上的思路很简单，只是之前没想到，`感谢月亮的召唤吧`还是。\n\n\n![关我毛事](http://upload-images.jianshu.io/upload_images/1835430-fc2c885752867d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n```\nNSDictionary * activeAttr = @{NSForegroundColorAttributeName:[UIColor redColor],@\"click\":NSStringFromSelector(@selector(click))};\n[attributeStr addAttributes:activeAttr range:NSMakeRange(100, 30)];\n[attributeStr addAttributes:activeAttr range:NSMakeRange(400, 100)];\n```\n这里老司机很随意的添加了一个click属性。\n\n```\n[arrText addObject:[NSValue valueWithCGRect:[self getLocWithFrame:frame CTLine:line CTRun:run origin:point]]];\n```\n然后这里老司机就把活动文本的frame计算出来了。\n\n思路就是这么简单。本着一年内保证售后服务的原则，老司机会给在前两篇博客中要demo的童鞋再发一份最新的demo通知新算法。\n\n另外老司机这里要提醒你一点的就是，`文字frame不同于获取图片的frame`。由于`图片`是在一个空白占位符上绘制文字，`所以一定是以一个CTRun进行绘制的`。但是第一篇文章中老司机说过，`每个CTRun是所有具有相同属性的连续同行文字的集合`。针对CTRun的特性，我们不难想到，文字由于可能出现两行，也有可能会活动文本的字体字号等其他属性不尽相同导致`一段文字由两个CTRun进行绘制`，所以不能单纯的保存一个frame，而是`要以一个数组容纳他`。再通过一些逻辑将不同的活动文本区别开来。由于是demo所以一切从简老司机没有说怎么区分活动文本，给个思路，就是你给click属性`绑定的value就可以用作区分`（这句好拗口）。至此，全部的文字点击及图片点击事件的大体思路讲述完毕。\n\n- - -\n为了吸取教训，这次老司机会留下demo。恩，也要去前两篇通知他们第三篇有demo。\n### [去这里下载demo](https://pan.baidu.com/s/1skQN7Md)\n\n然后，\n\n广告时间了：\n\n痛定思痛的老司机写了一个真正支持图文混排点击事件的Label控件。你可以实现如下的效果。\n\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n\n\n![爱你哟](http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- - - \n文章到最后都是一样的，喜欢点赞吧~关注吧~乖~话说老司机超爱兔子的~\n\n![乖](http://upload-images.jianshu.io/upload_images/1835430-1fd05923725b25f6.gif?imageMogr2/auto-orient/strip)\n","slug":"CoreText实现图文混排之文字环绕及点击算法","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htoy0008jigbfqfg2x7z","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-80b2fc8677bcd42f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CoreText实现图文混排之文字环绕及点击算法\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排</a></li>\n<li><a href=\"http://www.jianshu.com/p/51c47329203e\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之点击事件</a></li>\n<li><a href=\"http://www.jianshu.com/p/e154047b0f98\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之文字环绕及点击算法</a></li>\n</ul>\n<hr>\n<p>在这篇文章中你可以看到以下内容：</p>\n<ul>\n<li>图片环绕的实现方式</li>\n<li>点击事件获取的优化算法</li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<p>终于我来完成我CoreText图文混排的最后一章了。</p>\n<p>先说一下我为什么会来补发这一章呢？</p>\n<blockquote>\n<p>1.老司机最开始没有留demo，以至于这个博客老司机从发出来到现在整整维护了半年了=。=其实博客里面就是全部代码，但是宝宝们任性的要demo。</p>\n<p>2.时间长了，阅读量也上去了，老司机觉得自己有必要对粉丝们负责了</p>\n<p>3.有很多同学询问是否能做出文字环绕的效果，老司机之前的确也没有写过，这一篇是要补上的。</p>\n<p>4.关于点击事件，老司机在第二篇文章中有提到过一个思路，是每次遍历所有CTRun去做的。后期老司机考虑到遍历的实现效率似乎有些低，所以老司机研究了一下，重新整理思路，优化了一下算法。</p>\n</blockquote>\n<p>基于以上原因，以及一个<code>阴谋</code>，老司机又来更文了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6e1368fd36b6e027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"劳资回来了\"></p>\n<p>看了本篇博客，老司机能够帮你实现如下效果</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e44f7e218a059e4b.gif?imageMogr2/auto-orient/strip\" alt=\"CoreText\"></p>\n<p>这篇博客是以前两篇博客作为知识铺垫的，如果没有看过前两篇博客的童靴建议你去<a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">补票</a>。当然本身你就了解CoreText相关知识的话也可以直接看本篇文章。</p>\n<hr>\n<h3 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h3><p>优化算法以后，代码有些许改变，不过主体思路是一致的。下面是全部代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface CoreTextV ()</div><div class=\"line\">&#123;</div><div class=\"line\">    CTFrameRef _frame;</div><div class=\"line\">    NSInteger _length;</div><div class=\"line\">    CGRect _imgFrm;</div><div class=\"line\">    NSMutableArray * arrText;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation CoreTextV</div><div class=\"line\"></div><div class=\"line\">-(void)drawRect:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    [super drawRect:rect];</div><div class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</div><div class=\"line\">    CGContextScaleCTM(context, 1.0, -1.0);</div><div class=\"line\">    arrText = [NSMutableArray array];</div><div class=\"line\">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;];</div><div class=\"line\">    [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor whiteColor] range:NSMakeRange(0, attributeStr.length)];</div><div class=\"line\">    CTRunDelegateCallbacks callBacks;</div><div class=\"line\">    memset(&amp;callBacks, 0, sizeof(CTRunDelegateCallbacks));</div><div class=\"line\">    callBacks.version = kCTRunDelegateVersion1;    \t callBacks.getAscent = ascentCallBacks;    \tcallBacks.getDescent = descentCallBacks;    \tcallBacks.getWidth = widthCallBacks;</div><div class=\"line\">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@90,@&quot;width&quot;:@160&#125;;</div><div class=\"line\">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</div><div class=\"line\">    unichar placeHolder = 0xFFFC;</div><div class=\"line\">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</div><div class=\"line\">    NSMutableAttributedString * placeHolderAttrStr = \t[[NSMutableAttributedString alloc] initWithString:placeHolderStr];</div><div class=\"line\">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);    CFRelease(delegate);</div><div class=\"line\">    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:300];</div><div class=\"line\">    NSDictionary * activeAttr = @&#123;NSForegroundColorAttributeName:[UIColor redColor],@&quot;click&quot;:NSStringFromSelector(@selector(click))&#125;;</div><div class=\"line\">    [attributeStr addAttributes:activeAttr range:NSMakeRange(100, 30)];</div><div class=\"line\">    </div><div class=\"line\">    [attributeStr addAttributes:activeAttr range:NSMakeRange(400, 100)];</div><div class=\"line\"></div><div class=\"line\">    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</div><div class=\"line\">    UIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];</div><div class=\"line\">    UIBezierPath * cirP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 200)];</div><div class=\"line\">    [path appendPath:cirP];</div><div class=\"line\">    _length = attributeStr.length;</div><div class=\"line\">    _frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, _length), path.CGPath, NULL);</div><div class=\"line\">    CTFrameDraw(_frame, context);</div><div class=\"line\">    </div><div class=\"line\">    UIImage * image = [UIImage imageNamed:@&quot;1.jpg&quot;];</div><div class=\"line\">    [self handleActiveRectWithFrame:_frame];</div><div class=\"line\">    CGContextDrawImage(context,_imgFrm, image.CGImage);</div><div class=\"line\">    </div><div class=\"line\">    CGContextDrawImage(context, cirP.bounds, [[UIImage imageNamed:@&quot;1.jpg&quot;] dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)].CGImage);</div><div class=\"line\">    CFRelease(_frame);</div><div class=\"line\">    CFRelease(frameSetter);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static CGFloat ascentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat descentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat widthCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(void)handleActiveRectWithFrame:(CTFrameRef)frame</div><div class=\"line\">&#123;</div><div class=\"line\">    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</div><div class=\"line\">    NSInteger count = [arrLines count];</div><div class=\"line\">    CGPoint points[count];</div><div class=\"line\">    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</div><div class=\"line\">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</div><div class=\"line\">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</div><div class=\"line\">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</div><div class=\"line\">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);</div><div class=\"line\">            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</div><div class=\"line\">            CGPoint point = points[i];</div><div class=\"line\">            if (delegate == nil) &#123;</div><div class=\"line\">                NSString * string = attributes[@&quot;click&quot;];</div><div class=\"line\">                if (string) &#123;</div><div class=\"line\">                    [arrText addObject:[NSValue valueWithCGRect:[self getLocWithFrame:frame CTLine:line CTRun:run origin:point]]];</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate);</div><div class=\"line\">            if (![metaDic isKindOfClass:[NSDictionary class]]) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _imgFrm = [self getLocWithFrame:frame CTLine:line CTRun:run origin:point];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGRect)getLocWithFrame:(CTFrameRef)frame CTLine:(CTLineRef)line CTRun:(CTRunRef)run origin:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat ascent;</div><div class=\"line\">    CGFloat descent;</div><div class=\"line\">    CGRect boundsRun;</div><div class=\"line\">    boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</div><div class=\"line\">    boundsRun.size.height = ascent + descent;</div><div class=\"line\">    CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</div><div class=\"line\">    boundsRun.origin.x = origin.x + xOffset; </div><div class=\"line\">    boundsRun.origin.y = origin.y - descent;</div><div class=\"line\">    CGPathRef path = CTFrameGetPath(frame);</div><div class=\"line\">    CGRect colRect = CGPathGetBoundingBox(path); </div><div class=\"line\">    CGRect deleteBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class=\"line\">    return deleteBounds;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGRect)convertRectFromLoc:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGRectMake(rect.origin.x, self.bounds.size.height - rect.origin.y - rect.size.height, rect.size.width, rect.size.height);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    UITouch * touch = [touches anyObject];</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    CGRect imageFrmToScreen = [self convertRectFromLoc:_imgFrm];</div><div class=\"line\">    if (CGRectContainsPoint(imageFrmToScreen, location)) &#123;</div><div class=\"line\">        [[[UIAlertView alloc] initWithTitle:nil message:@&quot;你点击了图片&quot; delegate:nil cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil] show];</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [arrText enumerateObjectsUsingBlock:^(NSValue * rectV, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">        CGRect textFrmToScreen = [self convertRectFromLoc:[rectV CGRectValue]];</div><div class=\"line\">        if (CGRectContainsPoint(textFrmToScreen, location)) &#123;</div><div class=\"line\">            [self click];</div><div class=\"line\">            *stop = YES;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)click</div><div class=\"line\">&#123;</div><div class=\"line\">    [[[UIAlertView alloc] initWithTitle:nil message:@&quot;你点击了文字&quot; delegate:nil cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil] show];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>只关心结果或者着急写项目的童靴看到这里就足够了，因为所有代码都在，想找demo的话就去文章末尾找吧。因为接下来老司机要<code>开始扯淡了</code>。。。跟你们讲讲一切的<code>实现思路</code>。</p>\n<hr>\n<p>###图片环绕的实现方式</p>\n<p>由于我只是给个demo，所以一切代码均从简写。<code>实际过程中，代码应进行封装分块。</code></p>\n<p>我们将视线集中到<code>drawRect</code>方法中吧。</p>\n<p>之前的文章老司机讲过，我们在drawRect中绘制文本的时候主要是<code>根据Path去绘制</code>的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];</div><div class=\"line\">UIBezierPath * cirP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 200)];</div><div class=\"line\">[path appendPath:cirP];</div><div class=\"line\">_length = attributeStr.length;</div><div class=\"line\">_frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, _length), path.CGPath, NULL);</div><div class=\"line\">CTFrameDraw(_frame, context);</div></pre></td></tr></table></figure>\n<p>我们可以看到，我们是以path和frameSetter去生成我们绘制文本的frame的。所以说，只要在这个地方我们<code>传入的path中将特殊区域排除</code>我们获得的<code>frame就不包含该区域</code>，从而<code>绘制的文本也不会在该区域中绘制</code>。</p>\n<p>所以说上述的代码你看到的应该是这样子的文字区域</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b9e2009892b5bff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"排除文字区域\"></p>\n<p>这里你可能会有个疑问，问什么我cirP的rect是CGRectMake(100, 100, 100, 200)，这个排除的区域却在那里。这里你还记得老司机在第一篇文章里就说过<code>屏幕坐标系统跟系统坐标系统的区别</code>呢，原因就在这。</p>\n<p>也就是说，到了这里，我们只要绘制出这个椭圆形的图片就可以了。这你可能需要借助老司机之前写好的工具类，在这个仓库里的<a href=\"https://github.com/CodeWicky/-Tools\" target=\"_blank\" rel=\"external\">DWImageUtils</a>就是了。如果好用记得给我个<strong><code>star</code></strong>吧。</p>\n<p>有了这个工具类，你就可以这样生成<code>椭圆图片</code>了</p>\n<blockquote>\n<p>[image dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)]</p>\n</blockquote>\n<p>有了图片了，情况基本就变成了我们熟悉的状况了，绘制图片</p>\n<blockquote>\n<p> CGContextDrawImage(context, cirP.bounds, [[UIImage imageNamed:@”1.jpg”] dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)].CGImage);</p>\n</blockquote>\n<p>至此，我们就绘制出环绕的文本了。也算真正的实现所谓的图文混排了。</p>\n<hr>\n<h3 id=\"点击事件获取的优化算法\"><a href=\"#点击事件获取的优化算法\" class=\"headerlink\" title=\"点击事件获取的优化算法\"></a>点击事件获取的优化算法</h3><p>首先老司机来讲一下目前老司机了解到的几种获取点击事件的方式。</p>\n<h4 id=\"CTLineGetStringIndexForPosition\"><a href=\"#CTLineGetStringIndexForPosition\" class=\"headerlink\" title=\"CTLineGetStringIndexForPosition\"></a>CTLineGetStringIndexForPosition</h4><p>主流方式就是当前大部分基于CoreText封装的富文本展示类（包括<code>TTTAttributedLabel</code>、<code>NIAttributedLabel</code>和<code>FTCoreTextView</code>）中使用的方法 <code>CTLineGetStringIndexForPosition</code>。这个方法是<code>获取当前点在所在文字处于当前绘制文本的索引值</code>。事实上如果没有一些其他因素的话，能使用这个方法是最简便快捷的。然而老司机为什么没有使用这个方法去获取点击事件呢？请看下面的动图👇</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d6a8b77cf8ee04fd.gif?imageMogr2/auto-orient/strip\" alt=\"CTLineGetStringIndexForPosition\"></p>\n<p>这里老司机是以TTTAttributedLabel为样本做了一个点击事件的Demo。</p>\n<p>先明确一点，有下划线的区域应该为实际点击响应区域。可以看到，<code>实际的响应区域相比预期响应区域x坐标会整体向左偏移一定区域</code>。</p>\n<p>实际使用中CTLineGetStringIndexForPosition这个方法获取一个字的index范围是<code>这个字前面大概半个字开始到这个字中间的位置</code>。从这个字的中间到这个字的后半个字就会获得下一个字的index。举个例子：（勾选的勾字index应该为0，当点击勾字左半部分的时候返回0，右半部分返回1）。</p>\n<p>老司机查阅了很多资料，有的资料说这个方法在当有段前缩进或者首行缩进的时候，并不准确，不会跟着缩进而进行偏移。然而老司机在将段前缩进设为0仍然有这个问题。老司机也不知道具体问题在哪，然而老司机有强迫症的不能允许这<code>半个字的误差</code>，所以老司机当时决定不用这个方法，自己另辟蹊径。就有了老司机当时的遍历每个CTRun的算法。</p>\n<p>多说一句，CTLineGetStringIndexForPosition这个方法还有另一个作用还是很好用的。<code>这个方法最好的用处就是判断一行CTLine最多容纳多少的字符，只需把这个point的x位置调很大（超过CTFrame path的宽度）就可以了</code>。</p>\n<h4 id=\"遍历CTRun比较法\"><a href=\"#遍历CTRun比较法\" class=\"headerlink\" title=\"遍历CTRun比较法\"></a>遍历CTRun比较法</h4><p>老司机当时觉得半个字的误差实在是难以容忍，所以老司机舍近求远想出了这套<code>遍历CTRun</code>的算法。因为执行效率上一个屏幕内能展示的文字所包含的CTRun的数量在遍历过程中并不会造成过多的性能浪费，所以老司机当时也没有在意。</p>\n<p>直到后来老司机的项目中由于要尽量少的使用三方SDK，所以自告奋勇的把自己写的coreText的可点击label引入到工程里面。然而项目经理看了源码后表示虽然他没用过CoreText，但是遍历真的很蛋疼，决定引入一个TTT。老司机的心情瞬间跌入谷底。<code>老司机当即决定，我要优化算法</code>。</p>\n<h4 id=\"计算并缓存法\"><a href=\"#计算并缓存法\" class=\"headerlink\" title=\"计算并缓存法\"></a>计算并缓存法</h4><p>之所以说优化算法，没有说不用遍历是因为CoreText就那么些东西，获取图片的_frame还是需要遍历整个CTFrame中的所有CTRun的。所以老司机花了整整一个礼拜也<code>没找到替代遍历的方法</code>。</p>\n<p>终于有一天，感受到了月亮的召唤，老司机<code>变！身！了！</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-23cd1c8301471fbe.gif?imageMogr2/auto-orient/strip\" alt=\"变身了\"></p>\n<p>顺便想到了一个思路，<code>避免不了遍历我就只遍历一次就好了</code>。一次遍历中拿到所有活动图片和活动文字的frame，然后事情就简单多了，按照点击图片的处理方式处理文字就好了。</p>\n<p>所以老司机就想了一个办法期望在遍历的时候可以拿到活动文字的特征点，从而获取活动范围。老司机顺理成章的就<code>给想要添加点击事件的活动文本加了click这么一个属性</code>。（demo中老司机就随便写了，实际要慎重考虑叫什么名字不会被觉得太Low😂）</p>\n<p>其实实现上的思路很简单，只是之前没想到，<code>感谢月亮的召唤吧</code>还是。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-fc2c885752867d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"关我毛事\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSDictionary * activeAttr = @&#123;NSForegroundColorAttributeName:[UIColor redColor],@&quot;click&quot;:NSStringFromSelector(@selector(click))&#125;;</div><div class=\"line\">[attributeStr addAttributes:activeAttr range:NSMakeRange(100, 30)];</div><div class=\"line\">[attributeStr addAttributes:activeAttr range:NSMakeRange(400, 100)];</div></pre></td></tr></table></figure>\n<p>这里老司机很随意的添加了一个click属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[arrText addObject:[NSValue valueWithCGRect:[self getLocWithFrame:frame CTLine:line CTRun:run origin:point]]];</div></pre></td></tr></table></figure>\n<p>然后这里老司机就把活动文本的frame计算出来了。</p>\n<p>思路就是这么简单。本着一年内保证售后服务的原则，老司机会给在前两篇博客中要demo的童鞋再发一份最新的demo通知新算法。</p>\n<p>另外老司机这里要提醒你一点的就是，<code>文字frame不同于获取图片的frame</code>。由于<code>图片</code>是在一个空白占位符上绘制文字，<code>所以一定是以一个CTRun进行绘制的</code>。但是第一篇文章中老司机说过，<code>每个CTRun是所有具有相同属性的连续同行文字的集合</code>。针对CTRun的特性，我们不难想到，文字由于可能出现两行，也有可能会活动文本的字体字号等其他属性不尽相同导致<code>一段文字由两个CTRun进行绘制</code>，所以不能单纯的保存一个frame，而是<code>要以一个数组容纳他</code>。再通过一些逻辑将不同的活动文本区别开来。由于是demo所以一切从简老司机没有说怎么区分活动文本，给个思路，就是你给click属性<code>绑定的value就可以用作区分</code>（这句好拗口）。至此，全部的文字点击及图片点击事件的大体思路讲述完毕。</p>\n<hr>\n<p>为了吸取教训，这次老司机会留下demo。恩，也要去前两篇通知他们第三篇有demo。</p>\n<h3 id=\"去这里下载demo\"><a href=\"#去这里下载demo\" class=\"headerlink\" title=\"去这里下载demo\"></a><a href=\"https://pan.baidu.com/s/1skQN7Md\" target=\"_blank\" rel=\"external\">去这里下载demo</a></h3><p>然后，</p>\n<p>广告时间了：</p>\n<p>痛定思痛的老司机写了一个真正支持图文混排点击事件的Label控件。你可以实现如下的效果。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你哟\"></p>\n<hr>\n<p>文章到最后都是一样的，喜欢点赞吧~关注吧~乖~话说老司机超爱兔子的~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1fd05923725b25f6.gif?imageMogr2/auto-orient/strip\" alt=\"乖\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-80b2fc8677bcd42f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CoreText实现图文混排之文字环绕及点击算法\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">CoreText实现图文混排</a></li>\n<li><a href=\"http://www.jianshu.com/p/51c47329203e\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之点击事件</a></li>\n<li><a href=\"http://www.jianshu.com/p/e154047b0f98\" target=\"_blank\" rel=\"external\">CoreText实现图文混排之文字环绕及点击算法</a></li>\n</ul>\n<hr>\n<p>在这篇文章中你可以看到以下内容：</p>\n<ul>\n<li>图片环绕的实现方式</li>\n<li>点击事件获取的优化算法</li>\n</ul>","more":"<hr>\n<p>终于我来完成我CoreText图文混排的最后一章了。</p>\n<p>先说一下我为什么会来补发这一章呢？</p>\n<blockquote>\n<p>1.老司机最开始没有留demo，以至于这个博客老司机从发出来到现在整整维护了半年了=。=其实博客里面就是全部代码，但是宝宝们任性的要demo。</p>\n<p>2.时间长了，阅读量也上去了，老司机觉得自己有必要对粉丝们负责了</p>\n<p>3.有很多同学询问是否能做出文字环绕的效果，老司机之前的确也没有写过，这一篇是要补上的。</p>\n<p>4.关于点击事件，老司机在第二篇文章中有提到过一个思路，是每次遍历所有CTRun去做的。后期老司机考虑到遍历的实现效率似乎有些低，所以老司机研究了一下，重新整理思路，优化了一下算法。</p>\n</blockquote>\n<p>基于以上原因，以及一个<code>阴谋</code>，老司机又来更文了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6e1368fd36b6e027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"劳资回来了\"></p>\n<p>看了本篇博客，老司机能够帮你实现如下效果</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e44f7e218a059e4b.gif?imageMogr2/auto-orient/strip\" alt=\"CoreText\"></p>\n<p>这篇博客是以前两篇博客作为知识铺垫的，如果没有看过前两篇博客的童靴建议你去<a href=\"http://www.jianshu.com/p/6db3289fb05d\" target=\"_blank\" rel=\"external\">补票</a>。当然本身你就了解CoreText相关知识的话也可以直接看本篇文章。</p>\n<hr>\n<h3 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h3><p>优化算法以后，代码有些许改变，不过主体思路是一致的。下面是全部代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface CoreTextV ()</div><div class=\"line\">&#123;</div><div class=\"line\">    CTFrameRef _frame;</div><div class=\"line\">    NSInteger _length;</div><div class=\"line\">    CGRect _imgFrm;</div><div class=\"line\">    NSMutableArray * arrText;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation CoreTextV</div><div class=\"line\"></div><div class=\"line\">-(void)drawRect:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    [super drawRect:rect];</div><div class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</div><div class=\"line\">    CGContextScaleCTM(context, 1.0, -1.0);</div><div class=\"line\">    arrText = [NSMutableArray array];</div><div class=\"line\">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;];</div><div class=\"line\">    [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor whiteColor] range:NSMakeRange(0, attributeStr.length)];</div><div class=\"line\">    CTRunDelegateCallbacks callBacks;</div><div class=\"line\">    memset(&amp;callBacks, 0, sizeof(CTRunDelegateCallbacks));</div><div class=\"line\">    callBacks.version = kCTRunDelegateVersion1;    \t callBacks.getAscent = ascentCallBacks;    \tcallBacks.getDescent = descentCallBacks;    \tcallBacks.getWidth = widthCallBacks;</div><div class=\"line\">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@90,@&quot;width&quot;:@160&#125;;</div><div class=\"line\">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</div><div class=\"line\">    unichar placeHolder = 0xFFFC;</div><div class=\"line\">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</div><div class=\"line\">    NSMutableAttributedString * placeHolderAttrStr = \t[[NSMutableAttributedString alloc] initWithString:placeHolderStr];</div><div class=\"line\">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);    CFRelease(delegate);</div><div class=\"line\">    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:300];</div><div class=\"line\">    NSDictionary * activeAttr = @&#123;NSForegroundColorAttributeName:[UIColor redColor],@&quot;click&quot;:NSStringFromSelector(@selector(click))&#125;;</div><div class=\"line\">    [attributeStr addAttributes:activeAttr range:NSMakeRange(100, 30)];</div><div class=\"line\">    </div><div class=\"line\">    [attributeStr addAttributes:activeAttr range:NSMakeRange(400, 100)];</div><div class=\"line\"></div><div class=\"line\">    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</div><div class=\"line\">    UIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];</div><div class=\"line\">    UIBezierPath * cirP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 200)];</div><div class=\"line\">    [path appendPath:cirP];</div><div class=\"line\">    _length = attributeStr.length;</div><div class=\"line\">    _frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, _length), path.CGPath, NULL);</div><div class=\"line\">    CTFrameDraw(_frame, context);</div><div class=\"line\">    </div><div class=\"line\">    UIImage * image = [UIImage imageNamed:@&quot;1.jpg&quot;];</div><div class=\"line\">    [self handleActiveRectWithFrame:_frame];</div><div class=\"line\">    CGContextDrawImage(context,_imgFrm, image.CGImage);</div><div class=\"line\">    </div><div class=\"line\">    CGContextDrawImage(context, cirP.bounds, [[UIImage imageNamed:@&quot;1.jpg&quot;] dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)].CGImage);</div><div class=\"line\">    CFRelease(_frame);</div><div class=\"line\">    CFRelease(frameSetter);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static CGFloat ascentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat descentCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">static CGFloat widthCallBacks(void * ref)</div><div class=\"line\">&#123;</div><div class=\"line\">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(void)handleActiveRectWithFrame:(CTFrameRef)frame</div><div class=\"line\">&#123;</div><div class=\"line\">    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</div><div class=\"line\">    NSInteger count = [arrLines count];</div><div class=\"line\">    CGPoint points[count];</div><div class=\"line\">    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</div><div class=\"line\">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</div><div class=\"line\">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</div><div class=\"line\">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</div><div class=\"line\">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);</div><div class=\"line\">            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</div><div class=\"line\">            CGPoint point = points[i];</div><div class=\"line\">            if (delegate == nil) &#123;</div><div class=\"line\">                NSString * string = attributes[@&quot;click&quot;];</div><div class=\"line\">                if (string) &#123;</div><div class=\"line\">                    [arrText addObject:[NSValue valueWithCGRect:[self getLocWithFrame:frame CTLine:line CTRun:run origin:point]]];</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate);</div><div class=\"line\">            if (![metaDic isKindOfClass:[NSDictionary class]]) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _imgFrm = [self getLocWithFrame:frame CTLine:line CTRun:run origin:point];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGRect)getLocWithFrame:(CTFrameRef)frame CTLine:(CTLineRef)line CTRun:(CTRunRef)run origin:(CGPoint)origin</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat ascent;</div><div class=\"line\">    CGFloat descent;</div><div class=\"line\">    CGRect boundsRun;</div><div class=\"line\">    boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</div><div class=\"line\">    boundsRun.size.height = ascent + descent;</div><div class=\"line\">    CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</div><div class=\"line\">    boundsRun.origin.x = origin.x + xOffset; </div><div class=\"line\">    boundsRun.origin.y = origin.y - descent;</div><div class=\"line\">    CGPathRef path = CTFrameGetPath(frame);</div><div class=\"line\">    CGRect colRect = CGPathGetBoundingBox(path); </div><div class=\"line\">    CGRect deleteBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class=\"line\">    return deleteBounds;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGRect)convertRectFromLoc:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    return CGRectMake(rect.origin.x, self.bounds.size.height - rect.origin.y - rect.size.height, rect.size.width, rect.size.height);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    UITouch * touch = [touches anyObject];</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    CGRect imageFrmToScreen = [self convertRectFromLoc:_imgFrm];</div><div class=\"line\">    if (CGRectContainsPoint(imageFrmToScreen, location)) &#123;</div><div class=\"line\">        [[[UIAlertView alloc] initWithTitle:nil message:@&quot;你点击了图片&quot; delegate:nil cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil] show];</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [arrText enumerateObjectsUsingBlock:^(NSValue * rectV, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">        CGRect textFrmToScreen = [self convertRectFromLoc:[rectV CGRectValue]];</div><div class=\"line\">        if (CGRectContainsPoint(textFrmToScreen, location)) &#123;</div><div class=\"line\">            [self click];</div><div class=\"line\">            *stop = YES;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)click</div><div class=\"line\">&#123;</div><div class=\"line\">    [[[UIAlertView alloc] initWithTitle:nil message:@&quot;你点击了文字&quot; delegate:nil cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil] show];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>只关心结果或者着急写项目的童靴看到这里就足够了，因为所有代码都在，想找demo的话就去文章末尾找吧。因为接下来老司机要<code>开始扯淡了</code>。。。跟你们讲讲一切的<code>实现思路</code>。</p>\n<hr>\n<p>###图片环绕的实现方式</p>\n<p>由于我只是给个demo，所以一切代码均从简写。<code>实际过程中，代码应进行封装分块。</code></p>\n<p>我们将视线集中到<code>drawRect</code>方法中吧。</p>\n<p>之前的文章老司机讲过，我们在drawRect中绘制文本的时候主要是<code>根据Path去绘制</code>的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];</div><div class=\"line\">UIBezierPath * cirP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 200)];</div><div class=\"line\">[path appendPath:cirP];</div><div class=\"line\">_length = attributeStr.length;</div><div class=\"line\">_frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, _length), path.CGPath, NULL);</div><div class=\"line\">CTFrameDraw(_frame, context);</div></pre></td></tr></table></figure>\n<p>我们可以看到，我们是以path和frameSetter去生成我们绘制文本的frame的。所以说，只要在这个地方我们<code>传入的path中将特殊区域排除</code>我们获得的<code>frame就不包含该区域</code>，从而<code>绘制的文本也不会在该区域中绘制</code>。</p>\n<p>所以说上述的代码你看到的应该是这样子的文字区域</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b9e2009892b5bff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"排除文字区域\"></p>\n<p>这里你可能会有个疑问，问什么我cirP的rect是CGRectMake(100, 100, 100, 200)，这个排除的区域却在那里。这里你还记得老司机在第一篇文章里就说过<code>屏幕坐标系统跟系统坐标系统的区别</code>呢，原因就在这。</p>\n<p>也就是说，到了这里，我们只要绘制出这个椭圆形的图片就可以了。这你可能需要借助老司机之前写好的工具类，在这个仓库里的<a href=\"https://github.com/CodeWicky/-Tools\" target=\"_blank\" rel=\"external\">DWImageUtils</a>就是了。如果好用记得给我个<strong><code>star</code></strong>吧。</p>\n<p>有了这个工具类，你就可以这样生成<code>椭圆图片</code>了</p>\n<blockquote>\n<p>[image dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)]</p>\n</blockquote>\n<p>有了图片了，情况基本就变成了我们熟悉的状况了，绘制图片</p>\n<blockquote>\n<p> CGContextDrawImage(context, cirP.bounds, [[UIImage imageNamed:@”1.jpg”] dw_ClipImageWithPath:cirP mode:(DWContentModeScaleAspectFill)].CGImage);</p>\n</blockquote>\n<p>至此，我们就绘制出环绕的文本了。也算真正的实现所谓的图文混排了。</p>\n<hr>\n<h3 id=\"点击事件获取的优化算法\"><a href=\"#点击事件获取的优化算法\" class=\"headerlink\" title=\"点击事件获取的优化算法\"></a>点击事件获取的优化算法</h3><p>首先老司机来讲一下目前老司机了解到的几种获取点击事件的方式。</p>\n<h4 id=\"CTLineGetStringIndexForPosition\"><a href=\"#CTLineGetStringIndexForPosition\" class=\"headerlink\" title=\"CTLineGetStringIndexForPosition\"></a>CTLineGetStringIndexForPosition</h4><p>主流方式就是当前大部分基于CoreText封装的富文本展示类（包括<code>TTTAttributedLabel</code>、<code>NIAttributedLabel</code>和<code>FTCoreTextView</code>）中使用的方法 <code>CTLineGetStringIndexForPosition</code>。这个方法是<code>获取当前点在所在文字处于当前绘制文本的索引值</code>。事实上如果没有一些其他因素的话，能使用这个方法是最简便快捷的。然而老司机为什么没有使用这个方法去获取点击事件呢？请看下面的动图👇</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d6a8b77cf8ee04fd.gif?imageMogr2/auto-orient/strip\" alt=\"CTLineGetStringIndexForPosition\"></p>\n<p>这里老司机是以TTTAttributedLabel为样本做了一个点击事件的Demo。</p>\n<p>先明确一点，有下划线的区域应该为实际点击响应区域。可以看到，<code>实际的响应区域相比预期响应区域x坐标会整体向左偏移一定区域</code>。</p>\n<p>实际使用中CTLineGetStringIndexForPosition这个方法获取一个字的index范围是<code>这个字前面大概半个字开始到这个字中间的位置</code>。从这个字的中间到这个字的后半个字就会获得下一个字的index。举个例子：（勾选的勾字index应该为0，当点击勾字左半部分的时候返回0，右半部分返回1）。</p>\n<p>老司机查阅了很多资料，有的资料说这个方法在当有段前缩进或者首行缩进的时候，并不准确，不会跟着缩进而进行偏移。然而老司机在将段前缩进设为0仍然有这个问题。老司机也不知道具体问题在哪，然而老司机有强迫症的不能允许这<code>半个字的误差</code>，所以老司机当时决定不用这个方法，自己另辟蹊径。就有了老司机当时的遍历每个CTRun的算法。</p>\n<p>多说一句，CTLineGetStringIndexForPosition这个方法还有另一个作用还是很好用的。<code>这个方法最好的用处就是判断一行CTLine最多容纳多少的字符，只需把这个point的x位置调很大（超过CTFrame path的宽度）就可以了</code>。</p>\n<h4 id=\"遍历CTRun比较法\"><a href=\"#遍历CTRun比较法\" class=\"headerlink\" title=\"遍历CTRun比较法\"></a>遍历CTRun比较法</h4><p>老司机当时觉得半个字的误差实在是难以容忍，所以老司机舍近求远想出了这套<code>遍历CTRun</code>的算法。因为执行效率上一个屏幕内能展示的文字所包含的CTRun的数量在遍历过程中并不会造成过多的性能浪费，所以老司机当时也没有在意。</p>\n<p>直到后来老司机的项目中由于要尽量少的使用三方SDK，所以自告奋勇的把自己写的coreText的可点击label引入到工程里面。然而项目经理看了源码后表示虽然他没用过CoreText，但是遍历真的很蛋疼，决定引入一个TTT。老司机的心情瞬间跌入谷底。<code>老司机当即决定，我要优化算法</code>。</p>\n<h4 id=\"计算并缓存法\"><a href=\"#计算并缓存法\" class=\"headerlink\" title=\"计算并缓存法\"></a>计算并缓存法</h4><p>之所以说优化算法，没有说不用遍历是因为CoreText就那么些东西，获取图片的_frame还是需要遍历整个CTFrame中的所有CTRun的。所以老司机花了整整一个礼拜也<code>没找到替代遍历的方法</code>。</p>\n<p>终于有一天，感受到了月亮的召唤，老司机<code>变！身！了！</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-23cd1c8301471fbe.gif?imageMogr2/auto-orient/strip\" alt=\"变身了\"></p>\n<p>顺便想到了一个思路，<code>避免不了遍历我就只遍历一次就好了</code>。一次遍历中拿到所有活动图片和活动文字的frame，然后事情就简单多了，按照点击图片的处理方式处理文字就好了。</p>\n<p>所以老司机就想了一个办法期望在遍历的时候可以拿到活动文字的特征点，从而获取活动范围。老司机顺理成章的就<code>给想要添加点击事件的活动文本加了click这么一个属性</code>。（demo中老司机就随便写了，实际要慎重考虑叫什么名字不会被觉得太Low😂）</p>\n<p>其实实现上的思路很简单，只是之前没想到，<code>感谢月亮的召唤吧</code>还是。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-fc2c885752867d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"关我毛事\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSDictionary * activeAttr = @&#123;NSForegroundColorAttributeName:[UIColor redColor],@&quot;click&quot;:NSStringFromSelector(@selector(click))&#125;;</div><div class=\"line\">[attributeStr addAttributes:activeAttr range:NSMakeRange(100, 30)];</div><div class=\"line\">[attributeStr addAttributes:activeAttr range:NSMakeRange(400, 100)];</div></pre></td></tr></table></figure>\n<p>这里老司机很随意的添加了一个click属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[arrText addObject:[NSValue valueWithCGRect:[self getLocWithFrame:frame CTLine:line CTRun:run origin:point]]];</div></pre></td></tr></table></figure>\n<p>然后这里老司机就把活动文本的frame计算出来了。</p>\n<p>思路就是这么简单。本着一年内保证售后服务的原则，老司机会给在前两篇博客中要demo的童鞋再发一份最新的demo通知新算法。</p>\n<p>另外老司机这里要提醒你一点的就是，<code>文字frame不同于获取图片的frame</code>。由于<code>图片</code>是在一个空白占位符上绘制文字，<code>所以一定是以一个CTRun进行绘制的</code>。但是第一篇文章中老司机说过，<code>每个CTRun是所有具有相同属性的连续同行文字的集合</code>。针对CTRun的特性，我们不难想到，文字由于可能出现两行，也有可能会活动文本的字体字号等其他属性不尽相同导致<code>一段文字由两个CTRun进行绘制</code>，所以不能单纯的保存一个frame，而是<code>要以一个数组容纳他</code>。再通过一些逻辑将不同的活动文本区别开来。由于是demo所以一切从简老司机没有说怎么区分活动文本，给个思路，就是你给click属性<code>绑定的value就可以用作区分</code>（这句好拗口）。至此，全部的文字点击及图片点击事件的大体思路讲述完毕。</p>\n<hr>\n<p>为了吸取教训，这次老司机会留下demo。恩，也要去前两篇通知他们第三篇有demo。</p>\n<h3 id=\"去这里下载demo\"><a href=\"#去这里下载demo\" class=\"headerlink\" title=\"去这里下载demo\"></a><a href=\"https://pan.baidu.com/s/1skQN7Md\" target=\"_blank\" rel=\"external\">去这里下载demo</a></h3><p>然后，</p>\n<p>广告时间了：</p>\n<p>痛定思痛的老司机写了一个真正支持图文混排点击事件的Label控件。你可以实现如下的效果。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你哟\"></p>\n<hr>\n<p>文章到最后都是一样的，喜欢点赞吧~关注吧~乖~话说老司机超爱兔子的~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1fd05923725b25f6.gif?imageMogr2/auto-orient/strip\" alt=\"乖\"></p>"},{"title":"TableView优化之高度缓存","layout":"post","date":"2016-06-03T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![TableView优化之高度缓存](http://upload-images.jianshu.io/upload_images/1835430-a69cecb9aaa3f2d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n系列文章：\n\n- [TableView优化之高度缓存功能](http://www.jianshu.com/p/2b192257276f)\n\n- [TableView优化之加载图片的优化逻辑](http://www.jianshu.com/p/328e503900d0)\n\n- [TableView优化之快速滑动下的忽略加载](http://www.jianshu.com/p/0b020518de5e)\n- - -\n\n日常开发中，tableView的使用率很高，所以相对tableView的优化来说可以做很多很多的事情。很多情况下，我们的每一个cell都没有一个固定的高度，而是根据cell里面的内容自适应高度的。那么每次当我们cell将要出现在屏幕的时候，系统都会去计算cell的高度。如果说我能通过某种手段，在首次计算的时候，将每个cell对应的高度保存下载，当下次需要用到cell高度的时候再从保存的地方取出，从而减少了计算量，来达到优化的目的。\n\n因此应运而生了这套高度缓存的算法。\n\n在此声明，这套算法`不是老司机原创`，是整合并优化了外国一位大神的源码。\n\n**再次声明，**\n这原来是国人算法，扬我国威啊，原型名\nUITableView-FDTemplateLayoutCell。\n\n\n- - -\n这篇博客中你可能会用到\n\n- category 、subclass、protocol之间的区别\n- 自动布局相关\n- runTime动态绑定\n- tableViewCell重用的相关\n\n恩，其实东西并不多，重要的还是一个思想。\n\n<!-- more -->\n\n---\n\n## 全部代码\n\n老规矩，还是先放全部代码。\n\n```\n#import \"UITableView+HeightCache.h\"\n#import <objc/runtime.h>\n@implementation UITableView (HeightCache)\n\n#pragma mark ---接口方法---\n-(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier\n                               indexPath:(NSIndexPath *)indexPath\n                           configuration:(void(^)(id cell))configuration\n{\n    if(self.bounds.size.width != 0)//防止初始宽度为0（如autoLayout初次加载时）\n    {\n        if (!identifier.length || !indexPath) {//非空判断\n            return 0;\n        }\n        NSString * key = [self.cache makeKeyWithIdentifier:identifier indexPath:indexPath];//制作key\n        if ([self.cache existInCacheByKey:key]) {//如果key存在\n            return [self.cache heightFromCacheWithKey:key];//从字典中取出高\n        }\n        CGFloat height = [self DW_CalCulateCellWithIdentifier:identifier configuration:configuration];//不存在则计算高度\n        [self.cache cacheHeight:height byKey:key];//并缓存\n        return height;\n    }\n    return 0;\n}\n-(void)DW_RemoveHeightCacheWithIdentifier:(NSString *)identifier\n                                indexPath:(NSIndexPath *)indexPath\n                             numberOfRows:(NSInteger)rows\n{\n    [self.cache removeHeightByIdentifier:identifier indexPath:indexPath numberOfRows:rows];\n}\n-(void)DW_RemoveAllHeightCache\n{\n    [self.cache removeAllHeight];\n}\n-(void)DW_InsertCellToIndexPath:(NSIndexPath *)indexPath\n                 withIdentifier:(NSString *)identifier\n                   numberOfRows:(NSInteger)rows\n{\n    [self.cache insertCellToIndexPath:indexPath withIdentifier:identifier numberOfRows:rows toDictionaryForCache:self.cache.dicHeightCurrent];\n}\n-(void)DW_MoveCellFromIndexPath:(NSIndexPath *)sourceIndexPath\n    sourceIndexPathNumberOfRows:(NSInteger)sourceRows\n                    toIndexPath:(NSIndexPath *)destinationIndexPath\ndestinationIndexPathNumberOfRows:(NSInteger)destinationRows\n                 withIdentifier:(NSString *)identifier\n{\n    [self.cache moveCellFromIndexPath:sourceIndexPath sourceSectionNumberOfRows:sourceRows toIndexPath:destinationIndexPath destinationSectionNumberOfRows:destinationRows withIdentifier:identifier];\n}\n#pragma mark ---工具方法---\n///从重用池中返回计算用的cell\n-(__kindof UITableViewCell  *)DW_CalculateCellWithIdentifier:(NSString *)identifier\n{\n    if (!identifier.length) {\n        return nil;\n    }\n    NSMutableDictionary <NSString * ,UITableViewCell *> *DicForTheUniqueCalCell = objc_getAssociatedObject(self, _cmd);//利用runtime取出tableV绑定的存有cell的字典\n    if (!DicForTheUniqueCalCell) {\n        DicForTheUniqueCalCell = [NSMutableDictionary dictionary];//如果取不到则新建并绑定\n        objc_setAssociatedObject(self, _cmd, DicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//动态绑定（绑定目标，关键字，绑定者，策略）\n    }\n    //以上只是为了只绑定一个字典，类比懒加载\n    UITableViewCell * cell = DicForTheUniqueCalCell[identifier];\n    if (!cell) {\n        cell = [self dequeueReusableCellWithIdentifier:identifier];//从重用池中取一个cell用来计算，必须以本方式从重用池中取，若以indexPath方式取由于-heightForRowAtIndexPath方法会造成循环。\n        cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;//开启约束\n        cell.JustForCal = YES;//标记只用来计算\n        DicForTheUniqueCalCell[identifier] = cell;\n    }\n    //同上，保证只有一个用来计算的cell\n    return cell;\n}\n\n///根据重用表示取出cell并操作cell后，计算高度\n-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier\n                           configuration:(void(^)(id cell))configuration\n{\n    if (!identifier.length) {\n        return 0;\n    }\n    UITableViewCell * cell = [self DW_CalculateCellWithIdentifier:identifier];\n    [cell prepareForReuse];//放回重用池\n    if (configuration) {\n        configuration(cell);//对cell进行操作\n    }    \n    return [self DW_CalculateCellHeightWithCell:cell];\n}\n\n///根据cell计算cell的高度\n-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\n{\n    CGFloat width = self.bounds.size.width;\n    //根据辅助视图校正width\n    if (cell.accessoryView) {\n        width -= cell.accessoryView.bounds.size.width + 16;\n    }\n    else\n    {\n        static const CGFloat accessoryWidth[] = {\n            [UITableViewCellAccessoryNone] = 0,\n            [UITableViewCellAccessoryDisclosureIndicator] = 34,\n            [UITableViewCellAccessoryDetailDisclosureButton] = 68,\n            [UITableViewCellAccessoryCheckmark] = 40,\n            [UITableViewCellAccessoryDetailButton] = 48\n        };\n        width -= accessoryWidth[cell.accessoryType];\n    }\n    CGFloat height = 0;\n    if (!cell.NoAutoSizing && width > 0) {//如果不是非自适应模式则添加约束后计算约束后高度\n        NSLayoutConstraint * widthConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:width];//创建约束\n        [cell.contentView addConstraint:widthConstraint];//添加约束\n        height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;//计算高度\n        [cell.contentView removeConstraint:widthConstraint];//移除约束\n    }\n    if (height == 0) {//如果约束错误可能导致计算结果为零，则以自适应模式再次计算\n        height = [cell sizeThatFits:CGSizeMake(width, 0)].height;\n    }\n    if (height == 0) {//如果计算仍然为0，则给出默认高度\n        height = 44;\n    }\n    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) {//如果不为无分割线模式则添加分割线高度\n        height += 1.0 /[UIScreen mainScreen].scale;\n    }\n    return height;\n}\n\n#pragma mark ---setter、getter---\n-(HeightCache *)cache//懒加载形式\n{\n    HeightCache * cacheTemp = objc_getAssociatedObject(self, _cmd);\n    if (!cacheTemp) {\n        cacheTemp = [HeightCache new];\n        objc_setAssociatedObject(self, _cmd, cacheTemp, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    }\n    return cacheTemp;\n}\n-(void)setCache:(HeightCache *)cache\n{\n    objc_setAssociatedObject(self, @selector(cache), cache, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n@end\n\n\n@implementation UITableViewCell (HeightCacheCell)\n#pragma mark ---setter、getter---\n-(BOOL)NoAutoSizing\n{\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n-(void)setNoAutoSizing:(BOOL)NoAutoSizing\n{\n    objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);//关键字用getter的方法名，为保持关键字一致\n}\n-(BOOL)JustForCal\n{\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n-(void)setJustForCal:(BOOL)JustForCal\n{\n    objc_setAssociatedObject(self, @selector(JustForCal), @(JustForCal), OBJC_ASSOCIATION_RETAIN);\n}\n@end\n\n@implementation HeightCache\n///制作key\n-(NSString *)makeKeyWithIdentifier:(NSString *)identifier\n                         indexPath:(NSIndexPath *)indexPath\n{\n    return [NSString stringWithFormat:@\"%@S%ldR%ld\",identifier,indexPath.section,indexPath.row];\n}\n\n///高度是否存在\n-(BOOL)existInCacheByKey:(NSString *)key\n{\n    NSNumber * value = [self.dicHeightCurrent valueForKey:key];\n    return (value && ![value isEqualToNumber:@-1]);\n}\n\n///取出缓存的高度\n-(CGFloat)heightFromCacheWithKey:(NSString *)key\n{\n    NSNumber * value = [self.dicHeightCurrent valueForKey:key];\n    if ([self is64bit]) {\n        return [value doubleValue];\n    }\n    return [value floatValue];\n}\n\n///64位判断\n- (BOOL)is64bit\n{\n#if defined(__LP64__) && __LP64__\n    return YES;\n#else\n    return NO;\n#endif\n}\n\n///高度缓存\n-(void)cacheHeight:(CGFloat)height\n             byKey:(NSString *)key\n{\n    [self.dicHeightCurrent setValue:@(height) forKey:key];\n}\n\n///根据key删除缓存\n-(void)removeHeightByIdentifier:(NSString *)identifier\n                      indexPath:(NSIndexPath *)indexPath\n                   numberOfRows:(NSInteger)rows\n{\n    if (indexPath.row < rows) {\n        for (int i = 0; i < rows - 1 - indexPath.row; i ++) {\n            NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:indexPath.row + i inSection:indexPath.section];\n            NSLog(@\"%ld,%ld\",indexPathA.row,indexPathA.section);\n            NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:indexPath.row + i + 1 inSection:indexPath.section];\n            NSLog(@\"%ld,%ld\",indexPathB.row,indexPathB.section);\n            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheH];\n            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheV];\n        }\n        NSIndexPath * indexPathC = [NSIndexPath indexPathForRow:rows - 1 inSection:indexPath.section];\n        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:indexPathC];\n        [self.dicHeightCacheH removeObjectForKey:key];\n        [self.dicHeightCacheV removeObjectForKey:key];\n    }\n}\n\n///删除所有缓存\n-(void)removeAllHeight\n{\n    [self.dicHeightCacheH removeAllObjects];\n    [self.dicHeightCacheV removeAllObjects];\n}\n\n///插入cell是插入value\n-(void)insertCellToIndexPath:(NSIndexPath *)indexPath\n            withNumberOfRows:(NSInteger)rows\n                heightNumber:(NSNumber *)height\n                  identifier:(NSString *)identifier\n        toDictionaryForCache:(NSMutableDictionary *)dic\n{\n    if (indexPath.row < rows + 1) {\n        [self insertCellToIndexPath:indexPath withIdentifier:identifier numberOfRows:rows toDictionaryForCache:dic];\n        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:indexPath];\n        [dic setValue:height forKey:key];\n    }\n}\n-(void)insertCellToIndexPath:(NSIndexPath *)indexPath withIdentifier:(NSString *)identifier numberOfRows:(NSInteger)rows toDictionaryForCache:(NSMutableDictionary *)dic\n{\n    if (indexPath.row < rows + 1) {\n        for (int i = 0; i < rows - indexPath.row; i ++) {\n            NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:rows - i inSection:indexPath.section];\n            NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:rows - i - 1 inSection:indexPath.section];\n            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:dic];\n        }\n    }\n}\n///移动cell时交换value\n-(void)moveCellFromIndexPath:(NSIndexPath *)sourceIndexPath\n   sourceSectionNumberOfRows:(NSInteger)sourceRows\n                 toIndexPath:(NSIndexPath *)destinationIndexPath\ndestinationSectionNumberOfRows:(NSInteger)destinationRows\n              withIdentifier:(NSString *)identifier\n{\n    if (sourceIndexPath.section == destinationIndexPath.section) {\n        [self moveCellInSectionFromIndexPath:sourceIndexPath toIndexPath:destinationIndexPath withIdentifier:identifier];\n    }\n    else\n    {\n        [self moveCellOutSectionFromIndexPath:sourceIndexPath sourceSectionNumberOfRows:sourceRows toIndexPath:destinationIndexPath destinationSectionNumberOfRows:destinationRows withIdentifier:identifier];\n    }\n}\n///组内移动\n-(void)moveCellInSectionFromIndexPath:(NSIndexPath *)sourceIndexPath\n                          toIndexPath:(NSIndexPath *)destinationIndexPath\n                       withIdentifier:(NSString *)identifier\n{\n    NSInteger rowA = sourceIndexPath.row;\n    NSInteger rowB = destinationIndexPath.row;\n    for (int i = 0; i < (MAX(rowA, rowB) - MIN(rowA, rowB)); i ++) {\n        NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:MIN(rowA, rowB) + i inSection:sourceIndexPath.section];\n        NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:MIN(rowA, rowB) + i + 1 inSection:sourceIndexPath.section];\n        [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheV];\n        [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheH];\n    }\n}\n///组外移动\n-(void)moveCellOutSectionFromIndexPath:(NSIndexPath *)sourceIndexPath\n             sourceSectionNumberOfRows:(NSInteger)sourceRows\n                           toIndexPath:(NSIndexPath *)destinationIndexPath\n        destinationSectionNumberOfRows:(NSInteger)destinationRows\n                        withIdentifier:(NSString *)identifier\n{\n    NSNumber * numberH;\n    NSNumber * numberV;\n    NSLog(@\"%ld\",sourceIndexPath.row);\n    if (sourceIndexPath.row < sourceRows) {\n        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:sourceIndexPath];\n        numberH = self.dicHeightCacheH[key];\n        numberV = self.dicHeightCacheV[key];\n        [self removeHeightByIdentifier:identifier indexPath:sourceIndexPath numberOfRows:sourceRows];\n    }\n    NSLog(@\"%ld,%ld\",destinationIndexPath.row,destinationIndexPath.section);\n    [self insertCellToIndexPath:destinationIndexPath withNumberOfRows:destinationRows heightNumber:numberH identifier:identifier toDictionaryForCache:self.dicHeightCacheH];\n    [self insertCellToIndexPath:destinationIndexPath withNumberOfRows:destinationRows heightNumber:numberV identifier:identifier toDictionaryForCache:self.dicHeightCacheV];\n}\n///根据indexPath交换两个Key\n-(void)exchangeValueForIndexPathA:(NSIndexPath *)indexPathA\n                    andIndexPathB:(NSIndexPath *)indexPathB\n                   withIdentifier:(NSString *)identifier\n                       dictionary:(NSMutableDictionary *)dic\n{\n    NSString * keyA = [self makeKeyWithIdentifier:identifier indexPath:indexPathA];\n    NSString * keyB = [self makeKeyWithIdentifier:identifier indexPath:indexPathB];\n    NSNumber * Temp = dic[keyA];\n    dic[keyA] = dic[keyB];\n    dic[keyB] = Temp;\n}\n#pragma mark ---懒加载---\n-(NSMutableDictionary *)dicHeightCacheH\n{\n    if (!_dicHeightCacheH) {\n        _dicHeightCacheH = [NSMutableDictionary dictionary];\n    }\n    return _dicHeightCacheH;\n}\n-(NSMutableDictionary *)dicHeightCacheV\n{\n    if (!_dicHeightCacheV) {\n        _dicHeightCacheV = [NSMutableDictionary dictionary];\n    }\n    return _dicHeightCacheV;\n}\n-(NSMutableDictionary *)dicHeightCurrent//根据系统状态返回对应字典\n{\n    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation)?self.dicHeightCacheV:self.dicHeightCacheH;\n}\n@end\n\n```\n\n``这么多，你这个骗子！``\n你是不是这么想得。\n\n别慌，东西不多，因为这是一个category，复用性非常高，所以老司机想尽量减少文件个数，这样集成的时候也方便不是。\n\n所以，老司机`把三个类写在一个文件里了`。\n\n之前有人问过我把几个类写在一个文件中`有什么好处么`？\n\n老司机目前只能说，`除了看上去装逼点，别的没什么卵用`。\n\n可能是老司机的理解不深，不过为了集成方便我还是写在一个文件里了。\n\n废话不多说，分段讲解吧。\n- - -\n## 分段解析\n### 为什么选择category而不是subclass\n\n我想很多人都会有疑问，为什么选择category而不是继承，毕竟category不能添加属性,用起来不是很方便。说到这又要老生常谈了。\n\n>Protocol只是声明一套接口，并不能提供具体实现，变相的也算是一种抽象基类的实现方式（OC本身语法并不支持抽象基类）。\n\n>Category可以为已有的类提供额外的接口和具体的实现。\n\n>Protocol只能提供一套公用的接口声明，并不能提供具体实现，它的行为是，我只负责声明，而不管谁去实现，去如何实现。这样的话，我定义一套接口，可以使任意的类都用不同的方式去实现接口中的方法，就是为遵守了protocol的类提供了一些额外访问这个类的一些接口，像delegate和dataSource用protocol实现是最好的。\n\n>Category是对一个功能完备的类的一种补充、扩展，就像一个东西基本功能都完成了，可以用category为这个类添加不同的组件，使得这个类能够适应不同情况的需求（但是这些不同需求最核心的需求要一致）。当然，当某个类非常大的时候，使用category可以按照不同的功能将类的实现分在不同的模块中。还有，虽然category可以访问已有类的实例变量，但不能创建新的实例变量，如果要创建新的实例变量，请使用继承。\n\n>继承，它基于Protocol和Category之间，既可以像protocol一样只提供纯粹的接口，也可以像Category一样提供接口的完整实现，可以自由定义类的实例变量（这一点，Protocol倒是可以声明实例变量，但是也仅仅是声明而已），而且继承还可以对类以后的方法进行改写，所以继承的力量是最强大的。\n\n>在iOS开发中，继承是完全可以完成protocol和category的功能的，那么在开发过程中多多使用继承体系可好？\n\n>需要注意的是使用继承还有很大的代价问题。使用继承来进行扩展是一种耦合度很高的行为，对父类可以说是完全依赖，如果继承体系太过复杂，会造成难以维护的问题。如果仅仅只是对类进行扩展，并不建议使用继承，毕竟使用protocol和category是很简单、轻松的。除此之外，在开发过程中，我们应该尽量将界面、功能相似的类的代码提取到基类里面，然后各个子类继承自这个基类，实现各自的其他特殊部分。这样可以大大的优化代码，如果需要修改的话，只需要这倒对应子类修改即可。\n\n是不是感觉老司机屌屌的，啧啧啧，我百度的。\n\n我选择category就一个原因，扩展方便，二次开发也方便。\n\n---\n\n### 类目拆解\n老司机说过，这一坨代码是三个类写在了一个文件里，他们都是什么呢？\n\n- UITableView的category\n- UITableViewCell的category\n- 一个NSObject的子类\n\n他们分别是做什么的呢？\n\n首先，给UITableView添加category是因为为了`实现高度缓存`，我的方案是在计算高度的时候就模拟数据填充，从而计算出该cell的高度，所以，tableView应该有填充数据和计算高度的方法。故为其添加分类。\n\n而那个继承于NSObject的子类就是用来`存储计算出来的高度的`，这样当下次需要计算的时候直接从这里取出即可。\n\n至于那个UITableViewCell的类目是为了`给cell添加两个标识符`，一个用来判断当前cell是否需要一autolayout进行绘制，另一个是用来区分计算用的cell还是展示用的cell。这点现在可能你还不懂，一会我们会做相应介绍。\n\n---\n### UITableViewCell的category\n\n为什么先说这个类目呢，因为这个类目的内容最少，而且只用到了runtime的动态绑定，可以拿出来单独介绍一下runtime的相关知识。\n\n#### 什么是runtime\nrun，运行，time，时间，那么runtime就是运行时。恩，简单不？\n然后我们说说。。。诶诶诶，别打别打，开个玩笑。\nruntime，简称运行时，是`系统在运行期间的一些机制`。而对于OC来讲呢，其中最重要的就是`消息机制`。\n\nC语言呢，我们`调用函数`，在`编译期`就已经确定了要调用那个函数，而且整个过程是`顺序执行`的。\n\n而在OC中呢，我们是讲`消息发送`的。而且我们是等待某个信号`触发才执行`代码的。我们知道OC事实上是基于C的，那他是怎么实现这套转换的呢？就是`通过runtime去实现`的。\n\n不信？不信跟我来做个试验。\n\n新开一个工程，删掉所有文件，只`留下info.plist和main.m`。并且将引入的头文件删除掉。\n\n再`建一个类`，里面随便写一个方法的声明和实现。\n\n然后`在main.m中引入这个类`，`初始化并调用刚才声明的方法`，如下图。\n\n\n![新建一个工程](http://upload-images.jianshu.io/upload_images/1835430-7d31aa53377e7333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n此时，打开我们的终端。找到刚才的工程的main.m,并且输入\n`clang -rewrite-objc main.m`，点击回车。稍等你就会看到提示转换完成。\n\n![转化我们的文件](http://upload-images.jianshu.io/upload_images/1835430-0056ec0cb777ee26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n这回在finder中找到工程的文件夹，在main.m同级文件夹下多了一个文件`main.cpp`，这就是转换完的文件。我们看到代码还是很多的。`直接拖到最下方`我们大概能看到点认识的了，int main。。。\n\n这就是我们刚才`main函数里面的实现`。\n\n![找到实现](http://upload-images.jianshu.io/upload_images/1835430-fc8be701d9be1b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看不懂？待我帮你捋捋，去掉一些类型转换用的修饰符后剩下如下代码，是不是清晰多了？\n\n![姑且就叫化简吧](http://upload-images.jianshu.io/upload_images/1835430-4421b3ad6ca6a611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n先看被我框选中的代码，`objc_msgSend是说发送消息`，他有`两个参数`，一个是`实例`，一个是`方法`。`objc_getClass通过字符串获取到这个类`。`sel_registerName通过字符串获取方法`。所以这句话的意思就是`给这个类发送了这个消息，消息内容就是一个方法`。\n\n随后就容易了，给这个实例发送一个sayHello的消息，参数是后面的字符串。\n\n通过这里我们知道我们OC的语言是怎么实现的了吧，就是`通过runtime转化成了C++的代码`，然后进行运行。\n\n从这你也应该知道为什么OC中叫`发送消息`，不叫函数调用了吧。\n\n另外你还应该知道为什么OC中方法`只声明`，`不实现`，`编译时只报警不报错`，`运行时crash`是为什么了吧。\n\n既然说到这里就多少说一说C与OC吧。之前老司机说过，OC是基于C的，那么C语言中是没有对象这个概念呢，我们的对象又是什么呢？\n\n**右手啊，程序员哪有什么对象，啧啧啧。**\n\n除了右手，还有结构体，OC的对象就是`C语言中的结构体`。\n\n\n![对象的结构](http://upload-images.jianshu.io/upload_images/1835430-b4b5b2aa725808fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们看到了，每个类都是一个都是一个结构体，其中有各种`指针`，指向一个类的各种`参数`，`父类、属性列表、方法列表等等`。\n\n所以说当我们声明了类的方法，方法列表里面就有这个方法了，然后编译通过了，然后调用的时候，方法选择器去本类的方法列表里去寻找方法的实现，如果没有实现，则去其父类中寻找，如果在没有通过一系列`消息转发机制`会一直找下去，直到最后也没有找到这个方法的实现就crash了。关于消息转发，其实还有很多东西，但是在这里讲就又扯远了，所以等下期吧=。=\n\n本例中我们用runtime做了些什么呢？\n\n#### 使用runtime动态为category绑定属性\n\n\n之前老司机说过，category是不能添加属性的。那我又要为其添加两个标识符，只能使用runtime去`动态绑定`了，在类的`属性列表`里面`通过runtime添加`上这个属性，那我就可以使用这个属性了。\n\n首先在.h的UITableCell的category的@interface之中添加两个属性\n\n```\n@interface UITableViewCell (HeightCacheCell)\n@property (assign ,nonatomic)BOOL JustForCal;//计算用的cell标识符（将计算用的cell与正常显示的cell进行区分，避免不必要的ui响应）\n@property (assign ,nonatomic)BOOL NoAutoSizing;//不适用autoSizing标识符（不依靠约束计算，只进行自适应）\n@end\n```\n这是我为期添加的两个属性，具体有什么作用，下文中会提到的，先别急。\n\n然后在.m中添加两个属性的setter、getter方法\n\n```\n@implementation UITableViewCell (HeightCacheCell)\n#pragma mark ---setter、getter---\n-(BOOL)NoAutoSizing\n{\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n-(void)setNoAutoSizing:(BOOL)NoAutoSizing\n{\n    objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);//关键字用getter的方法名，为保持关键字一致\n}\n-(BOOL)JustForCal\n{\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n-(void)setJustForCal:(BOOL)JustForCal\n{\n    objc_setAssociatedObject(self, @selector(JustForCal), @(JustForCal), OBJC_ASSOCIATION_RETAIN);\n}\n@end\n```\n\n这里老司机有必要说一下两个方法\n\n- objc_setAssociatedObject\n- objc_getAssociatedObject\n\nOC自解释语言的好处就体现出来了，从函数名你就可以看出来，一个是给对象设置联系，一个是从对象获取联系。反正我英语水平就这样，我也没查字典，对不对的我就不深究了。一个setter一个getter就在这。\n\n##### objc_setAssociatedObject\n\nobjc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);\n\n方法总共四个参数，分别是`绑定目标，关键字，绑定者，策略`。\n\n所以说简单了，绑定目标，就是给谁绑定，当然是UITableViewCell这个category了，所以self。\n\n绑定的关键字就是说我给这个对象绑定一个属性，我总要有一个标示符去表示那个属性吧，这样我要调用这个属性的时候通过标示符去寻找才能找到这个属性。\n\n绑定者，就是我们要为这个属性绑定的值了。\n\n绑定策略就是说绑定的这个属性的引用机制了。这里要说明一点，`这个绑定策略如何选择，老司机目前也没有搞懂`，所以策略这里都沿用了原作者的写法，等老司机搞懂了之后会告诉大家的。\n\n\n##### objc_getAssociatedObject\n两个参数，一个绑定目标，一个关键字，通过关键字从绑定目标中获取属性的值。\n\n这下是不是明白这两个setter、getter方法的意义了。\n\n好了，这个category讲完了，他的东西真的很少。\n\n什么，你敲不出来这两个方法？\n忘了讲了，你没引入头文件。。。\n\n```\n #import <objc/runtime.h>\n```\n\n\n- - -\n### HeightCache\n\n为什么说这个类呢？怎么还不进入正题呢？说好的UITableView的category呢？\n\n因为这个类是`负责存储Cell高度`的类，而UITableView得category只是为获取cell高度提供了一个接口，当我们移动cell，添加cell，删除cell的时候要对这个高度的对应关系作出很多的操作，UITableView的category中`大量的使用了这里的方法`，所以老司机决定先把难啃的骨头解决了。\n\n在.h中添加三个字典\n\n```\n@property (strong ,nonatomic)NSMutableDictionary * dicHeightCacheV;//竖直行高缓存字典\n@property (strong ,nonatomic)NSMutableDictionary * dicHeightCacheH;//水平行高缓存字典\n@property (strong ,nonatomic)NSMutableDictionary * dicHeightCurrent;//当前状态行高缓存字典（中间量）\n```\n\n为什么三个字典呢？老司机是这样考虑的，`横屏和竖屏`情况下同样内容的cell有可能是不同的，如果以同一个高度去取得话有可能出现高度不准确的问题。所以竖屏横屏分别一个字典。那这个current又是什么呢？就是`自动返回当前屏幕状态所对应的字典`那么一个中间量，这样我们写代码的时候可以不用考虑当前屏幕状态而`统一使用current这个字典`，减少很多代码量。\n\n去.m中看看是如何实现的。\n\n\n```\n#pragma mark ---懒加载---\n-(NSMutableDictionary *)dicHeightCacheH\n{\n    if (!_dicHeightCacheH) {\n        _dicHeightCacheH = [NSMutableDictionary dictionary];\n    }\n    return _dicHeightCacheH;\n}\n-(NSMutableDictionary *)dicHeightCacheV\n{\n    if (!_dicHeightCacheV) {\n        _dicHeightCacheV = [NSMutableDictionary dictionary];\n    }\n    return _dicHeightCacheV;\n}\n-(NSMutableDictionary *)dicHeightCurrent//根据系统状态返回对应字典\n{\n    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation)?self.dicHeightCacheV:self.dicHeightCacheH;\n}\n```\n\n上面两个字典是懒加载，不多说了，在需要的时候创建字典。\n\n重点是这个current。\n\n`UIDeviceOrientationIsPortrait()`这个方法是判断括号中的状态是否是竖屏状态的一个方法，所以括号里面我们给他当前屏幕状态他就可以判断是不是竖屏了。\n\n[UIDevice currentDevice].orientation而这句代码见名知意，取出`当前设备的屏幕状态`。\n\n让后通过`三目运算符`返回相应的字典。\n\n是不是写法上很简单，实际使用过程中也很方便。\n\n上面几个工具方法最主要的主要由如下几个方法，`交换两个cell高度`的值，`插入一个cell高度`的值，`删除一个cell高度`的值。通过这三个最基本的方法组合出所有cell操作需要用到的方法。算法都很基础，没什么需要说的。\n\n- - -\n### UITableView的category\n\n最后的主角来了。其实你会发现这里的方法并不多。因为只是向外界提供了插入，删除，删除全部，移动，计算高度五个接口。\n\n我们看一下大体思路：\n\n\n![大体思路](http://upload-images.jianshu.io/upload_images/1835430-68cc9b817178ed3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n老司机觉得自己画这图也是没谁了。。。\n\n.h中添加一个属性，是我们刚才用来`存储高度`的那个类的一个实例。\n\n```\n@property (strong ,nonatomic)HeightCache * cache;//缓存实例\n```\n\n其实你`完全可以写在.m里当做一个私有变量去处理`，这样也`更安全`一些。\n老司机写在这里是`为了调试的时候更直观`的看到缓存高度操作时的状态。实际应用中，如无特殊需要，`建议将其写在.m中`。\n\n.m中，我们先看一下这几个工具方法，这才是核心部分。接口方法都是简单调用这几个工具方法，供外界调用的。\n- - -\n\n\n- -(__kindof UITableViewCell *)DW_CalculateCellWithIdentifier:(NSString *)identifier\n- -(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\n- -(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration\n                           \n核心算法都在这了，我一定会好好解析的。(第一个方法返回值有一个*号我敲不出来，不知道markdown什么鬼冲突。。)\n\n#### -(__kindof UITableViewCell *)DW_CalculateCellWithIdentifier:(NSString *)identifier\n第一个方法如下：\n\n```\n///从重用池中返回计算用的cell\n-(__kindof UITableViewCell *)DW_CalculateCellWithIdentifier:(NSString *)identifier\n{\n    if (!identifier.length) {\n        return nil;\n    }\n    NSMutableDictionary <NSString * ,UITableViewCell *> *DicForTheUniqueCalCell = objc_getAssociatedObject(self, _cmd);//利用runtime取出tableV绑定的存有cell的字典\n    if (!DicForTheUniqueCalCell) {\n        DicForTheUniqueCalCell = [NSMutableDictionary dictionary];//如果取不到则新建并绑定\n        objc_setAssociatedObject(self, _cmd, DicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//动态绑定（绑定目标，关键字，绑定者，策略）\n    }\n    //以上只是为了只绑定一个字典，类比懒加载\n    UITableViewCell * cell = DicForTheUniqueCalCell[identifier];\n    if (!cell) {\n        cell = [self dequeueReusableCellWithIdentifier:identifier];//从重用池中取一个cell用来计算，必须以本方式从重用池中取，若以indexPath方式取由于-heightForRowAtIndexPath方法会造成循环。\n        cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;//开启约束\n        cell.JustForCal = YES;//标记只用来计算\n        DicForTheUniqueCalCell[identifier] = cell;\n    }\n    //同上，保证只有一个用来计算的cell\n    return cell;\n}\n```\n\n其实每一句注释都表述的很清楚。不过老司机还是会一句一句给你说的，毕竟这才是老司机的风格，恩，就是`墨迹`。\n\n\n恩，老司机先说一说重用的问题吧。\n\n我们都喜欢用tableView，因为他很好的替我们做了内存控制的问题。\n\n他又是通过什么控制了内存呢？节省了性能呢？通过重用。\n\n这些大家都知道。但是有很多孩子误会了重用啊，孩子你们不懂重用啊。\n\n知道咋回事的这地方跳过吧。\n\n前方`高能预警`，以下内容`很基础`，`真的很基础`，`真的真的很基础`，只是给一些真的不知道的人看的。\n\n> 当一个cell将要离开屏幕时，这个cell会进入重用池。重用池并不是什么特殊的东西，就是系统给他放在一边了。他只是单纯的放在一边了，不进行任何操作。\n> \n> 当一个cell将要进入屏幕的时候，会调用tableView:(UITableView *)tableView cellForRowAtIndexPath这个代理，执行其中的方法\n\n说这两句为了说明什么呢？\n第一句我想说明的是，他只是放在重用池了，`没有进行任！何！操！作！`\n\n重点在哪呢？重点就在于存储的是整个cell，`包括cell原有的和你添加的所有子视图`。\n\n第二句我想说明的是，他会执行代理中的`每！一！句！话！`\n\n重点在哪呢？你从重用池中取出的cell，他是会对cell进行`再次进行绘制`。\n\n这两句说明了什么？\n\n- cell上不要布置太多的控件，不然存入重用池也够你吃一壶的。\n- tableView:(UITableView *)tableView cellForRowAtIndexPath这里面不要添加子视图，不然下次取出同一个cell的时候还会在同样的位置再添加一个同样的子视图。你上下来回滑动的时候cell就会添加无数个子视图。\n- 没有什么会影响重新绘制的，记住那句代码一定会走，只要走就一定会绘制。如果说你绘制出了什么问题，不要怪重用，跟他没关。问题一定在别的地方。\n\n恩，这是老司机对重用的理解。\n\n**刚才跳过的旅客朋友们，跳到这可以接上了。**\n\n接下来我们开始说这个方法。\n为什么我们要取到这个cell呢？而不是随便一个cell呢？\n\n因为我们无法保证或者指定只使用一种cell，很多情况下我们是自定义的cell。这样的话每个不同种类的cell上的子视图是不相同的，在自动计算高度的时候对cell的布局有很高要求，所以我们一定要`保证我们计算用的cell与展示用的cell是同一种cell`。\n\n所以说我们这个方法只有`一个参数`，identifier。因为他是从重用池中取出cell的唯一必要参数。\n\n首先为了安全，先判断传入的identifier`是否为空`，若为空返回nil。只是为了安全。还有代码的`严谨性`。老司机又吹牛逼了，还代码严谨性，我的代码通常都考虑不周全的。。。\n\n然后是`通过runtime从绑定的属性中取出一个字典`。如果取到的这个字典为空则创建一个字典并绑定。\n\n为什么要创建一个字典呢，因为`我们要保证只取到这一个cell`。这个cell是为了干什么的呢，就是为了计算高度的，那么我每次计算高度的时候`只要有这么一个cell`就好了，不要去初始化太多根本不用于显示只用于计算的cell。\n\n然后`从字典中取出我们的cell`，如果取出的cell为空，则从重用池中取出一个cell。并存入字典。\n\n首先字典和cell的判空，都是针对第一次计算cell高度的时候来的。再次进入的时候都不会为空。\n必须要说明的是，从重用池中取出cell的方法我们`一定`要使用`dequeueReusableCellWithIdentifier:`这种方式去取，不能以dequeueReusableCellWithIdentifier:indexPath那种方式去取。\n\n就像老司机注释中说的一样，若以indexPath那种方式去取会造成鸡生蛋蛋生鸡的问题，你这程序就进入死循环了。\n\n然后cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;这句是做什么呢？事实上，有两种自动布局方式，autoResizing和autoLayout。\nautoResizing是`UIView的固有属性`。是在IOS6之前用来实现自动布局的属性。当然IOS6之后的autoLayout就要比他强大不少了。\n\n事实上这个属性`默认情况下是YES`。当为YES时，则我们`设置约束是无效`的。因为后续我们要手动`添加一个约束辅助我们计算`，所以这里我们`将其设为NO`。\n\n然后将计算标识符置真，标识这个cell只参与计算高度，不负责展示。以后遇到批量处理cell的时候可以判断这个标识符，让其不参与运算。`当然老司机这里只是留了一个接口，实际我们有对其进行处理`。\n\n通过这个方法，我们就成功的拿到了一个计算高度用的cell。\n- - - \n#### -(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\n第二个方法：\n\n```\n///根据cell计算cell的高度\n-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\n{\n    CGFloat width = self.bounds.size.width;\n    //根据辅助视图校正width\n    if (cell.accessoryView) {\n        width -= cell.accessoryView.bounds.size.width + 16;\n    }\n    else\n    {\n        static const CGFloat accessoryWidth[] = {\n            [UITableViewCellAccessoryNone] = 0,\n            [UITableViewCellAccessoryDisclosureIndicator] = 34,\n            [UITableViewCellAccessoryDetailDisclosureButton] = 68,\n            [UITableViewCellAccessoryCheckmark] = 40,\n            [UITableViewCellAccessoryDetailButton] = 48\n        };\n        width -= accessoryWidth[cell.accessoryType];\n    }\n    CGFloat height = 0;\n    if (!cell.NoAutoSizing && width > 0) {//如果不是非自适应模式则添加约束后计算约束后高度\n        NSLayoutConstraint * widthConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:width];//创建约束\n        [cell.contentView addConstraint:widthConstraint];//添加约束\n        height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;//计算高度\n        [cell.contentView removeConstraint:widthConstraint];//移除约束\n    }\n    if (height == 0) {//如果约束错误可能导致计算结果为零，则以自适应模式再次计算\n        height = [cell sizeThatFits:CGSizeMake(width, 0)].height;\n    }\n    if (height == 0) {//如果计算仍然为0，则给出默认高度\n        height = 44;\n    }\n    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) {//如果不为无分割线模式则添加分割线高度\n        height += 1.0 /[UIScreen mainScreen].scale;\n    }\n    return height;\n}\n```\n\n**首先我们要想计算出我们cell的高度，就需要拿到cell的`contentView的实际宽度`。**\n\n1.先拿到cell的宽度\n\n2.根据辅助视图样式校正宽度\n\n\n如果有自定义辅助视图，则按照自定义辅助视图的宽度去校正，如果没有按照系统辅助视图样式去校正宽度，然后`根据宽度计算高度`。\n\n3.然后如果是`使用autoLayout进行自适应计算`。\n\n这个也是老司机为之后留下的接口，可以控制是否进行一autoLayout进行计算。但实际并没有处理。\n\n这里是添加约束的写法，先`添加一个宽度约束`，然后让系统`根据宽度约束自动计算高度`，接着`去掉我们添加的约束`。\n\n4.如果根据约束计算结果错误，则`以sizeThatFits去计算高度`。\n\n5.如果计算结果仍然为零，则给出`默认值44`。\n\n6.判断当前tableView的分割线样式，如果有分割线，还要`校正高度`。\n\n好了，至此你已经计算出这个cell应该有的高度了。\n\n- - -\n#### -(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration\n最后一个方法：\n\n```\n///根据重用表示取出cell并操作cell后，计算高度\n-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier\n                           configuration:(void(^)(id cell))configuration\n{\n    if (!identifier.length) {\n        return 0;\n    }\n    UITableViewCell * cell = [self DW_CalculateCellWithIdentifier:identifier];\n    [cell prepareForReuse];//放回重用池\n    if (configuration) {\n        configuration(cell);//对cell进行操作\n   }\n回重用池\n    return [self DW_CalculateCellHeightWithCell:cell];\n}\n\n```\n\n这个方法就比较简单了，先判断重用标示。如果空，直接返回0。还是只为了安全。\n\n再通过`第一个方法取出cell`，然后`将它放回重用池`，以至于下次`我们还能取出来这个cell`。\n\n不要在意我之后还要对cell进行操作，这个`重用池只是一个概念`，其实并不是什么东西，只是标志着这里面的cell可以用于重用，你完全可以理解成他只是cell的一个标签。所以我之后还是可以继续使用这个cell。不要纠结重用池、取出、放回了，少年，他只是一个概念。\n\n哦对了，另外有一点你要注意，你记不记得老司机说过，进入重用池，是将整个cell存储下来，`并没有做其他任何操作`。\n\n\n其实你可以`重写prepareForReuse这个方法`，这里可以做任何你想做的事。比如清除所有子视图。不过有三点你需要注意：\n\n- 别忘了先写[super prepareForReuse];\n- 真清除所有子视图的时候记得别把contentView也删了\n- 重写之后上面的程序中你要合理的考虑一下[cell prepareForReuse]这句话的位置，反正这么跟你讲，我是没想出来放哪。。\n\n最后就是返回高度了。终于完事了。\n\n- - -\n### 留给外界的接口\n\n#### -(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier indexPath:(NSIndexPath *)indexPath configuration:(void(^)(id cell))configuration\n\n\n我只说一个，这是最重要的一个返回高度的接口了，如果每次我们都计算高度，那我们这写法也算是废了，充其量算一个自动返回高度的算法。\n\n所以我们的逻辑应该是`先从cache里面中找，如果没有，计算并存储`。下次再找这个indexPath的时候就能找到了，正如下面的代码一样。\n\n```\n-(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier\n                               indexPath:(NSIndexPath *)indexPath\n                           configuration:(void(^)(id cell))configuration\n{\n    if(self.bounds.size.width != 0)//防止初始宽度为0（如autoLayout初次加载时）\n    {\n        if (!identifier.length || !indexPath) {//非空判断\n            return 0;\n        }\n        NSString * key = [self.cache makeKeyWithIdentifier:identifier indexPath:indexPath];//制作key\n        if ([self.cache existInCacheByKey:key]) {//如果key存在\n            return [self.cache heightFromCacheWithKey:key];//从字典中取出高\n        }\n        CGFloat height = [self DW_CalCulateCellWithIdentifier:identifier configuration:configuration];//不存在则计算高度\n        [self.cache cacheHeight:height byKey:key];//并缓存\n        return height;\n    }\n    return 0;\n}\n```\n\n\n- -- \n### 最后关于如何使用\n\n就是在原来返回tableView高度的方法出调用上面那个方法，仅此而已。\n\n特别注意，`一定要在方法中先填充数据，一定要在方法中先填充数据，一定要在方法中先填充数据`。重要的事情说三遍。否则你永远都是44啊亲们。。\n\n\n![注入数据](http://upload-images.jianshu.io/upload_images/1835430-b6f493667866eee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- - -\n\n我知道今天这个教程看上去很抽象，所以这次我会附上demo的链接。\n\n[demo地址](http://pan.baidu.com/s/1dFK6iHV)\n\n不过老司机还是想说一下自己对demo这件事的看法。\n\n老司机能选择在这里分享一些自己学到的东西，自然就不是一个敝帚自珍的人。然而之所以不爱附上demo链接是因为老司机觉得每次我都已经很详细的在博客中贴出我全部代码而且一句一句讲解真的已经知无不言言无不尽了，我觉得编程这种东西还是得下手敲一遍，看别人的东西看一天也看不懂。所以我更提倡你们自己去敲一遍。如果我把demo链接一放出来，你们直接下载了就去看，就去改，真的没有自己敲一遍学的快。当然有同学实在有需要可以留下邮箱，老司机会给你单独发demo的。\n- - -\n\n常用套话了，这么贪幕虚荣的老司机不就图你点个喜欢么=。=，觉得好点个喜欢吧。\n\n转载记得附上链接。\nhttp://www.jianshu.com/p/2b192257276f\n","source":"_posts/TableView优化之高度缓存.md","raw":"---\n\ntitle: TableView优化之高度缓存\nlayout: post\ndate: 2016-06-04 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- TableView优化 \n- 高度缓存\ncategories: 性能优化\n\n---\n\n![TableView优化之高度缓存](http://upload-images.jianshu.io/upload_images/1835430-a69cecb9aaa3f2d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n系列文章：\n\n- [TableView优化之高度缓存功能](http://www.jianshu.com/p/2b192257276f)\n\n- [TableView优化之加载图片的优化逻辑](http://www.jianshu.com/p/328e503900d0)\n\n- [TableView优化之快速滑动下的忽略加载](http://www.jianshu.com/p/0b020518de5e)\n- - -\n\n日常开发中，tableView的使用率很高，所以相对tableView的优化来说可以做很多很多的事情。很多情况下，我们的每一个cell都没有一个固定的高度，而是根据cell里面的内容自适应高度的。那么每次当我们cell将要出现在屏幕的时候，系统都会去计算cell的高度。如果说我能通过某种手段，在首次计算的时候，将每个cell对应的高度保存下载，当下次需要用到cell高度的时候再从保存的地方取出，从而减少了计算量，来达到优化的目的。\n\n因此应运而生了这套高度缓存的算法。\n\n在此声明，这套算法`不是老司机原创`，是整合并优化了外国一位大神的源码。\n\n**再次声明，**\n这原来是国人算法，扬我国威啊，原型名\nUITableView-FDTemplateLayoutCell。\n\n\n- - -\n这篇博客中你可能会用到\n\n- category 、subclass、protocol之间的区别\n- 自动布局相关\n- runTime动态绑定\n- tableViewCell重用的相关\n\n恩，其实东西并不多，重要的还是一个思想。\n\n<!-- more -->\n\n---\n\n## 全部代码\n\n老规矩，还是先放全部代码。\n\n```\n#import \"UITableView+HeightCache.h\"\n#import <objc/runtime.h>\n@implementation UITableView (HeightCache)\n\n#pragma mark ---接口方法---\n-(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier\n                               indexPath:(NSIndexPath *)indexPath\n                           configuration:(void(^)(id cell))configuration\n{\n    if(self.bounds.size.width != 0)//防止初始宽度为0（如autoLayout初次加载时）\n    {\n        if (!identifier.length || !indexPath) {//非空判断\n            return 0;\n        }\n        NSString * key = [self.cache makeKeyWithIdentifier:identifier indexPath:indexPath];//制作key\n        if ([self.cache existInCacheByKey:key]) {//如果key存在\n            return [self.cache heightFromCacheWithKey:key];//从字典中取出高\n        }\n        CGFloat height = [self DW_CalCulateCellWithIdentifier:identifier configuration:configuration];//不存在则计算高度\n        [self.cache cacheHeight:height byKey:key];//并缓存\n        return height;\n    }\n    return 0;\n}\n-(void)DW_RemoveHeightCacheWithIdentifier:(NSString *)identifier\n                                indexPath:(NSIndexPath *)indexPath\n                             numberOfRows:(NSInteger)rows\n{\n    [self.cache removeHeightByIdentifier:identifier indexPath:indexPath numberOfRows:rows];\n}\n-(void)DW_RemoveAllHeightCache\n{\n    [self.cache removeAllHeight];\n}\n-(void)DW_InsertCellToIndexPath:(NSIndexPath *)indexPath\n                 withIdentifier:(NSString *)identifier\n                   numberOfRows:(NSInteger)rows\n{\n    [self.cache insertCellToIndexPath:indexPath withIdentifier:identifier numberOfRows:rows toDictionaryForCache:self.cache.dicHeightCurrent];\n}\n-(void)DW_MoveCellFromIndexPath:(NSIndexPath *)sourceIndexPath\n    sourceIndexPathNumberOfRows:(NSInteger)sourceRows\n                    toIndexPath:(NSIndexPath *)destinationIndexPath\ndestinationIndexPathNumberOfRows:(NSInteger)destinationRows\n                 withIdentifier:(NSString *)identifier\n{\n    [self.cache moveCellFromIndexPath:sourceIndexPath sourceSectionNumberOfRows:sourceRows toIndexPath:destinationIndexPath destinationSectionNumberOfRows:destinationRows withIdentifier:identifier];\n}\n#pragma mark ---工具方法---\n///从重用池中返回计算用的cell\n-(__kindof UITableViewCell  *)DW_CalculateCellWithIdentifier:(NSString *)identifier\n{\n    if (!identifier.length) {\n        return nil;\n    }\n    NSMutableDictionary <NSString * ,UITableViewCell *> *DicForTheUniqueCalCell = objc_getAssociatedObject(self, _cmd);//利用runtime取出tableV绑定的存有cell的字典\n    if (!DicForTheUniqueCalCell) {\n        DicForTheUniqueCalCell = [NSMutableDictionary dictionary];//如果取不到则新建并绑定\n        objc_setAssociatedObject(self, _cmd, DicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//动态绑定（绑定目标，关键字，绑定者，策略）\n    }\n    //以上只是为了只绑定一个字典，类比懒加载\n    UITableViewCell * cell = DicForTheUniqueCalCell[identifier];\n    if (!cell) {\n        cell = [self dequeueReusableCellWithIdentifier:identifier];//从重用池中取一个cell用来计算，必须以本方式从重用池中取，若以indexPath方式取由于-heightForRowAtIndexPath方法会造成循环。\n        cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;//开启约束\n        cell.JustForCal = YES;//标记只用来计算\n        DicForTheUniqueCalCell[identifier] = cell;\n    }\n    //同上，保证只有一个用来计算的cell\n    return cell;\n}\n\n///根据重用表示取出cell并操作cell后，计算高度\n-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier\n                           configuration:(void(^)(id cell))configuration\n{\n    if (!identifier.length) {\n        return 0;\n    }\n    UITableViewCell * cell = [self DW_CalculateCellWithIdentifier:identifier];\n    [cell prepareForReuse];//放回重用池\n    if (configuration) {\n        configuration(cell);//对cell进行操作\n    }    \n    return [self DW_CalculateCellHeightWithCell:cell];\n}\n\n///根据cell计算cell的高度\n-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\n{\n    CGFloat width = self.bounds.size.width;\n    //根据辅助视图校正width\n    if (cell.accessoryView) {\n        width -= cell.accessoryView.bounds.size.width + 16;\n    }\n    else\n    {\n        static const CGFloat accessoryWidth[] = {\n            [UITableViewCellAccessoryNone] = 0,\n            [UITableViewCellAccessoryDisclosureIndicator] = 34,\n            [UITableViewCellAccessoryDetailDisclosureButton] = 68,\n            [UITableViewCellAccessoryCheckmark] = 40,\n            [UITableViewCellAccessoryDetailButton] = 48\n        };\n        width -= accessoryWidth[cell.accessoryType];\n    }\n    CGFloat height = 0;\n    if (!cell.NoAutoSizing && width > 0) {//如果不是非自适应模式则添加约束后计算约束后高度\n        NSLayoutConstraint * widthConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:width];//创建约束\n        [cell.contentView addConstraint:widthConstraint];//添加约束\n        height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;//计算高度\n        [cell.contentView removeConstraint:widthConstraint];//移除约束\n    }\n    if (height == 0) {//如果约束错误可能导致计算结果为零，则以自适应模式再次计算\n        height = [cell sizeThatFits:CGSizeMake(width, 0)].height;\n    }\n    if (height == 0) {//如果计算仍然为0，则给出默认高度\n        height = 44;\n    }\n    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) {//如果不为无分割线模式则添加分割线高度\n        height += 1.0 /[UIScreen mainScreen].scale;\n    }\n    return height;\n}\n\n#pragma mark ---setter、getter---\n-(HeightCache *)cache//懒加载形式\n{\n    HeightCache * cacheTemp = objc_getAssociatedObject(self, _cmd);\n    if (!cacheTemp) {\n        cacheTemp = [HeightCache new];\n        objc_setAssociatedObject(self, _cmd, cacheTemp, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    }\n    return cacheTemp;\n}\n-(void)setCache:(HeightCache *)cache\n{\n    objc_setAssociatedObject(self, @selector(cache), cache, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n@end\n\n\n@implementation UITableViewCell (HeightCacheCell)\n#pragma mark ---setter、getter---\n-(BOOL)NoAutoSizing\n{\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n-(void)setNoAutoSizing:(BOOL)NoAutoSizing\n{\n    objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);//关键字用getter的方法名，为保持关键字一致\n}\n-(BOOL)JustForCal\n{\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n-(void)setJustForCal:(BOOL)JustForCal\n{\n    objc_setAssociatedObject(self, @selector(JustForCal), @(JustForCal), OBJC_ASSOCIATION_RETAIN);\n}\n@end\n\n@implementation HeightCache\n///制作key\n-(NSString *)makeKeyWithIdentifier:(NSString *)identifier\n                         indexPath:(NSIndexPath *)indexPath\n{\n    return [NSString stringWithFormat:@\"%@S%ldR%ld\",identifier,indexPath.section,indexPath.row];\n}\n\n///高度是否存在\n-(BOOL)existInCacheByKey:(NSString *)key\n{\n    NSNumber * value = [self.dicHeightCurrent valueForKey:key];\n    return (value && ![value isEqualToNumber:@-1]);\n}\n\n///取出缓存的高度\n-(CGFloat)heightFromCacheWithKey:(NSString *)key\n{\n    NSNumber * value = [self.dicHeightCurrent valueForKey:key];\n    if ([self is64bit]) {\n        return [value doubleValue];\n    }\n    return [value floatValue];\n}\n\n///64位判断\n- (BOOL)is64bit\n{\n#if defined(__LP64__) && __LP64__\n    return YES;\n#else\n    return NO;\n#endif\n}\n\n///高度缓存\n-(void)cacheHeight:(CGFloat)height\n             byKey:(NSString *)key\n{\n    [self.dicHeightCurrent setValue:@(height) forKey:key];\n}\n\n///根据key删除缓存\n-(void)removeHeightByIdentifier:(NSString *)identifier\n                      indexPath:(NSIndexPath *)indexPath\n                   numberOfRows:(NSInteger)rows\n{\n    if (indexPath.row < rows) {\n        for (int i = 0; i < rows - 1 - indexPath.row; i ++) {\n            NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:indexPath.row + i inSection:indexPath.section];\n            NSLog(@\"%ld,%ld\",indexPathA.row,indexPathA.section);\n            NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:indexPath.row + i + 1 inSection:indexPath.section];\n            NSLog(@\"%ld,%ld\",indexPathB.row,indexPathB.section);\n            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheH];\n            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheV];\n        }\n        NSIndexPath * indexPathC = [NSIndexPath indexPathForRow:rows - 1 inSection:indexPath.section];\n        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:indexPathC];\n        [self.dicHeightCacheH removeObjectForKey:key];\n        [self.dicHeightCacheV removeObjectForKey:key];\n    }\n}\n\n///删除所有缓存\n-(void)removeAllHeight\n{\n    [self.dicHeightCacheH removeAllObjects];\n    [self.dicHeightCacheV removeAllObjects];\n}\n\n///插入cell是插入value\n-(void)insertCellToIndexPath:(NSIndexPath *)indexPath\n            withNumberOfRows:(NSInteger)rows\n                heightNumber:(NSNumber *)height\n                  identifier:(NSString *)identifier\n        toDictionaryForCache:(NSMutableDictionary *)dic\n{\n    if (indexPath.row < rows + 1) {\n        [self insertCellToIndexPath:indexPath withIdentifier:identifier numberOfRows:rows toDictionaryForCache:dic];\n        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:indexPath];\n        [dic setValue:height forKey:key];\n    }\n}\n-(void)insertCellToIndexPath:(NSIndexPath *)indexPath withIdentifier:(NSString *)identifier numberOfRows:(NSInteger)rows toDictionaryForCache:(NSMutableDictionary *)dic\n{\n    if (indexPath.row < rows + 1) {\n        for (int i = 0; i < rows - indexPath.row; i ++) {\n            NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:rows - i inSection:indexPath.section];\n            NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:rows - i - 1 inSection:indexPath.section];\n            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:dic];\n        }\n    }\n}\n///移动cell时交换value\n-(void)moveCellFromIndexPath:(NSIndexPath *)sourceIndexPath\n   sourceSectionNumberOfRows:(NSInteger)sourceRows\n                 toIndexPath:(NSIndexPath *)destinationIndexPath\ndestinationSectionNumberOfRows:(NSInteger)destinationRows\n              withIdentifier:(NSString *)identifier\n{\n    if (sourceIndexPath.section == destinationIndexPath.section) {\n        [self moveCellInSectionFromIndexPath:sourceIndexPath toIndexPath:destinationIndexPath withIdentifier:identifier];\n    }\n    else\n    {\n        [self moveCellOutSectionFromIndexPath:sourceIndexPath sourceSectionNumberOfRows:sourceRows toIndexPath:destinationIndexPath destinationSectionNumberOfRows:destinationRows withIdentifier:identifier];\n    }\n}\n///组内移动\n-(void)moveCellInSectionFromIndexPath:(NSIndexPath *)sourceIndexPath\n                          toIndexPath:(NSIndexPath *)destinationIndexPath\n                       withIdentifier:(NSString *)identifier\n{\n    NSInteger rowA = sourceIndexPath.row;\n    NSInteger rowB = destinationIndexPath.row;\n    for (int i = 0; i < (MAX(rowA, rowB) - MIN(rowA, rowB)); i ++) {\n        NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:MIN(rowA, rowB) + i inSection:sourceIndexPath.section];\n        NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:MIN(rowA, rowB) + i + 1 inSection:sourceIndexPath.section];\n        [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheV];\n        [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheH];\n    }\n}\n///组外移动\n-(void)moveCellOutSectionFromIndexPath:(NSIndexPath *)sourceIndexPath\n             sourceSectionNumberOfRows:(NSInteger)sourceRows\n                           toIndexPath:(NSIndexPath *)destinationIndexPath\n        destinationSectionNumberOfRows:(NSInteger)destinationRows\n                        withIdentifier:(NSString *)identifier\n{\n    NSNumber * numberH;\n    NSNumber * numberV;\n    NSLog(@\"%ld\",sourceIndexPath.row);\n    if (sourceIndexPath.row < sourceRows) {\n        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:sourceIndexPath];\n        numberH = self.dicHeightCacheH[key];\n        numberV = self.dicHeightCacheV[key];\n        [self removeHeightByIdentifier:identifier indexPath:sourceIndexPath numberOfRows:sourceRows];\n    }\n    NSLog(@\"%ld,%ld\",destinationIndexPath.row,destinationIndexPath.section);\n    [self insertCellToIndexPath:destinationIndexPath withNumberOfRows:destinationRows heightNumber:numberH identifier:identifier toDictionaryForCache:self.dicHeightCacheH];\n    [self insertCellToIndexPath:destinationIndexPath withNumberOfRows:destinationRows heightNumber:numberV identifier:identifier toDictionaryForCache:self.dicHeightCacheV];\n}\n///根据indexPath交换两个Key\n-(void)exchangeValueForIndexPathA:(NSIndexPath *)indexPathA\n                    andIndexPathB:(NSIndexPath *)indexPathB\n                   withIdentifier:(NSString *)identifier\n                       dictionary:(NSMutableDictionary *)dic\n{\n    NSString * keyA = [self makeKeyWithIdentifier:identifier indexPath:indexPathA];\n    NSString * keyB = [self makeKeyWithIdentifier:identifier indexPath:indexPathB];\n    NSNumber * Temp = dic[keyA];\n    dic[keyA] = dic[keyB];\n    dic[keyB] = Temp;\n}\n#pragma mark ---懒加载---\n-(NSMutableDictionary *)dicHeightCacheH\n{\n    if (!_dicHeightCacheH) {\n        _dicHeightCacheH = [NSMutableDictionary dictionary];\n    }\n    return _dicHeightCacheH;\n}\n-(NSMutableDictionary *)dicHeightCacheV\n{\n    if (!_dicHeightCacheV) {\n        _dicHeightCacheV = [NSMutableDictionary dictionary];\n    }\n    return _dicHeightCacheV;\n}\n-(NSMutableDictionary *)dicHeightCurrent//根据系统状态返回对应字典\n{\n    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation)?self.dicHeightCacheV:self.dicHeightCacheH;\n}\n@end\n\n```\n\n``这么多，你这个骗子！``\n你是不是这么想得。\n\n别慌，东西不多，因为这是一个category，复用性非常高，所以老司机想尽量减少文件个数，这样集成的时候也方便不是。\n\n所以，老司机`把三个类写在一个文件里了`。\n\n之前有人问过我把几个类写在一个文件中`有什么好处么`？\n\n老司机目前只能说，`除了看上去装逼点，别的没什么卵用`。\n\n可能是老司机的理解不深，不过为了集成方便我还是写在一个文件里了。\n\n废话不多说，分段讲解吧。\n- - -\n## 分段解析\n### 为什么选择category而不是subclass\n\n我想很多人都会有疑问，为什么选择category而不是继承，毕竟category不能添加属性,用起来不是很方便。说到这又要老生常谈了。\n\n>Protocol只是声明一套接口，并不能提供具体实现，变相的也算是一种抽象基类的实现方式（OC本身语法并不支持抽象基类）。\n\n>Category可以为已有的类提供额外的接口和具体的实现。\n\n>Protocol只能提供一套公用的接口声明，并不能提供具体实现，它的行为是，我只负责声明，而不管谁去实现，去如何实现。这样的话，我定义一套接口，可以使任意的类都用不同的方式去实现接口中的方法，就是为遵守了protocol的类提供了一些额外访问这个类的一些接口，像delegate和dataSource用protocol实现是最好的。\n\n>Category是对一个功能完备的类的一种补充、扩展，就像一个东西基本功能都完成了，可以用category为这个类添加不同的组件，使得这个类能够适应不同情况的需求（但是这些不同需求最核心的需求要一致）。当然，当某个类非常大的时候，使用category可以按照不同的功能将类的实现分在不同的模块中。还有，虽然category可以访问已有类的实例变量，但不能创建新的实例变量，如果要创建新的实例变量，请使用继承。\n\n>继承，它基于Protocol和Category之间，既可以像protocol一样只提供纯粹的接口，也可以像Category一样提供接口的完整实现，可以自由定义类的实例变量（这一点，Protocol倒是可以声明实例变量，但是也仅仅是声明而已），而且继承还可以对类以后的方法进行改写，所以继承的力量是最强大的。\n\n>在iOS开发中，继承是完全可以完成protocol和category的功能的，那么在开发过程中多多使用继承体系可好？\n\n>需要注意的是使用继承还有很大的代价问题。使用继承来进行扩展是一种耦合度很高的行为，对父类可以说是完全依赖，如果继承体系太过复杂，会造成难以维护的问题。如果仅仅只是对类进行扩展，并不建议使用继承，毕竟使用protocol和category是很简单、轻松的。除此之外，在开发过程中，我们应该尽量将界面、功能相似的类的代码提取到基类里面，然后各个子类继承自这个基类，实现各自的其他特殊部分。这样可以大大的优化代码，如果需要修改的话，只需要这倒对应子类修改即可。\n\n是不是感觉老司机屌屌的，啧啧啧，我百度的。\n\n我选择category就一个原因，扩展方便，二次开发也方便。\n\n---\n\n### 类目拆解\n老司机说过，这一坨代码是三个类写在了一个文件里，他们都是什么呢？\n\n- UITableView的category\n- UITableViewCell的category\n- 一个NSObject的子类\n\n他们分别是做什么的呢？\n\n首先，给UITableView添加category是因为为了`实现高度缓存`，我的方案是在计算高度的时候就模拟数据填充，从而计算出该cell的高度，所以，tableView应该有填充数据和计算高度的方法。故为其添加分类。\n\n而那个继承于NSObject的子类就是用来`存储计算出来的高度的`，这样当下次需要计算的时候直接从这里取出即可。\n\n至于那个UITableViewCell的类目是为了`给cell添加两个标识符`，一个用来判断当前cell是否需要一autolayout进行绘制，另一个是用来区分计算用的cell还是展示用的cell。这点现在可能你还不懂，一会我们会做相应介绍。\n\n---\n### UITableViewCell的category\n\n为什么先说这个类目呢，因为这个类目的内容最少，而且只用到了runtime的动态绑定，可以拿出来单独介绍一下runtime的相关知识。\n\n#### 什么是runtime\nrun，运行，time，时间，那么runtime就是运行时。恩，简单不？\n然后我们说说。。。诶诶诶，别打别打，开个玩笑。\nruntime，简称运行时，是`系统在运行期间的一些机制`。而对于OC来讲呢，其中最重要的就是`消息机制`。\n\nC语言呢，我们`调用函数`，在`编译期`就已经确定了要调用那个函数，而且整个过程是`顺序执行`的。\n\n而在OC中呢，我们是讲`消息发送`的。而且我们是等待某个信号`触发才执行`代码的。我们知道OC事实上是基于C的，那他是怎么实现这套转换的呢？就是`通过runtime去实现`的。\n\n不信？不信跟我来做个试验。\n\n新开一个工程，删掉所有文件，只`留下info.plist和main.m`。并且将引入的头文件删除掉。\n\n再`建一个类`，里面随便写一个方法的声明和实现。\n\n然后`在main.m中引入这个类`，`初始化并调用刚才声明的方法`，如下图。\n\n\n![新建一个工程](http://upload-images.jianshu.io/upload_images/1835430-7d31aa53377e7333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n此时，打开我们的终端。找到刚才的工程的main.m,并且输入\n`clang -rewrite-objc main.m`，点击回车。稍等你就会看到提示转换完成。\n\n![转化我们的文件](http://upload-images.jianshu.io/upload_images/1835430-0056ec0cb777ee26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n这回在finder中找到工程的文件夹，在main.m同级文件夹下多了一个文件`main.cpp`，这就是转换完的文件。我们看到代码还是很多的。`直接拖到最下方`我们大概能看到点认识的了，int main。。。\n\n这就是我们刚才`main函数里面的实现`。\n\n![找到实现](http://upload-images.jianshu.io/upload_images/1835430-fc8be701d9be1b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看不懂？待我帮你捋捋，去掉一些类型转换用的修饰符后剩下如下代码，是不是清晰多了？\n\n![姑且就叫化简吧](http://upload-images.jianshu.io/upload_images/1835430-4421b3ad6ca6a611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n先看被我框选中的代码，`objc_msgSend是说发送消息`，他有`两个参数`，一个是`实例`，一个是`方法`。`objc_getClass通过字符串获取到这个类`。`sel_registerName通过字符串获取方法`。所以这句话的意思就是`给这个类发送了这个消息，消息内容就是一个方法`。\n\n随后就容易了，给这个实例发送一个sayHello的消息，参数是后面的字符串。\n\n通过这里我们知道我们OC的语言是怎么实现的了吧，就是`通过runtime转化成了C++的代码`，然后进行运行。\n\n从这你也应该知道为什么OC中叫`发送消息`，不叫函数调用了吧。\n\n另外你还应该知道为什么OC中方法`只声明`，`不实现`，`编译时只报警不报错`，`运行时crash`是为什么了吧。\n\n既然说到这里就多少说一说C与OC吧。之前老司机说过，OC是基于C的，那么C语言中是没有对象这个概念呢，我们的对象又是什么呢？\n\n**右手啊，程序员哪有什么对象，啧啧啧。**\n\n除了右手，还有结构体，OC的对象就是`C语言中的结构体`。\n\n\n![对象的结构](http://upload-images.jianshu.io/upload_images/1835430-b4b5b2aa725808fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们看到了，每个类都是一个都是一个结构体，其中有各种`指针`，指向一个类的各种`参数`，`父类、属性列表、方法列表等等`。\n\n所以说当我们声明了类的方法，方法列表里面就有这个方法了，然后编译通过了，然后调用的时候，方法选择器去本类的方法列表里去寻找方法的实现，如果没有实现，则去其父类中寻找，如果在没有通过一系列`消息转发机制`会一直找下去，直到最后也没有找到这个方法的实现就crash了。关于消息转发，其实还有很多东西，但是在这里讲就又扯远了，所以等下期吧=。=\n\n本例中我们用runtime做了些什么呢？\n\n#### 使用runtime动态为category绑定属性\n\n\n之前老司机说过，category是不能添加属性的。那我又要为其添加两个标识符，只能使用runtime去`动态绑定`了，在类的`属性列表`里面`通过runtime添加`上这个属性，那我就可以使用这个属性了。\n\n首先在.h的UITableCell的category的@interface之中添加两个属性\n\n```\n@interface UITableViewCell (HeightCacheCell)\n@property (assign ,nonatomic)BOOL JustForCal;//计算用的cell标识符（将计算用的cell与正常显示的cell进行区分，避免不必要的ui响应）\n@property (assign ,nonatomic)BOOL NoAutoSizing;//不适用autoSizing标识符（不依靠约束计算，只进行自适应）\n@end\n```\n这是我为期添加的两个属性，具体有什么作用，下文中会提到的，先别急。\n\n然后在.m中添加两个属性的setter、getter方法\n\n```\n@implementation UITableViewCell (HeightCacheCell)\n#pragma mark ---setter、getter---\n-(BOOL)NoAutoSizing\n{\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n-(void)setNoAutoSizing:(BOOL)NoAutoSizing\n{\n    objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);//关键字用getter的方法名，为保持关键字一致\n}\n-(BOOL)JustForCal\n{\n    return [objc_getAssociatedObject(self, _cmd) boolValue];\n}\n-(void)setJustForCal:(BOOL)JustForCal\n{\n    objc_setAssociatedObject(self, @selector(JustForCal), @(JustForCal), OBJC_ASSOCIATION_RETAIN);\n}\n@end\n```\n\n这里老司机有必要说一下两个方法\n\n- objc_setAssociatedObject\n- objc_getAssociatedObject\n\nOC自解释语言的好处就体现出来了，从函数名你就可以看出来，一个是给对象设置联系，一个是从对象获取联系。反正我英语水平就这样，我也没查字典，对不对的我就不深究了。一个setter一个getter就在这。\n\n##### objc_setAssociatedObject\n\nobjc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);\n\n方法总共四个参数，分别是`绑定目标，关键字，绑定者，策略`。\n\n所以说简单了，绑定目标，就是给谁绑定，当然是UITableViewCell这个category了，所以self。\n\n绑定的关键字就是说我给这个对象绑定一个属性，我总要有一个标示符去表示那个属性吧，这样我要调用这个属性的时候通过标示符去寻找才能找到这个属性。\n\n绑定者，就是我们要为这个属性绑定的值了。\n\n绑定策略就是说绑定的这个属性的引用机制了。这里要说明一点，`这个绑定策略如何选择，老司机目前也没有搞懂`，所以策略这里都沿用了原作者的写法，等老司机搞懂了之后会告诉大家的。\n\n\n##### objc_getAssociatedObject\n两个参数，一个绑定目标，一个关键字，通过关键字从绑定目标中获取属性的值。\n\n这下是不是明白这两个setter、getter方法的意义了。\n\n好了，这个category讲完了，他的东西真的很少。\n\n什么，你敲不出来这两个方法？\n忘了讲了，你没引入头文件。。。\n\n```\n #import <objc/runtime.h>\n```\n\n\n- - -\n### HeightCache\n\n为什么说这个类呢？怎么还不进入正题呢？说好的UITableView的category呢？\n\n因为这个类是`负责存储Cell高度`的类，而UITableView得category只是为获取cell高度提供了一个接口，当我们移动cell，添加cell，删除cell的时候要对这个高度的对应关系作出很多的操作，UITableView的category中`大量的使用了这里的方法`，所以老司机决定先把难啃的骨头解决了。\n\n在.h中添加三个字典\n\n```\n@property (strong ,nonatomic)NSMutableDictionary * dicHeightCacheV;//竖直行高缓存字典\n@property (strong ,nonatomic)NSMutableDictionary * dicHeightCacheH;//水平行高缓存字典\n@property (strong ,nonatomic)NSMutableDictionary * dicHeightCurrent;//当前状态行高缓存字典（中间量）\n```\n\n为什么三个字典呢？老司机是这样考虑的，`横屏和竖屏`情况下同样内容的cell有可能是不同的，如果以同一个高度去取得话有可能出现高度不准确的问题。所以竖屏横屏分别一个字典。那这个current又是什么呢？就是`自动返回当前屏幕状态所对应的字典`那么一个中间量，这样我们写代码的时候可以不用考虑当前屏幕状态而`统一使用current这个字典`，减少很多代码量。\n\n去.m中看看是如何实现的。\n\n\n```\n#pragma mark ---懒加载---\n-(NSMutableDictionary *)dicHeightCacheH\n{\n    if (!_dicHeightCacheH) {\n        _dicHeightCacheH = [NSMutableDictionary dictionary];\n    }\n    return _dicHeightCacheH;\n}\n-(NSMutableDictionary *)dicHeightCacheV\n{\n    if (!_dicHeightCacheV) {\n        _dicHeightCacheV = [NSMutableDictionary dictionary];\n    }\n    return _dicHeightCacheV;\n}\n-(NSMutableDictionary *)dicHeightCurrent//根据系统状态返回对应字典\n{\n    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation)?self.dicHeightCacheV:self.dicHeightCacheH;\n}\n```\n\n上面两个字典是懒加载，不多说了，在需要的时候创建字典。\n\n重点是这个current。\n\n`UIDeviceOrientationIsPortrait()`这个方法是判断括号中的状态是否是竖屏状态的一个方法，所以括号里面我们给他当前屏幕状态他就可以判断是不是竖屏了。\n\n[UIDevice currentDevice].orientation而这句代码见名知意，取出`当前设备的屏幕状态`。\n\n让后通过`三目运算符`返回相应的字典。\n\n是不是写法上很简单，实际使用过程中也很方便。\n\n上面几个工具方法最主要的主要由如下几个方法，`交换两个cell高度`的值，`插入一个cell高度`的值，`删除一个cell高度`的值。通过这三个最基本的方法组合出所有cell操作需要用到的方法。算法都很基础，没什么需要说的。\n\n- - -\n### UITableView的category\n\n最后的主角来了。其实你会发现这里的方法并不多。因为只是向外界提供了插入，删除，删除全部，移动，计算高度五个接口。\n\n我们看一下大体思路：\n\n\n![大体思路](http://upload-images.jianshu.io/upload_images/1835430-68cc9b817178ed3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n老司机觉得自己画这图也是没谁了。。。\n\n.h中添加一个属性，是我们刚才用来`存储高度`的那个类的一个实例。\n\n```\n@property (strong ,nonatomic)HeightCache * cache;//缓存实例\n```\n\n其实你`完全可以写在.m里当做一个私有变量去处理`，这样也`更安全`一些。\n老司机写在这里是`为了调试的时候更直观`的看到缓存高度操作时的状态。实际应用中，如无特殊需要，`建议将其写在.m中`。\n\n.m中，我们先看一下这几个工具方法，这才是核心部分。接口方法都是简单调用这几个工具方法，供外界调用的。\n- - -\n\n\n- -(__kindof UITableViewCell *)DW_CalculateCellWithIdentifier:(NSString *)identifier\n- -(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\n- -(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration\n                           \n核心算法都在这了，我一定会好好解析的。(第一个方法返回值有一个*号我敲不出来，不知道markdown什么鬼冲突。。)\n\n#### -(__kindof UITableViewCell *)DW_CalculateCellWithIdentifier:(NSString *)identifier\n第一个方法如下：\n\n```\n///从重用池中返回计算用的cell\n-(__kindof UITableViewCell *)DW_CalculateCellWithIdentifier:(NSString *)identifier\n{\n    if (!identifier.length) {\n        return nil;\n    }\n    NSMutableDictionary <NSString * ,UITableViewCell *> *DicForTheUniqueCalCell = objc_getAssociatedObject(self, _cmd);//利用runtime取出tableV绑定的存有cell的字典\n    if (!DicForTheUniqueCalCell) {\n        DicForTheUniqueCalCell = [NSMutableDictionary dictionary];//如果取不到则新建并绑定\n        objc_setAssociatedObject(self, _cmd, DicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//动态绑定（绑定目标，关键字，绑定者，策略）\n    }\n    //以上只是为了只绑定一个字典，类比懒加载\n    UITableViewCell * cell = DicForTheUniqueCalCell[identifier];\n    if (!cell) {\n        cell = [self dequeueReusableCellWithIdentifier:identifier];//从重用池中取一个cell用来计算，必须以本方式从重用池中取，若以indexPath方式取由于-heightForRowAtIndexPath方法会造成循环。\n        cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;//开启约束\n        cell.JustForCal = YES;//标记只用来计算\n        DicForTheUniqueCalCell[identifier] = cell;\n    }\n    //同上，保证只有一个用来计算的cell\n    return cell;\n}\n```\n\n其实每一句注释都表述的很清楚。不过老司机还是会一句一句给你说的，毕竟这才是老司机的风格，恩，就是`墨迹`。\n\n\n恩，老司机先说一说重用的问题吧。\n\n我们都喜欢用tableView，因为他很好的替我们做了内存控制的问题。\n\n他又是通过什么控制了内存呢？节省了性能呢？通过重用。\n\n这些大家都知道。但是有很多孩子误会了重用啊，孩子你们不懂重用啊。\n\n知道咋回事的这地方跳过吧。\n\n前方`高能预警`，以下内容`很基础`，`真的很基础`，`真的真的很基础`，只是给一些真的不知道的人看的。\n\n> 当一个cell将要离开屏幕时，这个cell会进入重用池。重用池并不是什么特殊的东西，就是系统给他放在一边了。他只是单纯的放在一边了，不进行任何操作。\n> \n> 当一个cell将要进入屏幕的时候，会调用tableView:(UITableView *)tableView cellForRowAtIndexPath这个代理，执行其中的方法\n\n说这两句为了说明什么呢？\n第一句我想说明的是，他只是放在重用池了，`没有进行任！何！操！作！`\n\n重点在哪呢？重点就在于存储的是整个cell，`包括cell原有的和你添加的所有子视图`。\n\n第二句我想说明的是，他会执行代理中的`每！一！句！话！`\n\n重点在哪呢？你从重用池中取出的cell，他是会对cell进行`再次进行绘制`。\n\n这两句说明了什么？\n\n- cell上不要布置太多的控件，不然存入重用池也够你吃一壶的。\n- tableView:(UITableView *)tableView cellForRowAtIndexPath这里面不要添加子视图，不然下次取出同一个cell的时候还会在同样的位置再添加一个同样的子视图。你上下来回滑动的时候cell就会添加无数个子视图。\n- 没有什么会影响重新绘制的，记住那句代码一定会走，只要走就一定会绘制。如果说你绘制出了什么问题，不要怪重用，跟他没关。问题一定在别的地方。\n\n恩，这是老司机对重用的理解。\n\n**刚才跳过的旅客朋友们，跳到这可以接上了。**\n\n接下来我们开始说这个方法。\n为什么我们要取到这个cell呢？而不是随便一个cell呢？\n\n因为我们无法保证或者指定只使用一种cell，很多情况下我们是自定义的cell。这样的话每个不同种类的cell上的子视图是不相同的，在自动计算高度的时候对cell的布局有很高要求，所以我们一定要`保证我们计算用的cell与展示用的cell是同一种cell`。\n\n所以说我们这个方法只有`一个参数`，identifier。因为他是从重用池中取出cell的唯一必要参数。\n\n首先为了安全，先判断传入的identifier`是否为空`，若为空返回nil。只是为了安全。还有代码的`严谨性`。老司机又吹牛逼了，还代码严谨性，我的代码通常都考虑不周全的。。。\n\n然后是`通过runtime从绑定的属性中取出一个字典`。如果取到的这个字典为空则创建一个字典并绑定。\n\n为什么要创建一个字典呢，因为`我们要保证只取到这一个cell`。这个cell是为了干什么的呢，就是为了计算高度的，那么我每次计算高度的时候`只要有这么一个cell`就好了，不要去初始化太多根本不用于显示只用于计算的cell。\n\n然后`从字典中取出我们的cell`，如果取出的cell为空，则从重用池中取出一个cell。并存入字典。\n\n首先字典和cell的判空，都是针对第一次计算cell高度的时候来的。再次进入的时候都不会为空。\n必须要说明的是，从重用池中取出cell的方法我们`一定`要使用`dequeueReusableCellWithIdentifier:`这种方式去取，不能以dequeueReusableCellWithIdentifier:indexPath那种方式去取。\n\n就像老司机注释中说的一样，若以indexPath那种方式去取会造成鸡生蛋蛋生鸡的问题，你这程序就进入死循环了。\n\n然后cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;这句是做什么呢？事实上，有两种自动布局方式，autoResizing和autoLayout。\nautoResizing是`UIView的固有属性`。是在IOS6之前用来实现自动布局的属性。当然IOS6之后的autoLayout就要比他强大不少了。\n\n事实上这个属性`默认情况下是YES`。当为YES时，则我们`设置约束是无效`的。因为后续我们要手动`添加一个约束辅助我们计算`，所以这里我们`将其设为NO`。\n\n然后将计算标识符置真，标识这个cell只参与计算高度，不负责展示。以后遇到批量处理cell的时候可以判断这个标识符，让其不参与运算。`当然老司机这里只是留了一个接口，实际我们有对其进行处理`。\n\n通过这个方法，我们就成功的拿到了一个计算高度用的cell。\n- - - \n#### -(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\n第二个方法：\n\n```\n///根据cell计算cell的高度\n-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\n{\n    CGFloat width = self.bounds.size.width;\n    //根据辅助视图校正width\n    if (cell.accessoryView) {\n        width -= cell.accessoryView.bounds.size.width + 16;\n    }\n    else\n    {\n        static const CGFloat accessoryWidth[] = {\n            [UITableViewCellAccessoryNone] = 0,\n            [UITableViewCellAccessoryDisclosureIndicator] = 34,\n            [UITableViewCellAccessoryDetailDisclosureButton] = 68,\n            [UITableViewCellAccessoryCheckmark] = 40,\n            [UITableViewCellAccessoryDetailButton] = 48\n        };\n        width -= accessoryWidth[cell.accessoryType];\n    }\n    CGFloat height = 0;\n    if (!cell.NoAutoSizing && width > 0) {//如果不是非自适应模式则添加约束后计算约束后高度\n        NSLayoutConstraint * widthConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:width];//创建约束\n        [cell.contentView addConstraint:widthConstraint];//添加约束\n        height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;//计算高度\n        [cell.contentView removeConstraint:widthConstraint];//移除约束\n    }\n    if (height == 0) {//如果约束错误可能导致计算结果为零，则以自适应模式再次计算\n        height = [cell sizeThatFits:CGSizeMake(width, 0)].height;\n    }\n    if (height == 0) {//如果计算仍然为0，则给出默认高度\n        height = 44;\n    }\n    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) {//如果不为无分割线模式则添加分割线高度\n        height += 1.0 /[UIScreen mainScreen].scale;\n    }\n    return height;\n}\n```\n\n**首先我们要想计算出我们cell的高度，就需要拿到cell的`contentView的实际宽度`。**\n\n1.先拿到cell的宽度\n\n2.根据辅助视图样式校正宽度\n\n\n如果有自定义辅助视图，则按照自定义辅助视图的宽度去校正，如果没有按照系统辅助视图样式去校正宽度，然后`根据宽度计算高度`。\n\n3.然后如果是`使用autoLayout进行自适应计算`。\n\n这个也是老司机为之后留下的接口，可以控制是否进行一autoLayout进行计算。但实际并没有处理。\n\n这里是添加约束的写法，先`添加一个宽度约束`，然后让系统`根据宽度约束自动计算高度`，接着`去掉我们添加的约束`。\n\n4.如果根据约束计算结果错误，则`以sizeThatFits去计算高度`。\n\n5.如果计算结果仍然为零，则给出`默认值44`。\n\n6.判断当前tableView的分割线样式，如果有分割线，还要`校正高度`。\n\n好了，至此你已经计算出这个cell应该有的高度了。\n\n- - -\n#### -(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration\n最后一个方法：\n\n```\n///根据重用表示取出cell并操作cell后，计算高度\n-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier\n                           configuration:(void(^)(id cell))configuration\n{\n    if (!identifier.length) {\n        return 0;\n    }\n    UITableViewCell * cell = [self DW_CalculateCellWithIdentifier:identifier];\n    [cell prepareForReuse];//放回重用池\n    if (configuration) {\n        configuration(cell);//对cell进行操作\n   }\n回重用池\n    return [self DW_CalculateCellHeightWithCell:cell];\n}\n\n```\n\n这个方法就比较简单了，先判断重用标示。如果空，直接返回0。还是只为了安全。\n\n再通过`第一个方法取出cell`，然后`将它放回重用池`，以至于下次`我们还能取出来这个cell`。\n\n不要在意我之后还要对cell进行操作，这个`重用池只是一个概念`，其实并不是什么东西，只是标志着这里面的cell可以用于重用，你完全可以理解成他只是cell的一个标签。所以我之后还是可以继续使用这个cell。不要纠结重用池、取出、放回了，少年，他只是一个概念。\n\n哦对了，另外有一点你要注意，你记不记得老司机说过，进入重用池，是将整个cell存储下来，`并没有做其他任何操作`。\n\n\n其实你可以`重写prepareForReuse这个方法`，这里可以做任何你想做的事。比如清除所有子视图。不过有三点你需要注意：\n\n- 别忘了先写[super prepareForReuse];\n- 真清除所有子视图的时候记得别把contentView也删了\n- 重写之后上面的程序中你要合理的考虑一下[cell prepareForReuse]这句话的位置，反正这么跟你讲，我是没想出来放哪。。\n\n最后就是返回高度了。终于完事了。\n\n- - -\n### 留给外界的接口\n\n#### -(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier indexPath:(NSIndexPath *)indexPath configuration:(void(^)(id cell))configuration\n\n\n我只说一个，这是最重要的一个返回高度的接口了，如果每次我们都计算高度，那我们这写法也算是废了，充其量算一个自动返回高度的算法。\n\n所以我们的逻辑应该是`先从cache里面中找，如果没有，计算并存储`。下次再找这个indexPath的时候就能找到了，正如下面的代码一样。\n\n```\n-(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier\n                               indexPath:(NSIndexPath *)indexPath\n                           configuration:(void(^)(id cell))configuration\n{\n    if(self.bounds.size.width != 0)//防止初始宽度为0（如autoLayout初次加载时）\n    {\n        if (!identifier.length || !indexPath) {//非空判断\n            return 0;\n        }\n        NSString * key = [self.cache makeKeyWithIdentifier:identifier indexPath:indexPath];//制作key\n        if ([self.cache existInCacheByKey:key]) {//如果key存在\n            return [self.cache heightFromCacheWithKey:key];//从字典中取出高\n        }\n        CGFloat height = [self DW_CalCulateCellWithIdentifier:identifier configuration:configuration];//不存在则计算高度\n        [self.cache cacheHeight:height byKey:key];//并缓存\n        return height;\n    }\n    return 0;\n}\n```\n\n\n- -- \n### 最后关于如何使用\n\n就是在原来返回tableView高度的方法出调用上面那个方法，仅此而已。\n\n特别注意，`一定要在方法中先填充数据，一定要在方法中先填充数据，一定要在方法中先填充数据`。重要的事情说三遍。否则你永远都是44啊亲们。。\n\n\n![注入数据](http://upload-images.jianshu.io/upload_images/1835430-b6f493667866eee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- - -\n\n我知道今天这个教程看上去很抽象，所以这次我会附上demo的链接。\n\n[demo地址](http://pan.baidu.com/s/1dFK6iHV)\n\n不过老司机还是想说一下自己对demo这件事的看法。\n\n老司机能选择在这里分享一些自己学到的东西，自然就不是一个敝帚自珍的人。然而之所以不爱附上demo链接是因为老司机觉得每次我都已经很详细的在博客中贴出我全部代码而且一句一句讲解真的已经知无不言言无不尽了，我觉得编程这种东西还是得下手敲一遍，看别人的东西看一天也看不懂。所以我更提倡你们自己去敲一遍。如果我把demo链接一放出来，你们直接下载了就去看，就去改，真的没有自己敲一遍学的快。当然有同学实在有需要可以留下邮箱，老司机会给你单独发demo的。\n- - -\n\n常用套话了，这么贪幕虚荣的老司机不就图你点个喜欢么=。=，觉得好点个喜欢吧。\n\n转载记得附上链接。\nhttp://www.jianshu.com/p/2b192257276f\n","slug":"TableView优化之高度缓存","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htp20009jigbp4ieevfp","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a69cecb9aaa3f2d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TableView优化之高度缓存\"><br>系列文章：</p>\n<ul>\n<li><p><a href=\"http://www.jianshu.com/p/2b192257276f\" target=\"_blank\" rel=\"external\">TableView优化之高度缓存功能</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/328e503900d0\" target=\"_blank\" rel=\"external\">TableView优化之加载图片的优化逻辑</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/0b020518de5e\" target=\"_blank\" rel=\"external\">TableView优化之快速滑动下的忽略加载</a></p>\n</li>\n</ul>\n<hr>\n<p>日常开发中，tableView的使用率很高，所以相对tableView的优化来说可以做很多很多的事情。很多情况下，我们的每一个cell都没有一个固定的高度，而是根据cell里面的内容自适应高度的。那么每次当我们cell将要出现在屏幕的时候，系统都会去计算cell的高度。如果说我能通过某种手段，在首次计算的时候，将每个cell对应的高度保存下载，当下次需要用到cell高度的时候再从保存的地方取出，从而减少了计算量，来达到优化的目的。</p>\n<p>因此应运而生了这套高度缓存的算法。</p>\n<p>在此声明，这套算法<code>不是老司机原创</code>，是整合并优化了外国一位大神的源码。</p>\n<p><strong>再次声明，</strong><br>这原来是国人算法，扬我国威啊，原型名<br>UITableView-FDTemplateLayoutCell。</p>\n<hr>\n<p>这篇博客中你可能会用到</p>\n<ul>\n<li>category 、subclass、protocol之间的区别</li>\n<li>自动布局相关</li>\n<li>runTime动态绑定</li>\n<li>tableViewCell重用的相关</li>\n</ul>\n<p>恩，其实东西并不多，重要的还是一个思想。</p>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h2><p>老规矩，还是先放全部代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UITableView+HeightCache.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation UITableView (HeightCache)</div><div class=\"line\"></div><div class=\"line\">#pragma mark ---接口方法---</div><div class=\"line\">-(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">                               indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                           configuration:(void(^)(id cell))configuration</div><div class=\"line\">&#123;</div><div class=\"line\">    if(self.bounds.size.width != 0)//防止初始宽度为0（如autoLayout初次加载时）</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (!identifier.length || !indexPath) &#123;//非空判断</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSString * key = [self.cache makeKeyWithIdentifier:identifier indexPath:indexPath];//制作key</div><div class=\"line\">        if ([self.cache existInCacheByKey:key]) &#123;//如果key存在</div><div class=\"line\">            return [self.cache heightFromCacheWithKey:key];//从字典中取出高</div><div class=\"line\">        &#125;</div><div class=\"line\">        CGFloat height = [self DW_CalCulateCellWithIdentifier:identifier configuration:configuration];//不存在则计算高度</div><div class=\"line\">        [self.cache cacheHeight:height byKey:key];//并缓存</div><div class=\"line\">        return height;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)DW_RemoveHeightCacheWithIdentifier:(NSString *)identifier</div><div class=\"line\">                                indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                             numberOfRows:(NSInteger)rows</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache removeHeightByIdentifier:identifier indexPath:indexPath numberOfRows:rows];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)DW_RemoveAllHeightCache</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache removeAllHeight];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)DW_InsertCellToIndexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                 withIdentifier:(NSString *)identifier</div><div class=\"line\">                   numberOfRows:(NSInteger)rows</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache insertCellToIndexPath:indexPath withIdentifier:identifier numberOfRows:rows toDictionaryForCache:self.cache.dicHeightCurrent];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)DW_MoveCellFromIndexPath:(NSIndexPath *)sourceIndexPath</div><div class=\"line\">    sourceIndexPathNumberOfRows:(NSInteger)sourceRows</div><div class=\"line\">                    toIndexPath:(NSIndexPath *)destinationIndexPath</div><div class=\"line\">destinationIndexPathNumberOfRows:(NSInteger)destinationRows</div><div class=\"line\">                 withIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache moveCellFromIndexPath:sourceIndexPath sourceSectionNumberOfRows:sourceRows toIndexPath:destinationIndexPath destinationSectionNumberOfRows:destinationRows withIdentifier:identifier];</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark ---工具方法---</div><div class=\"line\">///从重用池中返回计算用的cell</div><div class=\"line\">-(__kindof UITableViewCell  *)DW_CalculateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!identifier.length) &#123;</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSMutableDictionary &lt;NSString * ,UITableViewCell *&gt; *DicForTheUniqueCalCell = objc_getAssociatedObject(self, _cmd);//利用runtime取出tableV绑定的存有cell的字典</div><div class=\"line\">    if (!DicForTheUniqueCalCell) &#123;</div><div class=\"line\">        DicForTheUniqueCalCell = [NSMutableDictionary dictionary];//如果取不到则新建并绑定</div><div class=\"line\">        objc_setAssociatedObject(self, _cmd, DicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//动态绑定（绑定目标，关键字，绑定者，策略）</div><div class=\"line\">    &#125;</div><div class=\"line\">    //以上只是为了只绑定一个字典，类比懒加载</div><div class=\"line\">    UITableViewCell * cell = DicForTheUniqueCalCell[identifier];</div><div class=\"line\">    if (!cell) &#123;</div><div class=\"line\">        cell = [self dequeueReusableCellWithIdentifier:identifier];//从重用池中取一个cell用来计算，必须以本方式从重用池中取，若以indexPath方式取由于-heightForRowAtIndexPath方法会造成循环。</div><div class=\"line\">        cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;//开启约束</div><div class=\"line\">        cell.JustForCal = YES;//标记只用来计算</div><div class=\"line\">        DicForTheUniqueCalCell[identifier] = cell;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //同上，保证只有一个用来计算的cell</div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///根据重用表示取出cell并操作cell后，计算高度</div><div class=\"line\">-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">                           configuration:(void(^)(id cell))configuration</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!identifier.length) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    UITableViewCell * cell = [self DW_CalculateCellWithIdentifier:identifier];</div><div class=\"line\">    [cell prepareForReuse];//放回重用池</div><div class=\"line\">    if (configuration) &#123;</div><div class=\"line\">        configuration(cell);//对cell进行操作</div><div class=\"line\">    &#125;    </div><div class=\"line\">    return [self DW_CalculateCellHeightWithCell:cell];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///根据cell计算cell的高度</div><div class=\"line\">-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat width = self.bounds.size.width;</div><div class=\"line\">    //根据辅助视图校正width</div><div class=\"line\">    if (cell.accessoryView) &#123;</div><div class=\"line\">        width -= cell.accessoryView.bounds.size.width + 16;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        static const CGFloat accessoryWidth[] = &#123;</div><div class=\"line\">            [UITableViewCellAccessoryNone] = 0,</div><div class=\"line\">            [UITableViewCellAccessoryDisclosureIndicator] = 34,</div><div class=\"line\">            [UITableViewCellAccessoryDetailDisclosureButton] = 68,</div><div class=\"line\">            [UITableViewCellAccessoryCheckmark] = 40,</div><div class=\"line\">            [UITableViewCellAccessoryDetailButton] = 48</div><div class=\"line\">        &#125;;</div><div class=\"line\">        width -= accessoryWidth[cell.accessoryType];</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat height = 0;</div><div class=\"line\">    if (!cell.NoAutoSizing &amp;&amp; width &gt; 0) &#123;//如果不是非自适应模式则添加约束后计算约束后高度</div><div class=\"line\">        NSLayoutConstraint * widthConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:width];//创建约束</div><div class=\"line\">        [cell.contentView addConstraint:widthConstraint];//添加约束</div><div class=\"line\">        height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;//计算高度</div><div class=\"line\">        [cell.contentView removeConstraint:widthConstraint];//移除约束</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (height == 0) &#123;//如果约束错误可能导致计算结果为零，则以自适应模式再次计算</div><div class=\"line\">        height = [cell sizeThatFits:CGSizeMake(width, 0)].height;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (height == 0) &#123;//如果计算仍然为0，则给出默认高度</div><div class=\"line\">        height = 44;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) &#123;//如果不为无分割线模式则添加分割线高度</div><div class=\"line\">        height += 1.0 /[UIScreen mainScreen].scale;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return height;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark ---setter、getter---</div><div class=\"line\">-(HeightCache *)cache//懒加载形式</div><div class=\"line\">&#123;</div><div class=\"line\">    HeightCache * cacheTemp = objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">    if (!cacheTemp) &#123;</div><div class=\"line\">        cacheTemp = [HeightCache new];</div><div class=\"line\">        objc_setAssociatedObject(self, _cmd, cacheTemp, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return cacheTemp;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setCache:(HeightCache *)cache</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(cache), cache, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation UITableViewCell (HeightCacheCell)</div><div class=\"line\">#pragma mark ---setter、getter---</div><div class=\"line\">-(BOOL)NoAutoSizing</div><div class=\"line\">&#123;</div><div class=\"line\">    return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setNoAutoSizing:(BOOL)NoAutoSizing</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);//关键字用getter的方法名，为保持关键字一致</div><div class=\"line\">&#125;</div><div class=\"line\">-(BOOL)JustForCal</div><div class=\"line\">&#123;</div><div class=\"line\">    return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setJustForCal:(BOOL)JustForCal</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(JustForCal), @(JustForCal), OBJC_ASSOCIATION_RETAIN);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation HeightCache</div><div class=\"line\">///制作key</div><div class=\"line\">-(NSString *)makeKeyWithIdentifier:(NSString *)identifier</div><div class=\"line\">                         indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    return [NSString stringWithFormat:@&quot;%@S%ldR%ld&quot;,identifier,indexPath.section,indexPath.row];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///高度是否存在</div><div class=\"line\">-(BOOL)existInCacheByKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    NSNumber * value = [self.dicHeightCurrent valueForKey:key];</div><div class=\"line\">    return (value &amp;&amp; ![value isEqualToNumber:@-1]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///取出缓存的高度</div><div class=\"line\">-(CGFloat)heightFromCacheWithKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    NSNumber * value = [self.dicHeightCurrent valueForKey:key];</div><div class=\"line\">    if ([self is64bit]) &#123;</div><div class=\"line\">        return [value doubleValue];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [value floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///64位判断</div><div class=\"line\">- (BOOL)is64bit</div><div class=\"line\">&#123;</div><div class=\"line\">#if defined(__LP64__) &amp;&amp; __LP64__</div><div class=\"line\">    return YES;</div><div class=\"line\">#else</div><div class=\"line\">    return NO;</div><div class=\"line\">#endif</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///高度缓存</div><div class=\"line\">-(void)cacheHeight:(CGFloat)height</div><div class=\"line\">             byKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.dicHeightCurrent setValue:@(height) forKey:key];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///根据key删除缓存</div><div class=\"line\">-(void)removeHeightByIdentifier:(NSString *)identifier</div><div class=\"line\">                      indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                   numberOfRows:(NSInteger)rows</div><div class=\"line\">&#123;</div><div class=\"line\">    if (indexPath.row &lt; rows) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; rows - 1 - indexPath.row; i ++) &#123;</div><div class=\"line\">            NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:indexPath.row + i inSection:indexPath.section];</div><div class=\"line\">            NSLog(@&quot;%ld,%ld&quot;,indexPathA.row,indexPathA.section);</div><div class=\"line\">            NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:indexPath.row + i + 1 inSection:indexPath.section];</div><div class=\"line\">            NSLog(@&quot;%ld,%ld&quot;,indexPathB.row,indexPathB.section);</div><div class=\"line\">            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheH];</div><div class=\"line\">            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheV];</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSIndexPath * indexPathC = [NSIndexPath indexPathForRow:rows - 1 inSection:indexPath.section];</div><div class=\"line\">        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:indexPathC];</div><div class=\"line\">        [self.dicHeightCacheH removeObjectForKey:key];</div><div class=\"line\">        [self.dicHeightCacheV removeObjectForKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///删除所有缓存</div><div class=\"line\">-(void)removeAllHeight</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.dicHeightCacheH removeAllObjects];</div><div class=\"line\">    [self.dicHeightCacheV removeAllObjects];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///插入cell是插入value</div><div class=\"line\">-(void)insertCellToIndexPath:(NSIndexPath *)indexPath</div><div class=\"line\">            withNumberOfRows:(NSInteger)rows</div><div class=\"line\">                heightNumber:(NSNumber *)height</div><div class=\"line\">                  identifier:(NSString *)identifier</div><div class=\"line\">        toDictionaryForCache:(NSMutableDictionary *)dic</div><div class=\"line\">&#123;</div><div class=\"line\">    if (indexPath.row &lt; rows + 1) &#123;</div><div class=\"line\">        [self insertCellToIndexPath:indexPath withIdentifier:identifier numberOfRows:rows toDictionaryForCache:dic];</div><div class=\"line\">        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:indexPath];</div><div class=\"line\">        [dic setValue:height forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)insertCellToIndexPath:(NSIndexPath *)indexPath withIdentifier:(NSString *)identifier numberOfRows:(NSInteger)rows toDictionaryForCache:(NSMutableDictionary *)dic</div><div class=\"line\">&#123;</div><div class=\"line\">    if (indexPath.row &lt; rows + 1) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; rows - indexPath.row; i ++) &#123;</div><div class=\"line\">            NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:rows - i inSection:indexPath.section];</div><div class=\"line\">            NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:rows - i - 1 inSection:indexPath.section];</div><div class=\"line\">            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:dic];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">///移动cell时交换value</div><div class=\"line\">-(void)moveCellFromIndexPath:(NSIndexPath *)sourceIndexPath</div><div class=\"line\">   sourceSectionNumberOfRows:(NSInteger)sourceRows</div><div class=\"line\">                 toIndexPath:(NSIndexPath *)destinationIndexPath</div><div class=\"line\">destinationSectionNumberOfRows:(NSInteger)destinationRows</div><div class=\"line\">              withIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    if (sourceIndexPath.section == destinationIndexPath.section) &#123;</div><div class=\"line\">        [self moveCellInSectionFromIndexPath:sourceIndexPath toIndexPath:destinationIndexPath withIdentifier:identifier];</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        [self moveCellOutSectionFromIndexPath:sourceIndexPath sourceSectionNumberOfRows:sourceRows toIndexPath:destinationIndexPath destinationSectionNumberOfRows:destinationRows withIdentifier:identifier];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">///组内移动</div><div class=\"line\">-(void)moveCellInSectionFromIndexPath:(NSIndexPath *)sourceIndexPath</div><div class=\"line\">                          toIndexPath:(NSIndexPath *)destinationIndexPath</div><div class=\"line\">                       withIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    NSInteger rowA = sourceIndexPath.row;</div><div class=\"line\">    NSInteger rowB = destinationIndexPath.row;</div><div class=\"line\">    for (int i = 0; i &lt; (MAX(rowA, rowB) - MIN(rowA, rowB)); i ++) &#123;</div><div class=\"line\">        NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:MIN(rowA, rowB) + i inSection:sourceIndexPath.section];</div><div class=\"line\">        NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:MIN(rowA, rowB) + i + 1 inSection:sourceIndexPath.section];</div><div class=\"line\">        [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheV];</div><div class=\"line\">        [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheH];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">///组外移动</div><div class=\"line\">-(void)moveCellOutSectionFromIndexPath:(NSIndexPath *)sourceIndexPath</div><div class=\"line\">             sourceSectionNumberOfRows:(NSInteger)sourceRows</div><div class=\"line\">                           toIndexPath:(NSIndexPath *)destinationIndexPath</div><div class=\"line\">        destinationSectionNumberOfRows:(NSInteger)destinationRows</div><div class=\"line\">                        withIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    NSNumber * numberH;</div><div class=\"line\">    NSNumber * numberV;</div><div class=\"line\">    NSLog(@&quot;%ld&quot;,sourceIndexPath.row);</div><div class=\"line\">    if (sourceIndexPath.row &lt; sourceRows) &#123;</div><div class=\"line\">        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:sourceIndexPath];</div><div class=\"line\">        numberH = self.dicHeightCacheH[key];</div><div class=\"line\">        numberV = self.dicHeightCacheV[key];</div><div class=\"line\">        [self removeHeightByIdentifier:identifier indexPath:sourceIndexPath numberOfRows:sourceRows];</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;%ld,%ld&quot;,destinationIndexPath.row,destinationIndexPath.section);</div><div class=\"line\">    [self insertCellToIndexPath:destinationIndexPath withNumberOfRows:destinationRows heightNumber:numberH identifier:identifier toDictionaryForCache:self.dicHeightCacheH];</div><div class=\"line\">    [self insertCellToIndexPath:destinationIndexPath withNumberOfRows:destinationRows heightNumber:numberV identifier:identifier toDictionaryForCache:self.dicHeightCacheV];</div><div class=\"line\">&#125;</div><div class=\"line\">///根据indexPath交换两个Key</div><div class=\"line\">-(void)exchangeValueForIndexPathA:(NSIndexPath *)indexPathA</div><div class=\"line\">                    andIndexPathB:(NSIndexPath *)indexPathB</div><div class=\"line\">                   withIdentifier:(NSString *)identifier</div><div class=\"line\">                       dictionary:(NSMutableDictionary *)dic</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString * keyA = [self makeKeyWithIdentifier:identifier indexPath:indexPathA];</div><div class=\"line\">    NSString * keyB = [self makeKeyWithIdentifier:identifier indexPath:indexPathB];</div><div class=\"line\">    NSNumber * Temp = dic[keyA];</div><div class=\"line\">    dic[keyA] = dic[keyB];</div><div class=\"line\">    dic[keyB] = Temp;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark ---懒加载---</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCacheH</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_dicHeightCacheH) &#123;</div><div class=\"line\">        _dicHeightCacheH = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dicHeightCacheH;</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCacheV</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_dicHeightCacheV) &#123;</div><div class=\"line\">        _dicHeightCacheV = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dicHeightCacheV;</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCurrent//根据系统状态返回对应字典</div><div class=\"line\">&#123;</div><div class=\"line\">    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation)?self.dicHeightCacheV:self.dicHeightCacheH;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><code>这么多，你这个骗子！</code><br>你是不是这么想得。</p>\n<p>别慌，东西不多，因为这是一个category，复用性非常高，所以老司机想尽量减少文件个数，这样集成的时候也方便不是。</p>\n<p>所以，老司机<code>把三个类写在一个文件里了</code>。</p>\n<p>之前有人问过我把几个类写在一个文件中<code>有什么好处么</code>？</p>\n<p>老司机目前只能说，<code>除了看上去装逼点，别的没什么卵用</code>。</p>\n<p>可能是老司机的理解不深，不过为了集成方便我还是写在一个文件里了。</p>\n<p>废话不多说，分段讲解吧。</p>\n<hr>\n<h2 id=\"分段解析\"><a href=\"#分段解析\" class=\"headerlink\" title=\"分段解析\"></a>分段解析</h2><h3 id=\"为什么选择category而不是subclass\"><a href=\"#为什么选择category而不是subclass\" class=\"headerlink\" title=\"为什么选择category而不是subclass\"></a>为什么选择category而不是subclass</h3><p>我想很多人都会有疑问，为什么选择category而不是继承，毕竟category不能添加属性,用起来不是很方便。说到这又要老生常谈了。</p>\n<blockquote>\n<p>Protocol只是声明一套接口，并不能提供具体实现，变相的也算是一种抽象基类的实现方式（OC本身语法并不支持抽象基类）。</p>\n<p>Category可以为已有的类提供额外的接口和具体的实现。</p>\n<p>Protocol只能提供一套公用的接口声明，并不能提供具体实现，它的行为是，我只负责声明，而不管谁去实现，去如何实现。这样的话，我定义一套接口，可以使任意的类都用不同的方式去实现接口中的方法，就是为遵守了protocol的类提供了一些额外访问这个类的一些接口，像delegate和dataSource用protocol实现是最好的。</p>\n<p>Category是对一个功能完备的类的一种补充、扩展，就像一个东西基本功能都完成了，可以用category为这个类添加不同的组件，使得这个类能够适应不同情况的需求（但是这些不同需求最核心的需求要一致）。当然，当某个类非常大的时候，使用category可以按照不同的功能将类的实现分在不同的模块中。还有，虽然category可以访问已有类的实例变量，但不能创建新的实例变量，如果要创建新的实例变量，请使用继承。</p>\n<p>继承，它基于Protocol和Category之间，既可以像protocol一样只提供纯粹的接口，也可以像Category一样提供接口的完整实现，可以自由定义类的实例变量（这一点，Protocol倒是可以声明实例变量，但是也仅仅是声明而已），而且继承还可以对类以后的方法进行改写，所以继承的力量是最强大的。</p>\n<p>在iOS开发中，继承是完全可以完成protocol和category的功能的，那么在开发过程中多多使用继承体系可好？</p>\n<p>需要注意的是使用继承还有很大的代价问题。使用继承来进行扩展是一种耦合度很高的行为，对父类可以说是完全依赖，如果继承体系太过复杂，会造成难以维护的问题。如果仅仅只是对类进行扩展，并不建议使用继承，毕竟使用protocol和category是很简单、轻松的。除此之外，在开发过程中，我们应该尽量将界面、功能相似的类的代码提取到基类里面，然后各个子类继承自这个基类，实现各自的其他特殊部分。这样可以大大的优化代码，如果需要修改的话，只需要这倒对应子类修改即可。</p>\n</blockquote>\n<p>是不是感觉老司机屌屌的，啧啧啧，我百度的。</p>\n<p>我选择category就一个原因，扩展方便，二次开发也方便。</p>\n<hr>\n<h3 id=\"类目拆解\"><a href=\"#类目拆解\" class=\"headerlink\" title=\"类目拆解\"></a>类目拆解</h3><p>老司机说过，这一坨代码是三个类写在了一个文件里，他们都是什么呢？</p>\n<ul>\n<li>UITableView的category</li>\n<li>UITableViewCell的category</li>\n<li>一个NSObject的子类</li>\n</ul>\n<p>他们分别是做什么的呢？</p>\n<p>首先，给UITableView添加category是因为为了<code>实现高度缓存</code>，我的方案是在计算高度的时候就模拟数据填充，从而计算出该cell的高度，所以，tableView应该有填充数据和计算高度的方法。故为其添加分类。</p>\n<p>而那个继承于NSObject的子类就是用来<code>存储计算出来的高度的</code>，这样当下次需要计算的时候直接从这里取出即可。</p>\n<p>至于那个UITableViewCell的类目是为了<code>给cell添加两个标识符</code>，一个用来判断当前cell是否需要一autolayout进行绘制，另一个是用来区分计算用的cell还是展示用的cell。这点现在可能你还不懂，一会我们会做相应介绍。</p>\n<hr>\n<h3 id=\"UITableViewCell的category\"><a href=\"#UITableViewCell的category\" class=\"headerlink\" title=\"UITableViewCell的category\"></a>UITableViewCell的category</h3><p>为什么先说这个类目呢，因为这个类目的内容最少，而且只用到了runtime的动态绑定，可以拿出来单独介绍一下runtime的相关知识。</p>\n<h4 id=\"什么是runtime\"><a href=\"#什么是runtime\" class=\"headerlink\" title=\"什么是runtime\"></a>什么是runtime</h4><p>run，运行，time，时间，那么runtime就是运行时。恩，简单不？<br>然后我们说说。。。诶诶诶，别打别打，开个玩笑。<br>runtime，简称运行时，是<code>系统在运行期间的一些机制</code>。而对于OC来讲呢，其中最重要的就是<code>消息机制</code>。</p>\n<p>C语言呢，我们<code>调用函数</code>，在<code>编译期</code>就已经确定了要调用那个函数，而且整个过程是<code>顺序执行</code>的。</p>\n<p>而在OC中呢，我们是讲<code>消息发送</code>的。而且我们是等待某个信号<code>触发才执行</code>代码的。我们知道OC事实上是基于C的，那他是怎么实现这套转换的呢？就是<code>通过runtime去实现</code>的。</p>\n<p>不信？不信跟我来做个试验。</p>\n<p>新开一个工程，删掉所有文件，只<code>留下info.plist和main.m</code>。并且将引入的头文件删除掉。</p>\n<p>再<code>建一个类</code>，里面随便写一个方法的声明和实现。</p>\n<p>然后<code>在main.m中引入这个类</code>，<code>初始化并调用刚才声明的方法</code>，如下图。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-7d31aa53377e7333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"新建一个工程\"></p>\n<p>此时，打开我们的终端。找到刚才的工程的main.m,并且输入<br><code>clang -rewrite-objc main.m</code>，点击回车。稍等你就会看到提示转换完成。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0056ec0cb777ee26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"转化我们的文件\"></p>\n<p>这回在finder中找到工程的文件夹，在main.m同级文件夹下多了一个文件<code>main.cpp</code>，这就是转换完的文件。我们看到代码还是很多的。<code>直接拖到最下方</code>我们大概能看到点认识的了，int main。。。</p>\n<p>这就是我们刚才<code>main函数里面的实现</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-fc8be701d9be1b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"找到实现\"></p>\n<p>看不懂？待我帮你捋捋，去掉一些类型转换用的修饰符后剩下如下代码，是不是清晰多了？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-4421b3ad6ca6a611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"姑且就叫化简吧\"></p>\n<p>先看被我框选中的代码，<code>objc_msgSend是说发送消息</code>，他有<code>两个参数</code>，一个是<code>实例</code>，一个是<code>方法</code>。<code>objc_getClass通过字符串获取到这个类</code>。<code>sel_registerName通过字符串获取方法</code>。所以这句话的意思就是<code>给这个类发送了这个消息，消息内容就是一个方法</code>。</p>\n<p>随后就容易了，给这个实例发送一个sayHello的消息，参数是后面的字符串。</p>\n<p>通过这里我们知道我们OC的语言是怎么实现的了吧，就是<code>通过runtime转化成了C++的代码</code>，然后进行运行。</p>\n<p>从这你也应该知道为什么OC中叫<code>发送消息</code>，不叫函数调用了吧。</p>\n<p>另外你还应该知道为什么OC中方法<code>只声明</code>，<code>不实现</code>，<code>编译时只报警不报错</code>，<code>运行时crash</code>是为什么了吧。</p>\n<p>既然说到这里就多少说一说C与OC吧。之前老司机说过，OC是基于C的，那么C语言中是没有对象这个概念呢，我们的对象又是什么呢？</p>\n<p><strong>右手啊，程序员哪有什么对象，啧啧啧。</strong></p>\n<p>除了右手，还有结构体，OC的对象就是<code>C语言中的结构体</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b4b5b2aa725808fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"对象的结构\"></p>\n<p>我们看到了，每个类都是一个都是一个结构体，其中有各种<code>指针</code>，指向一个类的各种<code>参数</code>，<code>父类、属性列表、方法列表等等</code>。</p>\n<p>所以说当我们声明了类的方法，方法列表里面就有这个方法了，然后编译通过了，然后调用的时候，方法选择器去本类的方法列表里去寻找方法的实现，如果没有实现，则去其父类中寻找，如果在没有通过一系列<code>消息转发机制</code>会一直找下去，直到最后也没有找到这个方法的实现就crash了。关于消息转发，其实还有很多东西，但是在这里讲就又扯远了，所以等下期吧=。=</p>\n<p>本例中我们用runtime做了些什么呢？</p>\n<h4 id=\"使用runtime动态为category绑定属性\"><a href=\"#使用runtime动态为category绑定属性\" class=\"headerlink\" title=\"使用runtime动态为category绑定属性\"></a>使用runtime动态为category绑定属性</h4><p>之前老司机说过，category是不能添加属性的。那我又要为其添加两个标识符，只能使用runtime去<code>动态绑定</code>了，在类的<code>属性列表</code>里面<code>通过runtime添加</code>上这个属性，那我就可以使用这个属性了。</p>\n<p>首先在.h的UITableCell的category的@interface之中添加两个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface UITableViewCell (HeightCacheCell)</div><div class=\"line\">@property (assign ,nonatomic)BOOL JustForCal;//计算用的cell标识符（将计算用的cell与正常显示的cell进行区分，避免不必要的ui响应）</div><div class=\"line\">@property (assign ,nonatomic)BOOL NoAutoSizing;//不适用autoSizing标识符（不依靠约束计算，只进行自适应）</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这是我为期添加的两个属性，具体有什么作用，下文中会提到的，先别急。</p>\n<p>然后在.m中添加两个属性的setter、getter方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation UITableViewCell (HeightCacheCell)</div><div class=\"line\">#pragma mark ---setter、getter---</div><div class=\"line\">-(BOOL)NoAutoSizing</div><div class=\"line\">&#123;</div><div class=\"line\">    return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setNoAutoSizing:(BOOL)NoAutoSizing</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);//关键字用getter的方法名，为保持关键字一致</div><div class=\"line\">&#125;</div><div class=\"line\">-(BOOL)JustForCal</div><div class=\"line\">&#123;</div><div class=\"line\">    return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setJustForCal:(BOOL)JustForCal</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(JustForCal), @(JustForCal), OBJC_ASSOCIATION_RETAIN);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这里老司机有必要说一下两个方法</p>\n<ul>\n<li>objc_setAssociatedObject</li>\n<li>objc_getAssociatedObject</li>\n</ul>\n<p>OC自解释语言的好处就体现出来了，从函数名你就可以看出来，一个是给对象设置联系，一个是从对象获取联系。反正我英语水平就这样，我也没查字典，对不对的我就不深究了。一个setter一个getter就在这。</p>\n<h5 id=\"objc-setAssociatedObject\"><a href=\"#objc-setAssociatedObject\" class=\"headerlink\" title=\"objc_setAssociatedObject\"></a>objc_setAssociatedObject</h5><p>objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);</p>\n<p>方法总共四个参数，分别是<code>绑定目标，关键字，绑定者，策略</code>。</p>\n<p>所以说简单了，绑定目标，就是给谁绑定，当然是UITableViewCell这个category了，所以self。</p>\n<p>绑定的关键字就是说我给这个对象绑定一个属性，我总要有一个标示符去表示那个属性吧，这样我要调用这个属性的时候通过标示符去寻找才能找到这个属性。</p>\n<p>绑定者，就是我们要为这个属性绑定的值了。</p>\n<p>绑定策略就是说绑定的这个属性的引用机制了。这里要说明一点，<code>这个绑定策略如何选择，老司机目前也没有搞懂</code>，所以策略这里都沿用了原作者的写法，等老司机搞懂了之后会告诉大家的。</p>\n<h5 id=\"objc-getAssociatedObject\"><a href=\"#objc-getAssociatedObject\" class=\"headerlink\" title=\"objc_getAssociatedObject\"></a>objc_getAssociatedObject</h5><p>两个参数，一个绑定目标，一个关键字，通过关键字从绑定目标中获取属性的值。</p>\n<p>这下是不是明白这两个setter、getter方法的意义了。</p>\n<p>好了，这个category讲完了，他的东西真的很少。</p>\n<p>什么，你敲不出来这两个方法？<br>忘了讲了，你没引入头文件。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;objc/runtime.h&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"HeightCache\"><a href=\"#HeightCache\" class=\"headerlink\" title=\"HeightCache\"></a>HeightCache</h3><p>为什么说这个类呢？怎么还不进入正题呢？说好的UITableView的category呢？</p>\n<p>因为这个类是<code>负责存储Cell高度</code>的类，而UITableView得category只是为获取cell高度提供了一个接口，当我们移动cell，添加cell，删除cell的时候要对这个高度的对应关系作出很多的操作，UITableView的category中<code>大量的使用了这里的方法</code>，所以老司机决定先把难啃的骨头解决了。</p>\n<p>在.h中添加三个字典</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (strong ,nonatomic)NSMutableDictionary * dicHeightCacheV;//竖直行高缓存字典</div><div class=\"line\">@property (strong ,nonatomic)NSMutableDictionary * dicHeightCacheH;//水平行高缓存字典</div><div class=\"line\">@property (strong ,nonatomic)NSMutableDictionary * dicHeightCurrent;//当前状态行高缓存字典（中间量）</div></pre></td></tr></table></figure>\n<p>为什么三个字典呢？老司机是这样考虑的，<code>横屏和竖屏</code>情况下同样内容的cell有可能是不同的，如果以同一个高度去取得话有可能出现高度不准确的问题。所以竖屏横屏分别一个字典。那这个current又是什么呢？就是<code>自动返回当前屏幕状态所对应的字典</code>那么一个中间量，这样我们写代码的时候可以不用考虑当前屏幕状态而<code>统一使用current这个字典</code>，减少很多代码量。</p>\n<p>去.m中看看是如何实现的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark ---懒加载---</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCacheH</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_dicHeightCacheH) &#123;</div><div class=\"line\">        _dicHeightCacheH = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dicHeightCacheH;</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCacheV</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_dicHeightCacheV) &#123;</div><div class=\"line\">        _dicHeightCacheV = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dicHeightCacheV;</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCurrent//根据系统状态返回对应字典</div><div class=\"line\">&#123;</div><div class=\"line\">    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation)?self.dicHeightCacheV:self.dicHeightCacheH;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面两个字典是懒加载，不多说了，在需要的时候创建字典。</p>\n<p>重点是这个current。</p>\n<p><code>UIDeviceOrientationIsPortrait()</code>这个方法是判断括号中的状态是否是竖屏状态的一个方法，所以括号里面我们给他当前屏幕状态他就可以判断是不是竖屏了。</p>\n<p>[UIDevice currentDevice].orientation而这句代码见名知意，取出<code>当前设备的屏幕状态</code>。</p>\n<p>让后通过<code>三目运算符</code>返回相应的字典。</p>\n<p>是不是写法上很简单，实际使用过程中也很方便。</p>\n<p>上面几个工具方法最主要的主要由如下几个方法，<code>交换两个cell高度</code>的值，<code>插入一个cell高度</code>的值，<code>删除一个cell高度</code>的值。通过这三个最基本的方法组合出所有cell操作需要用到的方法。算法都很基础，没什么需要说的。</p>\n<hr>\n<h3 id=\"UITableView的category\"><a href=\"#UITableView的category\" class=\"headerlink\" title=\"UITableView的category\"></a>UITableView的category</h3><p>最后的主角来了。其实你会发现这里的方法并不多。因为只是向外界提供了插入，删除，删除全部，移动，计算高度五个接口。</p>\n<p>我们看一下大体思路：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-68cc9b817178ed3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"大体思路\"></p>\n<p>老司机觉得自己画这图也是没谁了。。。</p>\n<p>.h中添加一个属性，是我们刚才用来<code>存储高度</code>的那个类的一个实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (strong ,nonatomic)HeightCache * cache;//缓存实例</div></pre></td></tr></table></figure>\n<p>其实你<code>完全可以写在.m里当做一个私有变量去处理</code>，这样也<code>更安全</code>一些。<br>老司机写在这里是<code>为了调试的时候更直观</code>的看到缓存高度操作时的状态。实际应用中，如无特殊需要，<code>建议将其写在.m中</code>。</p>\n<p>.m中，我们先看一下这几个工具方法，这才是核心部分。接口方法都是简单调用这几个工具方法，供外界调用的。</p>\n<hr>\n<ul>\n<li>-(__kindof UITableViewCell <em>)DW_CalculateCellWithIdentifier:(NSString </em>)identifier</li>\n<li>-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell</li>\n<li>-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration</li>\n</ul>\n<p>核心算法都在这了，我一定会好好解析的。(第一个方法返回值有一个*号我敲不出来，不知道markdown什么鬼冲突。。)</p>\n<h4 id=\"kindof-UITableViewCell-DW-CalculateCellWithIdentifier-NSString-identifier\"><a href=\"#kindof-UITableViewCell-DW-CalculateCellWithIdentifier-NSString-identifier\" class=\"headerlink\" title=\"-(__kindof UITableViewCell )DW_CalculateCellWithIdentifier:(NSString )identifier\"></a>-(__kindof UITableViewCell <em>)DW_CalculateCellWithIdentifier:(NSString </em>)identifier</h4><p>第一个方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">///从重用池中返回计算用的cell</div><div class=\"line\">-(__kindof UITableViewCell *)DW_CalculateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!identifier.length) &#123;</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSMutableDictionary &lt;NSString * ,UITableViewCell *&gt; *DicForTheUniqueCalCell = objc_getAssociatedObject(self, _cmd);//利用runtime取出tableV绑定的存有cell的字典</div><div class=\"line\">    if (!DicForTheUniqueCalCell) &#123;</div><div class=\"line\">        DicForTheUniqueCalCell = [NSMutableDictionary dictionary];//如果取不到则新建并绑定</div><div class=\"line\">        objc_setAssociatedObject(self, _cmd, DicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//动态绑定（绑定目标，关键字，绑定者，策略）</div><div class=\"line\">    &#125;</div><div class=\"line\">    //以上只是为了只绑定一个字典，类比懒加载</div><div class=\"line\">    UITableViewCell * cell = DicForTheUniqueCalCell[identifier];</div><div class=\"line\">    if (!cell) &#123;</div><div class=\"line\">        cell = [self dequeueReusableCellWithIdentifier:identifier];//从重用池中取一个cell用来计算，必须以本方式从重用池中取，若以indexPath方式取由于-heightForRowAtIndexPath方法会造成循环。</div><div class=\"line\">        cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;//开启约束</div><div class=\"line\">        cell.JustForCal = YES;//标记只用来计算</div><div class=\"line\">        DicForTheUniqueCalCell[identifier] = cell;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //同上，保证只有一个用来计算的cell</div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实每一句注释都表述的很清楚。不过老司机还是会一句一句给你说的，毕竟这才是老司机的风格，恩，就是<code>墨迹</code>。</p>\n<p>恩，老司机先说一说重用的问题吧。</p>\n<p>我们都喜欢用tableView，因为他很好的替我们做了内存控制的问题。</p>\n<p>他又是通过什么控制了内存呢？节省了性能呢？通过重用。</p>\n<p>这些大家都知道。但是有很多孩子误会了重用啊，孩子你们不懂重用啊。</p>\n<p>知道咋回事的这地方跳过吧。</p>\n<p>前方<code>高能预警</code>，以下内容<code>很基础</code>，<code>真的很基础</code>，<code>真的真的很基础</code>，只是给一些真的不知道的人看的。</p>\n<blockquote>\n<p>当一个cell将要离开屏幕时，这个cell会进入重用池。重用池并不是什么特殊的东西，就是系统给他放在一边了。他只是单纯的放在一边了，不进行任何操作。</p>\n<p>当一个cell将要进入屏幕的时候，会调用tableView:(UITableView *)tableView cellForRowAtIndexPath这个代理，执行其中的方法</p>\n</blockquote>\n<p>说这两句为了说明什么呢？<br>第一句我想说明的是，他只是放在重用池了，<code>没有进行任！何！操！作！</code></p>\n<p>重点在哪呢？重点就在于存储的是整个cell，<code>包括cell原有的和你添加的所有子视图</code>。</p>\n<p>第二句我想说明的是，他会执行代理中的<code>每！一！句！话！</code></p>\n<p>重点在哪呢？你从重用池中取出的cell，他是会对cell进行<code>再次进行绘制</code>。</p>\n<p>这两句说明了什么？</p>\n<ul>\n<li>cell上不要布置太多的控件，不然存入重用池也够你吃一壶的。</li>\n<li>tableView:(UITableView *)tableView cellForRowAtIndexPath这里面不要添加子视图，不然下次取出同一个cell的时候还会在同样的位置再添加一个同样的子视图。你上下来回滑动的时候cell就会添加无数个子视图。</li>\n<li>没有什么会影响重新绘制的，记住那句代码一定会走，只要走就一定会绘制。如果说你绘制出了什么问题，不要怪重用，跟他没关。问题一定在别的地方。</li>\n</ul>\n<p>恩，这是老司机对重用的理解。</p>\n<p><strong>刚才跳过的旅客朋友们，跳到这可以接上了。</strong></p>\n<p>接下来我们开始说这个方法。<br>为什么我们要取到这个cell呢？而不是随便一个cell呢？</p>\n<p>因为我们无法保证或者指定只使用一种cell，很多情况下我们是自定义的cell。这样的话每个不同种类的cell上的子视图是不相同的，在自动计算高度的时候对cell的布局有很高要求，所以我们一定要<code>保证我们计算用的cell与展示用的cell是同一种cell</code>。</p>\n<p>所以说我们这个方法只有<code>一个参数</code>，identifier。因为他是从重用池中取出cell的唯一必要参数。</p>\n<p>首先为了安全，先判断传入的identifier<code>是否为空</code>，若为空返回nil。只是为了安全。还有代码的<code>严谨性</code>。老司机又吹牛逼了，还代码严谨性，我的代码通常都考虑不周全的。。。</p>\n<p>然后是<code>通过runtime从绑定的属性中取出一个字典</code>。如果取到的这个字典为空则创建一个字典并绑定。</p>\n<p>为什么要创建一个字典呢，因为<code>我们要保证只取到这一个cell</code>。这个cell是为了干什么的呢，就是为了计算高度的，那么我每次计算高度的时候<code>只要有这么一个cell</code>就好了，不要去初始化太多根本不用于显示只用于计算的cell。</p>\n<p>然后<code>从字典中取出我们的cell</code>，如果取出的cell为空，则从重用池中取出一个cell。并存入字典。</p>\n<p>首先字典和cell的判空，都是针对第一次计算cell高度的时候来的。再次进入的时候都不会为空。<br>必须要说明的是，从重用池中取出cell的方法我们<code>一定</code>要使用<code>dequeueReusableCellWithIdentifier:</code>这种方式去取，不能以dequeueReusableCellWithIdentifier:indexPath那种方式去取。</p>\n<p>就像老司机注释中说的一样，若以indexPath那种方式去取会造成鸡生蛋蛋生鸡的问题，你这程序就进入死循环了。</p>\n<p>然后cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;这句是做什么呢？事实上，有两种自动布局方式，autoResizing和autoLayout。<br>autoResizing是<code>UIView的固有属性</code>。是在IOS6之前用来实现自动布局的属性。当然IOS6之后的autoLayout就要比他强大不少了。</p>\n<p>事实上这个属性<code>默认情况下是YES</code>。当为YES时，则我们<code>设置约束是无效</code>的。因为后续我们要手动<code>添加一个约束辅助我们计算</code>，所以这里我们<code>将其设为NO</code>。</p>\n<p>然后将计算标识符置真，标识这个cell只参与计算高度，不负责展示。以后遇到批量处理cell的时候可以判断这个标识符，让其不参与运算。<code>当然老司机这里只是留了一个接口，实际我们有对其进行处理</code>。</p>\n<p>通过这个方法，我们就成功的拿到了一个计算高度用的cell。</p>\n<hr>\n<h4 id=\"CGFloat-DW-CalculateCellHeightWithCell-UITableViewCell-cell\"><a href=\"#CGFloat-DW-CalculateCellHeightWithCell-UITableViewCell-cell\" class=\"headerlink\" title=\"-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\"></a>-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell</h4><p>第二个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">///根据cell计算cell的高度</div><div class=\"line\">-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat width = self.bounds.size.width;</div><div class=\"line\">    //根据辅助视图校正width</div><div class=\"line\">    if (cell.accessoryView) &#123;</div><div class=\"line\">        width -= cell.accessoryView.bounds.size.width + 16;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        static const CGFloat accessoryWidth[] = &#123;</div><div class=\"line\">            [UITableViewCellAccessoryNone] = 0,</div><div class=\"line\">            [UITableViewCellAccessoryDisclosureIndicator] = 34,</div><div class=\"line\">            [UITableViewCellAccessoryDetailDisclosureButton] = 68,</div><div class=\"line\">            [UITableViewCellAccessoryCheckmark] = 40,</div><div class=\"line\">            [UITableViewCellAccessoryDetailButton] = 48</div><div class=\"line\">        &#125;;</div><div class=\"line\">        width -= accessoryWidth[cell.accessoryType];</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat height = 0;</div><div class=\"line\">    if (!cell.NoAutoSizing &amp;&amp; width &gt; 0) &#123;//如果不是非自适应模式则添加约束后计算约束后高度</div><div class=\"line\">        NSLayoutConstraint * widthConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:width];//创建约束</div><div class=\"line\">        [cell.contentView addConstraint:widthConstraint];//添加约束</div><div class=\"line\">        height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;//计算高度</div><div class=\"line\">        [cell.contentView removeConstraint:widthConstraint];//移除约束</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (height == 0) &#123;//如果约束错误可能导致计算结果为零，则以自适应模式再次计算</div><div class=\"line\">        height = [cell sizeThatFits:CGSizeMake(width, 0)].height;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (height == 0) &#123;//如果计算仍然为0，则给出默认高度</div><div class=\"line\">        height = 44;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) &#123;//如果不为无分割线模式则添加分割线高度</div><div class=\"line\">        height += 1.0 /[UIScreen mainScreen].scale;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>首先我们要想计算出我们cell的高度，就需要拿到cell的<code>contentView的实际宽度</code>。</strong></p>\n<p>1.先拿到cell的宽度</p>\n<p>2.根据辅助视图样式校正宽度</p>\n<p>如果有自定义辅助视图，则按照自定义辅助视图的宽度去校正，如果没有按照系统辅助视图样式去校正宽度，然后<code>根据宽度计算高度</code>。</p>\n<p>3.然后如果是<code>使用autoLayout进行自适应计算</code>。</p>\n<p>这个也是老司机为之后留下的接口，可以控制是否进行一autoLayout进行计算。但实际并没有处理。</p>\n<p>这里是添加约束的写法，先<code>添加一个宽度约束</code>，然后让系统<code>根据宽度约束自动计算高度</code>，接着<code>去掉我们添加的约束</code>。</p>\n<p>4.如果根据约束计算结果错误，则<code>以sizeThatFits去计算高度</code>。</p>\n<p>5.如果计算结果仍然为零，则给出<code>默认值44</code>。</p>\n<p>6.判断当前tableView的分割线样式，如果有分割线，还要<code>校正高度</code>。</p>\n<p>好了，至此你已经计算出这个cell应该有的高度了。</p>\n<hr>\n<h4 id=\"CGFloat-DW-CalCulateCellWithIdentifier-NSString-identifier-configuration-void-id-cell-configuration\"><a href=\"#CGFloat-DW-CalCulateCellWithIdentifier-NSString-identifier-configuration-void-id-cell-configuration\" class=\"headerlink\" title=\"-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration\"></a>-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration</h4><p>最后一个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">///根据重用表示取出cell并操作cell后，计算高度</div><div class=\"line\">-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">                           configuration:(void(^)(id cell))configuration</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!identifier.length) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    UITableViewCell * cell = [self DW_CalculateCellWithIdentifier:identifier];</div><div class=\"line\">    [cell prepareForReuse];//放回重用池</div><div class=\"line\">    if (configuration) &#123;</div><div class=\"line\">        configuration(cell);//对cell进行操作</div><div class=\"line\">   &#125;</div><div class=\"line\">回重用池</div><div class=\"line\">    return [self DW_CalculateCellHeightWithCell:cell];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法就比较简单了，先判断重用标示。如果空，直接返回0。还是只为了安全。</p>\n<p>再通过<code>第一个方法取出cell</code>，然后<code>将它放回重用池</code>，以至于下次<code>我们还能取出来这个cell</code>。</p>\n<p>不要在意我之后还要对cell进行操作，这个<code>重用池只是一个概念</code>，其实并不是什么东西，只是标志着这里面的cell可以用于重用，你完全可以理解成他只是cell的一个标签。所以我之后还是可以继续使用这个cell。不要纠结重用池、取出、放回了，少年，他只是一个概念。</p>\n<p>哦对了，另外有一点你要注意，你记不记得老司机说过，进入重用池，是将整个cell存储下来，<code>并没有做其他任何操作</code>。</p>\n<p>其实你可以<code>重写prepareForReuse这个方法</code>，这里可以做任何你想做的事。比如清除所有子视图。不过有三点你需要注意：</p>\n<ul>\n<li>别忘了先写[super prepareForReuse];</li>\n<li>真清除所有子视图的时候记得别把contentView也删了</li>\n<li>重写之后上面的程序中你要合理的考虑一下[cell prepareForReuse]这句话的位置，反正这么跟你讲，我是没想出来放哪。。</li>\n</ul>\n<p>最后就是返回高度了。终于完事了。</p>\n<hr>\n<h3 id=\"留给外界的接口\"><a href=\"#留给外界的接口\" class=\"headerlink\" title=\"留给外界的接口\"></a>留给外界的接口</h3><h4 id=\"CGFloat-DW-CalculateCellWithIdentifier-NSString-identifier-indexPath-NSIndexPath-indexPath-configuration-void-id-cell-configuration\"><a href=\"#CGFloat-DW-CalculateCellWithIdentifier-NSString-identifier-indexPath-NSIndexPath-indexPath-configuration-void-id-cell-configuration\" class=\"headerlink\" title=\"-(CGFloat)DW_CalculateCellWithIdentifier:(NSString )identifier indexPath:(NSIndexPath )indexPath configuration:(void(^)(id cell))configuration\"></a>-(CGFloat)DW_CalculateCellWithIdentifier:(NSString <em>)identifier indexPath:(NSIndexPath </em>)indexPath configuration:(void(^)(id cell))configuration</h4><p>我只说一个，这是最重要的一个返回高度的接口了，如果每次我们都计算高度，那我们这写法也算是废了，充其量算一个自动返回高度的算法。</p>\n<p>所以我们的逻辑应该是<code>先从cache里面中找，如果没有，计算并存储</code>。下次再找这个indexPath的时候就能找到了，正如下面的代码一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">                               indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                           configuration:(void(^)(id cell))configuration</div><div class=\"line\">&#123;</div><div class=\"line\">    if(self.bounds.size.width != 0)//防止初始宽度为0（如autoLayout初次加载时）</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (!identifier.length || !indexPath) &#123;//非空判断</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSString * key = [self.cache makeKeyWithIdentifier:identifier indexPath:indexPath];//制作key</div><div class=\"line\">        if ([self.cache existInCacheByKey:key]) &#123;//如果key存在</div><div class=\"line\">            return [self.cache heightFromCacheWithKey:key];//从字典中取出高</div><div class=\"line\">        &#125;</div><div class=\"line\">        CGFloat height = [self DW_CalCulateCellWithIdentifier:identifier configuration:configuration];//不存在则计算高度</div><div class=\"line\">        [self.cache cacheHeight:height byKey:key];//并缓存</div><div class=\"line\">        return height;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"最后关于如何使用\"><a href=\"#最后关于如何使用\" class=\"headerlink\" title=\"最后关于如何使用\"></a>最后关于如何使用</h3><p>就是在原来返回tableView高度的方法出调用上面那个方法，仅此而已。</p>\n<p>特别注意，<code>一定要在方法中先填充数据，一定要在方法中先填充数据，一定要在方法中先填充数据</code>。重要的事情说三遍。否则你永远都是44啊亲们。。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b6f493667866eee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"注入数据\"></p>\n<hr>\n<p>我知道今天这个教程看上去很抽象，所以这次我会附上demo的链接。</p>\n<p><a href=\"http://pan.baidu.com/s/1dFK6iHV\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n<p>不过老司机还是想说一下自己对demo这件事的看法。</p>\n<p>老司机能选择在这里分享一些自己学到的东西，自然就不是一个敝帚自珍的人。然而之所以不爱附上demo链接是因为老司机觉得每次我都已经很详细的在博客中贴出我全部代码而且一句一句讲解真的已经知无不言言无不尽了，我觉得编程这种东西还是得下手敲一遍，看别人的东西看一天也看不懂。所以我更提倡你们自己去敲一遍。如果我把demo链接一放出来，你们直接下载了就去看，就去改，真的没有自己敲一遍学的快。当然有同学实在有需要可以留下邮箱，老司机会给你单独发demo的。</p>\n<hr>\n<p>常用套话了，这么贪幕虚荣的老司机不就图你点个喜欢么=。=，觉得好点个喜欢吧。</p>\n<p>转载记得附上链接。<br><a href=\"http://www.jianshu.com/p/2b192257276f\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/2b192257276f</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a69cecb9aaa3f2d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TableView优化之高度缓存\"><br>系列文章：</p>\n<ul>\n<li><p><a href=\"http://www.jianshu.com/p/2b192257276f\" target=\"_blank\" rel=\"external\">TableView优化之高度缓存功能</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/328e503900d0\" target=\"_blank\" rel=\"external\">TableView优化之加载图片的优化逻辑</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/0b020518de5e\" target=\"_blank\" rel=\"external\">TableView优化之快速滑动下的忽略加载</a></p>\n</li>\n</ul>\n<hr>\n<p>日常开发中，tableView的使用率很高，所以相对tableView的优化来说可以做很多很多的事情。很多情况下，我们的每一个cell都没有一个固定的高度，而是根据cell里面的内容自适应高度的。那么每次当我们cell将要出现在屏幕的时候，系统都会去计算cell的高度。如果说我能通过某种手段，在首次计算的时候，将每个cell对应的高度保存下载，当下次需要用到cell高度的时候再从保存的地方取出，从而减少了计算量，来达到优化的目的。</p>\n<p>因此应运而生了这套高度缓存的算法。</p>\n<p>在此声明，这套算法<code>不是老司机原创</code>，是整合并优化了外国一位大神的源码。</p>\n<p><strong>再次声明，</strong><br>这原来是国人算法，扬我国威啊，原型名<br>UITableView-FDTemplateLayoutCell。</p>\n<hr>\n<p>这篇博客中你可能会用到</p>\n<ul>\n<li>category 、subclass、protocol之间的区别</li>\n<li>自动布局相关</li>\n<li>runTime动态绑定</li>\n<li>tableViewCell重用的相关</li>\n</ul>\n<p>恩，其实东西并不多，重要的还是一个思想。</p>","more":"<hr>\n<h2 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h2><p>老规矩，还是先放全部代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UITableView+HeightCache.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation UITableView (HeightCache)</div><div class=\"line\"></div><div class=\"line\">#pragma mark ---接口方法---</div><div class=\"line\">-(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">                               indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                           configuration:(void(^)(id cell))configuration</div><div class=\"line\">&#123;</div><div class=\"line\">    if(self.bounds.size.width != 0)//防止初始宽度为0（如autoLayout初次加载时）</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (!identifier.length || !indexPath) &#123;//非空判断</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSString * key = [self.cache makeKeyWithIdentifier:identifier indexPath:indexPath];//制作key</div><div class=\"line\">        if ([self.cache existInCacheByKey:key]) &#123;//如果key存在</div><div class=\"line\">            return [self.cache heightFromCacheWithKey:key];//从字典中取出高</div><div class=\"line\">        &#125;</div><div class=\"line\">        CGFloat height = [self DW_CalCulateCellWithIdentifier:identifier configuration:configuration];//不存在则计算高度</div><div class=\"line\">        [self.cache cacheHeight:height byKey:key];//并缓存</div><div class=\"line\">        return height;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)DW_RemoveHeightCacheWithIdentifier:(NSString *)identifier</div><div class=\"line\">                                indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                             numberOfRows:(NSInteger)rows</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache removeHeightByIdentifier:identifier indexPath:indexPath numberOfRows:rows];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)DW_RemoveAllHeightCache</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache removeAllHeight];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)DW_InsertCellToIndexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                 withIdentifier:(NSString *)identifier</div><div class=\"line\">                   numberOfRows:(NSInteger)rows</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache insertCellToIndexPath:indexPath withIdentifier:identifier numberOfRows:rows toDictionaryForCache:self.cache.dicHeightCurrent];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)DW_MoveCellFromIndexPath:(NSIndexPath *)sourceIndexPath</div><div class=\"line\">    sourceIndexPathNumberOfRows:(NSInteger)sourceRows</div><div class=\"line\">                    toIndexPath:(NSIndexPath *)destinationIndexPath</div><div class=\"line\">destinationIndexPathNumberOfRows:(NSInteger)destinationRows</div><div class=\"line\">                 withIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache moveCellFromIndexPath:sourceIndexPath sourceSectionNumberOfRows:sourceRows toIndexPath:destinationIndexPath destinationSectionNumberOfRows:destinationRows withIdentifier:identifier];</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark ---工具方法---</div><div class=\"line\">///从重用池中返回计算用的cell</div><div class=\"line\">-(__kindof UITableViewCell  *)DW_CalculateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!identifier.length) &#123;</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSMutableDictionary &lt;NSString * ,UITableViewCell *&gt; *DicForTheUniqueCalCell = objc_getAssociatedObject(self, _cmd);//利用runtime取出tableV绑定的存有cell的字典</div><div class=\"line\">    if (!DicForTheUniqueCalCell) &#123;</div><div class=\"line\">        DicForTheUniqueCalCell = [NSMutableDictionary dictionary];//如果取不到则新建并绑定</div><div class=\"line\">        objc_setAssociatedObject(self, _cmd, DicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//动态绑定（绑定目标，关键字，绑定者，策略）</div><div class=\"line\">    &#125;</div><div class=\"line\">    //以上只是为了只绑定一个字典，类比懒加载</div><div class=\"line\">    UITableViewCell * cell = DicForTheUniqueCalCell[identifier];</div><div class=\"line\">    if (!cell) &#123;</div><div class=\"line\">        cell = [self dequeueReusableCellWithIdentifier:identifier];//从重用池中取一个cell用来计算，必须以本方式从重用池中取，若以indexPath方式取由于-heightForRowAtIndexPath方法会造成循环。</div><div class=\"line\">        cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;//开启约束</div><div class=\"line\">        cell.JustForCal = YES;//标记只用来计算</div><div class=\"line\">        DicForTheUniqueCalCell[identifier] = cell;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //同上，保证只有一个用来计算的cell</div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///根据重用表示取出cell并操作cell后，计算高度</div><div class=\"line\">-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">                           configuration:(void(^)(id cell))configuration</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!identifier.length) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    UITableViewCell * cell = [self DW_CalculateCellWithIdentifier:identifier];</div><div class=\"line\">    [cell prepareForReuse];//放回重用池</div><div class=\"line\">    if (configuration) &#123;</div><div class=\"line\">        configuration(cell);//对cell进行操作</div><div class=\"line\">    &#125;    </div><div class=\"line\">    return [self DW_CalculateCellHeightWithCell:cell];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///根据cell计算cell的高度</div><div class=\"line\">-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat width = self.bounds.size.width;</div><div class=\"line\">    //根据辅助视图校正width</div><div class=\"line\">    if (cell.accessoryView) &#123;</div><div class=\"line\">        width -= cell.accessoryView.bounds.size.width + 16;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        static const CGFloat accessoryWidth[] = &#123;</div><div class=\"line\">            [UITableViewCellAccessoryNone] = 0,</div><div class=\"line\">            [UITableViewCellAccessoryDisclosureIndicator] = 34,</div><div class=\"line\">            [UITableViewCellAccessoryDetailDisclosureButton] = 68,</div><div class=\"line\">            [UITableViewCellAccessoryCheckmark] = 40,</div><div class=\"line\">            [UITableViewCellAccessoryDetailButton] = 48</div><div class=\"line\">        &#125;;</div><div class=\"line\">        width -= accessoryWidth[cell.accessoryType];</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat height = 0;</div><div class=\"line\">    if (!cell.NoAutoSizing &amp;&amp; width &gt; 0) &#123;//如果不是非自适应模式则添加约束后计算约束后高度</div><div class=\"line\">        NSLayoutConstraint * widthConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:width];//创建约束</div><div class=\"line\">        [cell.contentView addConstraint:widthConstraint];//添加约束</div><div class=\"line\">        height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;//计算高度</div><div class=\"line\">        [cell.contentView removeConstraint:widthConstraint];//移除约束</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (height == 0) &#123;//如果约束错误可能导致计算结果为零，则以自适应模式再次计算</div><div class=\"line\">        height = [cell sizeThatFits:CGSizeMake(width, 0)].height;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (height == 0) &#123;//如果计算仍然为0，则给出默认高度</div><div class=\"line\">        height = 44;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) &#123;//如果不为无分割线模式则添加分割线高度</div><div class=\"line\">        height += 1.0 /[UIScreen mainScreen].scale;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return height;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark ---setter、getter---</div><div class=\"line\">-(HeightCache *)cache//懒加载形式</div><div class=\"line\">&#123;</div><div class=\"line\">    HeightCache * cacheTemp = objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">    if (!cacheTemp) &#123;</div><div class=\"line\">        cacheTemp = [HeightCache new];</div><div class=\"line\">        objc_setAssociatedObject(self, _cmd, cacheTemp, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return cacheTemp;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setCache:(HeightCache *)cache</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(cache), cache, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation UITableViewCell (HeightCacheCell)</div><div class=\"line\">#pragma mark ---setter、getter---</div><div class=\"line\">-(BOOL)NoAutoSizing</div><div class=\"line\">&#123;</div><div class=\"line\">    return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setNoAutoSizing:(BOOL)NoAutoSizing</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);//关键字用getter的方法名，为保持关键字一致</div><div class=\"line\">&#125;</div><div class=\"line\">-(BOOL)JustForCal</div><div class=\"line\">&#123;</div><div class=\"line\">    return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setJustForCal:(BOOL)JustForCal</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(JustForCal), @(JustForCal), OBJC_ASSOCIATION_RETAIN);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation HeightCache</div><div class=\"line\">///制作key</div><div class=\"line\">-(NSString *)makeKeyWithIdentifier:(NSString *)identifier</div><div class=\"line\">                         indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    return [NSString stringWithFormat:@&quot;%@S%ldR%ld&quot;,identifier,indexPath.section,indexPath.row];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///高度是否存在</div><div class=\"line\">-(BOOL)existInCacheByKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    NSNumber * value = [self.dicHeightCurrent valueForKey:key];</div><div class=\"line\">    return (value &amp;&amp; ![value isEqualToNumber:@-1]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///取出缓存的高度</div><div class=\"line\">-(CGFloat)heightFromCacheWithKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    NSNumber * value = [self.dicHeightCurrent valueForKey:key];</div><div class=\"line\">    if ([self is64bit]) &#123;</div><div class=\"line\">        return [value doubleValue];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [value floatValue];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///64位判断</div><div class=\"line\">- (BOOL)is64bit</div><div class=\"line\">&#123;</div><div class=\"line\">#if defined(__LP64__) &amp;&amp; __LP64__</div><div class=\"line\">    return YES;</div><div class=\"line\">#else</div><div class=\"line\">    return NO;</div><div class=\"line\">#endif</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///高度缓存</div><div class=\"line\">-(void)cacheHeight:(CGFloat)height</div><div class=\"line\">             byKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.dicHeightCurrent setValue:@(height) forKey:key];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///根据key删除缓存</div><div class=\"line\">-(void)removeHeightByIdentifier:(NSString *)identifier</div><div class=\"line\">                      indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                   numberOfRows:(NSInteger)rows</div><div class=\"line\">&#123;</div><div class=\"line\">    if (indexPath.row &lt; rows) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; rows - 1 - indexPath.row; i ++) &#123;</div><div class=\"line\">            NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:indexPath.row + i inSection:indexPath.section];</div><div class=\"line\">            NSLog(@&quot;%ld,%ld&quot;,indexPathA.row,indexPathA.section);</div><div class=\"line\">            NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:indexPath.row + i + 1 inSection:indexPath.section];</div><div class=\"line\">            NSLog(@&quot;%ld,%ld&quot;,indexPathB.row,indexPathB.section);</div><div class=\"line\">            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheH];</div><div class=\"line\">            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheV];</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSIndexPath * indexPathC = [NSIndexPath indexPathForRow:rows - 1 inSection:indexPath.section];</div><div class=\"line\">        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:indexPathC];</div><div class=\"line\">        [self.dicHeightCacheH removeObjectForKey:key];</div><div class=\"line\">        [self.dicHeightCacheV removeObjectForKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///删除所有缓存</div><div class=\"line\">-(void)removeAllHeight</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.dicHeightCacheH removeAllObjects];</div><div class=\"line\">    [self.dicHeightCacheV removeAllObjects];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///插入cell是插入value</div><div class=\"line\">-(void)insertCellToIndexPath:(NSIndexPath *)indexPath</div><div class=\"line\">            withNumberOfRows:(NSInteger)rows</div><div class=\"line\">                heightNumber:(NSNumber *)height</div><div class=\"line\">                  identifier:(NSString *)identifier</div><div class=\"line\">        toDictionaryForCache:(NSMutableDictionary *)dic</div><div class=\"line\">&#123;</div><div class=\"line\">    if (indexPath.row &lt; rows + 1) &#123;</div><div class=\"line\">        [self insertCellToIndexPath:indexPath withIdentifier:identifier numberOfRows:rows toDictionaryForCache:dic];</div><div class=\"line\">        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:indexPath];</div><div class=\"line\">        [dic setValue:height forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)insertCellToIndexPath:(NSIndexPath *)indexPath withIdentifier:(NSString *)identifier numberOfRows:(NSInteger)rows toDictionaryForCache:(NSMutableDictionary *)dic</div><div class=\"line\">&#123;</div><div class=\"line\">    if (indexPath.row &lt; rows + 1) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; rows - indexPath.row; i ++) &#123;</div><div class=\"line\">            NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:rows - i inSection:indexPath.section];</div><div class=\"line\">            NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:rows - i - 1 inSection:indexPath.section];</div><div class=\"line\">            [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:dic];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">///移动cell时交换value</div><div class=\"line\">-(void)moveCellFromIndexPath:(NSIndexPath *)sourceIndexPath</div><div class=\"line\">   sourceSectionNumberOfRows:(NSInteger)sourceRows</div><div class=\"line\">                 toIndexPath:(NSIndexPath *)destinationIndexPath</div><div class=\"line\">destinationSectionNumberOfRows:(NSInteger)destinationRows</div><div class=\"line\">              withIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    if (sourceIndexPath.section == destinationIndexPath.section) &#123;</div><div class=\"line\">        [self moveCellInSectionFromIndexPath:sourceIndexPath toIndexPath:destinationIndexPath withIdentifier:identifier];</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        [self moveCellOutSectionFromIndexPath:sourceIndexPath sourceSectionNumberOfRows:sourceRows toIndexPath:destinationIndexPath destinationSectionNumberOfRows:destinationRows withIdentifier:identifier];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">///组内移动</div><div class=\"line\">-(void)moveCellInSectionFromIndexPath:(NSIndexPath *)sourceIndexPath</div><div class=\"line\">                          toIndexPath:(NSIndexPath *)destinationIndexPath</div><div class=\"line\">                       withIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    NSInteger rowA = sourceIndexPath.row;</div><div class=\"line\">    NSInteger rowB = destinationIndexPath.row;</div><div class=\"line\">    for (int i = 0; i &lt; (MAX(rowA, rowB) - MIN(rowA, rowB)); i ++) &#123;</div><div class=\"line\">        NSIndexPath * indexPathA = [NSIndexPath indexPathForRow:MIN(rowA, rowB) + i inSection:sourceIndexPath.section];</div><div class=\"line\">        NSIndexPath * indexPathB = [NSIndexPath indexPathForRow:MIN(rowA, rowB) + i + 1 inSection:sourceIndexPath.section];</div><div class=\"line\">        [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheV];</div><div class=\"line\">        [self exchangeValueForIndexPathA:indexPathA andIndexPathB:indexPathB withIdentifier:identifier dictionary:self.dicHeightCacheH];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">///组外移动</div><div class=\"line\">-(void)moveCellOutSectionFromIndexPath:(NSIndexPath *)sourceIndexPath</div><div class=\"line\">             sourceSectionNumberOfRows:(NSInteger)sourceRows</div><div class=\"line\">                           toIndexPath:(NSIndexPath *)destinationIndexPath</div><div class=\"line\">        destinationSectionNumberOfRows:(NSInteger)destinationRows</div><div class=\"line\">                        withIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    NSNumber * numberH;</div><div class=\"line\">    NSNumber * numberV;</div><div class=\"line\">    NSLog(@&quot;%ld&quot;,sourceIndexPath.row);</div><div class=\"line\">    if (sourceIndexPath.row &lt; sourceRows) &#123;</div><div class=\"line\">        NSString * key = [self makeKeyWithIdentifier:identifier indexPath:sourceIndexPath];</div><div class=\"line\">        numberH = self.dicHeightCacheH[key];</div><div class=\"line\">        numberV = self.dicHeightCacheV[key];</div><div class=\"line\">        [self removeHeightByIdentifier:identifier indexPath:sourceIndexPath numberOfRows:sourceRows];</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;%ld,%ld&quot;,destinationIndexPath.row,destinationIndexPath.section);</div><div class=\"line\">    [self insertCellToIndexPath:destinationIndexPath withNumberOfRows:destinationRows heightNumber:numberH identifier:identifier toDictionaryForCache:self.dicHeightCacheH];</div><div class=\"line\">    [self insertCellToIndexPath:destinationIndexPath withNumberOfRows:destinationRows heightNumber:numberV identifier:identifier toDictionaryForCache:self.dicHeightCacheV];</div><div class=\"line\">&#125;</div><div class=\"line\">///根据indexPath交换两个Key</div><div class=\"line\">-(void)exchangeValueForIndexPathA:(NSIndexPath *)indexPathA</div><div class=\"line\">                    andIndexPathB:(NSIndexPath *)indexPathB</div><div class=\"line\">                   withIdentifier:(NSString *)identifier</div><div class=\"line\">                       dictionary:(NSMutableDictionary *)dic</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString * keyA = [self makeKeyWithIdentifier:identifier indexPath:indexPathA];</div><div class=\"line\">    NSString * keyB = [self makeKeyWithIdentifier:identifier indexPath:indexPathB];</div><div class=\"line\">    NSNumber * Temp = dic[keyA];</div><div class=\"line\">    dic[keyA] = dic[keyB];</div><div class=\"line\">    dic[keyB] = Temp;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark ---懒加载---</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCacheH</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_dicHeightCacheH) &#123;</div><div class=\"line\">        _dicHeightCacheH = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dicHeightCacheH;</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCacheV</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_dicHeightCacheV) &#123;</div><div class=\"line\">        _dicHeightCacheV = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dicHeightCacheV;</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCurrent//根据系统状态返回对应字典</div><div class=\"line\">&#123;</div><div class=\"line\">    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation)?self.dicHeightCacheV:self.dicHeightCacheH;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><code>这么多，你这个骗子！</code><br>你是不是这么想得。</p>\n<p>别慌，东西不多，因为这是一个category，复用性非常高，所以老司机想尽量减少文件个数，这样集成的时候也方便不是。</p>\n<p>所以，老司机<code>把三个类写在一个文件里了</code>。</p>\n<p>之前有人问过我把几个类写在一个文件中<code>有什么好处么</code>？</p>\n<p>老司机目前只能说，<code>除了看上去装逼点，别的没什么卵用</code>。</p>\n<p>可能是老司机的理解不深，不过为了集成方便我还是写在一个文件里了。</p>\n<p>废话不多说，分段讲解吧。</p>\n<hr>\n<h2 id=\"分段解析\"><a href=\"#分段解析\" class=\"headerlink\" title=\"分段解析\"></a>分段解析</h2><h3 id=\"为什么选择category而不是subclass\"><a href=\"#为什么选择category而不是subclass\" class=\"headerlink\" title=\"为什么选择category而不是subclass\"></a>为什么选择category而不是subclass</h3><p>我想很多人都会有疑问，为什么选择category而不是继承，毕竟category不能添加属性,用起来不是很方便。说到这又要老生常谈了。</p>\n<blockquote>\n<p>Protocol只是声明一套接口，并不能提供具体实现，变相的也算是一种抽象基类的实现方式（OC本身语法并不支持抽象基类）。</p>\n<p>Category可以为已有的类提供额外的接口和具体的实现。</p>\n<p>Protocol只能提供一套公用的接口声明，并不能提供具体实现，它的行为是，我只负责声明，而不管谁去实现，去如何实现。这样的话，我定义一套接口，可以使任意的类都用不同的方式去实现接口中的方法，就是为遵守了protocol的类提供了一些额外访问这个类的一些接口，像delegate和dataSource用protocol实现是最好的。</p>\n<p>Category是对一个功能完备的类的一种补充、扩展，就像一个东西基本功能都完成了，可以用category为这个类添加不同的组件，使得这个类能够适应不同情况的需求（但是这些不同需求最核心的需求要一致）。当然，当某个类非常大的时候，使用category可以按照不同的功能将类的实现分在不同的模块中。还有，虽然category可以访问已有类的实例变量，但不能创建新的实例变量，如果要创建新的实例变量，请使用继承。</p>\n<p>继承，它基于Protocol和Category之间，既可以像protocol一样只提供纯粹的接口，也可以像Category一样提供接口的完整实现，可以自由定义类的实例变量（这一点，Protocol倒是可以声明实例变量，但是也仅仅是声明而已），而且继承还可以对类以后的方法进行改写，所以继承的力量是最强大的。</p>\n<p>在iOS开发中，继承是完全可以完成protocol和category的功能的，那么在开发过程中多多使用继承体系可好？</p>\n<p>需要注意的是使用继承还有很大的代价问题。使用继承来进行扩展是一种耦合度很高的行为，对父类可以说是完全依赖，如果继承体系太过复杂，会造成难以维护的问题。如果仅仅只是对类进行扩展，并不建议使用继承，毕竟使用protocol和category是很简单、轻松的。除此之外，在开发过程中，我们应该尽量将界面、功能相似的类的代码提取到基类里面，然后各个子类继承自这个基类，实现各自的其他特殊部分。这样可以大大的优化代码，如果需要修改的话，只需要这倒对应子类修改即可。</p>\n</blockquote>\n<p>是不是感觉老司机屌屌的，啧啧啧，我百度的。</p>\n<p>我选择category就一个原因，扩展方便，二次开发也方便。</p>\n<hr>\n<h3 id=\"类目拆解\"><a href=\"#类目拆解\" class=\"headerlink\" title=\"类目拆解\"></a>类目拆解</h3><p>老司机说过，这一坨代码是三个类写在了一个文件里，他们都是什么呢？</p>\n<ul>\n<li>UITableView的category</li>\n<li>UITableViewCell的category</li>\n<li>一个NSObject的子类</li>\n</ul>\n<p>他们分别是做什么的呢？</p>\n<p>首先，给UITableView添加category是因为为了<code>实现高度缓存</code>，我的方案是在计算高度的时候就模拟数据填充，从而计算出该cell的高度，所以，tableView应该有填充数据和计算高度的方法。故为其添加分类。</p>\n<p>而那个继承于NSObject的子类就是用来<code>存储计算出来的高度的</code>，这样当下次需要计算的时候直接从这里取出即可。</p>\n<p>至于那个UITableViewCell的类目是为了<code>给cell添加两个标识符</code>，一个用来判断当前cell是否需要一autolayout进行绘制，另一个是用来区分计算用的cell还是展示用的cell。这点现在可能你还不懂，一会我们会做相应介绍。</p>\n<hr>\n<h3 id=\"UITableViewCell的category\"><a href=\"#UITableViewCell的category\" class=\"headerlink\" title=\"UITableViewCell的category\"></a>UITableViewCell的category</h3><p>为什么先说这个类目呢，因为这个类目的内容最少，而且只用到了runtime的动态绑定，可以拿出来单独介绍一下runtime的相关知识。</p>\n<h4 id=\"什么是runtime\"><a href=\"#什么是runtime\" class=\"headerlink\" title=\"什么是runtime\"></a>什么是runtime</h4><p>run，运行，time，时间，那么runtime就是运行时。恩，简单不？<br>然后我们说说。。。诶诶诶，别打别打，开个玩笑。<br>runtime，简称运行时，是<code>系统在运行期间的一些机制</code>。而对于OC来讲呢，其中最重要的就是<code>消息机制</code>。</p>\n<p>C语言呢，我们<code>调用函数</code>，在<code>编译期</code>就已经确定了要调用那个函数，而且整个过程是<code>顺序执行</code>的。</p>\n<p>而在OC中呢，我们是讲<code>消息发送</code>的。而且我们是等待某个信号<code>触发才执行</code>代码的。我们知道OC事实上是基于C的，那他是怎么实现这套转换的呢？就是<code>通过runtime去实现</code>的。</p>\n<p>不信？不信跟我来做个试验。</p>\n<p>新开一个工程，删掉所有文件，只<code>留下info.plist和main.m</code>。并且将引入的头文件删除掉。</p>\n<p>再<code>建一个类</code>，里面随便写一个方法的声明和实现。</p>\n<p>然后<code>在main.m中引入这个类</code>，<code>初始化并调用刚才声明的方法</code>，如下图。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-7d31aa53377e7333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"新建一个工程\"></p>\n<p>此时，打开我们的终端。找到刚才的工程的main.m,并且输入<br><code>clang -rewrite-objc main.m</code>，点击回车。稍等你就会看到提示转换完成。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0056ec0cb777ee26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"转化我们的文件\"></p>\n<p>这回在finder中找到工程的文件夹，在main.m同级文件夹下多了一个文件<code>main.cpp</code>，这就是转换完的文件。我们看到代码还是很多的。<code>直接拖到最下方</code>我们大概能看到点认识的了，int main。。。</p>\n<p>这就是我们刚才<code>main函数里面的实现</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-fc8be701d9be1b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"找到实现\"></p>\n<p>看不懂？待我帮你捋捋，去掉一些类型转换用的修饰符后剩下如下代码，是不是清晰多了？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-4421b3ad6ca6a611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"姑且就叫化简吧\"></p>\n<p>先看被我框选中的代码，<code>objc_msgSend是说发送消息</code>，他有<code>两个参数</code>，一个是<code>实例</code>，一个是<code>方法</code>。<code>objc_getClass通过字符串获取到这个类</code>。<code>sel_registerName通过字符串获取方法</code>。所以这句话的意思就是<code>给这个类发送了这个消息，消息内容就是一个方法</code>。</p>\n<p>随后就容易了，给这个实例发送一个sayHello的消息，参数是后面的字符串。</p>\n<p>通过这里我们知道我们OC的语言是怎么实现的了吧，就是<code>通过runtime转化成了C++的代码</code>，然后进行运行。</p>\n<p>从这你也应该知道为什么OC中叫<code>发送消息</code>，不叫函数调用了吧。</p>\n<p>另外你还应该知道为什么OC中方法<code>只声明</code>，<code>不实现</code>，<code>编译时只报警不报错</code>，<code>运行时crash</code>是为什么了吧。</p>\n<p>既然说到这里就多少说一说C与OC吧。之前老司机说过，OC是基于C的，那么C语言中是没有对象这个概念呢，我们的对象又是什么呢？</p>\n<p><strong>右手啊，程序员哪有什么对象，啧啧啧。</strong></p>\n<p>除了右手，还有结构体，OC的对象就是<code>C语言中的结构体</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b4b5b2aa725808fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"对象的结构\"></p>\n<p>我们看到了，每个类都是一个都是一个结构体，其中有各种<code>指针</code>，指向一个类的各种<code>参数</code>，<code>父类、属性列表、方法列表等等</code>。</p>\n<p>所以说当我们声明了类的方法，方法列表里面就有这个方法了，然后编译通过了，然后调用的时候，方法选择器去本类的方法列表里去寻找方法的实现，如果没有实现，则去其父类中寻找，如果在没有通过一系列<code>消息转发机制</code>会一直找下去，直到最后也没有找到这个方法的实现就crash了。关于消息转发，其实还有很多东西，但是在这里讲就又扯远了，所以等下期吧=。=</p>\n<p>本例中我们用runtime做了些什么呢？</p>\n<h4 id=\"使用runtime动态为category绑定属性\"><a href=\"#使用runtime动态为category绑定属性\" class=\"headerlink\" title=\"使用runtime动态为category绑定属性\"></a>使用runtime动态为category绑定属性</h4><p>之前老司机说过，category是不能添加属性的。那我又要为其添加两个标识符，只能使用runtime去<code>动态绑定</code>了，在类的<code>属性列表</code>里面<code>通过runtime添加</code>上这个属性，那我就可以使用这个属性了。</p>\n<p>首先在.h的UITableCell的category的@interface之中添加两个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface UITableViewCell (HeightCacheCell)</div><div class=\"line\">@property (assign ,nonatomic)BOOL JustForCal;//计算用的cell标识符（将计算用的cell与正常显示的cell进行区分，避免不必要的ui响应）</div><div class=\"line\">@property (assign ,nonatomic)BOOL NoAutoSizing;//不适用autoSizing标识符（不依靠约束计算，只进行自适应）</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这是我为期添加的两个属性，具体有什么作用，下文中会提到的，先别急。</p>\n<p>然后在.m中添加两个属性的setter、getter方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation UITableViewCell (HeightCacheCell)</div><div class=\"line\">#pragma mark ---setter、getter---</div><div class=\"line\">-(BOOL)NoAutoSizing</div><div class=\"line\">&#123;</div><div class=\"line\">    return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setNoAutoSizing:(BOOL)NoAutoSizing</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);//关键字用getter的方法名，为保持关键字一致</div><div class=\"line\">&#125;</div><div class=\"line\">-(BOOL)JustForCal</div><div class=\"line\">&#123;</div><div class=\"line\">    return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setJustForCal:(BOOL)JustForCal</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(JustForCal), @(JustForCal), OBJC_ASSOCIATION_RETAIN);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这里老司机有必要说一下两个方法</p>\n<ul>\n<li>objc_setAssociatedObject</li>\n<li>objc_getAssociatedObject</li>\n</ul>\n<p>OC自解释语言的好处就体现出来了，从函数名你就可以看出来，一个是给对象设置联系，一个是从对象获取联系。反正我英语水平就这样，我也没查字典，对不对的我就不深究了。一个setter一个getter就在这。</p>\n<h5 id=\"objc-setAssociatedObject\"><a href=\"#objc-setAssociatedObject\" class=\"headerlink\" title=\"objc_setAssociatedObject\"></a>objc_setAssociatedObject</h5><p>objc_setAssociatedObject(self, @selector(NoAutoSizing), @(NoAutoSizing), OBJC_ASSOCIATION_RETAIN);</p>\n<p>方法总共四个参数，分别是<code>绑定目标，关键字，绑定者，策略</code>。</p>\n<p>所以说简单了，绑定目标，就是给谁绑定，当然是UITableViewCell这个category了，所以self。</p>\n<p>绑定的关键字就是说我给这个对象绑定一个属性，我总要有一个标示符去表示那个属性吧，这样我要调用这个属性的时候通过标示符去寻找才能找到这个属性。</p>\n<p>绑定者，就是我们要为这个属性绑定的值了。</p>\n<p>绑定策略就是说绑定的这个属性的引用机制了。这里要说明一点，<code>这个绑定策略如何选择，老司机目前也没有搞懂</code>，所以策略这里都沿用了原作者的写法，等老司机搞懂了之后会告诉大家的。</p>\n<h5 id=\"objc-getAssociatedObject\"><a href=\"#objc-getAssociatedObject\" class=\"headerlink\" title=\"objc_getAssociatedObject\"></a>objc_getAssociatedObject</h5><p>两个参数，一个绑定目标，一个关键字，通过关键字从绑定目标中获取属性的值。</p>\n<p>这下是不是明白这两个setter、getter方法的意义了。</p>\n<p>好了，这个category讲完了，他的东西真的很少。</p>\n<p>什么，你敲不出来这两个方法？<br>忘了讲了，你没引入头文件。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;objc/runtime.h&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"HeightCache\"><a href=\"#HeightCache\" class=\"headerlink\" title=\"HeightCache\"></a>HeightCache</h3><p>为什么说这个类呢？怎么还不进入正题呢？说好的UITableView的category呢？</p>\n<p>因为这个类是<code>负责存储Cell高度</code>的类，而UITableView得category只是为获取cell高度提供了一个接口，当我们移动cell，添加cell，删除cell的时候要对这个高度的对应关系作出很多的操作，UITableView的category中<code>大量的使用了这里的方法</code>，所以老司机决定先把难啃的骨头解决了。</p>\n<p>在.h中添加三个字典</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (strong ,nonatomic)NSMutableDictionary * dicHeightCacheV;//竖直行高缓存字典</div><div class=\"line\">@property (strong ,nonatomic)NSMutableDictionary * dicHeightCacheH;//水平行高缓存字典</div><div class=\"line\">@property (strong ,nonatomic)NSMutableDictionary * dicHeightCurrent;//当前状态行高缓存字典（中间量）</div></pre></td></tr></table></figure>\n<p>为什么三个字典呢？老司机是这样考虑的，<code>横屏和竖屏</code>情况下同样内容的cell有可能是不同的，如果以同一个高度去取得话有可能出现高度不准确的问题。所以竖屏横屏分别一个字典。那这个current又是什么呢？就是<code>自动返回当前屏幕状态所对应的字典</code>那么一个中间量，这样我们写代码的时候可以不用考虑当前屏幕状态而<code>统一使用current这个字典</code>，减少很多代码量。</p>\n<p>去.m中看看是如何实现的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark ---懒加载---</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCacheH</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_dicHeightCacheH) &#123;</div><div class=\"line\">        _dicHeightCacheH = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dicHeightCacheH;</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCacheV</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_dicHeightCacheV) &#123;</div><div class=\"line\">        _dicHeightCacheV = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dicHeightCacheV;</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSMutableDictionary *)dicHeightCurrent//根据系统状态返回对应字典</div><div class=\"line\">&#123;</div><div class=\"line\">    return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation)?self.dicHeightCacheV:self.dicHeightCacheH;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面两个字典是懒加载，不多说了，在需要的时候创建字典。</p>\n<p>重点是这个current。</p>\n<p><code>UIDeviceOrientationIsPortrait()</code>这个方法是判断括号中的状态是否是竖屏状态的一个方法，所以括号里面我们给他当前屏幕状态他就可以判断是不是竖屏了。</p>\n<p>[UIDevice currentDevice].orientation而这句代码见名知意，取出<code>当前设备的屏幕状态</code>。</p>\n<p>让后通过<code>三目运算符</code>返回相应的字典。</p>\n<p>是不是写法上很简单，实际使用过程中也很方便。</p>\n<p>上面几个工具方法最主要的主要由如下几个方法，<code>交换两个cell高度</code>的值，<code>插入一个cell高度</code>的值，<code>删除一个cell高度</code>的值。通过这三个最基本的方法组合出所有cell操作需要用到的方法。算法都很基础，没什么需要说的。</p>\n<hr>\n<h3 id=\"UITableView的category\"><a href=\"#UITableView的category\" class=\"headerlink\" title=\"UITableView的category\"></a>UITableView的category</h3><p>最后的主角来了。其实你会发现这里的方法并不多。因为只是向外界提供了插入，删除，删除全部，移动，计算高度五个接口。</p>\n<p>我们看一下大体思路：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-68cc9b817178ed3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"大体思路\"></p>\n<p>老司机觉得自己画这图也是没谁了。。。</p>\n<p>.h中添加一个属性，是我们刚才用来<code>存储高度</code>的那个类的一个实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (strong ,nonatomic)HeightCache * cache;//缓存实例</div></pre></td></tr></table></figure>\n<p>其实你<code>完全可以写在.m里当做一个私有变量去处理</code>，这样也<code>更安全</code>一些。<br>老司机写在这里是<code>为了调试的时候更直观</code>的看到缓存高度操作时的状态。实际应用中，如无特殊需要，<code>建议将其写在.m中</code>。</p>\n<p>.m中，我们先看一下这几个工具方法，这才是核心部分。接口方法都是简单调用这几个工具方法，供外界调用的。</p>\n<hr>\n<ul>\n<li>-(__kindof UITableViewCell <em>)DW_CalculateCellWithIdentifier:(NSString </em>)identifier</li>\n<li>-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell</li>\n<li>-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration</li>\n</ul>\n<p>核心算法都在这了，我一定会好好解析的。(第一个方法返回值有一个*号我敲不出来，不知道markdown什么鬼冲突。。)</p>\n<h4 id=\"kindof-UITableViewCell-DW-CalculateCellWithIdentifier-NSString-identifier\"><a href=\"#kindof-UITableViewCell-DW-CalculateCellWithIdentifier-NSString-identifier\" class=\"headerlink\" title=\"-(__kindof UITableViewCell )DW_CalculateCellWithIdentifier:(NSString )identifier\"></a>-(__kindof UITableViewCell <em>)DW_CalculateCellWithIdentifier:(NSString </em>)identifier</h4><p>第一个方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">///从重用池中返回计算用的cell</div><div class=\"line\">-(__kindof UITableViewCell *)DW_CalculateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!identifier.length) &#123;</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSMutableDictionary &lt;NSString * ,UITableViewCell *&gt; *DicForTheUniqueCalCell = objc_getAssociatedObject(self, _cmd);//利用runtime取出tableV绑定的存有cell的字典</div><div class=\"line\">    if (!DicForTheUniqueCalCell) &#123;</div><div class=\"line\">        DicForTheUniqueCalCell = [NSMutableDictionary dictionary];//如果取不到则新建并绑定</div><div class=\"line\">        objc_setAssociatedObject(self, _cmd, DicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//动态绑定（绑定目标，关键字，绑定者，策略）</div><div class=\"line\">    &#125;</div><div class=\"line\">    //以上只是为了只绑定一个字典，类比懒加载</div><div class=\"line\">    UITableViewCell * cell = DicForTheUniqueCalCell[identifier];</div><div class=\"line\">    if (!cell) &#123;</div><div class=\"line\">        cell = [self dequeueReusableCellWithIdentifier:identifier];//从重用池中取一个cell用来计算，必须以本方式从重用池中取，若以indexPath方式取由于-heightForRowAtIndexPath方法会造成循环。</div><div class=\"line\">        cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;//开启约束</div><div class=\"line\">        cell.JustForCal = YES;//标记只用来计算</div><div class=\"line\">        DicForTheUniqueCalCell[identifier] = cell;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //同上，保证只有一个用来计算的cell</div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实每一句注释都表述的很清楚。不过老司机还是会一句一句给你说的，毕竟这才是老司机的风格，恩，就是<code>墨迹</code>。</p>\n<p>恩，老司机先说一说重用的问题吧。</p>\n<p>我们都喜欢用tableView，因为他很好的替我们做了内存控制的问题。</p>\n<p>他又是通过什么控制了内存呢？节省了性能呢？通过重用。</p>\n<p>这些大家都知道。但是有很多孩子误会了重用啊，孩子你们不懂重用啊。</p>\n<p>知道咋回事的这地方跳过吧。</p>\n<p>前方<code>高能预警</code>，以下内容<code>很基础</code>，<code>真的很基础</code>，<code>真的真的很基础</code>，只是给一些真的不知道的人看的。</p>\n<blockquote>\n<p>当一个cell将要离开屏幕时，这个cell会进入重用池。重用池并不是什么特殊的东西，就是系统给他放在一边了。他只是单纯的放在一边了，不进行任何操作。</p>\n<p>当一个cell将要进入屏幕的时候，会调用tableView:(UITableView *)tableView cellForRowAtIndexPath这个代理，执行其中的方法</p>\n</blockquote>\n<p>说这两句为了说明什么呢？<br>第一句我想说明的是，他只是放在重用池了，<code>没有进行任！何！操！作！</code></p>\n<p>重点在哪呢？重点就在于存储的是整个cell，<code>包括cell原有的和你添加的所有子视图</code>。</p>\n<p>第二句我想说明的是，他会执行代理中的<code>每！一！句！话！</code></p>\n<p>重点在哪呢？你从重用池中取出的cell，他是会对cell进行<code>再次进行绘制</code>。</p>\n<p>这两句说明了什么？</p>\n<ul>\n<li>cell上不要布置太多的控件，不然存入重用池也够你吃一壶的。</li>\n<li>tableView:(UITableView *)tableView cellForRowAtIndexPath这里面不要添加子视图，不然下次取出同一个cell的时候还会在同样的位置再添加一个同样的子视图。你上下来回滑动的时候cell就会添加无数个子视图。</li>\n<li>没有什么会影响重新绘制的，记住那句代码一定会走，只要走就一定会绘制。如果说你绘制出了什么问题，不要怪重用，跟他没关。问题一定在别的地方。</li>\n</ul>\n<p>恩，这是老司机对重用的理解。</p>\n<p><strong>刚才跳过的旅客朋友们，跳到这可以接上了。</strong></p>\n<p>接下来我们开始说这个方法。<br>为什么我们要取到这个cell呢？而不是随便一个cell呢？</p>\n<p>因为我们无法保证或者指定只使用一种cell，很多情况下我们是自定义的cell。这样的话每个不同种类的cell上的子视图是不相同的，在自动计算高度的时候对cell的布局有很高要求，所以我们一定要<code>保证我们计算用的cell与展示用的cell是同一种cell</code>。</p>\n<p>所以说我们这个方法只有<code>一个参数</code>，identifier。因为他是从重用池中取出cell的唯一必要参数。</p>\n<p>首先为了安全，先判断传入的identifier<code>是否为空</code>，若为空返回nil。只是为了安全。还有代码的<code>严谨性</code>。老司机又吹牛逼了，还代码严谨性，我的代码通常都考虑不周全的。。。</p>\n<p>然后是<code>通过runtime从绑定的属性中取出一个字典</code>。如果取到的这个字典为空则创建一个字典并绑定。</p>\n<p>为什么要创建一个字典呢，因为<code>我们要保证只取到这一个cell</code>。这个cell是为了干什么的呢，就是为了计算高度的，那么我每次计算高度的时候<code>只要有这么一个cell</code>就好了，不要去初始化太多根本不用于显示只用于计算的cell。</p>\n<p>然后<code>从字典中取出我们的cell</code>，如果取出的cell为空，则从重用池中取出一个cell。并存入字典。</p>\n<p>首先字典和cell的判空，都是针对第一次计算cell高度的时候来的。再次进入的时候都不会为空。<br>必须要说明的是，从重用池中取出cell的方法我们<code>一定</code>要使用<code>dequeueReusableCellWithIdentifier:</code>这种方式去取，不能以dequeueReusableCellWithIdentifier:indexPath那种方式去取。</p>\n<p>就像老司机注释中说的一样，若以indexPath那种方式去取会造成鸡生蛋蛋生鸡的问题，你这程序就进入死循环了。</p>\n<p>然后cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;这句是做什么呢？事实上，有两种自动布局方式，autoResizing和autoLayout。<br>autoResizing是<code>UIView的固有属性</code>。是在IOS6之前用来实现自动布局的属性。当然IOS6之后的autoLayout就要比他强大不少了。</p>\n<p>事实上这个属性<code>默认情况下是YES</code>。当为YES时，则我们<code>设置约束是无效</code>的。因为后续我们要手动<code>添加一个约束辅助我们计算</code>，所以这里我们<code>将其设为NO</code>。</p>\n<p>然后将计算标识符置真，标识这个cell只参与计算高度，不负责展示。以后遇到批量处理cell的时候可以判断这个标识符，让其不参与运算。<code>当然老司机这里只是留了一个接口，实际我们有对其进行处理</code>。</p>\n<p>通过这个方法，我们就成功的拿到了一个计算高度用的cell。</p>\n<hr>\n<h4 id=\"CGFloat-DW-CalculateCellHeightWithCell-UITableViewCell-cell\"><a href=\"#CGFloat-DW-CalculateCellHeightWithCell-UITableViewCell-cell\" class=\"headerlink\" title=\"-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell\"></a>-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell</h4><p>第二个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">///根据cell计算cell的高度</div><div class=\"line\">-(CGFloat)DW_CalculateCellHeightWithCell:(UITableViewCell *)cell</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat width = self.bounds.size.width;</div><div class=\"line\">    //根据辅助视图校正width</div><div class=\"line\">    if (cell.accessoryView) &#123;</div><div class=\"line\">        width -= cell.accessoryView.bounds.size.width + 16;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        static const CGFloat accessoryWidth[] = &#123;</div><div class=\"line\">            [UITableViewCellAccessoryNone] = 0,</div><div class=\"line\">            [UITableViewCellAccessoryDisclosureIndicator] = 34,</div><div class=\"line\">            [UITableViewCellAccessoryDetailDisclosureButton] = 68,</div><div class=\"line\">            [UITableViewCellAccessoryCheckmark] = 40,</div><div class=\"line\">            [UITableViewCellAccessoryDetailButton] = 48</div><div class=\"line\">        &#125;;</div><div class=\"line\">        width -= accessoryWidth[cell.accessoryType];</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat height = 0;</div><div class=\"line\">    if (!cell.NoAutoSizing &amp;&amp; width &gt; 0) &#123;//如果不是非自适应模式则添加约束后计算约束后高度</div><div class=\"line\">        NSLayoutConstraint * widthConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:width];//创建约束</div><div class=\"line\">        [cell.contentView addConstraint:widthConstraint];//添加约束</div><div class=\"line\">        height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;//计算高度</div><div class=\"line\">        [cell.contentView removeConstraint:widthConstraint];//移除约束</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (height == 0) &#123;//如果约束错误可能导致计算结果为零，则以自适应模式再次计算</div><div class=\"line\">        height = [cell sizeThatFits:CGSizeMake(width, 0)].height;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (height == 0) &#123;//如果计算仍然为0，则给出默认高度</div><div class=\"line\">        height = 44;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) &#123;//如果不为无分割线模式则添加分割线高度</div><div class=\"line\">        height += 1.0 /[UIScreen mainScreen].scale;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>首先我们要想计算出我们cell的高度，就需要拿到cell的<code>contentView的实际宽度</code>。</strong></p>\n<p>1.先拿到cell的宽度</p>\n<p>2.根据辅助视图样式校正宽度</p>\n<p>如果有自定义辅助视图，则按照自定义辅助视图的宽度去校正，如果没有按照系统辅助视图样式去校正宽度，然后<code>根据宽度计算高度</code>。</p>\n<p>3.然后如果是<code>使用autoLayout进行自适应计算</code>。</p>\n<p>这个也是老司机为之后留下的接口，可以控制是否进行一autoLayout进行计算。但实际并没有处理。</p>\n<p>这里是添加约束的写法，先<code>添加一个宽度约束</code>，然后让系统<code>根据宽度约束自动计算高度</code>，接着<code>去掉我们添加的约束</code>。</p>\n<p>4.如果根据约束计算结果错误，则<code>以sizeThatFits去计算高度</code>。</p>\n<p>5.如果计算结果仍然为零，则给出<code>默认值44</code>。</p>\n<p>6.判断当前tableView的分割线样式，如果有分割线，还要<code>校正高度</code>。</p>\n<p>好了，至此你已经计算出这个cell应该有的高度了。</p>\n<hr>\n<h4 id=\"CGFloat-DW-CalCulateCellWithIdentifier-NSString-identifier-configuration-void-id-cell-configuration\"><a href=\"#CGFloat-DW-CalCulateCellWithIdentifier-NSString-identifier-configuration-void-id-cell-configuration\" class=\"headerlink\" title=\"-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration\"></a>-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier configuration:(void(^)(id cell))configuration</h4><p>最后一个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">///根据重用表示取出cell并操作cell后，计算高度</div><div class=\"line\">-(CGFloat)DW_CalCulateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">                           configuration:(void(^)(id cell))configuration</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!identifier.length) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    UITableViewCell * cell = [self DW_CalculateCellWithIdentifier:identifier];</div><div class=\"line\">    [cell prepareForReuse];//放回重用池</div><div class=\"line\">    if (configuration) &#123;</div><div class=\"line\">        configuration(cell);//对cell进行操作</div><div class=\"line\">   &#125;</div><div class=\"line\">回重用池</div><div class=\"line\">    return [self DW_CalculateCellHeightWithCell:cell];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法就比较简单了，先判断重用标示。如果空，直接返回0。还是只为了安全。</p>\n<p>再通过<code>第一个方法取出cell</code>，然后<code>将它放回重用池</code>，以至于下次<code>我们还能取出来这个cell</code>。</p>\n<p>不要在意我之后还要对cell进行操作，这个<code>重用池只是一个概念</code>，其实并不是什么东西，只是标志着这里面的cell可以用于重用，你完全可以理解成他只是cell的一个标签。所以我之后还是可以继续使用这个cell。不要纠结重用池、取出、放回了，少年，他只是一个概念。</p>\n<p>哦对了，另外有一点你要注意，你记不记得老司机说过，进入重用池，是将整个cell存储下来，<code>并没有做其他任何操作</code>。</p>\n<p>其实你可以<code>重写prepareForReuse这个方法</code>，这里可以做任何你想做的事。比如清除所有子视图。不过有三点你需要注意：</p>\n<ul>\n<li>别忘了先写[super prepareForReuse];</li>\n<li>真清除所有子视图的时候记得别把contentView也删了</li>\n<li>重写之后上面的程序中你要合理的考虑一下[cell prepareForReuse]这句话的位置，反正这么跟你讲，我是没想出来放哪。。</li>\n</ul>\n<p>最后就是返回高度了。终于完事了。</p>\n<hr>\n<h3 id=\"留给外界的接口\"><a href=\"#留给外界的接口\" class=\"headerlink\" title=\"留给外界的接口\"></a>留给外界的接口</h3><h4 id=\"CGFloat-DW-CalculateCellWithIdentifier-NSString-identifier-indexPath-NSIndexPath-indexPath-configuration-void-id-cell-configuration\"><a href=\"#CGFloat-DW-CalculateCellWithIdentifier-NSString-identifier-indexPath-NSIndexPath-indexPath-configuration-void-id-cell-configuration\" class=\"headerlink\" title=\"-(CGFloat)DW_CalculateCellWithIdentifier:(NSString )identifier indexPath:(NSIndexPath )indexPath configuration:(void(^)(id cell))configuration\"></a>-(CGFloat)DW_CalculateCellWithIdentifier:(NSString <em>)identifier indexPath:(NSIndexPath </em>)indexPath configuration:(void(^)(id cell))configuration</h4><p>我只说一个，这是最重要的一个返回高度的接口了，如果每次我们都计算高度，那我们这写法也算是废了，充其量算一个自动返回高度的算法。</p>\n<p>所以我们的逻辑应该是<code>先从cache里面中找，如果没有，计算并存储</code>。下次再找这个indexPath的时候就能找到了，正如下面的代码一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(CGFloat)DW_CalculateCellWithIdentifier:(NSString *)identifier</div><div class=\"line\">                               indexPath:(NSIndexPath *)indexPath</div><div class=\"line\">                           configuration:(void(^)(id cell))configuration</div><div class=\"line\">&#123;</div><div class=\"line\">    if(self.bounds.size.width != 0)//防止初始宽度为0（如autoLayout初次加载时）</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (!identifier.length || !indexPath) &#123;//非空判断</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSString * key = [self.cache makeKeyWithIdentifier:identifier indexPath:indexPath];//制作key</div><div class=\"line\">        if ([self.cache existInCacheByKey:key]) &#123;//如果key存在</div><div class=\"line\">            return [self.cache heightFromCacheWithKey:key];//从字典中取出高</div><div class=\"line\">        &#125;</div><div class=\"line\">        CGFloat height = [self DW_CalCulateCellWithIdentifier:identifier configuration:configuration];//不存在则计算高度</div><div class=\"line\">        [self.cache cacheHeight:height byKey:key];//并缓存</div><div class=\"line\">        return height;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"最后关于如何使用\"><a href=\"#最后关于如何使用\" class=\"headerlink\" title=\"最后关于如何使用\"></a>最后关于如何使用</h3><p>就是在原来返回tableView高度的方法出调用上面那个方法，仅此而已。</p>\n<p>特别注意，<code>一定要在方法中先填充数据，一定要在方法中先填充数据，一定要在方法中先填充数据</code>。重要的事情说三遍。否则你永远都是44啊亲们。。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b6f493667866eee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"注入数据\"></p>\n<hr>\n<p>我知道今天这个教程看上去很抽象，所以这次我会附上demo的链接。</p>\n<p><a href=\"http://pan.baidu.com/s/1dFK6iHV\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n<p>不过老司机还是想说一下自己对demo这件事的看法。</p>\n<p>老司机能选择在这里分享一些自己学到的东西，自然就不是一个敝帚自珍的人。然而之所以不爱附上demo链接是因为老司机觉得每次我都已经很详细的在博客中贴出我全部代码而且一句一句讲解真的已经知无不言言无不尽了，我觉得编程这种东西还是得下手敲一遍，看别人的东西看一天也看不懂。所以我更提倡你们自己去敲一遍。如果我把demo链接一放出来，你们直接下载了就去看，就去改，真的没有自己敲一遍学的快。当然有同学实在有需要可以留下邮箱，老司机会给你单独发demo的。</p>\n<hr>\n<p>常用套话了，这么贪幕虚荣的老司机不就图你点个喜欢么=。=，觉得好点个喜欢吧。</p>\n<p>转载记得附上链接。<br><a href=\"http://www.jianshu.com/p/2b192257276f\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/2b192257276f</a></p>"},{"title":"TableView优化之加载图片的优化逻辑","layout":"post","date":"2016-04-15T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n系列文章：\n\n- [TableView优化之高度缓存功能](http://www.jianshu.com/p/2b192257276f)\n\n- [TableView优化之加载图片的优化逻辑](http://www.jianshu.com/p/328e503900d0)\n\n- [TableView优化之快速滑动下的忽略加载](http://www.jianshu.com/p/0b020518de5e)\n- - -\n日常中，最常使用的空间非UITableView莫属了。\n但是当TableView的cell中包含图片时，使用SDWebImage加载图片虽然是异步过程，但是仍然十分占用系统资源。\n那么我们就要想一个办法去优化加载图片的逻辑。\n\n此处，我只讲我自己的想法，或许也有更好的逻辑，还希望在下面留言指点我一下。\n\n我的想法是TableView滚动的时候不去加载未加载过的图片，停止滚动后再从网络加载。已经加载过得图片，无论什么时候都加载该图片（因为SDWebImage会将加载过得图片缓存下来，再次加载的时候从缓存中取，这样就不用开辟线程下载图片了）。\n\n<!-- more -->\n\n\n\n![啊.png](http://upload-images.jianshu.io/upload_images/1835430-6fdc073348c239aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![屏幕快照 2016-04-16 下午9.34.14.png](http://upload-images.jianshu.io/upload_images/1835430-acb3f2d28681883e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如上，就是我对TableView加载图片的优化逻辑。\n转载标注\nhttp://www.jianshu.com/p/328e503900d0\n","source":"_posts/TableView加载图片的优化逻辑.md","raw":"---\n\ntitle: TableView优化之加载图片的优化逻辑\nlayout: post\ndate: 2016-04-16 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- TableView优化 \n- TableView图片加载\ncategories: 性能优化\n\n---\n\n系列文章：\n\n- [TableView优化之高度缓存功能](http://www.jianshu.com/p/2b192257276f)\n\n- [TableView优化之加载图片的优化逻辑](http://www.jianshu.com/p/328e503900d0)\n\n- [TableView优化之快速滑动下的忽略加载](http://www.jianshu.com/p/0b020518de5e)\n- - -\n日常中，最常使用的空间非UITableView莫属了。\n但是当TableView的cell中包含图片时，使用SDWebImage加载图片虽然是异步过程，但是仍然十分占用系统资源。\n那么我们就要想一个办法去优化加载图片的逻辑。\n\n此处，我只讲我自己的想法，或许也有更好的逻辑，还希望在下面留言指点我一下。\n\n我的想法是TableView滚动的时候不去加载未加载过的图片，停止滚动后再从网络加载。已经加载过得图片，无论什么时候都加载该图片（因为SDWebImage会将加载过得图片缓存下来，再次加载的时候从缓存中取，这样就不用开辟线程下载图片了）。\n\n<!-- more -->\n\n\n\n![啊.png](http://upload-images.jianshu.io/upload_images/1835430-6fdc073348c239aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![屏幕快照 2016-04-16 下午9.34.14.png](http://upload-images.jianshu.io/upload_images/1835430-acb3f2d28681883e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如上，就是我对TableView加载图片的优化逻辑。\n转载标注\nhttp://www.jianshu.com/p/328e503900d0\n","slug":"TableView加载图片的优化逻辑","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htp5000cjigbshjuf7wu","content":"<p>系列文章：</p>\n<ul>\n<li><p><a href=\"http://www.jianshu.com/p/2b192257276f\" target=\"_blank\" rel=\"external\">TableView优化之高度缓存功能</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/328e503900d0\" target=\"_blank\" rel=\"external\">TableView优化之加载图片的优化逻辑</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/0b020518de5e\" target=\"_blank\" rel=\"external\">TableView优化之快速滑动下的忽略加载</a></p>\n</li>\n</ul>\n<hr>\n<p>日常中，最常使用的空间非UITableView莫属了。<br>但是当TableView的cell中包含图片时，使用SDWebImage加载图片虽然是异步过程，但是仍然十分占用系统资源。<br>那么我们就要想一个办法去优化加载图片的逻辑。</p>\n<p>此处，我只讲我自己的想法，或许也有更好的逻辑，还希望在下面留言指点我一下。</p>\n<p>我的想法是TableView滚动的时候不去加载未加载过的图片，停止滚动后再从网络加载。已经加载过得图片，无论什么时候都加载该图片（因为SDWebImage会将加载过得图片缓存下来，再次加载的时候从缓存中取，这样就不用开辟线程下载图片了）。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6fdc073348c239aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"啊.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-acb3f2d28681883e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-04-16 下午9.34.14.png\"></p>\n<p>如上，就是我对TableView加载图片的优化逻辑。<br>转载标注<br><a href=\"http://www.jianshu.com/p/328e503900d0\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/328e503900d0</a></p>\n","site":{"data":{}},"excerpt":"<p>系列文章：</p>\n<ul>\n<li><p><a href=\"http://www.jianshu.com/p/2b192257276f\" target=\"_blank\" rel=\"external\">TableView优化之高度缓存功能</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/328e503900d0\" target=\"_blank\" rel=\"external\">TableView优化之加载图片的优化逻辑</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/0b020518de5e\" target=\"_blank\" rel=\"external\">TableView优化之快速滑动下的忽略加载</a></p>\n</li>\n</ul>\n<hr>\n<p>日常中，最常使用的空间非UITableView莫属了。<br>但是当TableView的cell中包含图片时，使用SDWebImage加载图片虽然是异步过程，但是仍然十分占用系统资源。<br>那么我们就要想一个办法去优化加载图片的逻辑。</p>\n<p>此处，我只讲我自己的想法，或许也有更好的逻辑，还希望在下面留言指点我一下。</p>\n<p>我的想法是TableView滚动的时候不去加载未加载过的图片，停止滚动后再从网络加载。已经加载过得图片，无论什么时候都加载该图片（因为SDWebImage会将加载过得图片缓存下来，再次加载的时候从缓存中取，这样就不用开辟线程下载图片了）。</p>","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6fdc073348c239aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"啊.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-acb3f2d28681883e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-04-16 下午9.34.14.png\"></p>\n<p>如上，就是我对TableView加载图片的优化逻辑。<br>转载标注<br><a href=\"http://www.jianshu.com/p/328e503900d0\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/328e503900d0</a></p>"},{"title":"老司机出品———疯狂造轮子之图片异步下载类","layout":"post","date":"2017-03-06T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![图片异步下载类](http://upload-images.jianshu.io/upload_images/1835430-01cbaf922323f1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\nSDWebImage，我估计没有一个做iOS的不知道这个三方库吧，他为我们提供了简洁的图片异步下载方式。在他为我一句api带来这么大便利的同时，你有没有想过他是怎么实现的呢？让我们先来看看他为我们做了什么？\n\n- 图片异步加载\n- 图片缓存\n- 图片编解码\n- 图片渐进式下载\n- 下载任务管理\n\nSo，你以为我要给你讲讲SDWebImage实现原理？\nNONONO！SD这么一个成熟的框架早已有无数人对其架构进行过透彻的分析，老司机说了也是一样的，但作为程序员最快的成长就是不断地重造轮子。当然你造轮子不一定是要替代原来的，只是扩展一种思路。\n\n所以，今天老司机就带着你来`实现一个简单的图片下载类`。\n\n让我们先分析以下我们究竟需要些什么？\n\n\n![下载思路](http://upload-images.jianshu.io/upload_images/1835430-d2a03dd9a32406fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这是一个完整的图片下载思路，编解码等图片处理的老司机没有纳在其中，因为需要详尽的图片编解码知识才能读懂代码，而且本期教程也重在整理下载思路。\n\n其实有了上面的分析我们需要做的就很明显了。\n\n- 首先我们需要一个`图片下载类`，为我们进行图片下载任务，并在完成时执行相关回调。\n- 其次我们需要一个`图片缓存类`，图片下载完成时将图片进行缓存。\n- 最后我们需要一个`下载任务管理类`，帮助我们管理当前下载任务，避免重复下载。\n\n那我们接下来一一分析相关需求。\n\n<!-- more -->\n\n- - -\n### NSURLSession\n\n其实要写一个下载类，我们的思路应该很明显。\n既然是数据请求，我们当然应该立刻想到`NSURLSession`做下载。\n\n> NSURLSession是iOS7推出的与NSURLConnection并列的网络请求库，并且在iOS9中苹果宣布废弃NSURLConnection，NSURLSession从此正式步入历史舞台，大多数还在维护的网络相关的三方库都跟随苹果的脚步将底层Api替换为NSURLSession相关。  \n>————引自《老司机瞎逼逼》第一卷第一章第一篇第一行第一句\n\n那么我们来使用NSURLSession写一个下载类。\n\nNSURLSession其实是一个会话，管理着发生在其之上的所有数据交换任务。`一个会话可以同时管理多个数据请求`。并且NSURLSession还向我们提供了`指定任务回调的队列`的Api，让我们方便的选择在主线程或子线程中回调。\n\n一般来讲，没有特殊需求，我们应该尽量复用我们的会话，毕竟频繁的创建与释放对象都是系统资源上的浪费。\n\nNSURLSession为我们提供了两种初始化方式\n\n>+sessionWithConfiguration:\n>+sessionWithConfiguration:delegate:delegateQueue:\n\n这里可以根据不同的需求选择对应粒度的Api进行初始化。\n\n其中Configuration这个参数我们可以传进去一个配置对象，来定制我们session会话的不同参数。\n这里系统为我们预置了3中配置\n\n#### defaultSessionConfiguration\n \n> 默认配置使用的是持久化的硬盘缓存，存储证书到用户钥匙链。存储cookie到shareCookie。\n\n> 标注：如果想要移植原来基于NSURLConnect的代码到NSURLSession，可使用该默认配置，然后再根据需要定制该默认配置。\n\n#### ephemeralSessionConfiguration\n\n> 返回一个不适用永久持存cookie、证书、缓存的配置，最佳优化数据传输。\n> \n>标注：当程序作废session时，所有的ephemeral session 数据会立即清除。此外，如果你的程序处于暂停状态，内存数据可能不会立即清除，但是会在程序终止或者收到内存警告或者内存压力时立即清除。\n\n\n#### backgroundSessionConfigurationWithIdentifier\n>生成一个可以上传下载HTTP和HTTPS的后台任务(程序在后台运行)。\n在后台时，将网络传输交给系统的单独的一个进程。\n\n>重要：identifier 是configuration的唯一标示，不能为空或nil\n\n摘自[ NSURLSessionConfiguration API详解 ](http://blog.csdn.net/growinggiant/article/details/50483127)\n\n这里我们使用默认配置单独设置一下请求超时时长即可。\n![NSURLSession](http://upload-images.jianshu.io/upload_images/1835430-f11ba37b9d5978dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有了session对象，我们就可以以request初始化NSURLSessionTask对象来做数据交换。\n\n>NSURLSessionUploadTask：上传用的Task，传完以后不会再下载返回结果；\n>\n>NSURLSessionDownloadTask：下载用的Task；\n>\n>NSURLSessionDataTask：可以上传内容，上传完成后再进行下载。\n\n引自[NSURLSession使用说明及后台工作流程分析](http://www.cocoachina.com/industry/20131106/7304.html)\n\n有了上面两个参考资料，这里我假设你已经会使用NSURLSession了（毕竟这不是我今天的主题），鉴于我不关心下载过程，只关心下载结果，所以我选择了最简单直接的Api。\n\n![Task](http://upload-images.jianshu.io/upload_images/1835430-299b6d20ce29bfb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n可以看到，老司机在现在完成的回调中一共做了以下几件事：\n\n- 检验是否下载失败，若失败，抛出错误信息\n- 若成功取到UIImage对象，使用缓存类进行数据缓存\n- 遍历回调数组进行回调\n\n代码都很简单，也不用多做解释，这样我们的下载类就完成了。\n\n放一下下载类的全部代码\n\n### 图片下载类\n\n\n```\n#pragma mark --- 图片下载类 ---\n@interface DWWebImageDownloader : NSObject\n\n///回调数组\n@property (nonatomic ,strong) NSMutableArray <DWWebImageCallBack>* callBacks;\n\n///下载任务\n@property (nonatomic ,strong) NSURLSessionDataTask * task;\n\n///下载图像实例\n/**\n 任务完成前为nil\n */\n@property (nonatomic ,strong) UIImage * image;\n\n///现在完成标志\n@property (nonatomic ,assign) BOOL downloadFinish;\n\n///初始化方法\n-(instancetype)initWithSession:(NSURLSession *)session;\n\n///以url下载图片\n-(void)downloadImageWithUrlString:(NSString *)url;\n\n///开启下载\n-(void)resume;\n\n///取消下载\n-(void)cancel;\n\n@end\n\n```\n\n```\n#pragma mark --- DWWebImageDownloader ---\n@interface DWWebImageDownloader ()\n\n@property (nonatomic ,copy) NSString * url;\n\n@property (nonatomic ,strong) NSURLSession * session;\n\n@end\n\n@implementation DWWebImageDownloader\n\n#pragma mark --- 接口方法 ---\n-(instancetype)initWithSession:(NSURLSession *)session {\n    self = [super init];\n    if (self) {\n        _session = session;\n        _downloadFinish = NO;\n    }\n    return self;\n}\n\n-(void)downloadImageWithUrlString:(NSString *)url\n{\n    if (!url.length) {\n        dispatch_async_main_safe((^(){\n            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"error\":DWErrorWithDescription(10001,@\"url为空\"),@\"url\":self.url}];\n        }));\n        return;\n    }\n    [self downloadImageWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]]];\n}\n\n-(void)resume {\n    [self.task resume];\n}\n\n-(void)cancel {\n    [self.task cancel];\n}\n\n#pragma mark --- Tool Method ---\n-(void)downloadImageWithRequest:(NSURLRequest *)request\n{\n    if (!request) {\n        dispatch_async_main_safe((^(){\n            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"error\":DWErrorWithDescription(10002,@\"无法生成request对象\"),@\"url\":self.url}];\n        }));\n        return;\n    }\n    \n    self.url = request.URL.absoluteString;\n    \n    self.task = [self.session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {\n        if (error) {///下载错误\n            dispatch_async_main_safe((^(){\n                [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"error\":DWErrorWithDescription(10003, @\"任务取消或错误\"),@\"url\":self.url}];\n            }));\n            return ;\n        }\n        _session = nil;\n        UIImage * image = [UIImage imageWithData:data];\n        self.downloadFinish = YES;///标志下载完成\n        self.image = image;\n        if (!image) {\n            dispatch_async_main_safe((^(){\n                [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"error\":DWErrorWithDescription(10000, ([NSString stringWithFormat:@\"图片下载失败：%@\",self.url])),@\"url\":self.url}];\n            }));\n            return ;\n        }\n        //保存数据\n        [[DWWebImageCache shareCache] cacheObj:data forKey:self.url];\n        \n        ///并发遍历\n        [self.callBacks enumerateObjectsWithOptions:(NSEnumerationConcurrent | NSEnumerationReverse) usingBlock:^(DWWebImageCallBack  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n            if (obj) {\n                //图片回调\n                dispatch_async_main_safe(^(){\n                    obj(image);\n                });\n            }\n        }];\n        ///发送通知\n        dispatch_async_main_safe((^(){\n            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"url\":self.url,@\"image\":image}];\n        }));\n    }];\n}\n\n-(NSMutableArray<DWWebImageCallBack> *)callBacks\n{\n    if (!_callBacks) {\n        _callBacks = [NSMutableArray array];\n    }\n    return _callBacks;\n}\n\n@end\n```\n\n- - -\n### 图片缓存类\nSD中对图片进行了多级缓存，包括内存缓存和磁盘缓存。\n这里我们也来模拟一下其实现过程。\n对于这个缓存类，我们可以给自己提几个需求：\n> 1.支持内存缓存及磁盘缓存两种缓存方式\n> \n> 2.对于缓存类缓存文件应做加密\n> \n> 3.磁盘缓存应保留清除缓存接口，并且应具备过期缓存自动清除功能\n \n对自己好一点，少提一些需求吧┑(￣Д ￣)┍\n\n所以按照需求我们可以大概知道几个技术点，一一分析一下。\n\n#### 内存缓存\n这里我们使用的内存缓存是系统提供的NSCache类。\n\nNSCache基本使用方法与字典相同，以key值存值和取值。不同的是，NSCache会在内存吃紧的时候自动释放内存。且相对于字典来说，NSCache是线程安全的，所以你并不需要手动加锁哦。\n\n所以确定了内存缓存的实现方式后，我们只要部署缓存逻辑即可。\n\n我们知道，内存读取速度是要大于磁盘读取速度的，所以当去缓存的时候我们优先取内存缓存使我们的主要策略。\n另外进行磁盘缓存的时候我们还要注意两点，第一点，一定要异步子线程去执行，这样可以避免线程阻塞。第二点，既然开启了子线程就应该注意线程安全，所以这里应注意加线程安全相关的代码。\n\n![缓存读写](http://upload-images.jianshu.io/upload_images/1835430-14f53e263e302bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 缓存加密\n这里我们采取与SDWebImage相同的做法，以图片下载URL做MD5加密后的字符串当做key与缓存一一对应。加密算法相对固定，再次不做赘述，稍后会有统一放代码。\n\n#### 自动清理\n自动清理的核心思想则是每当首次加载我们的Api的时候检测我们的磁盘缓存文件的最后修改时间，如果距离当前超过我们预设的过期时间则将文件移除。\n![移除过期文件](http://upload-images.jianshu.io/upload_images/1835430-6dcb473a8f17a51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下面是图片缓存类的代码\n\n```\n#pragma mark --- 缓存管理类 ---\n@interface DWWebImageCache : NSObject<NSCopying>\n\n///缓存策略\n@property (nonatomic ,assign) DWWebImageCachePolicy cachePolicy;\n\n///缓存数据类型\n@property (nonatomic ,assign) DWWebImageCacheType cacheType;\n\n///缓存过期时间，默认值7天\n@property (nonatomic ,assign) unsigned long long expirateTime;\n\n///是否加密缓存\n@property (nonatomic ,assign) BOOL useSecureKey;\n\n///缓存空间\n@property (nonatomic ,copy) NSString * cacheSpace;\n\n///单例\n+(instancetype)shareCache;\n\n///通过key存缓存\n-(void)cacheObj:(id)obj forKey:(NSString *)key;\n\n///通过key取缓存\n-(id)objCacheForKey:(NSString *)key;\n\n///通过key移除缓存\n-(void)removeCacheByKey:(NSString *)key;\n\n///移除过期缓存\n-(void)removeExpiratedCache;\n\n@end\n\n```\n\n```\n#pragma mark --- DWWebImageCache ---\n@interface DWWebImageCache ()\n\n@property (nonatomic ,strong) NSCache * memCache;\n\n@property (nonatomic ,strong) dispatch_semaphore_t semaphore;\n\n@property (nonatomic ,strong) NSFileManager * fileMgr;\n\n@end\n\n@implementation DWWebImageCache\n\n#pragma mark --- 接口方法 ---\n-(instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _memCache = [[NSCache alloc] init];\n        _memCache.totalCostLimit = DWWebImageCacheDefaultCost;\n        _memCache.countLimit = 20;\n        _expirateTime = DWWebImageCacheDefaultExpirateTime;\n        _useSecureKey = YES;\n        _cachePolicy = DWWebImageCachePolicyDisk;\n        _cacheType = DWWebImageCacheTypeData;\n        _semaphore = dispatch_semaphore_create(1);\n        _fileMgr = [NSFileManager defaultManager];\n        [self createTempPath];\n    }\n    return self;\n}\n\n-(void)cacheObj:(id)obj forKey:(NSString *)key\n{\n    NSString * url = key;\n    key = transferKey(key, self.useSecureKey);\n    if (self.cachePolicy & DWWebImageCachePolicyDisk) {///磁盘缓存\n        writeFileWithKey(obj, url, key, self.semaphore, self.fileMgr,self.cacheSpace);\n    }\n    if (self.cachePolicy & DWWebImageCachePolicyMemory) {\n        ///做内存缓存\n        [self.memCache setObject:obj forKey:key cost:costForObj(obj)];\n    }\n}\n\n-(id)objCacheForKey:(NSString *)key\n{\n    __block id obj = nil;\n    key = transferKey(key, self.useSecureKey);\n    obj = [self.memCache objectForKey:key];\n    if (!obj) {\n        NSAssert((self.cacheType != DWWebImageCacheTypeUndefined), @\"you must set a cacheType but not DWWebImageCacheTypeUndefined\");\n        readFileWithKey(key, self.cacheType, self.semaphore, self.cacheSpace,^(id object) {\n            obj = object;\n        });\n    }\n    return obj;\n}\n\n-(void)removeCacheByKey:(NSString *)key\n{\n    key = transferKey(key, self.useSecureKey);\n    [self.memCache removeObjectForKey:key];\n    [self.fileMgr removeItemAtPath:objPathWithKey(key,self.cacheSpace) error:nil];\n}\n\n-(void)removeExpiratedCache\n{\n    if (self.expirateTime) {\n        dispatch_async(dispatch_get_global_queue(0, 0), ^{\n            NSDirectoryEnumerator *dir=[self.fileMgr enumeratorAtPath:sandBoxPath(self.cacheSpace)];\n            NSString *path=[NSString new];\n            unsigned long long timeStamp = [[NSDate date] timeIntervalSince1970];\n            while ((path=[dir nextObject])!=nil) {\n                NSString * fileP = objPathWithKey(path,self.cacheSpace);\n                NSDictionary * attrs = [self.fileMgr attributesOfItemAtPath:fileP error:nil];\n                NSDate * dataCreate = attrs[NSFileModificationDate];\n                if ((timeStamp - [dataCreate timeIntervalSince1970]) > self.expirateTime) {\n                    [self.fileMgr removeItemAtPath:fileP error:nil];\n                }\n            }\n        });\n    }\n}\n\n#pragma mark -- Tool Method ---\n-(void)createTempPath\n{\n    if (![self.fileMgr fileExistsAtPath:sandBoxPath(self.cacheSpace)]) {\n        [self.fileMgr createDirectoryAtPath:sandBoxPath(self.cacheSpace) withIntermediateDirectories:YES attributes:nil error:NULL];\n    }\n}\n\n#pragma mark --- Setter、getter ---\n-(void)setExpirateTime:(unsigned long long)expirateTime\n{\n    _expirateTime = expirateTime;\n    if (expirateTime) {\n        [self removeExpiratedCache];\n    }\n}\n\n-(NSString *)cacheSpace\n{\n    if (!_cacheSpace) {\n        return @\"defaultCacheSpace\";\n    }\n    return _cacheSpace;\n}\n\n#pragma mark --- 单例 ---\nstatic DWWebImageCache * cache = nil;\n+(instancetype)shareCache\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        cache = [[self alloc] init];\n    });\n    return cache;\n}\n\n+(instancetype)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        cache = [super allocWithZone:zone];\n    });\n    return cache;\n}\n\n-(id)copyWithZone:(NSZone *)zone\n{\n    return cache;\n}\n\n#pragma mark --- 内联函数 ---\n\n/**\n 异步文件写入\n\n @param obj 写入对象\n @param url 下载url\n @param key 缓存key\n @param semaphore 信号量\n @param fileMgr 文件管理者\n @param cacheSpace  缓存空间\n */\nstatic inline void writeFileWithKey(id obj,NSString * url,NSString * key,dispatch_semaphore_t semaphore,NSFileManager * fileMgr,NSString * cacheSpace){\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        NSString * path = objPathWithKey(key,cacheSpace);\n        if ([fileMgr fileExistsAtPath:path]) {\n            [fileMgr removeItemAtPath:path error:nil];\n        }\n        if ([obj2Data(obj) writeToFile:path atomically:YES]) {\n            dispatch_async_main_safe(^(){\n                [[NSNotificationCenter defaultCenter] postNotificationName:\n                 DWWebImageCacheCompleteNotification object:nil userInfo:@{@\"url\":url}];\n            });\n        }\n        dispatch_semaphore_signal(semaphore);\n    });\n};\n\n\n/**\n 文件读取\n\n @param key 缓存key\n @param type 文件类型\n @param semaphore 信号量\n @param cacheSpace 缓存空间\n @param completion 读取完成回调\n */\nstatic inline void readFileWithKey(NSString * key,DWWebImageCacheType type,dispatch_semaphore_t semaphore,NSString * cacheSpace,void (^completion)(id obj)){\n    dispatch_sync(dispatch_get_global_queue(0, 0), ^{\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        NSData * data = [NSData dataWithContentsOfFile:objPathWithKey(key,cacheSpace)];\n        if (data && completion) {\n            completion(transferDataToObj(data, type));\n        }\n        dispatch_semaphore_signal(semaphore);\n    });\n};\n\n\n/**\n 数据格式转换\n\n @param data 源数据\n @param type 数据类型\n @return 转换后数据\n */\nstatic inline id transferDataToObj(NSData * data,DWWebImageCacheType type){\n    switch (type) {\n        case DWWebImageCacheTypeData:\n            return data;\n            break;\n        case DWWebImageCacheTypeImage:\n            return [UIImage imageWithData:data];\n            break;\n        default:\n            return nil;\n            break;\n    }\n};\n\n\n/**\n 返回文件路径\n\n @param key 缓存key\n @param cacheSpace 缓存空间\n @return 文件路径\n */\nstatic inline NSString * objPathWithKey(NSString * key,NSString * cacheSpace){\n    return [NSString stringWithFormat:@\"%@/%@\",sandBoxPath(cacheSpace),key];\n};\n\n\n/**\n 对象转为NSData\n\n @param obj 对象\n @return 转换后data\n */\nstatic inline NSData * obj2Data(id obj){\n    NSData * data = nil;\n    if ([obj isKindOfClass:[NSData class]]) {\n        data = obj;\n    }\n    else if([obj isKindOfClass:[UIImage class]]) {\n        data = UIImageJPEGRepresentation(obj, 1);\n    }\n    return data;\n}\n\n\n/**\n 沙盒路径\n\n @param cacheSpace 缓存空间\n @return 沙盒路径\n */\nstatic inline NSString * sandBoxPath(NSString * cacheSpace){\n    return [NSHomeDirectory() stringByAppendingString:[NSString stringWithFormat:@\"/Documents/DWWebImageCache/%@/\",cacheSpace]];\n};\n\n\n/**\n 计算对象所需缓存成本\n\n @param obj 对象\n @return 缓存成本\n */\nstatic inline NSUInteger costForObj(id obj){\n    NSUInteger cost = 0;\n    ///根据数据类型计算cost\n    if ([obj isKindOfClass:[NSData class]]) {\n        cost = [[obj valueForKey:@\"length\"] unsignedIntegerValue];\n    } else if ([obj isKindOfClass:[UIImage class]]) {\n        UIImage * image = (UIImage *)obj;\n        cost = (NSUInteger)image.size.width * image.size.height * image.scale * image.scale;\n    }\n    return cost;\n};\n\n\n/**\n 返回缓存key\n\n @param originKey 原始key\n @param useSecureKey 是否加密\n @return 缓存key\n */\nstatic inline NSString * transferKey(NSString * originKey,BOOL useSecureKey){\n    return useSecureKey?encryptToMD5(originKey):originKey;\n};\n\n\n/**\n 返回MD5加密字符串\n\n @param str 原始字符串\n @return 加密后字符串\n */\nstatic inline NSString *encryptToMD5(NSString * str){\n    CC_MD5_CTX md5;\n    CC_MD5_Init (&md5);\n    CC_MD5_Update (&md5, [str UTF8String], (CC_LONG)[str length]);\n    \n    unsigned char digest[CC_MD5_DIGEST_LENGTH];\n    CC_MD5_Final (digest, &md5);\n    return  [NSString stringWithFormat: @\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",\n             digest[0],  digest[1],\n             digest[2],  digest[3],\n             digest[4],  digest[5],\n             digest[6],  digest[7],\n             digest[8],  digest[9],\n             digest[10], digest[11],\n             digest[12], digest[13],\n             digest[14], digest[15]];\n};\n\n@end\n\n```\n- - - \n### 下载任务管理类\n有没有发现分模块后思路很清晰，我们接着给自己捋捋需求吧。\n\n- 我们的管理类要能区分当前URL存在缓存的话，我们不需要开启下载任务，直接从缓存中读取。\n- 如果没有缓存，判断当前URL是否正在下载，如果正在下载不应开启新的下载任务，而是为之前的任务增加回调。\n- 应该为任务添加优先级，新追加的下载任务应该较之前添加且尚未开始的下载任务具有更高的优先级。\n\n前两个需求，无非就是两个条件判断，而任务优先级我们可以通过NSOperation去添加依赖，从而实现。\n我们知道NSOperation和NSURLSessionTask都是需要手动开启的，所以我们可以重写NSOperation的resume方法，可以同时开启下载任务。\n\n同时我们知道添加到NSOperationQueue中的NSOperation会按需自动调用resume方法，所以我们可以成功的借助NSOperationQueue实现我们下载任务的相互依赖关系。看一下代码：\n\n![为下载任务添加依赖](http://upload-images.jianshu.io/upload_images/1835430-0a128b05402b1477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可能现在这么说还是不懂，先等下，接着看。\n\n![下载逻辑](http://upload-images.jianshu.io/upload_images/1835430-0a2d28d7d4c50102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们看到，每一次当创建新的任务时，我都会将上次记录的任务的依赖设置为新的任务，这样新添加的任务就会优先于上一个任务执行。然后将它加入到队列中，这样就会自动开启任务。\n\n管理类和线程类的全部代码放一下：\n\n```\n#pragma mark --- 任务线程类 ---\n@interface DWWebImageOperation : NSOperation\n\n///图片下载器\n@property (nonatomic ,strong) DWWebImageDownloader * donwloader;\n\n///下载任务是否完成\n@property (nonatomic , assign, getter=isFinished) BOOL finished;\n\n///以url及session下载图片\n-(instancetype)initWithUrl:(NSString *)url session:(NSURLSession *)session;\n\n@end\n\n\n\n#pragma mark --- 下载管理类 ---\n@interface DWWebImageManager : NSObject<NSCopying>\n\n///线程字典\n/**\n url为key，对应任务线程\n */\n@property (nonatomic ,strong) NSMutableDictionary <NSString *,DWWebImageOperation *>* operations;\n\n///缓存管理对象\n@property (nonatomic ,strong) DWWebImageCache * cache;\n\n///单例\n+(instancetype)shareManager;\n\n///以url下载图片，进行回调\n-(void)downloadImageWithUrl:(NSString *)url completion:(DWWebImageCallBack)completion;\n\n///以url移除下载任务\n-(void)removeOperationByUrl:(NSString *)url;\n\n@end\n```\n\n```\n\n#pragma mark --- DWWebImageOperation ---\n@implementation DWWebImageOperation\n@synthesize finished = _finished;\n\n-(instancetype)initWithUrl:(NSString *)url session:(NSURLSession *)session\n{\n    self = [super init];\n    if (self) {\n        _donwloader = [[DWWebImageDownloader alloc] initWithSession:session];\n        [_donwloader downloadImageWithUrlString:url];\n    }\n    return self;\n}\n\n-(void)start\n{\n    [super start];\n    [self.donwloader resume];\n}\n\n-(void)cancel\n{\n    [super cancel];\n    [self.donwloader cancel];\n}\n\n-(void)setFinished:(BOOL)finished {\n    [self willChangeValueForKey:@\"isFinished\"];\n    _finished = finished;\n    [self didChangeValueForKey:@\"isFinished\"];\n}\n\n@end\n\n#pragma mark --- DWWebImageManager ---\n\n@interface DWWebImageManager ()\n\n@property (nonatomic ,strong) NSURLSession * session;\n\n@property (nonatomic ,strong) dispatch_semaphore_t semaphore;\n\n@property (nonatomic ,strong) NSOperationQueue * queue;\n\n@property (nonatomic ,strong) DWWebImageOperation * lastOperation;\n\n@end\n\n@implementation DWWebImageManager\n\n-(instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.semaphore = dispatch_semaphore_create(1);\n        self.cache = [DWWebImageCache shareCache];\n        self.cache.cachePolicy = DWWebImageCachePolicyDisk | DWWebImageCachePolicyMemory;\n        [self.cache removeExpiratedCache];\n        dispatch_async_main_safe(^(){\n            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(cacheCompleteFinishNotice:) name:DWWebImageCacheCompleteNotification object:nil];\n            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downloadFinishNotice:) name:DWWebImageDownloadFinishNotification object:nil];\n        });\n    }\n    return self;\n}\n\n///下载图片\n-(void)downloadImageWithUrl:(NSString *)url completion:(DWWebImageCallBack)completion\n{\n    NSAssert(url.length, @\"url不能为空\");\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        ///从缓存加载图片\n        UIImage * image = [UIImage imageWithData:[self.cache objCacheForKey:url]];\n        if (image) {\n            dispatch_async_main_safe(^(){\n                completion(image);\n            });\n        } else {///无缓存\n            dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);\n            DWWebImageOperation * operation = self.operations[url];///取出下载任务\n            if (!operation) {///无任务\n                operation = [[DWWebImageOperation alloc] initWithUrl:url session:self.session];\n                self.operations[url] = operation;\n                if (self.lastOperation) {\n                    [self.lastOperation addDependency:operation];\n                }\n                [self.queue addOperation:operation];\n                self.lastOperation = operation;\n            }\n            if (!operation.donwloader.downloadFinish) {\n                [operation.donwloader.callBacks addObject:[completion copy]];\n            } else {\n                ///从缓存读取图片回调\n                dispatch_async_main_safe(^(){\n                    completion(operation.donwloader.image);\n                });\n            }\n            dispatch_semaphore_signal(self.semaphore);\n        }\n    });\n}\n\n///下载完成回调\n-(void)downloadFinishNotice:(NSNotification *)sender\n{\n    NSError * error = sender.userInfo[@\"error\"];\n    if (error) {///移除任务\n        [self removeOperationByUrl:sender.userInfo[@\"url\"]];\n        [self removeCacheByUrl:sender.userInfo[@\"url\"]];\n    } else {\n        NSString * url = sender.userInfo[@\"url\"];\n        DWWebImageOperation * operation = self.operations[url];///取出下载任务\n        operation.finished = YES;\n    }\n}\n\n///缓存完成通知回调\n-(void)cacheCompleteFinishNotice:(NSNotification *)sender\n{\n    NSString * url = sender.userInfo[@\"url\"];\n    if (url.length) {\n        [self removeOperationByUrl:sender.userInfo[@\"url\"]];\n    }\n}\n\n///移除下载进程\n-(void)removeOperationByUrl:(NSString *)url\n{\n    DWWebImageOperation * operation = self.operations[url];\n    [operation cancel];\n    [self.operations removeObjectForKey:url];\n}\n\n///移除缓存\n-(void)removeCacheByUrl:(NSString *)url\n{\n    [self.cache removeCacheByKey:url];\n}\n\n-(NSMutableDictionary<NSString *,DWWebImageOperation *> *)operations\n{\n    if (!_operations) {\n        _operations = [NSMutableDictionary dictionary];\n    }\n    return _operations;\n}\n\n-(NSURLSession *)session\n{\n    if (!_session) {\n        NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration];\n        config.timeoutIntervalForRequest = 15;\n        _session = [NSURLSession sessionWithConfiguration:config];\n    }\n    return _session;\n}\n\n-(NSOperationQueue *)queue\n{\n    if (!_queue) {\n        _queue = [[NSOperationQueue alloc] init];\n        _queue.maxConcurrentOperationCount = 6;\n    }\n    return _queue;\n}\n\n#pragma mark --- 单例 ---\nstatic DWWebImageManager * mgr = nil;\n+(instancetype)shareManager\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        mgr = [[self alloc] init];\n    });\n    return mgr;\n}\n\n+(instancetype)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        mgr = [super allocWithZone:zone];\n    });\n    return mgr;\n}\n\n-(id)copyWithZone:(NSZone *)zone\n{\n    return mgr;\n}\n\n@end\n\n```\n\n- - - \n至此，你已经自己实现了一个异步下载类。你可以像SD一样，为UIImageView、UIButton等添加分类实现相同的效果。\n\n这个下载思路与SD大同小异，相信你自己撸一份以后对SD会有更深的理解。\n当然SD为我们做的远不止这些，你怎么可能凭一己之力抗衡千人。有空多读读成熟的第三方代码也是对自我的锻炼与提升。\n\n- - -\n同样的，老司机把写好的下载类同样放在了我的Git上，[在这里](https://github.com/CodeWicky/-Tools/tree/master/DWWebImage)。\n- - -\n\n参考资料\n\n- [ NSURLSessionConfiguration API详解 ](http://blog.csdn.net/growinggiant/article/details/50483127)\n \n- [NSURLSession使用说明及后台工作流程分析](http://www.cocoachina.com/industry/20131106/7304.html)\n- [SDWebImage](https://github.com/rs/SDWebImage)\n\n- - -\n你说老司机今天怎么不逗比了，人家一直是治学严谨的老学究好么！\n\n![傲娇](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1488882401345&di=78cd0501c1a318d33bd98df0de28842f&imgtype=0&src=http%3A%2F%2Fwanzao2.b0.upaiyun.com%2Fsystem%2Fpictures%2F18747638%2Foriginal%2F80ffdf3a1ee62dac.gif)\n- - -\n恩，你在忍忍，这应该是我更新前最后一次做软广了=。=\n\n\nDWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。\n\n>version 1.1.0\n>全面支持自动链接支持、定制检测规则、图文混排、响应事件\n>优化大部分算法，提高响应效率及绘制效率\n \n>version 1.1.1\n>高亮取消逻辑优化\n>自动检测逻辑优化\n>部分常用方法改为内联函数，提高运行效率\n \n>version 1.1.2\n>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）\n \n>version 1.1.3\n>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中\n \n>version 1.1.4\n>事务管理类去除，异步绘制文件抽出\n \n>version 1.1.5\n>添加网络图片异步加载库，支持绘制网络图片\n>\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n\n\n![爱你哟](http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/老司机出品———疯狂造轮子之图片异步下载类.md","raw":"\n---\ntitle: 老司机出品———疯狂造轮子之图片异步下载类\nlayout: post\ndate: 2017-03-07 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- 异步下载\n- SDWebImage \ncategories: 源码解析\n---\n\n![图片异步下载类](http://upload-images.jianshu.io/upload_images/1835430-01cbaf922323f1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\nSDWebImage，我估计没有一个做iOS的不知道这个三方库吧，他为我们提供了简洁的图片异步下载方式。在他为我一句api带来这么大便利的同时，你有没有想过他是怎么实现的呢？让我们先来看看他为我们做了什么？\n\n- 图片异步加载\n- 图片缓存\n- 图片编解码\n- 图片渐进式下载\n- 下载任务管理\n\nSo，你以为我要给你讲讲SDWebImage实现原理？\nNONONO！SD这么一个成熟的框架早已有无数人对其架构进行过透彻的分析，老司机说了也是一样的，但作为程序员最快的成长就是不断地重造轮子。当然你造轮子不一定是要替代原来的，只是扩展一种思路。\n\n所以，今天老司机就带着你来`实现一个简单的图片下载类`。\n\n让我们先分析以下我们究竟需要些什么？\n\n\n![下载思路](http://upload-images.jianshu.io/upload_images/1835430-d2a03dd9a32406fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这是一个完整的图片下载思路，编解码等图片处理的老司机没有纳在其中，因为需要详尽的图片编解码知识才能读懂代码，而且本期教程也重在整理下载思路。\n\n其实有了上面的分析我们需要做的就很明显了。\n\n- 首先我们需要一个`图片下载类`，为我们进行图片下载任务，并在完成时执行相关回调。\n- 其次我们需要一个`图片缓存类`，图片下载完成时将图片进行缓存。\n- 最后我们需要一个`下载任务管理类`，帮助我们管理当前下载任务，避免重复下载。\n\n那我们接下来一一分析相关需求。\n\n<!-- more -->\n\n- - -\n### NSURLSession\n\n其实要写一个下载类，我们的思路应该很明显。\n既然是数据请求，我们当然应该立刻想到`NSURLSession`做下载。\n\n> NSURLSession是iOS7推出的与NSURLConnection并列的网络请求库，并且在iOS9中苹果宣布废弃NSURLConnection，NSURLSession从此正式步入历史舞台，大多数还在维护的网络相关的三方库都跟随苹果的脚步将底层Api替换为NSURLSession相关。  \n>————引自《老司机瞎逼逼》第一卷第一章第一篇第一行第一句\n\n那么我们来使用NSURLSession写一个下载类。\n\nNSURLSession其实是一个会话，管理着发生在其之上的所有数据交换任务。`一个会话可以同时管理多个数据请求`。并且NSURLSession还向我们提供了`指定任务回调的队列`的Api，让我们方便的选择在主线程或子线程中回调。\n\n一般来讲，没有特殊需求，我们应该尽量复用我们的会话，毕竟频繁的创建与释放对象都是系统资源上的浪费。\n\nNSURLSession为我们提供了两种初始化方式\n\n>+sessionWithConfiguration:\n>+sessionWithConfiguration:delegate:delegateQueue:\n\n这里可以根据不同的需求选择对应粒度的Api进行初始化。\n\n其中Configuration这个参数我们可以传进去一个配置对象，来定制我们session会话的不同参数。\n这里系统为我们预置了3中配置\n\n#### defaultSessionConfiguration\n \n> 默认配置使用的是持久化的硬盘缓存，存储证书到用户钥匙链。存储cookie到shareCookie。\n\n> 标注：如果想要移植原来基于NSURLConnect的代码到NSURLSession，可使用该默认配置，然后再根据需要定制该默认配置。\n\n#### ephemeralSessionConfiguration\n\n> 返回一个不适用永久持存cookie、证书、缓存的配置，最佳优化数据传输。\n> \n>标注：当程序作废session时，所有的ephemeral session 数据会立即清除。此外，如果你的程序处于暂停状态，内存数据可能不会立即清除，但是会在程序终止或者收到内存警告或者内存压力时立即清除。\n\n\n#### backgroundSessionConfigurationWithIdentifier\n>生成一个可以上传下载HTTP和HTTPS的后台任务(程序在后台运行)。\n在后台时，将网络传输交给系统的单独的一个进程。\n\n>重要：identifier 是configuration的唯一标示，不能为空或nil\n\n摘自[ NSURLSessionConfiguration API详解 ](http://blog.csdn.net/growinggiant/article/details/50483127)\n\n这里我们使用默认配置单独设置一下请求超时时长即可。\n![NSURLSession](http://upload-images.jianshu.io/upload_images/1835430-f11ba37b9d5978dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有了session对象，我们就可以以request初始化NSURLSessionTask对象来做数据交换。\n\n>NSURLSessionUploadTask：上传用的Task，传完以后不会再下载返回结果；\n>\n>NSURLSessionDownloadTask：下载用的Task；\n>\n>NSURLSessionDataTask：可以上传内容，上传完成后再进行下载。\n\n引自[NSURLSession使用说明及后台工作流程分析](http://www.cocoachina.com/industry/20131106/7304.html)\n\n有了上面两个参考资料，这里我假设你已经会使用NSURLSession了（毕竟这不是我今天的主题），鉴于我不关心下载过程，只关心下载结果，所以我选择了最简单直接的Api。\n\n![Task](http://upload-images.jianshu.io/upload_images/1835430-299b6d20ce29bfb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n可以看到，老司机在现在完成的回调中一共做了以下几件事：\n\n- 检验是否下载失败，若失败，抛出错误信息\n- 若成功取到UIImage对象，使用缓存类进行数据缓存\n- 遍历回调数组进行回调\n\n代码都很简单，也不用多做解释，这样我们的下载类就完成了。\n\n放一下下载类的全部代码\n\n### 图片下载类\n\n\n```\n#pragma mark --- 图片下载类 ---\n@interface DWWebImageDownloader : NSObject\n\n///回调数组\n@property (nonatomic ,strong) NSMutableArray <DWWebImageCallBack>* callBacks;\n\n///下载任务\n@property (nonatomic ,strong) NSURLSessionDataTask * task;\n\n///下载图像实例\n/**\n 任务完成前为nil\n */\n@property (nonatomic ,strong) UIImage * image;\n\n///现在完成标志\n@property (nonatomic ,assign) BOOL downloadFinish;\n\n///初始化方法\n-(instancetype)initWithSession:(NSURLSession *)session;\n\n///以url下载图片\n-(void)downloadImageWithUrlString:(NSString *)url;\n\n///开启下载\n-(void)resume;\n\n///取消下载\n-(void)cancel;\n\n@end\n\n```\n\n```\n#pragma mark --- DWWebImageDownloader ---\n@interface DWWebImageDownloader ()\n\n@property (nonatomic ,copy) NSString * url;\n\n@property (nonatomic ,strong) NSURLSession * session;\n\n@end\n\n@implementation DWWebImageDownloader\n\n#pragma mark --- 接口方法 ---\n-(instancetype)initWithSession:(NSURLSession *)session {\n    self = [super init];\n    if (self) {\n        _session = session;\n        _downloadFinish = NO;\n    }\n    return self;\n}\n\n-(void)downloadImageWithUrlString:(NSString *)url\n{\n    if (!url.length) {\n        dispatch_async_main_safe((^(){\n            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"error\":DWErrorWithDescription(10001,@\"url为空\"),@\"url\":self.url}];\n        }));\n        return;\n    }\n    [self downloadImageWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]]];\n}\n\n-(void)resume {\n    [self.task resume];\n}\n\n-(void)cancel {\n    [self.task cancel];\n}\n\n#pragma mark --- Tool Method ---\n-(void)downloadImageWithRequest:(NSURLRequest *)request\n{\n    if (!request) {\n        dispatch_async_main_safe((^(){\n            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"error\":DWErrorWithDescription(10002,@\"无法生成request对象\"),@\"url\":self.url}];\n        }));\n        return;\n    }\n    \n    self.url = request.URL.absoluteString;\n    \n    self.task = [self.session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {\n        if (error) {///下载错误\n            dispatch_async_main_safe((^(){\n                [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"error\":DWErrorWithDescription(10003, @\"任务取消或错误\"),@\"url\":self.url}];\n            }));\n            return ;\n        }\n        _session = nil;\n        UIImage * image = [UIImage imageWithData:data];\n        self.downloadFinish = YES;///标志下载完成\n        self.image = image;\n        if (!image) {\n            dispatch_async_main_safe((^(){\n                [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"error\":DWErrorWithDescription(10000, ([NSString stringWithFormat:@\"图片下载失败：%@\",self.url])),@\"url\":self.url}];\n            }));\n            return ;\n        }\n        //保存数据\n        [[DWWebImageCache shareCache] cacheObj:data forKey:self.url];\n        \n        ///并发遍历\n        [self.callBacks enumerateObjectsWithOptions:(NSEnumerationConcurrent | NSEnumerationReverse) usingBlock:^(DWWebImageCallBack  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n            if (obj) {\n                //图片回调\n                dispatch_async_main_safe(^(){\n                    obj(image);\n                });\n            }\n        }];\n        ///发送通知\n        dispatch_async_main_safe((^(){\n            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@{@\"url\":self.url,@\"image\":image}];\n        }));\n    }];\n}\n\n-(NSMutableArray<DWWebImageCallBack> *)callBacks\n{\n    if (!_callBacks) {\n        _callBacks = [NSMutableArray array];\n    }\n    return _callBacks;\n}\n\n@end\n```\n\n- - -\n### 图片缓存类\nSD中对图片进行了多级缓存，包括内存缓存和磁盘缓存。\n这里我们也来模拟一下其实现过程。\n对于这个缓存类，我们可以给自己提几个需求：\n> 1.支持内存缓存及磁盘缓存两种缓存方式\n> \n> 2.对于缓存类缓存文件应做加密\n> \n> 3.磁盘缓存应保留清除缓存接口，并且应具备过期缓存自动清除功能\n \n对自己好一点，少提一些需求吧┑(￣Д ￣)┍\n\n所以按照需求我们可以大概知道几个技术点，一一分析一下。\n\n#### 内存缓存\n这里我们使用的内存缓存是系统提供的NSCache类。\n\nNSCache基本使用方法与字典相同，以key值存值和取值。不同的是，NSCache会在内存吃紧的时候自动释放内存。且相对于字典来说，NSCache是线程安全的，所以你并不需要手动加锁哦。\n\n所以确定了内存缓存的实现方式后，我们只要部署缓存逻辑即可。\n\n我们知道，内存读取速度是要大于磁盘读取速度的，所以当去缓存的时候我们优先取内存缓存使我们的主要策略。\n另外进行磁盘缓存的时候我们还要注意两点，第一点，一定要异步子线程去执行，这样可以避免线程阻塞。第二点，既然开启了子线程就应该注意线程安全，所以这里应注意加线程安全相关的代码。\n\n![缓存读写](http://upload-images.jianshu.io/upload_images/1835430-14f53e263e302bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 缓存加密\n这里我们采取与SDWebImage相同的做法，以图片下载URL做MD5加密后的字符串当做key与缓存一一对应。加密算法相对固定，再次不做赘述，稍后会有统一放代码。\n\n#### 自动清理\n自动清理的核心思想则是每当首次加载我们的Api的时候检测我们的磁盘缓存文件的最后修改时间，如果距离当前超过我们预设的过期时间则将文件移除。\n![移除过期文件](http://upload-images.jianshu.io/upload_images/1835430-6dcb473a8f17a51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下面是图片缓存类的代码\n\n```\n#pragma mark --- 缓存管理类 ---\n@interface DWWebImageCache : NSObject<NSCopying>\n\n///缓存策略\n@property (nonatomic ,assign) DWWebImageCachePolicy cachePolicy;\n\n///缓存数据类型\n@property (nonatomic ,assign) DWWebImageCacheType cacheType;\n\n///缓存过期时间，默认值7天\n@property (nonatomic ,assign) unsigned long long expirateTime;\n\n///是否加密缓存\n@property (nonatomic ,assign) BOOL useSecureKey;\n\n///缓存空间\n@property (nonatomic ,copy) NSString * cacheSpace;\n\n///单例\n+(instancetype)shareCache;\n\n///通过key存缓存\n-(void)cacheObj:(id)obj forKey:(NSString *)key;\n\n///通过key取缓存\n-(id)objCacheForKey:(NSString *)key;\n\n///通过key移除缓存\n-(void)removeCacheByKey:(NSString *)key;\n\n///移除过期缓存\n-(void)removeExpiratedCache;\n\n@end\n\n```\n\n```\n#pragma mark --- DWWebImageCache ---\n@interface DWWebImageCache ()\n\n@property (nonatomic ,strong) NSCache * memCache;\n\n@property (nonatomic ,strong) dispatch_semaphore_t semaphore;\n\n@property (nonatomic ,strong) NSFileManager * fileMgr;\n\n@end\n\n@implementation DWWebImageCache\n\n#pragma mark --- 接口方法 ---\n-(instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _memCache = [[NSCache alloc] init];\n        _memCache.totalCostLimit = DWWebImageCacheDefaultCost;\n        _memCache.countLimit = 20;\n        _expirateTime = DWWebImageCacheDefaultExpirateTime;\n        _useSecureKey = YES;\n        _cachePolicy = DWWebImageCachePolicyDisk;\n        _cacheType = DWWebImageCacheTypeData;\n        _semaphore = dispatch_semaphore_create(1);\n        _fileMgr = [NSFileManager defaultManager];\n        [self createTempPath];\n    }\n    return self;\n}\n\n-(void)cacheObj:(id)obj forKey:(NSString *)key\n{\n    NSString * url = key;\n    key = transferKey(key, self.useSecureKey);\n    if (self.cachePolicy & DWWebImageCachePolicyDisk) {///磁盘缓存\n        writeFileWithKey(obj, url, key, self.semaphore, self.fileMgr,self.cacheSpace);\n    }\n    if (self.cachePolicy & DWWebImageCachePolicyMemory) {\n        ///做内存缓存\n        [self.memCache setObject:obj forKey:key cost:costForObj(obj)];\n    }\n}\n\n-(id)objCacheForKey:(NSString *)key\n{\n    __block id obj = nil;\n    key = transferKey(key, self.useSecureKey);\n    obj = [self.memCache objectForKey:key];\n    if (!obj) {\n        NSAssert((self.cacheType != DWWebImageCacheTypeUndefined), @\"you must set a cacheType but not DWWebImageCacheTypeUndefined\");\n        readFileWithKey(key, self.cacheType, self.semaphore, self.cacheSpace,^(id object) {\n            obj = object;\n        });\n    }\n    return obj;\n}\n\n-(void)removeCacheByKey:(NSString *)key\n{\n    key = transferKey(key, self.useSecureKey);\n    [self.memCache removeObjectForKey:key];\n    [self.fileMgr removeItemAtPath:objPathWithKey(key,self.cacheSpace) error:nil];\n}\n\n-(void)removeExpiratedCache\n{\n    if (self.expirateTime) {\n        dispatch_async(dispatch_get_global_queue(0, 0), ^{\n            NSDirectoryEnumerator *dir=[self.fileMgr enumeratorAtPath:sandBoxPath(self.cacheSpace)];\n            NSString *path=[NSString new];\n            unsigned long long timeStamp = [[NSDate date] timeIntervalSince1970];\n            while ((path=[dir nextObject])!=nil) {\n                NSString * fileP = objPathWithKey(path,self.cacheSpace);\n                NSDictionary * attrs = [self.fileMgr attributesOfItemAtPath:fileP error:nil];\n                NSDate * dataCreate = attrs[NSFileModificationDate];\n                if ((timeStamp - [dataCreate timeIntervalSince1970]) > self.expirateTime) {\n                    [self.fileMgr removeItemAtPath:fileP error:nil];\n                }\n            }\n        });\n    }\n}\n\n#pragma mark -- Tool Method ---\n-(void)createTempPath\n{\n    if (![self.fileMgr fileExistsAtPath:sandBoxPath(self.cacheSpace)]) {\n        [self.fileMgr createDirectoryAtPath:sandBoxPath(self.cacheSpace) withIntermediateDirectories:YES attributes:nil error:NULL];\n    }\n}\n\n#pragma mark --- Setter、getter ---\n-(void)setExpirateTime:(unsigned long long)expirateTime\n{\n    _expirateTime = expirateTime;\n    if (expirateTime) {\n        [self removeExpiratedCache];\n    }\n}\n\n-(NSString *)cacheSpace\n{\n    if (!_cacheSpace) {\n        return @\"defaultCacheSpace\";\n    }\n    return _cacheSpace;\n}\n\n#pragma mark --- 单例 ---\nstatic DWWebImageCache * cache = nil;\n+(instancetype)shareCache\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        cache = [[self alloc] init];\n    });\n    return cache;\n}\n\n+(instancetype)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        cache = [super allocWithZone:zone];\n    });\n    return cache;\n}\n\n-(id)copyWithZone:(NSZone *)zone\n{\n    return cache;\n}\n\n#pragma mark --- 内联函数 ---\n\n/**\n 异步文件写入\n\n @param obj 写入对象\n @param url 下载url\n @param key 缓存key\n @param semaphore 信号量\n @param fileMgr 文件管理者\n @param cacheSpace  缓存空间\n */\nstatic inline void writeFileWithKey(id obj,NSString * url,NSString * key,dispatch_semaphore_t semaphore,NSFileManager * fileMgr,NSString * cacheSpace){\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        NSString * path = objPathWithKey(key,cacheSpace);\n        if ([fileMgr fileExistsAtPath:path]) {\n            [fileMgr removeItemAtPath:path error:nil];\n        }\n        if ([obj2Data(obj) writeToFile:path atomically:YES]) {\n            dispatch_async_main_safe(^(){\n                [[NSNotificationCenter defaultCenter] postNotificationName:\n                 DWWebImageCacheCompleteNotification object:nil userInfo:@{@\"url\":url}];\n            });\n        }\n        dispatch_semaphore_signal(semaphore);\n    });\n};\n\n\n/**\n 文件读取\n\n @param key 缓存key\n @param type 文件类型\n @param semaphore 信号量\n @param cacheSpace 缓存空间\n @param completion 读取完成回调\n */\nstatic inline void readFileWithKey(NSString * key,DWWebImageCacheType type,dispatch_semaphore_t semaphore,NSString * cacheSpace,void (^completion)(id obj)){\n    dispatch_sync(dispatch_get_global_queue(0, 0), ^{\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        NSData * data = [NSData dataWithContentsOfFile:objPathWithKey(key,cacheSpace)];\n        if (data && completion) {\n            completion(transferDataToObj(data, type));\n        }\n        dispatch_semaphore_signal(semaphore);\n    });\n};\n\n\n/**\n 数据格式转换\n\n @param data 源数据\n @param type 数据类型\n @return 转换后数据\n */\nstatic inline id transferDataToObj(NSData * data,DWWebImageCacheType type){\n    switch (type) {\n        case DWWebImageCacheTypeData:\n            return data;\n            break;\n        case DWWebImageCacheTypeImage:\n            return [UIImage imageWithData:data];\n            break;\n        default:\n            return nil;\n            break;\n    }\n};\n\n\n/**\n 返回文件路径\n\n @param key 缓存key\n @param cacheSpace 缓存空间\n @return 文件路径\n */\nstatic inline NSString * objPathWithKey(NSString * key,NSString * cacheSpace){\n    return [NSString stringWithFormat:@\"%@/%@\",sandBoxPath(cacheSpace),key];\n};\n\n\n/**\n 对象转为NSData\n\n @param obj 对象\n @return 转换后data\n */\nstatic inline NSData * obj2Data(id obj){\n    NSData * data = nil;\n    if ([obj isKindOfClass:[NSData class]]) {\n        data = obj;\n    }\n    else if([obj isKindOfClass:[UIImage class]]) {\n        data = UIImageJPEGRepresentation(obj, 1);\n    }\n    return data;\n}\n\n\n/**\n 沙盒路径\n\n @param cacheSpace 缓存空间\n @return 沙盒路径\n */\nstatic inline NSString * sandBoxPath(NSString * cacheSpace){\n    return [NSHomeDirectory() stringByAppendingString:[NSString stringWithFormat:@\"/Documents/DWWebImageCache/%@/\",cacheSpace]];\n};\n\n\n/**\n 计算对象所需缓存成本\n\n @param obj 对象\n @return 缓存成本\n */\nstatic inline NSUInteger costForObj(id obj){\n    NSUInteger cost = 0;\n    ///根据数据类型计算cost\n    if ([obj isKindOfClass:[NSData class]]) {\n        cost = [[obj valueForKey:@\"length\"] unsignedIntegerValue];\n    } else if ([obj isKindOfClass:[UIImage class]]) {\n        UIImage * image = (UIImage *)obj;\n        cost = (NSUInteger)image.size.width * image.size.height * image.scale * image.scale;\n    }\n    return cost;\n};\n\n\n/**\n 返回缓存key\n\n @param originKey 原始key\n @param useSecureKey 是否加密\n @return 缓存key\n */\nstatic inline NSString * transferKey(NSString * originKey,BOOL useSecureKey){\n    return useSecureKey?encryptToMD5(originKey):originKey;\n};\n\n\n/**\n 返回MD5加密字符串\n\n @param str 原始字符串\n @return 加密后字符串\n */\nstatic inline NSString *encryptToMD5(NSString * str){\n    CC_MD5_CTX md5;\n    CC_MD5_Init (&md5);\n    CC_MD5_Update (&md5, [str UTF8String], (CC_LONG)[str length]);\n    \n    unsigned char digest[CC_MD5_DIGEST_LENGTH];\n    CC_MD5_Final (digest, &md5);\n    return  [NSString stringWithFormat: @\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",\n             digest[0],  digest[1],\n             digest[2],  digest[3],\n             digest[4],  digest[5],\n             digest[6],  digest[7],\n             digest[8],  digest[9],\n             digest[10], digest[11],\n             digest[12], digest[13],\n             digest[14], digest[15]];\n};\n\n@end\n\n```\n- - - \n### 下载任务管理类\n有没有发现分模块后思路很清晰，我们接着给自己捋捋需求吧。\n\n- 我们的管理类要能区分当前URL存在缓存的话，我们不需要开启下载任务，直接从缓存中读取。\n- 如果没有缓存，判断当前URL是否正在下载，如果正在下载不应开启新的下载任务，而是为之前的任务增加回调。\n- 应该为任务添加优先级，新追加的下载任务应该较之前添加且尚未开始的下载任务具有更高的优先级。\n\n前两个需求，无非就是两个条件判断，而任务优先级我们可以通过NSOperation去添加依赖，从而实现。\n我们知道NSOperation和NSURLSessionTask都是需要手动开启的，所以我们可以重写NSOperation的resume方法，可以同时开启下载任务。\n\n同时我们知道添加到NSOperationQueue中的NSOperation会按需自动调用resume方法，所以我们可以成功的借助NSOperationQueue实现我们下载任务的相互依赖关系。看一下代码：\n\n![为下载任务添加依赖](http://upload-images.jianshu.io/upload_images/1835430-0a128b05402b1477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可能现在这么说还是不懂，先等下，接着看。\n\n![下载逻辑](http://upload-images.jianshu.io/upload_images/1835430-0a2d28d7d4c50102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们看到，每一次当创建新的任务时，我都会将上次记录的任务的依赖设置为新的任务，这样新添加的任务就会优先于上一个任务执行。然后将它加入到队列中，这样就会自动开启任务。\n\n管理类和线程类的全部代码放一下：\n\n```\n#pragma mark --- 任务线程类 ---\n@interface DWWebImageOperation : NSOperation\n\n///图片下载器\n@property (nonatomic ,strong) DWWebImageDownloader * donwloader;\n\n///下载任务是否完成\n@property (nonatomic , assign, getter=isFinished) BOOL finished;\n\n///以url及session下载图片\n-(instancetype)initWithUrl:(NSString *)url session:(NSURLSession *)session;\n\n@end\n\n\n\n#pragma mark --- 下载管理类 ---\n@interface DWWebImageManager : NSObject<NSCopying>\n\n///线程字典\n/**\n url为key，对应任务线程\n */\n@property (nonatomic ,strong) NSMutableDictionary <NSString *,DWWebImageOperation *>* operations;\n\n///缓存管理对象\n@property (nonatomic ,strong) DWWebImageCache * cache;\n\n///单例\n+(instancetype)shareManager;\n\n///以url下载图片，进行回调\n-(void)downloadImageWithUrl:(NSString *)url completion:(DWWebImageCallBack)completion;\n\n///以url移除下载任务\n-(void)removeOperationByUrl:(NSString *)url;\n\n@end\n```\n\n```\n\n#pragma mark --- DWWebImageOperation ---\n@implementation DWWebImageOperation\n@synthesize finished = _finished;\n\n-(instancetype)initWithUrl:(NSString *)url session:(NSURLSession *)session\n{\n    self = [super init];\n    if (self) {\n        _donwloader = [[DWWebImageDownloader alloc] initWithSession:session];\n        [_donwloader downloadImageWithUrlString:url];\n    }\n    return self;\n}\n\n-(void)start\n{\n    [super start];\n    [self.donwloader resume];\n}\n\n-(void)cancel\n{\n    [super cancel];\n    [self.donwloader cancel];\n}\n\n-(void)setFinished:(BOOL)finished {\n    [self willChangeValueForKey:@\"isFinished\"];\n    _finished = finished;\n    [self didChangeValueForKey:@\"isFinished\"];\n}\n\n@end\n\n#pragma mark --- DWWebImageManager ---\n\n@interface DWWebImageManager ()\n\n@property (nonatomic ,strong) NSURLSession * session;\n\n@property (nonatomic ,strong) dispatch_semaphore_t semaphore;\n\n@property (nonatomic ,strong) NSOperationQueue * queue;\n\n@property (nonatomic ,strong) DWWebImageOperation * lastOperation;\n\n@end\n\n@implementation DWWebImageManager\n\n-(instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.semaphore = dispatch_semaphore_create(1);\n        self.cache = [DWWebImageCache shareCache];\n        self.cache.cachePolicy = DWWebImageCachePolicyDisk | DWWebImageCachePolicyMemory;\n        [self.cache removeExpiratedCache];\n        dispatch_async_main_safe(^(){\n            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(cacheCompleteFinishNotice:) name:DWWebImageCacheCompleteNotification object:nil];\n            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downloadFinishNotice:) name:DWWebImageDownloadFinishNotification object:nil];\n        });\n    }\n    return self;\n}\n\n///下载图片\n-(void)downloadImageWithUrl:(NSString *)url completion:(DWWebImageCallBack)completion\n{\n    NSAssert(url.length, @\"url不能为空\");\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        ///从缓存加载图片\n        UIImage * image = [UIImage imageWithData:[self.cache objCacheForKey:url]];\n        if (image) {\n            dispatch_async_main_safe(^(){\n                completion(image);\n            });\n        } else {///无缓存\n            dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);\n            DWWebImageOperation * operation = self.operations[url];///取出下载任务\n            if (!operation) {///无任务\n                operation = [[DWWebImageOperation alloc] initWithUrl:url session:self.session];\n                self.operations[url] = operation;\n                if (self.lastOperation) {\n                    [self.lastOperation addDependency:operation];\n                }\n                [self.queue addOperation:operation];\n                self.lastOperation = operation;\n            }\n            if (!operation.donwloader.downloadFinish) {\n                [operation.donwloader.callBacks addObject:[completion copy]];\n            } else {\n                ///从缓存读取图片回调\n                dispatch_async_main_safe(^(){\n                    completion(operation.donwloader.image);\n                });\n            }\n            dispatch_semaphore_signal(self.semaphore);\n        }\n    });\n}\n\n///下载完成回调\n-(void)downloadFinishNotice:(NSNotification *)sender\n{\n    NSError * error = sender.userInfo[@\"error\"];\n    if (error) {///移除任务\n        [self removeOperationByUrl:sender.userInfo[@\"url\"]];\n        [self removeCacheByUrl:sender.userInfo[@\"url\"]];\n    } else {\n        NSString * url = sender.userInfo[@\"url\"];\n        DWWebImageOperation * operation = self.operations[url];///取出下载任务\n        operation.finished = YES;\n    }\n}\n\n///缓存完成通知回调\n-(void)cacheCompleteFinishNotice:(NSNotification *)sender\n{\n    NSString * url = sender.userInfo[@\"url\"];\n    if (url.length) {\n        [self removeOperationByUrl:sender.userInfo[@\"url\"]];\n    }\n}\n\n///移除下载进程\n-(void)removeOperationByUrl:(NSString *)url\n{\n    DWWebImageOperation * operation = self.operations[url];\n    [operation cancel];\n    [self.operations removeObjectForKey:url];\n}\n\n///移除缓存\n-(void)removeCacheByUrl:(NSString *)url\n{\n    [self.cache removeCacheByKey:url];\n}\n\n-(NSMutableDictionary<NSString *,DWWebImageOperation *> *)operations\n{\n    if (!_operations) {\n        _operations = [NSMutableDictionary dictionary];\n    }\n    return _operations;\n}\n\n-(NSURLSession *)session\n{\n    if (!_session) {\n        NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration];\n        config.timeoutIntervalForRequest = 15;\n        _session = [NSURLSession sessionWithConfiguration:config];\n    }\n    return _session;\n}\n\n-(NSOperationQueue *)queue\n{\n    if (!_queue) {\n        _queue = [[NSOperationQueue alloc] init];\n        _queue.maxConcurrentOperationCount = 6;\n    }\n    return _queue;\n}\n\n#pragma mark --- 单例 ---\nstatic DWWebImageManager * mgr = nil;\n+(instancetype)shareManager\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        mgr = [[self alloc] init];\n    });\n    return mgr;\n}\n\n+(instancetype)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        mgr = [super allocWithZone:zone];\n    });\n    return mgr;\n}\n\n-(id)copyWithZone:(NSZone *)zone\n{\n    return mgr;\n}\n\n@end\n\n```\n\n- - - \n至此，你已经自己实现了一个异步下载类。你可以像SD一样，为UIImageView、UIButton等添加分类实现相同的效果。\n\n这个下载思路与SD大同小异，相信你自己撸一份以后对SD会有更深的理解。\n当然SD为我们做的远不止这些，你怎么可能凭一己之力抗衡千人。有空多读读成熟的第三方代码也是对自我的锻炼与提升。\n\n- - -\n同样的，老司机把写好的下载类同样放在了我的Git上，[在这里](https://github.com/CodeWicky/-Tools/tree/master/DWWebImage)。\n- - -\n\n参考资料\n\n- [ NSURLSessionConfiguration API详解 ](http://blog.csdn.net/growinggiant/article/details/50483127)\n \n- [NSURLSession使用说明及后台工作流程分析](http://www.cocoachina.com/industry/20131106/7304.html)\n- [SDWebImage](https://github.com/rs/SDWebImage)\n\n- - -\n你说老司机今天怎么不逗比了，人家一直是治学严谨的老学究好么！\n\n![傲娇](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1488882401345&di=78cd0501c1a318d33bd98df0de28842f&imgtype=0&src=http%3A%2F%2Fwanzao2.b0.upaiyun.com%2Fsystem%2Fpictures%2F18747638%2Foriginal%2F80ffdf3a1ee62dac.gif)\n- - -\n恩，你在忍忍，这应该是我更新前最后一次做软广了=。=\n\n\nDWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。\n\n>version 1.1.0\n>全面支持自动链接支持、定制检测规则、图文混排、响应事件\n>优化大部分算法，提高响应效率及绘制效率\n \n>version 1.1.1\n>高亮取消逻辑优化\n>自动检测逻辑优化\n>部分常用方法改为内联函数，提高运行效率\n \n>version 1.1.2\n>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）\n \n>version 1.1.3\n>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中\n \n>version 1.1.4\n>事务管理类去除，异步绘制文件抽出\n \n>version 1.1.5\n>添加网络图片异步加载库，支持绘制网络图片\n>\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n\n\n![爱你哟](http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"老司机出品———疯狂造轮子之图片异步下载类","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htp6000ejigbval1itul","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-01cbaf922323f1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片异步下载类\"></p>\n<p>SDWebImage，我估计没有一个做iOS的不知道这个三方库吧，他为我们提供了简洁的图片异步下载方式。在他为我一句api带来这么大便利的同时，你有没有想过他是怎么实现的呢？让我们先来看看他为我们做了什么？</p>\n<ul>\n<li>图片异步加载</li>\n<li>图片缓存</li>\n<li>图片编解码</li>\n<li>图片渐进式下载</li>\n<li>下载任务管理</li>\n</ul>\n<p>So，你以为我要给你讲讲SDWebImage实现原理？<br>NONONO！SD这么一个成熟的框架早已有无数人对其架构进行过透彻的分析，老司机说了也是一样的，但作为程序员最快的成长就是不断地重造轮子。当然你造轮子不一定是要替代原来的，只是扩展一种思路。</p>\n<p>所以，今天老司机就带着你来<code>实现一个简单的图片下载类</code>。</p>\n<p>让我们先分析以下我们究竟需要些什么？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d2a03dd9a32406fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"下载思路\"></p>\n<p>这是一个完整的图片下载思路，编解码等图片处理的老司机没有纳在其中，因为需要详尽的图片编解码知识才能读懂代码，而且本期教程也重在整理下载思路。</p>\n<p>其实有了上面的分析我们需要做的就很明显了。</p>\n<ul>\n<li>首先我们需要一个<code>图片下载类</code>，为我们进行图片下载任务，并在完成时执行相关回调。</li>\n<li>其次我们需要一个<code>图片缓存类</code>，图片下载完成时将图片进行缓存。</li>\n<li>最后我们需要一个<code>下载任务管理类</code>，帮助我们管理当前下载任务，避免重复下载。</li>\n</ul>\n<p>那我们接下来一一分析相关需求。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"NSURLSession\"><a href=\"#NSURLSession\" class=\"headerlink\" title=\"NSURLSession\"></a>NSURLSession</h3><p>其实要写一个下载类，我们的思路应该很明显。<br>既然是数据请求，我们当然应该立刻想到<code>NSURLSession</code>做下载。</p>\n<blockquote>\n<p>NSURLSession是iOS7推出的与NSURLConnection并列的网络请求库，并且在iOS9中苹果宣布废弃NSURLConnection，NSURLSession从此正式步入历史舞台，大多数还在维护的网络相关的三方库都跟随苹果的脚步将底层Api替换为NSURLSession相关。<br>————引自《老司机瞎逼逼》第一卷第一章第一篇第一行第一句</p>\n</blockquote>\n<p>那么我们来使用NSURLSession写一个下载类。</p>\n<p>NSURLSession其实是一个会话，管理着发生在其之上的所有数据交换任务。<code>一个会话可以同时管理多个数据请求</code>。并且NSURLSession还向我们提供了<code>指定任务回调的队列</code>的Api，让我们方便的选择在主线程或子线程中回调。</p>\n<p>一般来讲，没有特殊需求，我们应该尽量复用我们的会话，毕竟频繁的创建与释放对象都是系统资源上的浪费。</p>\n<p>NSURLSession为我们提供了两种初始化方式</p>\n<blockquote>\n<p>+sessionWithConfiguration:<br>+sessionWithConfiguration:delegate:delegateQueue:</p>\n</blockquote>\n<p>这里可以根据不同的需求选择对应粒度的Api进行初始化。</p>\n<p>其中Configuration这个参数我们可以传进去一个配置对象，来定制我们session会话的不同参数。<br>这里系统为我们预置了3中配置</p>\n<h4 id=\"defaultSessionConfiguration\"><a href=\"#defaultSessionConfiguration\" class=\"headerlink\" title=\"defaultSessionConfiguration\"></a>defaultSessionConfiguration</h4><blockquote>\n<p>默认配置使用的是持久化的硬盘缓存，存储证书到用户钥匙链。存储cookie到shareCookie。</p>\n<p>标注：如果想要移植原来基于NSURLConnect的代码到NSURLSession，可使用该默认配置，然后再根据需要定制该默认配置。</p>\n</blockquote>\n<h4 id=\"ephemeralSessionConfiguration\"><a href=\"#ephemeralSessionConfiguration\" class=\"headerlink\" title=\"ephemeralSessionConfiguration\"></a>ephemeralSessionConfiguration</h4><blockquote>\n<p>返回一个不适用永久持存cookie、证书、缓存的配置，最佳优化数据传输。</p>\n<p>标注：当程序作废session时，所有的ephemeral session 数据会立即清除。此外，如果你的程序处于暂停状态，内存数据可能不会立即清除，但是会在程序终止或者收到内存警告或者内存压力时立即清除。</p>\n</blockquote>\n<h4 id=\"backgroundSessionConfigurationWithIdentifier\"><a href=\"#backgroundSessionConfigurationWithIdentifier\" class=\"headerlink\" title=\"backgroundSessionConfigurationWithIdentifier\"></a>backgroundSessionConfigurationWithIdentifier</h4><blockquote>\n<p>生成一个可以上传下载HTTP和HTTPS的后台任务(程序在后台运行)。<br>在后台时，将网络传输交给系统的单独的一个进程。</p>\n<p>重要：identifier 是configuration的唯一标示，不能为空或nil</p>\n</blockquote>\n<p>摘自<a href=\"http://blog.csdn.net/growinggiant/article/details/50483127\" target=\"_blank\" rel=\"external\"> NSURLSessionConfiguration API详解 </a></p>\n<p>这里我们使用默认配置单独设置一下请求超时时长即可。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-f11ba37b9d5978dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"NSURLSession\"></p>\n<p>有了session对象，我们就可以以request初始化NSURLSessionTask对象来做数据交换。</p>\n<blockquote>\n<p>NSURLSessionUploadTask：上传用的Task，传完以后不会再下载返回结果；</p>\n<p>NSURLSessionDownloadTask：下载用的Task；</p>\n<p>NSURLSessionDataTask：可以上传内容，上传完成后再进行下载。</p>\n</blockquote>\n<p>引自<a href=\"http://www.cocoachina.com/industry/20131106/7304.html\" target=\"_blank\" rel=\"external\">NSURLSession使用说明及后台工作流程分析</a></p>\n<p>有了上面两个参考资料，这里我假设你已经会使用NSURLSession了（毕竟这不是我今天的主题），鉴于我不关心下载过程，只关心下载结果，所以我选择了最简单直接的Api。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-299b6d20ce29bfb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Task\"></p>\n<p>可以看到，老司机在现在完成的回调中一共做了以下几件事：</p>\n<ul>\n<li>检验是否下载失败，若失败，抛出错误信息</li>\n<li>若成功取到UIImage对象，使用缓存类进行数据缓存</li>\n<li>遍历回调数组进行回调</li>\n</ul>\n<p>代码都很简单，也不用多做解释，这样我们的下载类就完成了。</p>\n<p>放一下下载类的全部代码</p>\n<h3 id=\"图片下载类\"><a href=\"#图片下载类\" class=\"headerlink\" title=\"图片下载类\"></a>图片下载类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- 图片下载类 ---</div><div class=\"line\">@interface DWWebImageDownloader : NSObject</div><div class=\"line\"></div><div class=\"line\">///回调数组</div><div class=\"line\">@property (nonatomic ,strong) NSMutableArray &lt;DWWebImageCallBack&gt;* callBacks;</div><div class=\"line\"></div><div class=\"line\">///下载任务</div><div class=\"line\">@property (nonatomic ,strong) NSURLSessionDataTask * task;</div><div class=\"line\"></div><div class=\"line\">///下载图像实例</div><div class=\"line\">/**</div><div class=\"line\"> 任务完成前为nil</div><div class=\"line\"> */</div><div class=\"line\">@property (nonatomic ,strong) UIImage * image;</div><div class=\"line\"></div><div class=\"line\">///现在完成标志</div><div class=\"line\">@property (nonatomic ,assign) BOOL downloadFinish;</div><div class=\"line\"></div><div class=\"line\">///初始化方法</div><div class=\"line\">-(instancetype)initWithSession:(NSURLSession *)session;</div><div class=\"line\"></div><div class=\"line\">///以url下载图片</div><div class=\"line\">-(void)downloadImageWithUrlString:(NSString *)url;</div><div class=\"line\"></div><div class=\"line\">///开启下载</div><div class=\"line\">-(void)resume;</div><div class=\"line\"></div><div class=\"line\">///取消下载</div><div class=\"line\">-(void)cancel;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- DWWebImageDownloader ---</div><div class=\"line\">@interface DWWebImageDownloader ()</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,copy) NSString * url;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSURLSession * session;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation DWWebImageDownloader</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 接口方法 ---</div><div class=\"line\">-(instancetype)initWithSession:(NSURLSession *)session &#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        _session = session;</div><div class=\"line\">        _downloadFinish = NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)downloadImageWithUrlString:(NSString *)url</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!url.length) &#123;</div><div class=\"line\">        dispatch_async_main_safe((^()&#123;</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;error&quot;:DWErrorWithDescription(10001,@&quot;url为空&quot;),@&quot;url&quot;:self.url&#125;];</div><div class=\"line\">        &#125;));</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self downloadImageWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)resume &#123;</div><div class=\"line\">    [self.task resume];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancel &#123;</div><div class=\"line\">    [self.task cancel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- Tool Method ---</div><div class=\"line\">-(void)downloadImageWithRequest:(NSURLRequest *)request</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!request) &#123;</div><div class=\"line\">        dispatch_async_main_safe((^()&#123;</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;error&quot;:DWErrorWithDescription(10002,@&quot;无法生成request对象&quot;),@&quot;url&quot;:self.url&#125;];</div><div class=\"line\">        &#125;));</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.url = request.URL.absoluteString;</div><div class=\"line\">    </div><div class=\"line\">    self.task = [self.session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class=\"line\">        if (error) &#123;///下载错误</div><div class=\"line\">            dispatch_async_main_safe((^()&#123;</div><div class=\"line\">                [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;error&quot;:DWErrorWithDescription(10003, @&quot;任务取消或错误&quot;),@&quot;url&quot;:self.url&#125;];</div><div class=\"line\">            &#125;));</div><div class=\"line\">            return ;</div><div class=\"line\">        &#125;</div><div class=\"line\">        _session = nil;</div><div class=\"line\">        UIImage * image = [UIImage imageWithData:data];</div><div class=\"line\">        self.downloadFinish = YES;///标志下载完成</div><div class=\"line\">        self.image = image;</div><div class=\"line\">        if (!image) &#123;</div><div class=\"line\">            dispatch_async_main_safe((^()&#123;</div><div class=\"line\">                [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;error&quot;:DWErrorWithDescription(10000, ([NSString stringWithFormat:@&quot;图片下载失败：%@&quot;,self.url])),@&quot;url&quot;:self.url&#125;];</div><div class=\"line\">            &#125;));</div><div class=\"line\">            return ;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //保存数据</div><div class=\"line\">        [[DWWebImageCache shareCache] cacheObj:data forKey:self.url];</div><div class=\"line\">        </div><div class=\"line\">        ///并发遍历</div><div class=\"line\">        [self.callBacks enumerateObjectsWithOptions:(NSEnumerationConcurrent | NSEnumerationReverse) usingBlock:^(DWWebImageCallBack  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">            if (obj) &#123;</div><div class=\"line\">                //图片回调</div><div class=\"line\">                dispatch_async_main_safe(^()&#123;</div><div class=\"line\">                    obj(image);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;];</div><div class=\"line\">        ///发送通知</div><div class=\"line\">        dispatch_async_main_safe((^()&#123;</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;url&quot;:self.url,@&quot;image&quot;:image&#125;];</div><div class=\"line\">        &#125;));</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSMutableArray&lt;DWWebImageCallBack&gt; *)callBacks</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_callBacks) &#123;</div><div class=\"line\">        _callBacks = [NSMutableArray array];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _callBacks;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"图片缓存类\"><a href=\"#图片缓存类\" class=\"headerlink\" title=\"图片缓存类\"></a>图片缓存类</h3><p>SD中对图片进行了多级缓存，包括内存缓存和磁盘缓存。<br>这里我们也来模拟一下其实现过程。<br>对于这个缓存类，我们可以给自己提几个需求：</p>\n<blockquote>\n<p>1.支持内存缓存及磁盘缓存两种缓存方式</p>\n<p>2.对于缓存类缓存文件应做加密</p>\n<p>3.磁盘缓存应保留清除缓存接口，并且应具备过期缓存自动清除功能</p>\n</blockquote>\n<p>对自己好一点，少提一些需求吧┑(￣Д ￣)┍</p>\n<p>所以按照需求我们可以大概知道几个技术点，一一分析一下。</p>\n<h4 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h4><p>这里我们使用的内存缓存是系统提供的NSCache类。</p>\n<p>NSCache基本使用方法与字典相同，以key值存值和取值。不同的是，NSCache会在内存吃紧的时候自动释放内存。且相对于字典来说，NSCache是线程安全的，所以你并不需要手动加锁哦。</p>\n<p>所以确定了内存缓存的实现方式后，我们只要部署缓存逻辑即可。</p>\n<p>我们知道，内存读取速度是要大于磁盘读取速度的，所以当去缓存的时候我们优先取内存缓存使我们的主要策略。<br>另外进行磁盘缓存的时候我们还要注意两点，第一点，一定要异步子线程去执行，这样可以避免线程阻塞。第二点，既然开启了子线程就应该注意线程安全，所以这里应注意加线程安全相关的代码。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-14f53e263e302bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"缓存读写\"></p>\n<h4 id=\"缓存加密\"><a href=\"#缓存加密\" class=\"headerlink\" title=\"缓存加密\"></a>缓存加密</h4><p>这里我们采取与SDWebImage相同的做法，以图片下载URL做MD5加密后的字符串当做key与缓存一一对应。加密算法相对固定，再次不做赘述，稍后会有统一放代码。</p>\n<h4 id=\"自动清理\"><a href=\"#自动清理\" class=\"headerlink\" title=\"自动清理\"></a>自动清理</h4><p>自动清理的核心思想则是每当首次加载我们的Api的时候检测我们的磁盘缓存文件的最后修改时间，如果距离当前超过我们预设的过期时间则将文件移除。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6dcb473a8f17a51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"移除过期文件\"></p>\n<p>下面是图片缓存类的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- 缓存管理类 ---</div><div class=\"line\">@interface DWWebImageCache : NSObject&lt;NSCopying&gt;</div><div class=\"line\"></div><div class=\"line\">///缓存策略</div><div class=\"line\">@property (nonatomic ,assign) DWWebImageCachePolicy cachePolicy;</div><div class=\"line\"></div><div class=\"line\">///缓存数据类型</div><div class=\"line\">@property (nonatomic ,assign) DWWebImageCacheType cacheType;</div><div class=\"line\"></div><div class=\"line\">///缓存过期时间，默认值7天</div><div class=\"line\">@property (nonatomic ,assign) unsigned long long expirateTime;</div><div class=\"line\"></div><div class=\"line\">///是否加密缓存</div><div class=\"line\">@property (nonatomic ,assign) BOOL useSecureKey;</div><div class=\"line\"></div><div class=\"line\">///缓存空间</div><div class=\"line\">@property (nonatomic ,copy) NSString * cacheSpace;</div><div class=\"line\"></div><div class=\"line\">///单例</div><div class=\"line\">+(instancetype)shareCache;</div><div class=\"line\"></div><div class=\"line\">///通过key存缓存</div><div class=\"line\">-(void)cacheObj:(id)obj forKey:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">///通过key取缓存</div><div class=\"line\">-(id)objCacheForKey:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">///通过key移除缓存</div><div class=\"line\">-(void)removeCacheByKey:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">///移除过期缓存</div><div class=\"line\">-(void)removeExpiratedCache;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- DWWebImageCache ---</div><div class=\"line\">@interface DWWebImageCache ()</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSCache * memCache;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) dispatch_semaphore_t semaphore;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSFileManager * fileMgr;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation DWWebImageCache</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 接口方法 ---</div><div class=\"line\">-(instancetype)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        _memCache = [[NSCache alloc] init];</div><div class=\"line\">        _memCache.totalCostLimit = DWWebImageCacheDefaultCost;</div><div class=\"line\">        _memCache.countLimit = 20;</div><div class=\"line\">        _expirateTime = DWWebImageCacheDefaultExpirateTime;</div><div class=\"line\">        _useSecureKey = YES;</div><div class=\"line\">        _cachePolicy = DWWebImageCachePolicyDisk;</div><div class=\"line\">        _cacheType = DWWebImageCacheTypeData;</div><div class=\"line\">        _semaphore = dispatch_semaphore_create(1);</div><div class=\"line\">        _fileMgr = [NSFileManager defaultManager];</div><div class=\"line\">        [self createTempPath];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cacheObj:(id)obj forKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString * url = key;</div><div class=\"line\">    key = transferKey(key, self.useSecureKey);</div><div class=\"line\">    if (self.cachePolicy &amp; DWWebImageCachePolicyDisk) &#123;///磁盘缓存</div><div class=\"line\">        writeFileWithKey(obj, url, key, self.semaphore, self.fileMgr,self.cacheSpace);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.cachePolicy &amp; DWWebImageCachePolicyMemory) &#123;</div><div class=\"line\">        ///做内存缓存</div><div class=\"line\">        [self.memCache setObject:obj forKey:key cost:costForObj(obj)];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(id)objCacheForKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    __block id obj = nil;</div><div class=\"line\">    key = transferKey(key, self.useSecureKey);</div><div class=\"line\">    obj = [self.memCache objectForKey:key];</div><div class=\"line\">    if (!obj) &#123;</div><div class=\"line\">        NSAssert((self.cacheType != DWWebImageCacheTypeUndefined), @&quot;you must set a cacheType but not DWWebImageCacheTypeUndefined&quot;);</div><div class=\"line\">        readFileWithKey(key, self.cacheType, self.semaphore, self.cacheSpace,^(id object) &#123;</div><div class=\"line\">            obj = object;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)removeCacheByKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    key = transferKey(key, self.useSecureKey);</div><div class=\"line\">    [self.memCache removeObjectForKey:key];</div><div class=\"line\">    [self.fileMgr removeItemAtPath:objPathWithKey(key,self.cacheSpace) error:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)removeExpiratedCache</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self.expirateTime) &#123;</div><div class=\"line\">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">            NSDirectoryEnumerator *dir=[self.fileMgr enumeratorAtPath:sandBoxPath(self.cacheSpace)];</div><div class=\"line\">            NSString *path=[NSString new];</div><div class=\"line\">            unsigned long long timeStamp = [[NSDate date] timeIntervalSince1970];</div><div class=\"line\">            while ((path=[dir nextObject])!=nil) &#123;</div><div class=\"line\">                NSString * fileP = objPathWithKey(path,self.cacheSpace);</div><div class=\"line\">                NSDictionary * attrs = [self.fileMgr attributesOfItemAtPath:fileP error:nil];</div><div class=\"line\">                NSDate * dataCreate = attrs[NSFileModificationDate];</div><div class=\"line\">                if ((timeStamp - [dataCreate timeIntervalSince1970]) &gt; self.expirateTime) &#123;</div><div class=\"line\">                    [self.fileMgr removeItemAtPath:fileP error:nil];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark -- Tool Method ---</div><div class=\"line\">-(void)createTempPath</div><div class=\"line\">&#123;</div><div class=\"line\">    if (![self.fileMgr fileExistsAtPath:sandBoxPath(self.cacheSpace)]) &#123;</div><div class=\"line\">        [self.fileMgr createDirectoryAtPath:sandBoxPath(self.cacheSpace) withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- Setter、getter ---</div><div class=\"line\">-(void)setExpirateTime:(unsigned long long)expirateTime</div><div class=\"line\">&#123;</div><div class=\"line\">    _expirateTime = expirateTime;</div><div class=\"line\">    if (expirateTime) &#123;</div><div class=\"line\">        [self removeExpiratedCache];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSString *)cacheSpace</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_cacheSpace) &#123;</div><div class=\"line\">        return @&quot;defaultCacheSpace&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _cacheSpace;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 单例 ---</div><div class=\"line\">static DWWebImageCache * cache = nil;</div><div class=\"line\">+(instancetype)shareCache</div><div class=\"line\">&#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        cache = [[self alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return cache;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(instancetype)allocWithZone:(struct _NSZone *)zone</div><div class=\"line\">&#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        cache = [super allocWithZone:zone];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return cache;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(id)copyWithZone:(NSZone *)zone</div><div class=\"line\">&#123;</div><div class=\"line\">    return cache;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 内联函数 ---</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 异步文件写入</div><div class=\"line\"></div><div class=\"line\"> @param obj 写入对象</div><div class=\"line\"> @param url 下载url</div><div class=\"line\"> @param key 缓存key</div><div class=\"line\"> @param semaphore 信号量</div><div class=\"line\"> @param fileMgr 文件管理者</div><div class=\"line\"> @param cacheSpace  缓存空间</div><div class=\"line\"> */</div><div class=\"line\">static inline void writeFileWithKey(id obj,NSString * url,NSString * key,dispatch_semaphore_t semaphore,NSFileManager * fileMgr,NSString * cacheSpace)&#123;</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">        NSString * path = objPathWithKey(key,cacheSpace);</div><div class=\"line\">        if ([fileMgr fileExistsAtPath:path]) &#123;</div><div class=\"line\">            [fileMgr removeItemAtPath:path error:nil];</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ([obj2Data(obj) writeToFile:path atomically:YES]) &#123;</div><div class=\"line\">            dispatch_async_main_safe(^()&#123;</div><div class=\"line\">                [[NSNotificationCenter defaultCenter] postNotificationName:</div><div class=\"line\">                 DWWebImageCacheCompleteNotification object:nil userInfo:@&#123;@&quot;url&quot;:url&#125;];</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 文件读取</div><div class=\"line\"></div><div class=\"line\"> @param key 缓存key</div><div class=\"line\"> @param type 文件类型</div><div class=\"line\"> @param semaphore 信号量</div><div class=\"line\"> @param cacheSpace 缓存空间</div><div class=\"line\"> @param completion 读取完成回调</div><div class=\"line\"> */</div><div class=\"line\">static inline void readFileWithKey(NSString * key,DWWebImageCacheType type,dispatch_semaphore_t semaphore,NSString * cacheSpace,void (^completion)(id obj))&#123;</div><div class=\"line\">    dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">        NSData * data = [NSData dataWithContentsOfFile:objPathWithKey(key,cacheSpace)];</div><div class=\"line\">        if (data &amp;&amp; completion) &#123;</div><div class=\"line\">            completion(transferDataToObj(data, type));</div><div class=\"line\">        &#125;</div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 数据格式转换</div><div class=\"line\"></div><div class=\"line\"> @param data 源数据</div><div class=\"line\"> @param type 数据类型</div><div class=\"line\"> @return 转换后数据</div><div class=\"line\"> */</div><div class=\"line\">static inline id transferDataToObj(NSData * data,DWWebImageCacheType type)&#123;</div><div class=\"line\">    switch (type) &#123;</div><div class=\"line\">        case DWWebImageCacheTypeData:</div><div class=\"line\">            return data;</div><div class=\"line\">            break;</div><div class=\"line\">        case DWWebImageCacheTypeImage:</div><div class=\"line\">            return [UIImage imageWithData:data];</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            return nil;</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 返回文件路径</div><div class=\"line\"></div><div class=\"line\"> @param key 缓存key</div><div class=\"line\"> @param cacheSpace 缓存空间</div><div class=\"line\"> @return 文件路径</div><div class=\"line\"> */</div><div class=\"line\">static inline NSString * objPathWithKey(NSString * key,NSString * cacheSpace)&#123;</div><div class=\"line\">    return [NSString stringWithFormat:@&quot;%@/%@&quot;,sandBoxPath(cacheSpace),key];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 对象转为NSData</div><div class=\"line\"></div><div class=\"line\"> @param obj 对象</div><div class=\"line\"> @return 转换后data</div><div class=\"line\"> */</div><div class=\"line\">static inline NSData * obj2Data(id obj)&#123;</div><div class=\"line\">    NSData * data = nil;</div><div class=\"line\">    if ([obj isKindOfClass:[NSData class]]) &#123;</div><div class=\"line\">        data = obj;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if([obj isKindOfClass:[UIImage class]]) &#123;</div><div class=\"line\">        data = UIImageJPEGRepresentation(obj, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return data;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 沙盒路径</div><div class=\"line\"></div><div class=\"line\"> @param cacheSpace 缓存空间</div><div class=\"line\"> @return 沙盒路径</div><div class=\"line\"> */</div><div class=\"line\">static inline NSString * sandBoxPath(NSString * cacheSpace)&#123;</div><div class=\"line\">    return [NSHomeDirectory() stringByAppendingString:[NSString stringWithFormat:@&quot;/Documents/DWWebImageCache/%@/&quot;,cacheSpace]];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 计算对象所需缓存成本</div><div class=\"line\"></div><div class=\"line\"> @param obj 对象</div><div class=\"line\"> @return 缓存成本</div><div class=\"line\"> */</div><div class=\"line\">static inline NSUInteger costForObj(id obj)&#123;</div><div class=\"line\">    NSUInteger cost = 0;</div><div class=\"line\">    ///根据数据类型计算cost</div><div class=\"line\">    if ([obj isKindOfClass:[NSData class]]) &#123;</div><div class=\"line\">        cost = [[obj valueForKey:@&quot;length&quot;] unsignedIntegerValue];</div><div class=\"line\">    &#125; else if ([obj isKindOfClass:[UIImage class]]) &#123;</div><div class=\"line\">        UIImage * image = (UIImage *)obj;</div><div class=\"line\">        cost = (NSUInteger)image.size.width * image.size.height * image.scale * image.scale;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return cost;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 返回缓存key</div><div class=\"line\"></div><div class=\"line\"> @param originKey 原始key</div><div class=\"line\"> @param useSecureKey 是否加密</div><div class=\"line\"> @return 缓存key</div><div class=\"line\"> */</div><div class=\"line\">static inline NSString * transferKey(NSString * originKey,BOOL useSecureKey)&#123;</div><div class=\"line\">    return useSecureKey?encryptToMD5(originKey):originKey;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 返回MD5加密字符串</div><div class=\"line\"></div><div class=\"line\"> @param str 原始字符串</div><div class=\"line\"> @return 加密后字符串</div><div class=\"line\"> */</div><div class=\"line\">static inline NSString *encryptToMD5(NSString * str)&#123;</div><div class=\"line\">    CC_MD5_CTX md5;</div><div class=\"line\">    CC_MD5_Init (&amp;md5);</div><div class=\"line\">    CC_MD5_Update (&amp;md5, [str UTF8String], (CC_LONG)[str length]);</div><div class=\"line\">    </div><div class=\"line\">    unsigned char digest[CC_MD5_DIGEST_LENGTH];</div><div class=\"line\">    CC_MD5_Final (digest, &amp;md5);</div><div class=\"line\">    return  [NSString stringWithFormat: @&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&quot;,</div><div class=\"line\">             digest[0],  digest[1],</div><div class=\"line\">             digest[2],  digest[3],</div><div class=\"line\">             digest[4],  digest[5],</div><div class=\"line\">             digest[6],  digest[7],</div><div class=\"line\">             digest[8],  digest[9],</div><div class=\"line\">             digest[10], digest[11],</div><div class=\"line\">             digest[12], digest[13],</div><div class=\"line\">             digest[14], digest[15]];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"下载任务管理类\"><a href=\"#下载任务管理类\" class=\"headerlink\" title=\"下载任务管理类\"></a>下载任务管理类</h3><p>有没有发现分模块后思路很清晰，我们接着给自己捋捋需求吧。</p>\n<ul>\n<li>我们的管理类要能区分当前URL存在缓存的话，我们不需要开启下载任务，直接从缓存中读取。</li>\n<li>如果没有缓存，判断当前URL是否正在下载，如果正在下载不应开启新的下载任务，而是为之前的任务增加回调。</li>\n<li>应该为任务添加优先级，新追加的下载任务应该较之前添加且尚未开始的下载任务具有更高的优先级。</li>\n</ul>\n<p>前两个需求，无非就是两个条件判断，而任务优先级我们可以通过NSOperation去添加依赖，从而实现。<br>我们知道NSOperation和NSURLSessionTask都是需要手动开启的，所以我们可以重写NSOperation的resume方法，可以同时开启下载任务。</p>\n<p>同时我们知道添加到NSOperationQueue中的NSOperation会按需自动调用resume方法，所以我们可以成功的借助NSOperationQueue实现我们下载任务的相互依赖关系。看一下代码：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0a128b05402b1477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"为下载任务添加依赖\"></p>\n<p>可能现在这么说还是不懂，先等下，接着看。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0a2d28d7d4c50102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"下载逻辑\"></p>\n<p>我们看到，每一次当创建新的任务时，我都会将上次记录的任务的依赖设置为新的任务，这样新添加的任务就会优先于上一个任务执行。然后将它加入到队列中，这样就会自动开启任务。</p>\n<p>管理类和线程类的全部代码放一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- 任务线程类 ---</div><div class=\"line\">@interface DWWebImageOperation : NSOperation</div><div class=\"line\"></div><div class=\"line\">///图片下载器</div><div class=\"line\">@property (nonatomic ,strong) DWWebImageDownloader * donwloader;</div><div class=\"line\"></div><div class=\"line\">///下载任务是否完成</div><div class=\"line\">@property (nonatomic , assign, getter=isFinished) BOOL finished;</div><div class=\"line\"></div><div class=\"line\">///以url及session下载图片</div><div class=\"line\">-(instancetype)initWithUrl:(NSString *)url session:(NSURLSession *)session;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 下载管理类 ---</div><div class=\"line\">@interface DWWebImageManager : NSObject&lt;NSCopying&gt;</div><div class=\"line\"></div><div class=\"line\">///线程字典</div><div class=\"line\">/**</div><div class=\"line\"> url为key，对应任务线程</div><div class=\"line\"> */</div><div class=\"line\">@property (nonatomic ,strong) NSMutableDictionary &lt;NSString *,DWWebImageOperation *&gt;* operations;</div><div class=\"line\"></div><div class=\"line\">///缓存管理对象</div><div class=\"line\">@property (nonatomic ,strong) DWWebImageCache * cache;</div><div class=\"line\"></div><div class=\"line\">///单例</div><div class=\"line\">+(instancetype)shareManager;</div><div class=\"line\"></div><div class=\"line\">///以url下载图片，进行回调</div><div class=\"line\">-(void)downloadImageWithUrl:(NSString *)url completion:(DWWebImageCallBack)completion;</div><div class=\"line\"></div><div class=\"line\">///以url移除下载任务</div><div class=\"line\">-(void)removeOperationByUrl:(NSString *)url;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#pragma mark --- DWWebImageOperation ---</div><div class=\"line\">@implementation DWWebImageOperation</div><div class=\"line\">@synthesize finished = _finished;</div><div class=\"line\"></div><div class=\"line\">-(instancetype)initWithUrl:(NSString *)url session:(NSURLSession *)session</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        _donwloader = [[DWWebImageDownloader alloc] initWithSession:session];</div><div class=\"line\">        [_donwloader downloadImageWithUrlString:url];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)start</div><div class=\"line\">&#123;</div><div class=\"line\">    [super start];</div><div class=\"line\">    [self.donwloader resume];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancel</div><div class=\"line\">&#123;</div><div class=\"line\">    [super cancel];</div><div class=\"line\">    [self.donwloader cancel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setFinished:(BOOL)finished &#123;</div><div class=\"line\">    [self willChangeValueForKey:@&quot;isFinished&quot;];</div><div class=\"line\">    _finished = finished;</div><div class=\"line\">    [self didChangeValueForKey:@&quot;isFinished&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- DWWebImageManager ---</div><div class=\"line\"></div><div class=\"line\">@interface DWWebImageManager ()</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSURLSession * session;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) dispatch_semaphore_t semaphore;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSOperationQueue * queue;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) DWWebImageOperation * lastOperation;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation DWWebImageManager</div><div class=\"line\"></div><div class=\"line\">-(instancetype)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        self.semaphore = dispatch_semaphore_create(1);</div><div class=\"line\">        self.cache = [DWWebImageCache shareCache];</div><div class=\"line\">        self.cache.cachePolicy = DWWebImageCachePolicyDisk | DWWebImageCachePolicyMemory;</div><div class=\"line\">        [self.cache removeExpiratedCache];</div><div class=\"line\">        dispatch_async_main_safe(^()&#123;</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(cacheCompleteFinishNotice:) name:DWWebImageCacheCompleteNotification object:nil];</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downloadFinishNotice:) name:DWWebImageDownloadFinishNotification object:nil];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///下载图片</div><div class=\"line\">-(void)downloadImageWithUrl:(NSString *)url completion:(DWWebImageCallBack)completion</div><div class=\"line\">&#123;</div><div class=\"line\">    NSAssert(url.length, @&quot;url不能为空&quot;);</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        ///从缓存加载图片</div><div class=\"line\">        UIImage * image = [UIImage imageWithData:[self.cache objCacheForKey:url]];</div><div class=\"line\">        if (image) &#123;</div><div class=\"line\">            dispatch_async_main_safe(^()&#123;</div><div class=\"line\">                completion(image);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; else &#123;///无缓存</div><div class=\"line\">            dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">            DWWebImageOperation * operation = self.operations[url];///取出下载任务</div><div class=\"line\">            if (!operation) &#123;///无任务</div><div class=\"line\">                operation = [[DWWebImageOperation alloc] initWithUrl:url session:self.session];</div><div class=\"line\">                self.operations[url] = operation;</div><div class=\"line\">                if (self.lastOperation) &#123;</div><div class=\"line\">                    [self.lastOperation addDependency:operation];</div><div class=\"line\">                &#125;</div><div class=\"line\">                [self.queue addOperation:operation];</div><div class=\"line\">                self.lastOperation = operation;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!operation.donwloader.downloadFinish) &#123;</div><div class=\"line\">                [operation.donwloader.callBacks addObject:[completion copy]];</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                ///从缓存读取图片回调</div><div class=\"line\">                dispatch_async_main_safe(^()&#123;</div><div class=\"line\">                    completion(operation.donwloader.image);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            dispatch_semaphore_signal(self.semaphore);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///下载完成回调</div><div class=\"line\">-(void)downloadFinishNotice:(NSNotification *)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    NSError * error = sender.userInfo[@&quot;error&quot;];</div><div class=\"line\">    if (error) &#123;///移除任务</div><div class=\"line\">        [self removeOperationByUrl:sender.userInfo[@&quot;url&quot;]];</div><div class=\"line\">        [self removeCacheByUrl:sender.userInfo[@&quot;url&quot;]];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSString * url = sender.userInfo[@&quot;url&quot;];</div><div class=\"line\">        DWWebImageOperation * operation = self.operations[url];///取出下载任务</div><div class=\"line\">        operation.finished = YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///缓存完成通知回调</div><div class=\"line\">-(void)cacheCompleteFinishNotice:(NSNotification *)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString * url = sender.userInfo[@&quot;url&quot;];</div><div class=\"line\">    if (url.length) &#123;</div><div class=\"line\">        [self removeOperationByUrl:sender.userInfo[@&quot;url&quot;]];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///移除下载进程</div><div class=\"line\">-(void)removeOperationByUrl:(NSString *)url</div><div class=\"line\">&#123;</div><div class=\"line\">    DWWebImageOperation * operation = self.operations[url];</div><div class=\"line\">    [operation cancel];</div><div class=\"line\">    [self.operations removeObjectForKey:url];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///移除缓存</div><div class=\"line\">-(void)removeCacheByUrl:(NSString *)url</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache removeCacheByKey:url];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSMutableDictionary&lt;NSString *,DWWebImageOperation *&gt; *)operations</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_operations) &#123;</div><div class=\"line\">        _operations = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _operations;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSURLSession *)session</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_session) &#123;</div><div class=\"line\">        NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class=\"line\">        config.timeoutIntervalForRequest = 15;</div><div class=\"line\">        _session = [NSURLSession sessionWithConfiguration:config];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _session;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSOperationQueue *)queue</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_queue) &#123;</div><div class=\"line\">        _queue = [[NSOperationQueue alloc] init];</div><div class=\"line\">        _queue.maxConcurrentOperationCount = 6;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _queue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 单例 ---</div><div class=\"line\">static DWWebImageManager * mgr = nil;</div><div class=\"line\">+(instancetype)shareManager</div><div class=\"line\">&#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        mgr = [[self alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return mgr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(instancetype)allocWithZone:(struct _NSZone *)zone</div><div class=\"line\">&#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        mgr = [super allocWithZone:zone];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return mgr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(id)copyWithZone:(NSZone *)zone</div><div class=\"line\">&#123;</div><div class=\"line\">    return mgr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<p>至此，你已经自己实现了一个异步下载类。你可以像SD一样，为UIImageView、UIButton等添加分类实现相同的效果。</p>\n<p>这个下载思路与SD大同小异，相信你自己撸一份以后对SD会有更深的理解。<br>当然SD为我们做的远不止这些，你怎么可能凭一己之力抗衡千人。有空多读读成熟的第三方代码也是对自我的锻炼与提升。</p>\n<hr>\n<p>同样的，老司机把写好的下载类同样放在了我的Git上，<a href=\"https://github.com/CodeWicky/-Tools/tree/master/DWWebImage\" target=\"_blank\" rel=\"external\">在这里</a>。</p>\n<hr>\n<p>参考资料</p>\n<ul>\n<li><p><a href=\"http://blog.csdn.net/growinggiant/article/details/50483127\" target=\"_blank\" rel=\"external\"> NSURLSessionConfiguration API详解 </a></p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/industry/20131106/7304.html\" target=\"_blank\" rel=\"external\">NSURLSession使用说明及后台工作流程分析</a></p>\n</li>\n<li><a href=\"https://github.com/rs/SDWebImage\" target=\"_blank\" rel=\"external\">SDWebImage</a></li>\n</ul>\n<hr>\n<p>你说老司机今天怎么不逗比了，人家一直是治学严谨的老学究好么！</p>\n<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1488882401345&amp;di=78cd0501c1a318d33bd98df0de28842f&amp;imgtype=0&amp;src=http%3A%2F%2Fwanzao2.b0.upaiyun.com%2Fsystem%2Fpictures%2F18747638%2Foriginal%2F80ffdf3a1ee62dac.gif\" alt=\"傲娇\"></p>\n<hr>\n<p>恩，你在忍忍，这应该是我更新前最后一次做软广了=。=</p>\n<p>DWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。</p>\n<blockquote>\n<p>version 1.1.0<br>全面支持自动链接支持、定制检测规则、图文混排、响应事件<br>优化大部分算法，提高响应效率及绘制效率</p>\n<p>version 1.1.1<br>高亮取消逻辑优化<br>自动检测逻辑优化<br>部分常用方法改为内联函数，提高运行效率</p>\n<p>version 1.1.2<br>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）</p>\n<p>version 1.1.3<br>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中</p>\n<p>version 1.1.4<br>事务管理类去除，异步绘制文件抽出</p>\n<p>version 1.1.5<br>添加网络图片异步加载库，支持绘制网络图片</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你哟\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-01cbaf922323f1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片异步下载类\"></p>\n<p>SDWebImage，我估计没有一个做iOS的不知道这个三方库吧，他为我们提供了简洁的图片异步下载方式。在他为我一句api带来这么大便利的同时，你有没有想过他是怎么实现的呢？让我们先来看看他为我们做了什么？</p>\n<ul>\n<li>图片异步加载</li>\n<li>图片缓存</li>\n<li>图片编解码</li>\n<li>图片渐进式下载</li>\n<li>下载任务管理</li>\n</ul>\n<p>So，你以为我要给你讲讲SDWebImage实现原理？<br>NONONO！SD这么一个成熟的框架早已有无数人对其架构进行过透彻的分析，老司机说了也是一样的，但作为程序员最快的成长就是不断地重造轮子。当然你造轮子不一定是要替代原来的，只是扩展一种思路。</p>\n<p>所以，今天老司机就带着你来<code>实现一个简单的图片下载类</code>。</p>\n<p>让我们先分析以下我们究竟需要些什么？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d2a03dd9a32406fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"下载思路\"></p>\n<p>这是一个完整的图片下载思路，编解码等图片处理的老司机没有纳在其中，因为需要详尽的图片编解码知识才能读懂代码，而且本期教程也重在整理下载思路。</p>\n<p>其实有了上面的分析我们需要做的就很明显了。</p>\n<ul>\n<li>首先我们需要一个<code>图片下载类</code>，为我们进行图片下载任务，并在完成时执行相关回调。</li>\n<li>其次我们需要一个<code>图片缓存类</code>，图片下载完成时将图片进行缓存。</li>\n<li>最后我们需要一个<code>下载任务管理类</code>，帮助我们管理当前下载任务，避免重复下载。</li>\n</ul>\n<p>那我们接下来一一分析相关需求。</p>","more":"<hr>\n<h3 id=\"NSURLSession\"><a href=\"#NSURLSession\" class=\"headerlink\" title=\"NSURLSession\"></a>NSURLSession</h3><p>其实要写一个下载类，我们的思路应该很明显。<br>既然是数据请求，我们当然应该立刻想到<code>NSURLSession</code>做下载。</p>\n<blockquote>\n<p>NSURLSession是iOS7推出的与NSURLConnection并列的网络请求库，并且在iOS9中苹果宣布废弃NSURLConnection，NSURLSession从此正式步入历史舞台，大多数还在维护的网络相关的三方库都跟随苹果的脚步将底层Api替换为NSURLSession相关。<br>————引自《老司机瞎逼逼》第一卷第一章第一篇第一行第一句</p>\n</blockquote>\n<p>那么我们来使用NSURLSession写一个下载类。</p>\n<p>NSURLSession其实是一个会话，管理着发生在其之上的所有数据交换任务。<code>一个会话可以同时管理多个数据请求</code>。并且NSURLSession还向我们提供了<code>指定任务回调的队列</code>的Api，让我们方便的选择在主线程或子线程中回调。</p>\n<p>一般来讲，没有特殊需求，我们应该尽量复用我们的会话，毕竟频繁的创建与释放对象都是系统资源上的浪费。</p>\n<p>NSURLSession为我们提供了两种初始化方式</p>\n<blockquote>\n<p>+sessionWithConfiguration:<br>+sessionWithConfiguration:delegate:delegateQueue:</p>\n</blockquote>\n<p>这里可以根据不同的需求选择对应粒度的Api进行初始化。</p>\n<p>其中Configuration这个参数我们可以传进去一个配置对象，来定制我们session会话的不同参数。<br>这里系统为我们预置了3中配置</p>\n<h4 id=\"defaultSessionConfiguration\"><a href=\"#defaultSessionConfiguration\" class=\"headerlink\" title=\"defaultSessionConfiguration\"></a>defaultSessionConfiguration</h4><blockquote>\n<p>默认配置使用的是持久化的硬盘缓存，存储证书到用户钥匙链。存储cookie到shareCookie。</p>\n<p>标注：如果想要移植原来基于NSURLConnect的代码到NSURLSession，可使用该默认配置，然后再根据需要定制该默认配置。</p>\n</blockquote>\n<h4 id=\"ephemeralSessionConfiguration\"><a href=\"#ephemeralSessionConfiguration\" class=\"headerlink\" title=\"ephemeralSessionConfiguration\"></a>ephemeralSessionConfiguration</h4><blockquote>\n<p>返回一个不适用永久持存cookie、证书、缓存的配置，最佳优化数据传输。</p>\n<p>标注：当程序作废session时，所有的ephemeral session 数据会立即清除。此外，如果你的程序处于暂停状态，内存数据可能不会立即清除，但是会在程序终止或者收到内存警告或者内存压力时立即清除。</p>\n</blockquote>\n<h4 id=\"backgroundSessionConfigurationWithIdentifier\"><a href=\"#backgroundSessionConfigurationWithIdentifier\" class=\"headerlink\" title=\"backgroundSessionConfigurationWithIdentifier\"></a>backgroundSessionConfigurationWithIdentifier</h4><blockquote>\n<p>生成一个可以上传下载HTTP和HTTPS的后台任务(程序在后台运行)。<br>在后台时，将网络传输交给系统的单独的一个进程。</p>\n<p>重要：identifier 是configuration的唯一标示，不能为空或nil</p>\n</blockquote>\n<p>摘自<a href=\"http://blog.csdn.net/growinggiant/article/details/50483127\" target=\"_blank\" rel=\"external\"> NSURLSessionConfiguration API详解 </a></p>\n<p>这里我们使用默认配置单独设置一下请求超时时长即可。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-f11ba37b9d5978dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"NSURLSession\"></p>\n<p>有了session对象，我们就可以以request初始化NSURLSessionTask对象来做数据交换。</p>\n<blockquote>\n<p>NSURLSessionUploadTask：上传用的Task，传完以后不会再下载返回结果；</p>\n<p>NSURLSessionDownloadTask：下载用的Task；</p>\n<p>NSURLSessionDataTask：可以上传内容，上传完成后再进行下载。</p>\n</blockquote>\n<p>引自<a href=\"http://www.cocoachina.com/industry/20131106/7304.html\" target=\"_blank\" rel=\"external\">NSURLSession使用说明及后台工作流程分析</a></p>\n<p>有了上面两个参考资料，这里我假设你已经会使用NSURLSession了（毕竟这不是我今天的主题），鉴于我不关心下载过程，只关心下载结果，所以我选择了最简单直接的Api。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-299b6d20ce29bfb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Task\"></p>\n<p>可以看到，老司机在现在完成的回调中一共做了以下几件事：</p>\n<ul>\n<li>检验是否下载失败，若失败，抛出错误信息</li>\n<li>若成功取到UIImage对象，使用缓存类进行数据缓存</li>\n<li>遍历回调数组进行回调</li>\n</ul>\n<p>代码都很简单，也不用多做解释，这样我们的下载类就完成了。</p>\n<p>放一下下载类的全部代码</p>\n<h3 id=\"图片下载类\"><a href=\"#图片下载类\" class=\"headerlink\" title=\"图片下载类\"></a>图片下载类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- 图片下载类 ---</div><div class=\"line\">@interface DWWebImageDownloader : NSObject</div><div class=\"line\"></div><div class=\"line\">///回调数组</div><div class=\"line\">@property (nonatomic ,strong) NSMutableArray &lt;DWWebImageCallBack&gt;* callBacks;</div><div class=\"line\"></div><div class=\"line\">///下载任务</div><div class=\"line\">@property (nonatomic ,strong) NSURLSessionDataTask * task;</div><div class=\"line\"></div><div class=\"line\">///下载图像实例</div><div class=\"line\">/**</div><div class=\"line\"> 任务完成前为nil</div><div class=\"line\"> */</div><div class=\"line\">@property (nonatomic ,strong) UIImage * image;</div><div class=\"line\"></div><div class=\"line\">///现在完成标志</div><div class=\"line\">@property (nonatomic ,assign) BOOL downloadFinish;</div><div class=\"line\"></div><div class=\"line\">///初始化方法</div><div class=\"line\">-(instancetype)initWithSession:(NSURLSession *)session;</div><div class=\"line\"></div><div class=\"line\">///以url下载图片</div><div class=\"line\">-(void)downloadImageWithUrlString:(NSString *)url;</div><div class=\"line\"></div><div class=\"line\">///开启下载</div><div class=\"line\">-(void)resume;</div><div class=\"line\"></div><div class=\"line\">///取消下载</div><div class=\"line\">-(void)cancel;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- DWWebImageDownloader ---</div><div class=\"line\">@interface DWWebImageDownloader ()</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,copy) NSString * url;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSURLSession * session;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation DWWebImageDownloader</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 接口方法 ---</div><div class=\"line\">-(instancetype)initWithSession:(NSURLSession *)session &#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        _session = session;</div><div class=\"line\">        _downloadFinish = NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)downloadImageWithUrlString:(NSString *)url</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!url.length) &#123;</div><div class=\"line\">        dispatch_async_main_safe((^()&#123;</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;error&quot;:DWErrorWithDescription(10001,@&quot;url为空&quot;),@&quot;url&quot;:self.url&#125;];</div><div class=\"line\">        &#125;));</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self downloadImageWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)resume &#123;</div><div class=\"line\">    [self.task resume];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancel &#123;</div><div class=\"line\">    [self.task cancel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- Tool Method ---</div><div class=\"line\">-(void)downloadImageWithRequest:(NSURLRequest *)request</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!request) &#123;</div><div class=\"line\">        dispatch_async_main_safe((^()&#123;</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;error&quot;:DWErrorWithDescription(10002,@&quot;无法生成request对象&quot;),@&quot;url&quot;:self.url&#125;];</div><div class=\"line\">        &#125;));</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.url = request.URL.absoluteString;</div><div class=\"line\">    </div><div class=\"line\">    self.task = [self.session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class=\"line\">        if (error) &#123;///下载错误</div><div class=\"line\">            dispatch_async_main_safe((^()&#123;</div><div class=\"line\">                [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;error&quot;:DWErrorWithDescription(10003, @&quot;任务取消或错误&quot;),@&quot;url&quot;:self.url&#125;];</div><div class=\"line\">            &#125;));</div><div class=\"line\">            return ;</div><div class=\"line\">        &#125;</div><div class=\"line\">        _session = nil;</div><div class=\"line\">        UIImage * image = [UIImage imageWithData:data];</div><div class=\"line\">        self.downloadFinish = YES;///标志下载完成</div><div class=\"line\">        self.image = image;</div><div class=\"line\">        if (!image) &#123;</div><div class=\"line\">            dispatch_async_main_safe((^()&#123;</div><div class=\"line\">                [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;error&quot;:DWErrorWithDescription(10000, ([NSString stringWithFormat:@&quot;图片下载失败：%@&quot;,self.url])),@&quot;url&quot;:self.url&#125;];</div><div class=\"line\">            &#125;));</div><div class=\"line\">            return ;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //保存数据</div><div class=\"line\">        [[DWWebImageCache shareCache] cacheObj:data forKey:self.url];</div><div class=\"line\">        </div><div class=\"line\">        ///并发遍历</div><div class=\"line\">        [self.callBacks enumerateObjectsWithOptions:(NSEnumerationConcurrent | NSEnumerationReverse) usingBlock:^(DWWebImageCallBack  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">            if (obj) &#123;</div><div class=\"line\">                //图片回调</div><div class=\"line\">                dispatch_async_main_safe(^()&#123;</div><div class=\"line\">                    obj(image);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;];</div><div class=\"line\">        ///发送通知</div><div class=\"line\">        dispatch_async_main_safe((^()&#123;</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] postNotificationName:DWWebImageDownloadFinishNotification object:nil userInfo:@&#123;@&quot;url&quot;:self.url,@&quot;image&quot;:image&#125;];</div><div class=\"line\">        &#125;));</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSMutableArray&lt;DWWebImageCallBack&gt; *)callBacks</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_callBacks) &#123;</div><div class=\"line\">        _callBacks = [NSMutableArray array];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _callBacks;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"图片缓存类\"><a href=\"#图片缓存类\" class=\"headerlink\" title=\"图片缓存类\"></a>图片缓存类</h3><p>SD中对图片进行了多级缓存，包括内存缓存和磁盘缓存。<br>这里我们也来模拟一下其实现过程。<br>对于这个缓存类，我们可以给自己提几个需求：</p>\n<blockquote>\n<p>1.支持内存缓存及磁盘缓存两种缓存方式</p>\n<p>2.对于缓存类缓存文件应做加密</p>\n<p>3.磁盘缓存应保留清除缓存接口，并且应具备过期缓存自动清除功能</p>\n</blockquote>\n<p>对自己好一点，少提一些需求吧┑(￣Д ￣)┍</p>\n<p>所以按照需求我们可以大概知道几个技术点，一一分析一下。</p>\n<h4 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h4><p>这里我们使用的内存缓存是系统提供的NSCache类。</p>\n<p>NSCache基本使用方法与字典相同，以key值存值和取值。不同的是，NSCache会在内存吃紧的时候自动释放内存。且相对于字典来说，NSCache是线程安全的，所以你并不需要手动加锁哦。</p>\n<p>所以确定了内存缓存的实现方式后，我们只要部署缓存逻辑即可。</p>\n<p>我们知道，内存读取速度是要大于磁盘读取速度的，所以当去缓存的时候我们优先取内存缓存使我们的主要策略。<br>另外进行磁盘缓存的时候我们还要注意两点，第一点，一定要异步子线程去执行，这样可以避免线程阻塞。第二点，既然开启了子线程就应该注意线程安全，所以这里应注意加线程安全相关的代码。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-14f53e263e302bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"缓存读写\"></p>\n<h4 id=\"缓存加密\"><a href=\"#缓存加密\" class=\"headerlink\" title=\"缓存加密\"></a>缓存加密</h4><p>这里我们采取与SDWebImage相同的做法，以图片下载URL做MD5加密后的字符串当做key与缓存一一对应。加密算法相对固定，再次不做赘述，稍后会有统一放代码。</p>\n<h4 id=\"自动清理\"><a href=\"#自动清理\" class=\"headerlink\" title=\"自动清理\"></a>自动清理</h4><p>自动清理的核心思想则是每当首次加载我们的Api的时候检测我们的磁盘缓存文件的最后修改时间，如果距离当前超过我们预设的过期时间则将文件移除。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6dcb473a8f17a51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"移除过期文件\"></p>\n<p>下面是图片缓存类的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- 缓存管理类 ---</div><div class=\"line\">@interface DWWebImageCache : NSObject&lt;NSCopying&gt;</div><div class=\"line\"></div><div class=\"line\">///缓存策略</div><div class=\"line\">@property (nonatomic ,assign) DWWebImageCachePolicy cachePolicy;</div><div class=\"line\"></div><div class=\"line\">///缓存数据类型</div><div class=\"line\">@property (nonatomic ,assign) DWWebImageCacheType cacheType;</div><div class=\"line\"></div><div class=\"line\">///缓存过期时间，默认值7天</div><div class=\"line\">@property (nonatomic ,assign) unsigned long long expirateTime;</div><div class=\"line\"></div><div class=\"line\">///是否加密缓存</div><div class=\"line\">@property (nonatomic ,assign) BOOL useSecureKey;</div><div class=\"line\"></div><div class=\"line\">///缓存空间</div><div class=\"line\">@property (nonatomic ,copy) NSString * cacheSpace;</div><div class=\"line\"></div><div class=\"line\">///单例</div><div class=\"line\">+(instancetype)shareCache;</div><div class=\"line\"></div><div class=\"line\">///通过key存缓存</div><div class=\"line\">-(void)cacheObj:(id)obj forKey:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">///通过key取缓存</div><div class=\"line\">-(id)objCacheForKey:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">///通过key移除缓存</div><div class=\"line\">-(void)removeCacheByKey:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">///移除过期缓存</div><div class=\"line\">-(void)removeExpiratedCache;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- DWWebImageCache ---</div><div class=\"line\">@interface DWWebImageCache ()</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSCache * memCache;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) dispatch_semaphore_t semaphore;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSFileManager * fileMgr;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation DWWebImageCache</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 接口方法 ---</div><div class=\"line\">-(instancetype)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        _memCache = [[NSCache alloc] init];</div><div class=\"line\">        _memCache.totalCostLimit = DWWebImageCacheDefaultCost;</div><div class=\"line\">        _memCache.countLimit = 20;</div><div class=\"line\">        _expirateTime = DWWebImageCacheDefaultExpirateTime;</div><div class=\"line\">        _useSecureKey = YES;</div><div class=\"line\">        _cachePolicy = DWWebImageCachePolicyDisk;</div><div class=\"line\">        _cacheType = DWWebImageCacheTypeData;</div><div class=\"line\">        _semaphore = dispatch_semaphore_create(1);</div><div class=\"line\">        _fileMgr = [NSFileManager defaultManager];</div><div class=\"line\">        [self createTempPath];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cacheObj:(id)obj forKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString * url = key;</div><div class=\"line\">    key = transferKey(key, self.useSecureKey);</div><div class=\"line\">    if (self.cachePolicy &amp; DWWebImageCachePolicyDisk) &#123;///磁盘缓存</div><div class=\"line\">        writeFileWithKey(obj, url, key, self.semaphore, self.fileMgr,self.cacheSpace);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (self.cachePolicy &amp; DWWebImageCachePolicyMemory) &#123;</div><div class=\"line\">        ///做内存缓存</div><div class=\"line\">        [self.memCache setObject:obj forKey:key cost:costForObj(obj)];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(id)objCacheForKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    __block id obj = nil;</div><div class=\"line\">    key = transferKey(key, self.useSecureKey);</div><div class=\"line\">    obj = [self.memCache objectForKey:key];</div><div class=\"line\">    if (!obj) &#123;</div><div class=\"line\">        NSAssert((self.cacheType != DWWebImageCacheTypeUndefined), @&quot;you must set a cacheType but not DWWebImageCacheTypeUndefined&quot;);</div><div class=\"line\">        readFileWithKey(key, self.cacheType, self.semaphore, self.cacheSpace,^(id object) &#123;</div><div class=\"line\">            obj = object;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)removeCacheByKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    key = transferKey(key, self.useSecureKey);</div><div class=\"line\">    [self.memCache removeObjectForKey:key];</div><div class=\"line\">    [self.fileMgr removeItemAtPath:objPathWithKey(key,self.cacheSpace) error:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)removeExpiratedCache</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self.expirateTime) &#123;</div><div class=\"line\">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">            NSDirectoryEnumerator *dir=[self.fileMgr enumeratorAtPath:sandBoxPath(self.cacheSpace)];</div><div class=\"line\">            NSString *path=[NSString new];</div><div class=\"line\">            unsigned long long timeStamp = [[NSDate date] timeIntervalSince1970];</div><div class=\"line\">            while ((path=[dir nextObject])!=nil) &#123;</div><div class=\"line\">                NSString * fileP = objPathWithKey(path,self.cacheSpace);</div><div class=\"line\">                NSDictionary * attrs = [self.fileMgr attributesOfItemAtPath:fileP error:nil];</div><div class=\"line\">                NSDate * dataCreate = attrs[NSFileModificationDate];</div><div class=\"line\">                if ((timeStamp - [dataCreate timeIntervalSince1970]) &gt; self.expirateTime) &#123;</div><div class=\"line\">                    [self.fileMgr removeItemAtPath:fileP error:nil];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark -- Tool Method ---</div><div class=\"line\">-(void)createTempPath</div><div class=\"line\">&#123;</div><div class=\"line\">    if (![self.fileMgr fileExistsAtPath:sandBoxPath(self.cacheSpace)]) &#123;</div><div class=\"line\">        [self.fileMgr createDirectoryAtPath:sandBoxPath(self.cacheSpace) withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- Setter、getter ---</div><div class=\"line\">-(void)setExpirateTime:(unsigned long long)expirateTime</div><div class=\"line\">&#123;</div><div class=\"line\">    _expirateTime = expirateTime;</div><div class=\"line\">    if (expirateTime) &#123;</div><div class=\"line\">        [self removeExpiratedCache];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSString *)cacheSpace</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_cacheSpace) &#123;</div><div class=\"line\">        return @&quot;defaultCacheSpace&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _cacheSpace;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 单例 ---</div><div class=\"line\">static DWWebImageCache * cache = nil;</div><div class=\"line\">+(instancetype)shareCache</div><div class=\"line\">&#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        cache = [[self alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return cache;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(instancetype)allocWithZone:(struct _NSZone *)zone</div><div class=\"line\">&#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        cache = [super allocWithZone:zone];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return cache;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(id)copyWithZone:(NSZone *)zone</div><div class=\"line\">&#123;</div><div class=\"line\">    return cache;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 内联函数 ---</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 异步文件写入</div><div class=\"line\"></div><div class=\"line\"> @param obj 写入对象</div><div class=\"line\"> @param url 下载url</div><div class=\"line\"> @param key 缓存key</div><div class=\"line\"> @param semaphore 信号量</div><div class=\"line\"> @param fileMgr 文件管理者</div><div class=\"line\"> @param cacheSpace  缓存空间</div><div class=\"line\"> */</div><div class=\"line\">static inline void writeFileWithKey(id obj,NSString * url,NSString * key,dispatch_semaphore_t semaphore,NSFileManager * fileMgr,NSString * cacheSpace)&#123;</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">        NSString * path = objPathWithKey(key,cacheSpace);</div><div class=\"line\">        if ([fileMgr fileExistsAtPath:path]) &#123;</div><div class=\"line\">            [fileMgr removeItemAtPath:path error:nil];</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ([obj2Data(obj) writeToFile:path atomically:YES]) &#123;</div><div class=\"line\">            dispatch_async_main_safe(^()&#123;</div><div class=\"line\">                [[NSNotificationCenter defaultCenter] postNotificationName:</div><div class=\"line\">                 DWWebImageCacheCompleteNotification object:nil userInfo:@&#123;@&quot;url&quot;:url&#125;];</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 文件读取</div><div class=\"line\"></div><div class=\"line\"> @param key 缓存key</div><div class=\"line\"> @param type 文件类型</div><div class=\"line\"> @param semaphore 信号量</div><div class=\"line\"> @param cacheSpace 缓存空间</div><div class=\"line\"> @param completion 读取完成回调</div><div class=\"line\"> */</div><div class=\"line\">static inline void readFileWithKey(NSString * key,DWWebImageCacheType type,dispatch_semaphore_t semaphore,NSString * cacheSpace,void (^completion)(id obj))&#123;</div><div class=\"line\">    dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">        NSData * data = [NSData dataWithContentsOfFile:objPathWithKey(key,cacheSpace)];</div><div class=\"line\">        if (data &amp;&amp; completion) &#123;</div><div class=\"line\">            completion(transferDataToObj(data, type));</div><div class=\"line\">        &#125;</div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 数据格式转换</div><div class=\"line\"></div><div class=\"line\"> @param data 源数据</div><div class=\"line\"> @param type 数据类型</div><div class=\"line\"> @return 转换后数据</div><div class=\"line\"> */</div><div class=\"line\">static inline id transferDataToObj(NSData * data,DWWebImageCacheType type)&#123;</div><div class=\"line\">    switch (type) &#123;</div><div class=\"line\">        case DWWebImageCacheTypeData:</div><div class=\"line\">            return data;</div><div class=\"line\">            break;</div><div class=\"line\">        case DWWebImageCacheTypeImage:</div><div class=\"line\">            return [UIImage imageWithData:data];</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            return nil;</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 返回文件路径</div><div class=\"line\"></div><div class=\"line\"> @param key 缓存key</div><div class=\"line\"> @param cacheSpace 缓存空间</div><div class=\"line\"> @return 文件路径</div><div class=\"line\"> */</div><div class=\"line\">static inline NSString * objPathWithKey(NSString * key,NSString * cacheSpace)&#123;</div><div class=\"line\">    return [NSString stringWithFormat:@&quot;%@/%@&quot;,sandBoxPath(cacheSpace),key];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 对象转为NSData</div><div class=\"line\"></div><div class=\"line\"> @param obj 对象</div><div class=\"line\"> @return 转换后data</div><div class=\"line\"> */</div><div class=\"line\">static inline NSData * obj2Data(id obj)&#123;</div><div class=\"line\">    NSData * data = nil;</div><div class=\"line\">    if ([obj isKindOfClass:[NSData class]]) &#123;</div><div class=\"line\">        data = obj;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if([obj isKindOfClass:[UIImage class]]) &#123;</div><div class=\"line\">        data = UIImageJPEGRepresentation(obj, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return data;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 沙盒路径</div><div class=\"line\"></div><div class=\"line\"> @param cacheSpace 缓存空间</div><div class=\"line\"> @return 沙盒路径</div><div class=\"line\"> */</div><div class=\"line\">static inline NSString * sandBoxPath(NSString * cacheSpace)&#123;</div><div class=\"line\">    return [NSHomeDirectory() stringByAppendingString:[NSString stringWithFormat:@&quot;/Documents/DWWebImageCache/%@/&quot;,cacheSpace]];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 计算对象所需缓存成本</div><div class=\"line\"></div><div class=\"line\"> @param obj 对象</div><div class=\"line\"> @return 缓存成本</div><div class=\"line\"> */</div><div class=\"line\">static inline NSUInteger costForObj(id obj)&#123;</div><div class=\"line\">    NSUInteger cost = 0;</div><div class=\"line\">    ///根据数据类型计算cost</div><div class=\"line\">    if ([obj isKindOfClass:[NSData class]]) &#123;</div><div class=\"line\">        cost = [[obj valueForKey:@&quot;length&quot;] unsignedIntegerValue];</div><div class=\"line\">    &#125; else if ([obj isKindOfClass:[UIImage class]]) &#123;</div><div class=\"line\">        UIImage * image = (UIImage *)obj;</div><div class=\"line\">        cost = (NSUInteger)image.size.width * image.size.height * image.scale * image.scale;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return cost;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 返回缓存key</div><div class=\"line\"></div><div class=\"line\"> @param originKey 原始key</div><div class=\"line\"> @param useSecureKey 是否加密</div><div class=\"line\"> @return 缓存key</div><div class=\"line\"> */</div><div class=\"line\">static inline NSString * transferKey(NSString * originKey,BOOL useSecureKey)&#123;</div><div class=\"line\">    return useSecureKey?encryptToMD5(originKey):originKey;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 返回MD5加密字符串</div><div class=\"line\"></div><div class=\"line\"> @param str 原始字符串</div><div class=\"line\"> @return 加密后字符串</div><div class=\"line\"> */</div><div class=\"line\">static inline NSString *encryptToMD5(NSString * str)&#123;</div><div class=\"line\">    CC_MD5_CTX md5;</div><div class=\"line\">    CC_MD5_Init (&amp;md5);</div><div class=\"line\">    CC_MD5_Update (&amp;md5, [str UTF8String], (CC_LONG)[str length]);</div><div class=\"line\">    </div><div class=\"line\">    unsigned char digest[CC_MD5_DIGEST_LENGTH];</div><div class=\"line\">    CC_MD5_Final (digest, &amp;md5);</div><div class=\"line\">    return  [NSString stringWithFormat: @&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&quot;,</div><div class=\"line\">             digest[0],  digest[1],</div><div class=\"line\">             digest[2],  digest[3],</div><div class=\"line\">             digest[4],  digest[5],</div><div class=\"line\">             digest[6],  digest[7],</div><div class=\"line\">             digest[8],  digest[9],</div><div class=\"line\">             digest[10], digest[11],</div><div class=\"line\">             digest[12], digest[13],</div><div class=\"line\">             digest[14], digest[15]];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"下载任务管理类\"><a href=\"#下载任务管理类\" class=\"headerlink\" title=\"下载任务管理类\"></a>下载任务管理类</h3><p>有没有发现分模块后思路很清晰，我们接着给自己捋捋需求吧。</p>\n<ul>\n<li>我们的管理类要能区分当前URL存在缓存的话，我们不需要开启下载任务，直接从缓存中读取。</li>\n<li>如果没有缓存，判断当前URL是否正在下载，如果正在下载不应开启新的下载任务，而是为之前的任务增加回调。</li>\n<li>应该为任务添加优先级，新追加的下载任务应该较之前添加且尚未开始的下载任务具有更高的优先级。</li>\n</ul>\n<p>前两个需求，无非就是两个条件判断，而任务优先级我们可以通过NSOperation去添加依赖，从而实现。<br>我们知道NSOperation和NSURLSessionTask都是需要手动开启的，所以我们可以重写NSOperation的resume方法，可以同时开启下载任务。</p>\n<p>同时我们知道添加到NSOperationQueue中的NSOperation会按需自动调用resume方法，所以我们可以成功的借助NSOperationQueue实现我们下载任务的相互依赖关系。看一下代码：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0a128b05402b1477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"为下载任务添加依赖\"></p>\n<p>可能现在这么说还是不懂，先等下，接着看。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0a2d28d7d4c50102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"下载逻辑\"></p>\n<p>我们看到，每一次当创建新的任务时，我都会将上次记录的任务的依赖设置为新的任务，这样新添加的任务就会优先于上一个任务执行。然后将它加入到队列中，这样就会自动开启任务。</p>\n<p>管理类和线程类的全部代码放一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- 任务线程类 ---</div><div class=\"line\">@interface DWWebImageOperation : NSOperation</div><div class=\"line\"></div><div class=\"line\">///图片下载器</div><div class=\"line\">@property (nonatomic ,strong) DWWebImageDownloader * donwloader;</div><div class=\"line\"></div><div class=\"line\">///下载任务是否完成</div><div class=\"line\">@property (nonatomic , assign, getter=isFinished) BOOL finished;</div><div class=\"line\"></div><div class=\"line\">///以url及session下载图片</div><div class=\"line\">-(instancetype)initWithUrl:(NSString *)url session:(NSURLSession *)session;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 下载管理类 ---</div><div class=\"line\">@interface DWWebImageManager : NSObject&lt;NSCopying&gt;</div><div class=\"line\"></div><div class=\"line\">///线程字典</div><div class=\"line\">/**</div><div class=\"line\"> url为key，对应任务线程</div><div class=\"line\"> */</div><div class=\"line\">@property (nonatomic ,strong) NSMutableDictionary &lt;NSString *,DWWebImageOperation *&gt;* operations;</div><div class=\"line\"></div><div class=\"line\">///缓存管理对象</div><div class=\"line\">@property (nonatomic ,strong) DWWebImageCache * cache;</div><div class=\"line\"></div><div class=\"line\">///单例</div><div class=\"line\">+(instancetype)shareManager;</div><div class=\"line\"></div><div class=\"line\">///以url下载图片，进行回调</div><div class=\"line\">-(void)downloadImageWithUrl:(NSString *)url completion:(DWWebImageCallBack)completion;</div><div class=\"line\"></div><div class=\"line\">///以url移除下载任务</div><div class=\"line\">-(void)removeOperationByUrl:(NSString *)url;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#pragma mark --- DWWebImageOperation ---</div><div class=\"line\">@implementation DWWebImageOperation</div><div class=\"line\">@synthesize finished = _finished;</div><div class=\"line\"></div><div class=\"line\">-(instancetype)initWithUrl:(NSString *)url session:(NSURLSession *)session</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        _donwloader = [[DWWebImageDownloader alloc] initWithSession:session];</div><div class=\"line\">        [_donwloader downloadImageWithUrlString:url];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)start</div><div class=\"line\">&#123;</div><div class=\"line\">    [super start];</div><div class=\"line\">    [self.donwloader resume];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancel</div><div class=\"line\">&#123;</div><div class=\"line\">    [super cancel];</div><div class=\"line\">    [self.donwloader cancel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setFinished:(BOOL)finished &#123;</div><div class=\"line\">    [self willChangeValueForKey:@&quot;isFinished&quot;];</div><div class=\"line\">    _finished = finished;</div><div class=\"line\">    [self didChangeValueForKey:@&quot;isFinished&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- DWWebImageManager ---</div><div class=\"line\"></div><div class=\"line\">@interface DWWebImageManager ()</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSURLSession * session;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) dispatch_semaphore_t semaphore;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) NSOperationQueue * queue;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic ,strong) DWWebImageOperation * lastOperation;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation DWWebImageManager</div><div class=\"line\"></div><div class=\"line\">-(instancetype)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        self.semaphore = dispatch_semaphore_create(1);</div><div class=\"line\">        self.cache = [DWWebImageCache shareCache];</div><div class=\"line\">        self.cache.cachePolicy = DWWebImageCachePolicyDisk | DWWebImageCachePolicyMemory;</div><div class=\"line\">        [self.cache removeExpiratedCache];</div><div class=\"line\">        dispatch_async_main_safe(^()&#123;</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(cacheCompleteFinishNotice:) name:DWWebImageCacheCompleteNotification object:nil];</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downloadFinishNotice:) name:DWWebImageDownloadFinishNotification object:nil];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///下载图片</div><div class=\"line\">-(void)downloadImageWithUrl:(NSString *)url completion:(DWWebImageCallBack)completion</div><div class=\"line\">&#123;</div><div class=\"line\">    NSAssert(url.length, @&quot;url不能为空&quot;);</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        ///从缓存加载图片</div><div class=\"line\">        UIImage * image = [UIImage imageWithData:[self.cache objCacheForKey:url]];</div><div class=\"line\">        if (image) &#123;</div><div class=\"line\">            dispatch_async_main_safe(^()&#123;</div><div class=\"line\">                completion(image);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; else &#123;///无缓存</div><div class=\"line\">            dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">            DWWebImageOperation * operation = self.operations[url];///取出下载任务</div><div class=\"line\">            if (!operation) &#123;///无任务</div><div class=\"line\">                operation = [[DWWebImageOperation alloc] initWithUrl:url session:self.session];</div><div class=\"line\">                self.operations[url] = operation;</div><div class=\"line\">                if (self.lastOperation) &#123;</div><div class=\"line\">                    [self.lastOperation addDependency:operation];</div><div class=\"line\">                &#125;</div><div class=\"line\">                [self.queue addOperation:operation];</div><div class=\"line\">                self.lastOperation = operation;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!operation.donwloader.downloadFinish) &#123;</div><div class=\"line\">                [operation.donwloader.callBacks addObject:[completion copy]];</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                ///从缓存读取图片回调</div><div class=\"line\">                dispatch_async_main_safe(^()&#123;</div><div class=\"line\">                    completion(operation.donwloader.image);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            dispatch_semaphore_signal(self.semaphore);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///下载完成回调</div><div class=\"line\">-(void)downloadFinishNotice:(NSNotification *)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    NSError * error = sender.userInfo[@&quot;error&quot;];</div><div class=\"line\">    if (error) &#123;///移除任务</div><div class=\"line\">        [self removeOperationByUrl:sender.userInfo[@&quot;url&quot;]];</div><div class=\"line\">        [self removeCacheByUrl:sender.userInfo[@&quot;url&quot;]];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSString * url = sender.userInfo[@&quot;url&quot;];</div><div class=\"line\">        DWWebImageOperation * operation = self.operations[url];///取出下载任务</div><div class=\"line\">        operation.finished = YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///缓存完成通知回调</div><div class=\"line\">-(void)cacheCompleteFinishNotice:(NSNotification *)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString * url = sender.userInfo[@&quot;url&quot;];</div><div class=\"line\">    if (url.length) &#123;</div><div class=\"line\">        [self removeOperationByUrl:sender.userInfo[@&quot;url&quot;]];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///移除下载进程</div><div class=\"line\">-(void)removeOperationByUrl:(NSString *)url</div><div class=\"line\">&#123;</div><div class=\"line\">    DWWebImageOperation * operation = self.operations[url];</div><div class=\"line\">    [operation cancel];</div><div class=\"line\">    [self.operations removeObjectForKey:url];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///移除缓存</div><div class=\"line\">-(void)removeCacheByUrl:(NSString *)url</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.cache removeCacheByKey:url];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSMutableDictionary&lt;NSString *,DWWebImageOperation *&gt; *)operations</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_operations) &#123;</div><div class=\"line\">        _operations = [NSMutableDictionary dictionary];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _operations;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSURLSession *)session</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_session) &#123;</div><div class=\"line\">        NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class=\"line\">        config.timeoutIntervalForRequest = 15;</div><div class=\"line\">        _session = [NSURLSession sessionWithConfiguration:config];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _session;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSOperationQueue *)queue</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_queue) &#123;</div><div class=\"line\">        _queue = [[NSOperationQueue alloc] init];</div><div class=\"line\">        _queue.maxConcurrentOperationCount = 6;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _queue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 单例 ---</div><div class=\"line\">static DWWebImageManager * mgr = nil;</div><div class=\"line\">+(instancetype)shareManager</div><div class=\"line\">&#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        mgr = [[self alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return mgr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(instancetype)allocWithZone:(struct _NSZone *)zone</div><div class=\"line\">&#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        mgr = [super allocWithZone:zone];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return mgr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(id)copyWithZone:(NSZone *)zone</div><div class=\"line\">&#123;</div><div class=\"line\">    return mgr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<p>至此，你已经自己实现了一个异步下载类。你可以像SD一样，为UIImageView、UIButton等添加分类实现相同的效果。</p>\n<p>这个下载思路与SD大同小异，相信你自己撸一份以后对SD会有更深的理解。<br>当然SD为我们做的远不止这些，你怎么可能凭一己之力抗衡千人。有空多读读成熟的第三方代码也是对自我的锻炼与提升。</p>\n<hr>\n<p>同样的，老司机把写好的下载类同样放在了我的Git上，<a href=\"https://github.com/CodeWicky/-Tools/tree/master/DWWebImage\" target=\"_blank\" rel=\"external\">在这里</a>。</p>\n<hr>\n<p>参考资料</p>\n<ul>\n<li><p><a href=\"http://blog.csdn.net/growinggiant/article/details/50483127\" target=\"_blank\" rel=\"external\"> NSURLSessionConfiguration API详解 </a></p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/industry/20131106/7304.html\" target=\"_blank\" rel=\"external\">NSURLSession使用说明及后台工作流程分析</a></p>\n</li>\n<li><a href=\"https://github.com/rs/SDWebImage\" target=\"_blank\" rel=\"external\">SDWebImage</a></li>\n</ul>\n<hr>\n<p>你说老司机今天怎么不逗比了，人家一直是治学严谨的老学究好么！</p>\n<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1488882401345&amp;di=78cd0501c1a318d33bd98df0de28842f&amp;imgtype=0&amp;src=http%3A%2F%2Fwanzao2.b0.upaiyun.com%2Fsystem%2Fpictures%2F18747638%2Foriginal%2F80ffdf3a1ee62dac.gif\" alt=\"傲娇\"></p>\n<hr>\n<p>恩，你在忍忍，这应该是我更新前最后一次做软广了=。=</p>\n<p>DWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。</p>\n<blockquote>\n<p>version 1.1.0<br>全面支持自动链接支持、定制检测规则、图文混排、响应事件<br>优化大部分算法，提高响应效率及绘制效率</p>\n<p>version 1.1.1<br>高亮取消逻辑优化<br>自动检测逻辑优化<br>部分常用方法改为内联函数，提高运行效率</p>\n<p>version 1.1.2<br>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）</p>\n<p>version 1.1.3<br>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中</p>\n<p>version 1.1.4<br>事务管理类去除，异步绘制文件抽出</p>\n<p>version 1.1.5<br>添加网络图片异步加载库，支持绘制网络图片</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你哟\"></p>"},{"title":"老司机出品———疯狂造轮子之滑动验证码","layout":"post","date":"2017-04-17T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![滑动验证码](http://upload-images.jianshu.io/upload_images/1835430-68fa83a613cc526f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n消失了好久，大家放心，我还活着。\n要问我为什么消失了这么久，如果你知道什么叫封闭开发或许你会懂我。\n![笑不出来](http://upload-images.jianshu.io/upload_images/1835430-ea822f41d102e85b.gif?imageMogr2/auto-orient/strip)\n然而最近一直也没时间搞什么飞机，也没有什么能拿出来跟大家分享的，就把最近开发过程中写的一些小东西贴出来给大家看吧。\n因为东西比较少，而且没有什么新鲜的技术点，所以老司机先把效果图放出来，这样的话如果你不感兴趣可能看到这就够了。\n\n![[滑块验证视图,点我跳到仓库哟](https://github.com/CodeWicky/DWSlideCaptchaView)](https://github.com/CodeWicky/DWSlideCaptchaView/raw/master/%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA.gif)\n\n![[步进滑竿,点我跳到仓库哟](https://github.com/CodeWicky/Components/tree/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF)](https://github.com/CodeWicky/Components/raw/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF/%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA.gif)\n\n\n在这篇文章中，你会看到以下内容：\n- 滑动验证视图\n- 继承UIControl重新实现一个Slider\n- 步进Slider\n\n<!-- more -->\n\n- - -\n### 滑动验证视图\n\n看到这了相信你可能是对这个滑动验证有些兴趣。\n之所以写这个控件，是因为需求用到了，然而当前有没有相应的类库能让我拿来直接用。\n\n所有效果是仿照日常网页中的效果去做的，所以我们还是应该首先分析一下我们需要什么。\n\n- 首先，我们需要一张底图\n- 第二，我们要从底图上截取一小部分作为一个滑块\n- 最后，当滑块位置改变并且最终与截取的位置重合时应该验证成功\n\n需求在这了，可能唯一的技术点就在于如何截取图片了。\n\n  \n```\n#pragma mark - 截取当前image对象rect区域内的图像\n- (UIImage *)dw_SubImageWithRect:(CGRect)rect {\n    ///防止处理过image的scale不为1情况rect错误\n    CGFloat scale = self.scale;\n    CGRect scaleRect = CGRectMake(rect.origin.x * scale, rect.origin.y * scale, rect.size.width * scale, rect.size.height * scale);\n    CGImageRef newImageRef = CGImageCreateWithImageInRect(self.CGImage, scaleRect);\n    UIImage *newImage = [[UIImage imageWithCGImage:newImageRef] dw_RescaleImageToSize:rect.size];\n    CGImageRelease(newImageRef);\n    return newImage;\n}\n\n#pragma mark - 压缩图片至指定尺寸\n- (UIImage *)dw_RescaleImageToSize:(CGSize)size\n{\n    CGRect rect = (CGRect){CGPointZero, size};\n    \n    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);\n    \n    [self drawInRect:rect];\n    \n    UIImage *resImage = UIGraphicsGetImageFromCurrentImageContext();\n    \n    UIGraphicsEndImageContext();\n    \n    return resImage;\n}\n```\n\n**这些代码是老司机写在一个UIImage的category里面的，所以你应该知道所有的self都是一个UIImage实例。**恩，在这个分类里面老司机封装了很多UIImage常用的方法，如下：\n```\n///高性能按图片名称检索本地图片\n+(UIImage *)dw_ImageNamed:(NSString *)name;\n///高性能返回无延迟立即解压的图片实例\n+(UIImage *)dw_ImageWithUrl:(NSURL *)url;\n///转换图片为Base64字符串\n-(NSString *)dw_ImageToBase64String;\n///Base64转换为图片\n+ (UIImage *)dw_ImageWithBase64String:(NSString *)base64String;\n///取图片某点颜色\n-(UIColor *)dw_ColorAtPoint:(CGPoint)point;\n///按给定颜色生层图片\n+(UIImage *)dw_ImageWithColor:(UIColor *)color;\n///以灰色空间生成图片\n-(UIImage *)dw_ConvertToGrayImage;\n///生成图片的反色图片对象\n-(UIImage *)dw_ConvertToReversedColor;\n///以给定颜色生成图像剪影\n-(UIImage *)dw_ConvertToSketchWithColor:(UIColor *)color;\n///生成处理每像素颜色后的图片\n-(UIImage *)dw_ConvertImageWithPixelHandler:(void(^)(UInt8 * pixel,int x,int y))handler;\n///获取带圆角的图片\n-(UIImage *)dw_CornerRadius:(CGFloat)radius withWidth:(CGFloat)width contentMode:(DWContentMode)mode;\n///按给定path剪裁图片\n-(UIImage *)dw_ClipImageWithPath:(UIBezierPath *)path mode:(DWContentMode)mode;\n///获取旋转角度的图片\n-(UIImage *)dw_RotateImageWithAngle:(CGFloat)angle;\n///按给定的方向旋转图片\n-(UIImage*)dw_RotateWithOrient:(UIImageOrientation)orient;\n///垂直翻转\n-(UIImage *)dw_FlipVertical;\n///水平翻转\n-(UIImage *)dw_FlipHorizontal;\n///压缩图片至指定尺寸\n-(UIImage *)dw_RescaleImageToSize:(CGSize)size;\n///压缩图片至指定像素\n-(UIImage *)dw_RescaleImageToPX:(CGFloat )toPX;\n///纠正图片方向\n-(UIImage *)dw_FixOrientation;\n///截取当前image对象rect区域内的图像\n-(UIImage *)dw_SubImageWithRect:(CGRect)rect;\n///在指定的size里面生成一个平铺的图片\n-(UIImage *)dw_GetTiledImageWithSize:(CGSize)size;\n///UIView转化为UIImage\n+(UIImage *)dw_ImageFromView:(UIView *)view;\n///将两个图片生成一张图片\n+(UIImage*)dw_MergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage;\n```\n这个分类还是比较全的，老司机还是比较推荐的，给个[传送门](https://github.com/CodeWicky/-Tools/tree/master/DWImageUtils)，觉得好的话给我个star吧。\n\n所以说借助这个分类，你应该可以从一整张图片上截取一部分图片了，接下来你只需要：\n- 随意生成一个区域将它定为验证区域，并在该区域覆盖滑块形状的白色半透明的覆盖层\n- 创建一个与上面的区域形状相同的Layer，将截取好的图片赋给Layer，同时用贝塞尔曲线将Layer绘制成滑块的形状\n- 最后当验证视图滑块的位置改变至验证区域时，验证成功即可。\n\n思路比较简单，实现起来也比较简单，300多行代码，老司机就直接放全部代码了：\n\n```\n-(instancetype)initWithFrame:(CGRect)frame {\n    NSAssert((frame.size.width >= 100 && frame.size.height >= 40), @\"To get a better experience,you may set the width more than 100 and height more than 50.\");\n    if (self = [super initWithFrame:frame]) {\n        _useRandomValue = YES;\n        _targetValue = DWSlideCaptchaUndefineValue;\n        _thumbCenterY = DWSlideCaptchaUndefineValue;\n        _tolerance = DWSlideCaptchaUndefineValue;\n        _thumbSize = puzzlePath().bounds.size;\n    }\n    return self;\n}\n\n-(instancetype)initWithFrame:(CGRect)frame bgImage:(UIImage *)bgImage {\n    if (self = [self initWithFrame:frame]) {\n        [self beginConfiguration];\n        self.bgImage = bgImage;\n        [self commitConfiguration];\n    }\n    return self;\n}\n\n-(void)beginConfiguration {\n    _configurating = YES;\n    self.resetTargetPoint = YES;\n}\n\n-(void)commitConfiguration {\n    if (!self.configurating) {\n        return;\n    }\n    _configurating = NO;\n    self.layer.contents = (id)self.bgImage.CGImage;\n    [self handlePositionLayer];\n    [self handleThumbLayer];\n    [self hideThumbWithAnimated:NO];\n}\n\n-(void)reset {\n    _successed = NO;\n    [self beginConfiguration];\n    [self commitConfiguration];\n}\n\n-(void)indentifyWithAnimated:(BOOL)animated result:(void(^)(BOOL success))result {\n    BOOL isSuccess = fabs(self.targetPoint.x - self.currentPoint.x) < self.tolerance;\n    isSuccess &= fabs(self.targetPoint.y - self.currentPoint.y) < self.tolerance;\n    _successed = isSuccess;\n    _indentified = YES;\n    if (isSuccess) {\n        if (animated) {\n            if (self.delegate && [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationWillStartWithSuccess:)]) {///动画开始回调\n                [self.delegate dw_CaptchaView:self animationWillStartWithSuccess:YES];\n            }\n            if (!self.successAnimation) {///未指定动画使用默认动画\n                [self.layer addAnimation:defaultSuccessAnimaiton(self) forKey:@\"successAnimation\"];\n                [self hideThumbWithAnimated:NO];\n                DWLayerTransactionWithAnimation(NO, ^(){\n                    self.positionLayer.opacity = 0;\n                });\n            } else {///使用指定动画\n                [self.thumbLayer addAnimation:self.successAnimation forKey:@\"successAnimation\"];\n            }\n        }\n        if (result) result(YES);\n    } else {\n        if (animated) {\n            if (self.delegate && [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationWillStartWithSuccess:)]) {///动画开始回调\n                [self.delegate dw_CaptchaView:self animationWillStartWithSuccess:YES];\n            }\n            if (!self.failAnimation) {///未指定动画则使用默认动画\n                [self.thumbLayer addAnimation:defaultFailAnimation(self) forKey:@\"failAnimation\"];\n            } else {///使用指定动画\n                [self.thumbLayer addAnimation:self.failAnimation forKey:@\"failAnimation\"];\n            }\n        }\n        if (result) result(NO);\n    }\n}\n\n-(void)moveToPoint:(CGPoint)point animated:(BOOL)animated {\n    if (self.successed) {\n        return;\n    }\n    _indentified = NO;\n    point = fixPointWithLimit(point, self.validSize, self.thumbSize);\n    self.currentPoint = point;\n    if (self.thumbLayer.opacity != 1) {\n        [self showThumbWithAnimated:YES];\n    }\n    DWLayerTransactionWithAnimation(animated, ^(){\n        self.thumbLayer.position = transformLocation2Center(point, self.thumbSize);\n    });\n}\n\n-(void)setValue:(CGFloat)value animated:(BOOL)animated {\n    CGFloat x = value * self.validSize.width + self.thumbSize.width / 2;\n    CGFloat y = self.targetPoint.y + self.thumbSize.height / 2;\n    [self moveToPoint:CGPointMake(x, y) animated:animated];\n}\n\n-(void)showThumbWithAnimated:(BOOL)animated {\n    DWLayerTransactionWithAnimation(animated,^(){\n        self.thumbLayer.opacity = 1;\n    });\n}\n\n-(void)hideThumbWithAnimated:(BOOL)animated {\n    DWLayerTransactionWithAnimation(animated, ^(){\n        self.thumbLayer.opacity = 0;\n    });\n}\n\n#pragma mark --- tool Method ---\n-(void)handleThumbLayer {\n    UIImage * thumbImage = [self.bgImage dw_SubImageWithRect:self.positionLayer.frame];\n    thumbImage = [thumbImage dw_ClipImageWithPath:self.thumbShape mode:(DWContentModeScaleToFill)];\n    self.thumbLayer.contents = (id)thumbImage.CGImage;\n    self.thumbLayer.frame = self.positionLayer.frame;\n    [self setValue:0 animated:NO];\n    if (!self.thumbLayer.superlayer) {\n        [self.layer addSublayer:self.thumbLayer];\n    }\n}\n\n-(void)handlePositionLayer {\n    UIBezierPath * path = [self.thumbShape copy];\n    self.positionLayer.fillColor = [UIColor colorWithWhite:1 alpha:0.7].CGColor;\n    self.positionLayer.path = path.CGPath;\n    self.positionLayer.frame = CGRectMake(self.targetPoint.x, self.targetPoint.y, (int)path.bounds.size.width, (int)path.bounds.size.height);\n    if (!self.positionLayer.superlayer) {\n        [self.layer addSublayer:self.positionLayer];\n    }\n}\n\n#pragma mark --- animation delegate ---\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {\n    if (self.isSuccessed) {\n        if (self.delegate && [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationCompletionWithSuccess:)]) {\n            [self.delegate dw_CaptchaView:self animationCompletionWithSuccess:YES];\n        }\n    } else {\n        if (self.delegate && [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationCompletionWithSuccess:)]) {\n            [self.delegate dw_CaptchaView:self animationCompletionWithSuccess:NO];\n        }\n    }\n}\n\n#pragma mark --- 内联方法 ---\n///默认滑块形状\nstatic inline UIBezierPath * puzzlePath (){\n    UIBezierPath * path = [UIBezierPath bezierPathWithPathMaker:^(DWPathMaker *maker) {\n        maker.MoveTo(0, 8).\n        AddLineTo(12, 8).AddArcWithPoint(12, 8, 20, 8, 5, YES, YES).AddLineTo(32, 8).\n        AddLineTo(32, 20).AddArcWithPoint(32, 20, 32, 28, 5, YES, YES).AddLineTo(32, 40).\n        AddLineTo(20, 40).AddArcWithPoint(20, 40, 12, 40, 5, NO, YES).AddLineTo(0, 40).\n        AddLineTo(0, 28).AddArcWithPoint(0, 28, 0, 20, 5, NO, YES).ClosePath();\n    }];\n    return path;\n}\n\n///指定尺寸内的随机点\nstatic inline CGPoint randomPointInSize(CGSize size) {\n    CGPoint point = CGPointZero;\n    point.x = randomValueInLength((int)size.width);\n    point.y = randomValueInLength((int)size.height);\n    return point;\n}\n\n///指定范围内的随机值\nstatic inline int randomValueInLength(int length) {\n    return arc4random() % ((int)(length + 1));\n}\n\n///修正centerY值合适的值\nstatic inline CGFloat fixCenterYWithSize(CGSize thumbSize,CGSize validSize,CGFloat centerY) {\n    CGFloat y = centerY - thumbSize.height / 2;\n    return fixValueWithLimit(y, validSize.height);\n}\n\n///将值修正至指定范围\nstatic inline CGFloat fixValueWithLimit(CGFloat value,CGFloat limitLength) {\n    return value < 0 ? 0 : (value > limitLength ? limitLength : value);\n}\n\n///将点修正值有效范围内\nstatic inline CGPoint fixPointWithLimit(CGPoint point,CGSize validSize,CGSize thumbSize) {\n    CGFloat x = point.x - thumbSize.width / 2;\n    CGFloat y = point.y - thumbSize.height / 2;\n    return CGPointMake(fixValueWithLimit(x, validSize.width), fixValueWithLimit(y, validSize.height));\n}\n\n///将验证位置转换为layer中心点\nstatic inline CGPoint transformLocation2Center(CGPoint origin,CGSize thumbSize) {\n    return CGPointMake(origin.x + thumbSize.width / 2, origin.y + thumbSize.height / 2);\n}\n\n///Point转value\nstatic inline NSValue * valueOfPoint(CGPoint point) {\n    return [NSValue valueWithCGPoint:point];\n}\n\n///默认成功动画\nstatic inline CAAnimation * defaultSuccessAnimaiton(id<CAAnimationDelegate> delegate) {\n    CABasicAnimation * animation = [CABasicAnimation animationWithKeyPath:@\"opacity\"];\n    animation.duration = 0.2;\n    animation.autoreverses = YES;\n    animation.fromValue = @1;\n    animation.toValue = @0;\n    animation.removedOnCompletion = YES;\n    animation.delegate = delegate;\n    return animation;\n}\n\n///默认失败动画\nstatic inline CAAnimation * defaultFailAnimation(id<CAAnimationDelegate> delegate) {\n    DWSlideCaptchaView * captcha = (DWSlideCaptchaView *)delegate;\n    CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    CGFloat a = 3;\n    CGPoint Cp = captcha.thumbLayer.position;\n    CGPoint Lp = CGPointMake(Cp.x - a, Cp.y);\n    CGPoint Rp = CGPointMake(Cp.x + a, Cp.y);\n    animation.values = @[valueOfPoint(Cp),valueOfPoint(Lp),valueOfPoint(Rp),valueOfPoint(Cp)];\n    animation.repeatCount = 2;\n    animation.removedOnCompletion = YES;\n    animation.duration = 0.2;\n    animation.delegate = captcha;\n    return animation;\n}\n\n#pragma mark --- setter/getter ---\n-(CAShapeLayer *)positionLayer {\n    if (!_positionLayer) {\n        _positionLayer = [CAShapeLayer layer];\n    }\n    return _positionLayer;\n}\n\n-(CAShapeLayer *)thumbLayer {\n    if (!_thumbLayer) {\n        _thumbLayer = [CAShapeLayer layer];\n    }\n    return _thumbLayer;\n}\n\n-(void)setThumbShape:(UIBezierPath *)thumbShape {\n    SafeConfiguration\n    CGSize size = thumbShape.bounds.size;\n    if (!(size.width >= 40 && size.height >= 40)) {\n        NSAssert(NO, @\"To get a better experience,the width and height of thumbShape both should be more than 40.\");\n        return;\n    }\n    \n    _thumbShape = thumbShape;\n    _thumbSize = size;\n}\n\n-(UIBezierPath *)thumbShape {\n    if (!_thumbShape) {\n        return puzzlePath();\n    }\n    return _thumbShape;\n}\n\n-(void)setTargetValue:(CGFloat)targetValue {\n    SafeConfiguration\n    _targetValue = fixValueWithLimit(targetValue, 1);\n}\n\n-(void)setThumbCenterY:(CGFloat)thumbCenterY {\n    SafeConfiguration\n    _thumbCenterY = thumbCenterY;\n}\n\n-(void)setUseRandomValue:(BOOL)useRandomValue {\n    SafeConfiguration\n    _useRandomValue = useRandomValue;\n}\n\n-(void)setTolerance:(CGFloat)tolerance {\n    SafeConfiguration\n    _tolerance = tolerance;\n}\n\n-(CGFloat)tolerance {\n    if (_tolerance < 0) {\n        return 3;\n    }\n    return _tolerance;\n}\n\n-(void)setSuccessAnimation:(CAAnimation *)successAnimation {\n    SafeConfiguration\n    _successAnimation = successAnimation;\n    _successAnimation.delegate = self;\n}\n\n-(void)setFailAnimation:(CAAnimation *)failAnimation {\n    SafeConfiguration\n    _failAnimation = failAnimation;\n    _failAnimation.delegate = self;\n}\n\n-(void)setBgImage:(UIImage *)bgImage {\n    SafeConfiguration\n    if (bgImage) {\n        _bgImage = [bgImage dw_RescaleImageToSize:self.frame.size];\n    } else {\n        _bgImage = nil;\n    }\n}\n\n-(void)setThumbSize:(CGSize)thumbSize {\n    SafeConfiguration\n    if (!CGSizeEqualToSize(_thumbSize, thumbSize)) {\n        _thumbSize = thumbSize;\n    }\n}\n\n-(CGPoint)targetPoint {\n    if (!self.resetTargetPoint) {\n        return _targetPoint;\n    }\n    self.resetTargetPoint = NO;\n    if (self.useRandomValue) {\n        _targetPoint = randomPointInSize(self.validSize);\n        return _targetPoint;\n    }\n    CGFloat x = (self.targetValue != DWSlideCaptchaUndefineValue) ? self.targetValue : randomValueInLength((int)self.validSize.width);\n    CGFloat y = (self.thumbCenterY != DWSlideCaptchaUndefineValue) ? fixCenterYWithSize(self.thumbSize, self.validSize, self.thumbCenterY) : randomValueInLength((int)self.validSize.height);\n    _targetPoint = CGPointMake(x, y);\n    return _targetPoint;\n}\n\n-(CGSize)validSize {\n    return CGSizeMake(self.bounds.size.width - self.thumbSize.width, self.bounds.size.height - self.thumbSize.height);\n}\n```\n\n恩，这个库老司机不仅上传到GitHub上面，还让他支持了Cocoapods，你可以通过 ` pod 'DWSlideCaptchaView', '~> 1.0.2'`来集成这个视图，觉得好请Star。\n\n说到这里老司机说一下，现在你可以通过`pod search wicky`命令搜索老司机上传到Cocoapods上面的类库，目前有三个：\n\n![当前支持Cocoapods的库](http://upload-images.jianshu.io/upload_images/1835430-03eb96944d07d1fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n老司机这里还是主推DWCoreTextLabel，他是一个基于CoreText的异步绘制的图文混排控件，并且支持图片的异步加载与缓存，基本上可以完美的实现图文混排需求。你值得使用。\n\nDWCheckBox就是单选复选框了，也是一个快捷使用并且有着高定制型的类库。\n\n- - -\n### 继承UIControl重新实现一个Slider\n\n广告打完了咱们来看第二环节，slider。\n最初的时候其实我就是想实现后面那个步进Slider，最初的想法继承UISlider去重写，奈何转了一大圈，各种私有属性用一遍也无法完美的完成我的需求。\n\n主要是由于UISlider中对于滑块和滑竿的定制性很困难，所以自己重写一个Slider吧。\n\n所以为什么想到继承自UIControl去写呢？第一是UISlider继承自UIControl，第二是UIControl封装了`-addTarget:selector:events`以及事件追踪的一系列方法。\n\n其实UIControl有四个核心的方法，是用于控制事件追踪的。\n```\n///判断是否开始事件追踪\n-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;\n///判断事件追踪是否继续\n-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;\n///事件追踪取消时处理\n-(void)cancelTrackingWithEvent:(UIEvent *)event;\n///事件追踪结束时处理\n-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;\n```\n使用方法无非就是判断当视图接收到事件是如何追踪，可以看一下老司机写Slider的处理。\n```\n#pragma mark --- tracking Method ---\n-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:self];\n    location = [self.thumbLayer convertPoint:location fromLayer:self.layer];\n    if ([PathWithBounds(self.thumbLayer.bounds, FitCornerRadius(self.thumbLayer, self.thumbCornerRadius)) containsPoint:location]) {\n        self.clickOnThumb = YES;\n        return YES;\n    }\n    location = [self.trackBgLayer convertPoint:location fromLayer:self.thumbLayer];\n    if ([PathWithBounds(self.trackBgLayer.bounds, FitCornerRadius(self.trackBgLayer, self.trackCornerRadius)) containsPoint:location]) {\n        self.clickOnThumb = NO;\n        return YES;\n    }\n    return NO;\n}\n\n-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:self];\n    CGFloat margin = FitMarginForThumb(self.thumbSize, [self thumbMarginForBounds:self.bounds]);\n    location.x -= margin;\n    CGFloat actualW = CGRectGetWidth([self trackRectForBounds:self.bounds]) - margin * 2;\n    if (location.x < 0) {\n        location.x = 0;\n    } else if (location.x > actualW) {\n        location.x = actualW;\n    }\n    CGFloat percent = location.x / actualW;\n    CGFloat value = self.minimumValue + (self.maximumValue - self.minimumValue) * percent;\n    if (value == self.value) {\n        return YES;\n    }\n    _value = value;\n    [self sendActionsForControlEvents:UIControlEventValueChanged];\n    if (self.clickOnThumb) {\n        [self updateValueAnimated:NO];\n        return YES;\n    } else {\n        [self updateValueAnimated:YES];\n        self.clickOnThumb = NO;\n        return NO;\n    }\n}\n\n-(void)cancelTrackingWithEvent:(UIEvent *)event {\n    self.clickOnThumb = NO;\n}\n\n-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    self.clickOnThumb = NO;\n}\n```\n\n处理过事件追踪，我们只要处理好视图相关的内容即可。\n\n此处可以分为两种思路，一种是通过DrawRect方法去追踪行为后不断绘制，另一种是通过Layer展示各个图层并追踪行为。这里呢，老司机更加推荐使用Layer去处理图层，因为本身DrawRect方法中的代码是使用CPU进行预算然后将bitmap提交给GPU，他处理绘制的速度远不如CALayer直接使用GPU来的快。\n\n图层的绘制老司机在CoreAnimation系列中已经写得很细了，在这也就不多写了。\n老司机重写的DWSlider是一个UISlider的替换类，它具备UISlider的所有功能，并且还能自由定制你的Slider的各个属性，相比UISlider来讲可玩性更强，老司机这里放一个[传送门](https://github.com/CodeWicky/-Tools/tree/master/DWSlider)。\n\n- - -\n### 步进Slider\nDWStepSlider是一个分段的Slider，继承自DWSlider。\n主要是实现分段的Slider至实现，主要思想还是通过更改事件追踪后的赋值。\n\n```\n#pragma mark --- tracking Method ---\n-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:self];\n    location = [self.thumbLayer convertPoint:location fromLayer:self.layer];\n    if ([PathWithBounds(self.thumbLayer.bounds, FitCornerRadius(self.thumbLayer, self.thumbCornerRadius)) containsPoint:location]) {\n        self.clickOnThumb = YES;\n        return YES;\n    }\n    location = [self.trackBgLayer convertPoint:location fromLayer:self.thumbLayer];\n    if ([PathWithBounds(self.trackBgLayer.bounds, FitCornerRadius(self.trackBgLayer, self.trackCornerRadius)) containsPoint:location]) {\n        self.clickOnThumb = NO;\n        return YES;\n    }\n    return NO;\n}\n\n-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:self];\n    CGFloat margin = FitMarginForThumb(self.thumbSize, [self thumbMarginForBounds:self.bounds]);\n    location.x -= margin;\n    CGFloat actualW = CGRectGetWidth([self trackRectForBounds:self.bounds]) - margin * 2;\n    if (location.x < 0) {\n        location.x = 0;\n    } else if (location.x > actualW) {\n        location.x = actualW;\n    }\n    CGFloat percent = location.x / actualW;\n    CGFloat value = self.minimumValue + (self.maximumValue - self.minimumValue) * percent;\n    if (value == self.value) {\n        return YES;\n    }\n    [self setValue:value updateThumb:NO];\n    [self sendActionsForControlEvents:UIControlEventValueChanged];\n    if (self.clickOnThumb) {\n        [self updateValueAnimated:NO];\n        return YES;\n    } else {\n        [self setValue:FixValue(value, _nodes.count) updateThumb:NO];\n        [self updateValueAnimated:YES];\n        return NO;\n    }\n}\n\n-(void)cancelTrackingWithEvent:(UIEvent *)event {\n    if (self.clickOnThumb) {\n        self.value = FixValue(self.value, _nodes.count);\n        self.clickOnThumb = NO;\n    }\n}\n\n-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    if (self.clickOnThumb) {\n        self.value = FixValue(self.value, _nodes.count);\n        self.clickOnThumb = NO;\n    }\n}\n```\n至于图形还是CAShapeLayer的各种形状，老司机也早就说过了，还是[传送门](https://github.com/CodeWicky/Components/blob/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF)吧。\n- - -\n好吧，今天其实也没什么新鲜内容，毕竟都是一些UI控件的封装。\n不过也是捋一下思路，控件要如何封装，所以还是不要脸的发出来了。\n喜欢哪个给哪个**Star**吧~恩，就是这么好意思~\n![图文无关](http://upload-images.jianshu.io/upload_images/1835430-1f4614d93cbc24e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/老司机出品———疯狂造轮子之滑动验证码.md","raw":"\n---\ntitle: 老司机出品———疯狂造轮子之滑动验证码\nlayout: post\ndate: 2017-04-18 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- 滑动验证码\ncategories: 疯狂造轮子\n---\n\n![滑动验证码](http://upload-images.jianshu.io/upload_images/1835430-68fa83a613cc526f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n消失了好久，大家放心，我还活着。\n要问我为什么消失了这么久，如果你知道什么叫封闭开发或许你会懂我。\n![笑不出来](http://upload-images.jianshu.io/upload_images/1835430-ea822f41d102e85b.gif?imageMogr2/auto-orient/strip)\n然而最近一直也没时间搞什么飞机，也没有什么能拿出来跟大家分享的，就把最近开发过程中写的一些小东西贴出来给大家看吧。\n因为东西比较少，而且没有什么新鲜的技术点，所以老司机先把效果图放出来，这样的话如果你不感兴趣可能看到这就够了。\n\n![[滑块验证视图,点我跳到仓库哟](https://github.com/CodeWicky/DWSlideCaptchaView)](https://github.com/CodeWicky/DWSlideCaptchaView/raw/master/%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA.gif)\n\n![[步进滑竿,点我跳到仓库哟](https://github.com/CodeWicky/Components/tree/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF)](https://github.com/CodeWicky/Components/raw/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF/%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA.gif)\n\n\n在这篇文章中，你会看到以下内容：\n- 滑动验证视图\n- 继承UIControl重新实现一个Slider\n- 步进Slider\n\n<!-- more -->\n\n- - -\n### 滑动验证视图\n\n看到这了相信你可能是对这个滑动验证有些兴趣。\n之所以写这个控件，是因为需求用到了，然而当前有没有相应的类库能让我拿来直接用。\n\n所有效果是仿照日常网页中的效果去做的，所以我们还是应该首先分析一下我们需要什么。\n\n- 首先，我们需要一张底图\n- 第二，我们要从底图上截取一小部分作为一个滑块\n- 最后，当滑块位置改变并且最终与截取的位置重合时应该验证成功\n\n需求在这了，可能唯一的技术点就在于如何截取图片了。\n\n  \n```\n#pragma mark - 截取当前image对象rect区域内的图像\n- (UIImage *)dw_SubImageWithRect:(CGRect)rect {\n    ///防止处理过image的scale不为1情况rect错误\n    CGFloat scale = self.scale;\n    CGRect scaleRect = CGRectMake(rect.origin.x * scale, rect.origin.y * scale, rect.size.width * scale, rect.size.height * scale);\n    CGImageRef newImageRef = CGImageCreateWithImageInRect(self.CGImage, scaleRect);\n    UIImage *newImage = [[UIImage imageWithCGImage:newImageRef] dw_RescaleImageToSize:rect.size];\n    CGImageRelease(newImageRef);\n    return newImage;\n}\n\n#pragma mark - 压缩图片至指定尺寸\n- (UIImage *)dw_RescaleImageToSize:(CGSize)size\n{\n    CGRect rect = (CGRect){CGPointZero, size};\n    \n    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);\n    \n    [self drawInRect:rect];\n    \n    UIImage *resImage = UIGraphicsGetImageFromCurrentImageContext();\n    \n    UIGraphicsEndImageContext();\n    \n    return resImage;\n}\n```\n\n**这些代码是老司机写在一个UIImage的category里面的，所以你应该知道所有的self都是一个UIImage实例。**恩，在这个分类里面老司机封装了很多UIImage常用的方法，如下：\n```\n///高性能按图片名称检索本地图片\n+(UIImage *)dw_ImageNamed:(NSString *)name;\n///高性能返回无延迟立即解压的图片实例\n+(UIImage *)dw_ImageWithUrl:(NSURL *)url;\n///转换图片为Base64字符串\n-(NSString *)dw_ImageToBase64String;\n///Base64转换为图片\n+ (UIImage *)dw_ImageWithBase64String:(NSString *)base64String;\n///取图片某点颜色\n-(UIColor *)dw_ColorAtPoint:(CGPoint)point;\n///按给定颜色生层图片\n+(UIImage *)dw_ImageWithColor:(UIColor *)color;\n///以灰色空间生成图片\n-(UIImage *)dw_ConvertToGrayImage;\n///生成图片的反色图片对象\n-(UIImage *)dw_ConvertToReversedColor;\n///以给定颜色生成图像剪影\n-(UIImage *)dw_ConvertToSketchWithColor:(UIColor *)color;\n///生成处理每像素颜色后的图片\n-(UIImage *)dw_ConvertImageWithPixelHandler:(void(^)(UInt8 * pixel,int x,int y))handler;\n///获取带圆角的图片\n-(UIImage *)dw_CornerRadius:(CGFloat)radius withWidth:(CGFloat)width contentMode:(DWContentMode)mode;\n///按给定path剪裁图片\n-(UIImage *)dw_ClipImageWithPath:(UIBezierPath *)path mode:(DWContentMode)mode;\n///获取旋转角度的图片\n-(UIImage *)dw_RotateImageWithAngle:(CGFloat)angle;\n///按给定的方向旋转图片\n-(UIImage*)dw_RotateWithOrient:(UIImageOrientation)orient;\n///垂直翻转\n-(UIImage *)dw_FlipVertical;\n///水平翻转\n-(UIImage *)dw_FlipHorizontal;\n///压缩图片至指定尺寸\n-(UIImage *)dw_RescaleImageToSize:(CGSize)size;\n///压缩图片至指定像素\n-(UIImage *)dw_RescaleImageToPX:(CGFloat )toPX;\n///纠正图片方向\n-(UIImage *)dw_FixOrientation;\n///截取当前image对象rect区域内的图像\n-(UIImage *)dw_SubImageWithRect:(CGRect)rect;\n///在指定的size里面生成一个平铺的图片\n-(UIImage *)dw_GetTiledImageWithSize:(CGSize)size;\n///UIView转化为UIImage\n+(UIImage *)dw_ImageFromView:(UIView *)view;\n///将两个图片生成一张图片\n+(UIImage*)dw_MergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage;\n```\n这个分类还是比较全的，老司机还是比较推荐的，给个[传送门](https://github.com/CodeWicky/-Tools/tree/master/DWImageUtils)，觉得好的话给我个star吧。\n\n所以说借助这个分类，你应该可以从一整张图片上截取一部分图片了，接下来你只需要：\n- 随意生成一个区域将它定为验证区域，并在该区域覆盖滑块形状的白色半透明的覆盖层\n- 创建一个与上面的区域形状相同的Layer，将截取好的图片赋给Layer，同时用贝塞尔曲线将Layer绘制成滑块的形状\n- 最后当验证视图滑块的位置改变至验证区域时，验证成功即可。\n\n思路比较简单，实现起来也比较简单，300多行代码，老司机就直接放全部代码了：\n\n```\n-(instancetype)initWithFrame:(CGRect)frame {\n    NSAssert((frame.size.width >= 100 && frame.size.height >= 40), @\"To get a better experience,you may set the width more than 100 and height more than 50.\");\n    if (self = [super initWithFrame:frame]) {\n        _useRandomValue = YES;\n        _targetValue = DWSlideCaptchaUndefineValue;\n        _thumbCenterY = DWSlideCaptchaUndefineValue;\n        _tolerance = DWSlideCaptchaUndefineValue;\n        _thumbSize = puzzlePath().bounds.size;\n    }\n    return self;\n}\n\n-(instancetype)initWithFrame:(CGRect)frame bgImage:(UIImage *)bgImage {\n    if (self = [self initWithFrame:frame]) {\n        [self beginConfiguration];\n        self.bgImage = bgImage;\n        [self commitConfiguration];\n    }\n    return self;\n}\n\n-(void)beginConfiguration {\n    _configurating = YES;\n    self.resetTargetPoint = YES;\n}\n\n-(void)commitConfiguration {\n    if (!self.configurating) {\n        return;\n    }\n    _configurating = NO;\n    self.layer.contents = (id)self.bgImage.CGImage;\n    [self handlePositionLayer];\n    [self handleThumbLayer];\n    [self hideThumbWithAnimated:NO];\n}\n\n-(void)reset {\n    _successed = NO;\n    [self beginConfiguration];\n    [self commitConfiguration];\n}\n\n-(void)indentifyWithAnimated:(BOOL)animated result:(void(^)(BOOL success))result {\n    BOOL isSuccess = fabs(self.targetPoint.x - self.currentPoint.x) < self.tolerance;\n    isSuccess &= fabs(self.targetPoint.y - self.currentPoint.y) < self.tolerance;\n    _successed = isSuccess;\n    _indentified = YES;\n    if (isSuccess) {\n        if (animated) {\n            if (self.delegate && [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationWillStartWithSuccess:)]) {///动画开始回调\n                [self.delegate dw_CaptchaView:self animationWillStartWithSuccess:YES];\n            }\n            if (!self.successAnimation) {///未指定动画使用默认动画\n                [self.layer addAnimation:defaultSuccessAnimaiton(self) forKey:@\"successAnimation\"];\n                [self hideThumbWithAnimated:NO];\n                DWLayerTransactionWithAnimation(NO, ^(){\n                    self.positionLayer.opacity = 0;\n                });\n            } else {///使用指定动画\n                [self.thumbLayer addAnimation:self.successAnimation forKey:@\"successAnimation\"];\n            }\n        }\n        if (result) result(YES);\n    } else {\n        if (animated) {\n            if (self.delegate && [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationWillStartWithSuccess:)]) {///动画开始回调\n                [self.delegate dw_CaptchaView:self animationWillStartWithSuccess:YES];\n            }\n            if (!self.failAnimation) {///未指定动画则使用默认动画\n                [self.thumbLayer addAnimation:defaultFailAnimation(self) forKey:@\"failAnimation\"];\n            } else {///使用指定动画\n                [self.thumbLayer addAnimation:self.failAnimation forKey:@\"failAnimation\"];\n            }\n        }\n        if (result) result(NO);\n    }\n}\n\n-(void)moveToPoint:(CGPoint)point animated:(BOOL)animated {\n    if (self.successed) {\n        return;\n    }\n    _indentified = NO;\n    point = fixPointWithLimit(point, self.validSize, self.thumbSize);\n    self.currentPoint = point;\n    if (self.thumbLayer.opacity != 1) {\n        [self showThumbWithAnimated:YES];\n    }\n    DWLayerTransactionWithAnimation(animated, ^(){\n        self.thumbLayer.position = transformLocation2Center(point, self.thumbSize);\n    });\n}\n\n-(void)setValue:(CGFloat)value animated:(BOOL)animated {\n    CGFloat x = value * self.validSize.width + self.thumbSize.width / 2;\n    CGFloat y = self.targetPoint.y + self.thumbSize.height / 2;\n    [self moveToPoint:CGPointMake(x, y) animated:animated];\n}\n\n-(void)showThumbWithAnimated:(BOOL)animated {\n    DWLayerTransactionWithAnimation(animated,^(){\n        self.thumbLayer.opacity = 1;\n    });\n}\n\n-(void)hideThumbWithAnimated:(BOOL)animated {\n    DWLayerTransactionWithAnimation(animated, ^(){\n        self.thumbLayer.opacity = 0;\n    });\n}\n\n#pragma mark --- tool Method ---\n-(void)handleThumbLayer {\n    UIImage * thumbImage = [self.bgImage dw_SubImageWithRect:self.positionLayer.frame];\n    thumbImage = [thumbImage dw_ClipImageWithPath:self.thumbShape mode:(DWContentModeScaleToFill)];\n    self.thumbLayer.contents = (id)thumbImage.CGImage;\n    self.thumbLayer.frame = self.positionLayer.frame;\n    [self setValue:0 animated:NO];\n    if (!self.thumbLayer.superlayer) {\n        [self.layer addSublayer:self.thumbLayer];\n    }\n}\n\n-(void)handlePositionLayer {\n    UIBezierPath * path = [self.thumbShape copy];\n    self.positionLayer.fillColor = [UIColor colorWithWhite:1 alpha:0.7].CGColor;\n    self.positionLayer.path = path.CGPath;\n    self.positionLayer.frame = CGRectMake(self.targetPoint.x, self.targetPoint.y, (int)path.bounds.size.width, (int)path.bounds.size.height);\n    if (!self.positionLayer.superlayer) {\n        [self.layer addSublayer:self.positionLayer];\n    }\n}\n\n#pragma mark --- animation delegate ---\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {\n    if (self.isSuccessed) {\n        if (self.delegate && [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationCompletionWithSuccess:)]) {\n            [self.delegate dw_CaptchaView:self animationCompletionWithSuccess:YES];\n        }\n    } else {\n        if (self.delegate && [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationCompletionWithSuccess:)]) {\n            [self.delegate dw_CaptchaView:self animationCompletionWithSuccess:NO];\n        }\n    }\n}\n\n#pragma mark --- 内联方法 ---\n///默认滑块形状\nstatic inline UIBezierPath * puzzlePath (){\n    UIBezierPath * path = [UIBezierPath bezierPathWithPathMaker:^(DWPathMaker *maker) {\n        maker.MoveTo(0, 8).\n        AddLineTo(12, 8).AddArcWithPoint(12, 8, 20, 8, 5, YES, YES).AddLineTo(32, 8).\n        AddLineTo(32, 20).AddArcWithPoint(32, 20, 32, 28, 5, YES, YES).AddLineTo(32, 40).\n        AddLineTo(20, 40).AddArcWithPoint(20, 40, 12, 40, 5, NO, YES).AddLineTo(0, 40).\n        AddLineTo(0, 28).AddArcWithPoint(0, 28, 0, 20, 5, NO, YES).ClosePath();\n    }];\n    return path;\n}\n\n///指定尺寸内的随机点\nstatic inline CGPoint randomPointInSize(CGSize size) {\n    CGPoint point = CGPointZero;\n    point.x = randomValueInLength((int)size.width);\n    point.y = randomValueInLength((int)size.height);\n    return point;\n}\n\n///指定范围内的随机值\nstatic inline int randomValueInLength(int length) {\n    return arc4random() % ((int)(length + 1));\n}\n\n///修正centerY值合适的值\nstatic inline CGFloat fixCenterYWithSize(CGSize thumbSize,CGSize validSize,CGFloat centerY) {\n    CGFloat y = centerY - thumbSize.height / 2;\n    return fixValueWithLimit(y, validSize.height);\n}\n\n///将值修正至指定范围\nstatic inline CGFloat fixValueWithLimit(CGFloat value,CGFloat limitLength) {\n    return value < 0 ? 0 : (value > limitLength ? limitLength : value);\n}\n\n///将点修正值有效范围内\nstatic inline CGPoint fixPointWithLimit(CGPoint point,CGSize validSize,CGSize thumbSize) {\n    CGFloat x = point.x - thumbSize.width / 2;\n    CGFloat y = point.y - thumbSize.height / 2;\n    return CGPointMake(fixValueWithLimit(x, validSize.width), fixValueWithLimit(y, validSize.height));\n}\n\n///将验证位置转换为layer中心点\nstatic inline CGPoint transformLocation2Center(CGPoint origin,CGSize thumbSize) {\n    return CGPointMake(origin.x + thumbSize.width / 2, origin.y + thumbSize.height / 2);\n}\n\n///Point转value\nstatic inline NSValue * valueOfPoint(CGPoint point) {\n    return [NSValue valueWithCGPoint:point];\n}\n\n///默认成功动画\nstatic inline CAAnimation * defaultSuccessAnimaiton(id<CAAnimationDelegate> delegate) {\n    CABasicAnimation * animation = [CABasicAnimation animationWithKeyPath:@\"opacity\"];\n    animation.duration = 0.2;\n    animation.autoreverses = YES;\n    animation.fromValue = @1;\n    animation.toValue = @0;\n    animation.removedOnCompletion = YES;\n    animation.delegate = delegate;\n    return animation;\n}\n\n///默认失败动画\nstatic inline CAAnimation * defaultFailAnimation(id<CAAnimationDelegate> delegate) {\n    DWSlideCaptchaView * captcha = (DWSlideCaptchaView *)delegate;\n    CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    CGFloat a = 3;\n    CGPoint Cp = captcha.thumbLayer.position;\n    CGPoint Lp = CGPointMake(Cp.x - a, Cp.y);\n    CGPoint Rp = CGPointMake(Cp.x + a, Cp.y);\n    animation.values = @[valueOfPoint(Cp),valueOfPoint(Lp),valueOfPoint(Rp),valueOfPoint(Cp)];\n    animation.repeatCount = 2;\n    animation.removedOnCompletion = YES;\n    animation.duration = 0.2;\n    animation.delegate = captcha;\n    return animation;\n}\n\n#pragma mark --- setter/getter ---\n-(CAShapeLayer *)positionLayer {\n    if (!_positionLayer) {\n        _positionLayer = [CAShapeLayer layer];\n    }\n    return _positionLayer;\n}\n\n-(CAShapeLayer *)thumbLayer {\n    if (!_thumbLayer) {\n        _thumbLayer = [CAShapeLayer layer];\n    }\n    return _thumbLayer;\n}\n\n-(void)setThumbShape:(UIBezierPath *)thumbShape {\n    SafeConfiguration\n    CGSize size = thumbShape.bounds.size;\n    if (!(size.width >= 40 && size.height >= 40)) {\n        NSAssert(NO, @\"To get a better experience,the width and height of thumbShape both should be more than 40.\");\n        return;\n    }\n    \n    _thumbShape = thumbShape;\n    _thumbSize = size;\n}\n\n-(UIBezierPath *)thumbShape {\n    if (!_thumbShape) {\n        return puzzlePath();\n    }\n    return _thumbShape;\n}\n\n-(void)setTargetValue:(CGFloat)targetValue {\n    SafeConfiguration\n    _targetValue = fixValueWithLimit(targetValue, 1);\n}\n\n-(void)setThumbCenterY:(CGFloat)thumbCenterY {\n    SafeConfiguration\n    _thumbCenterY = thumbCenterY;\n}\n\n-(void)setUseRandomValue:(BOOL)useRandomValue {\n    SafeConfiguration\n    _useRandomValue = useRandomValue;\n}\n\n-(void)setTolerance:(CGFloat)tolerance {\n    SafeConfiguration\n    _tolerance = tolerance;\n}\n\n-(CGFloat)tolerance {\n    if (_tolerance < 0) {\n        return 3;\n    }\n    return _tolerance;\n}\n\n-(void)setSuccessAnimation:(CAAnimation *)successAnimation {\n    SafeConfiguration\n    _successAnimation = successAnimation;\n    _successAnimation.delegate = self;\n}\n\n-(void)setFailAnimation:(CAAnimation *)failAnimation {\n    SafeConfiguration\n    _failAnimation = failAnimation;\n    _failAnimation.delegate = self;\n}\n\n-(void)setBgImage:(UIImage *)bgImage {\n    SafeConfiguration\n    if (bgImage) {\n        _bgImage = [bgImage dw_RescaleImageToSize:self.frame.size];\n    } else {\n        _bgImage = nil;\n    }\n}\n\n-(void)setThumbSize:(CGSize)thumbSize {\n    SafeConfiguration\n    if (!CGSizeEqualToSize(_thumbSize, thumbSize)) {\n        _thumbSize = thumbSize;\n    }\n}\n\n-(CGPoint)targetPoint {\n    if (!self.resetTargetPoint) {\n        return _targetPoint;\n    }\n    self.resetTargetPoint = NO;\n    if (self.useRandomValue) {\n        _targetPoint = randomPointInSize(self.validSize);\n        return _targetPoint;\n    }\n    CGFloat x = (self.targetValue != DWSlideCaptchaUndefineValue) ? self.targetValue : randomValueInLength((int)self.validSize.width);\n    CGFloat y = (self.thumbCenterY != DWSlideCaptchaUndefineValue) ? fixCenterYWithSize(self.thumbSize, self.validSize, self.thumbCenterY) : randomValueInLength((int)self.validSize.height);\n    _targetPoint = CGPointMake(x, y);\n    return _targetPoint;\n}\n\n-(CGSize)validSize {\n    return CGSizeMake(self.bounds.size.width - self.thumbSize.width, self.bounds.size.height - self.thumbSize.height);\n}\n```\n\n恩，这个库老司机不仅上传到GitHub上面，还让他支持了Cocoapods，你可以通过 ` pod 'DWSlideCaptchaView', '~> 1.0.2'`来集成这个视图，觉得好请Star。\n\n说到这里老司机说一下，现在你可以通过`pod search wicky`命令搜索老司机上传到Cocoapods上面的类库，目前有三个：\n\n![当前支持Cocoapods的库](http://upload-images.jianshu.io/upload_images/1835430-03eb96944d07d1fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n老司机这里还是主推DWCoreTextLabel，他是一个基于CoreText的异步绘制的图文混排控件，并且支持图片的异步加载与缓存，基本上可以完美的实现图文混排需求。你值得使用。\n\nDWCheckBox就是单选复选框了，也是一个快捷使用并且有着高定制型的类库。\n\n- - -\n### 继承UIControl重新实现一个Slider\n\n广告打完了咱们来看第二环节，slider。\n最初的时候其实我就是想实现后面那个步进Slider，最初的想法继承UISlider去重写，奈何转了一大圈，各种私有属性用一遍也无法完美的完成我的需求。\n\n主要是由于UISlider中对于滑块和滑竿的定制性很困难，所以自己重写一个Slider吧。\n\n所以为什么想到继承自UIControl去写呢？第一是UISlider继承自UIControl，第二是UIControl封装了`-addTarget:selector:events`以及事件追踪的一系列方法。\n\n其实UIControl有四个核心的方法，是用于控制事件追踪的。\n```\n///判断是否开始事件追踪\n-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;\n///判断事件追踪是否继续\n-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;\n///事件追踪取消时处理\n-(void)cancelTrackingWithEvent:(UIEvent *)event;\n///事件追踪结束时处理\n-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;\n```\n使用方法无非就是判断当视图接收到事件是如何追踪，可以看一下老司机写Slider的处理。\n```\n#pragma mark --- tracking Method ---\n-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:self];\n    location = [self.thumbLayer convertPoint:location fromLayer:self.layer];\n    if ([PathWithBounds(self.thumbLayer.bounds, FitCornerRadius(self.thumbLayer, self.thumbCornerRadius)) containsPoint:location]) {\n        self.clickOnThumb = YES;\n        return YES;\n    }\n    location = [self.trackBgLayer convertPoint:location fromLayer:self.thumbLayer];\n    if ([PathWithBounds(self.trackBgLayer.bounds, FitCornerRadius(self.trackBgLayer, self.trackCornerRadius)) containsPoint:location]) {\n        self.clickOnThumb = NO;\n        return YES;\n    }\n    return NO;\n}\n\n-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:self];\n    CGFloat margin = FitMarginForThumb(self.thumbSize, [self thumbMarginForBounds:self.bounds]);\n    location.x -= margin;\n    CGFloat actualW = CGRectGetWidth([self trackRectForBounds:self.bounds]) - margin * 2;\n    if (location.x < 0) {\n        location.x = 0;\n    } else if (location.x > actualW) {\n        location.x = actualW;\n    }\n    CGFloat percent = location.x / actualW;\n    CGFloat value = self.minimumValue + (self.maximumValue - self.minimumValue) * percent;\n    if (value == self.value) {\n        return YES;\n    }\n    _value = value;\n    [self sendActionsForControlEvents:UIControlEventValueChanged];\n    if (self.clickOnThumb) {\n        [self updateValueAnimated:NO];\n        return YES;\n    } else {\n        [self updateValueAnimated:YES];\n        self.clickOnThumb = NO;\n        return NO;\n    }\n}\n\n-(void)cancelTrackingWithEvent:(UIEvent *)event {\n    self.clickOnThumb = NO;\n}\n\n-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    self.clickOnThumb = NO;\n}\n```\n\n处理过事件追踪，我们只要处理好视图相关的内容即可。\n\n此处可以分为两种思路，一种是通过DrawRect方法去追踪行为后不断绘制，另一种是通过Layer展示各个图层并追踪行为。这里呢，老司机更加推荐使用Layer去处理图层，因为本身DrawRect方法中的代码是使用CPU进行预算然后将bitmap提交给GPU，他处理绘制的速度远不如CALayer直接使用GPU来的快。\n\n图层的绘制老司机在CoreAnimation系列中已经写得很细了，在这也就不多写了。\n老司机重写的DWSlider是一个UISlider的替换类，它具备UISlider的所有功能，并且还能自由定制你的Slider的各个属性，相比UISlider来讲可玩性更强，老司机这里放一个[传送门](https://github.com/CodeWicky/-Tools/tree/master/DWSlider)。\n\n- - -\n### 步进Slider\nDWStepSlider是一个分段的Slider，继承自DWSlider。\n主要是实现分段的Slider至实现，主要思想还是通过更改事件追踪后的赋值。\n\n```\n#pragma mark --- tracking Method ---\n-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:self];\n    location = [self.thumbLayer convertPoint:location fromLayer:self.layer];\n    if ([PathWithBounds(self.thumbLayer.bounds, FitCornerRadius(self.thumbLayer, self.thumbCornerRadius)) containsPoint:location]) {\n        self.clickOnThumb = YES;\n        return YES;\n    }\n    location = [self.trackBgLayer convertPoint:location fromLayer:self.thumbLayer];\n    if ([PathWithBounds(self.trackBgLayer.bounds, FitCornerRadius(self.trackBgLayer, self.trackCornerRadius)) containsPoint:location]) {\n        self.clickOnThumb = NO;\n        return YES;\n    }\n    return NO;\n}\n\n-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:self];\n    CGFloat margin = FitMarginForThumb(self.thumbSize, [self thumbMarginForBounds:self.bounds]);\n    location.x -= margin;\n    CGFloat actualW = CGRectGetWidth([self trackRectForBounds:self.bounds]) - margin * 2;\n    if (location.x < 0) {\n        location.x = 0;\n    } else if (location.x > actualW) {\n        location.x = actualW;\n    }\n    CGFloat percent = location.x / actualW;\n    CGFloat value = self.minimumValue + (self.maximumValue - self.minimumValue) * percent;\n    if (value == self.value) {\n        return YES;\n    }\n    [self setValue:value updateThumb:NO];\n    [self sendActionsForControlEvents:UIControlEventValueChanged];\n    if (self.clickOnThumb) {\n        [self updateValueAnimated:NO];\n        return YES;\n    } else {\n        [self setValue:FixValue(value, _nodes.count) updateThumb:NO];\n        [self updateValueAnimated:YES];\n        return NO;\n    }\n}\n\n-(void)cancelTrackingWithEvent:(UIEvent *)event {\n    if (self.clickOnThumb) {\n        self.value = FixValue(self.value, _nodes.count);\n        self.clickOnThumb = NO;\n    }\n}\n\n-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {\n    if (self.clickOnThumb) {\n        self.value = FixValue(self.value, _nodes.count);\n        self.clickOnThumb = NO;\n    }\n}\n```\n至于图形还是CAShapeLayer的各种形状，老司机也早就说过了，还是[传送门](https://github.com/CodeWicky/Components/blob/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF)吧。\n- - -\n好吧，今天其实也没什么新鲜内容，毕竟都是一些UI控件的封装。\n不过也是捋一下思路，控件要如何封装，所以还是不要脸的发出来了。\n喜欢哪个给哪个**Star**吧~恩，就是这么好意思~\n![图文无关](http://upload-images.jianshu.io/upload_images/1835430-1f4614d93cbc24e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"老司机出品———疯狂造轮子之滑动验证码","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htpe000ijigbhj075jie","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-68fa83a613cc526f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"滑动验证码\"></p>\n<p>消失了好久，大家放心，我还活着。<br>要问我为什么消失了这么久，如果你知道什么叫封闭开发或许你会懂我。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ea822f41d102e85b.gif?imageMogr2/auto-orient/strip\" alt=\"笑不出来\"><br>然而最近一直也没时间搞什么飞机，也没有什么能拿出来跟大家分享的，就把最近开发过程中写的一些小东西贴出来给大家看吧。<br>因为东西比较少，而且没有什么新鲜的技术点，所以老司机先把效果图放出来，这样的话如果你不感兴趣可能看到这就够了。</p>\n<p><img src=\"https://github.com/CodeWicky/DWSlideCaptchaView/raw/master/%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA.gif\" alt=\"[滑块验证视图,点我跳到仓库哟](https://github.com/CodeWicky/DWSlideCaptchaView)\"></p>\n<p><img src=\"https://github.com/CodeWicky/Components/raw/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF/%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA.gif\" alt=\"[步进滑竿,点我跳到仓库哟](https://github.com/CodeWicky/Components/tree/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF)\"></p>\n<p>在这篇文章中，你会看到以下内容：</p>\n<ul>\n<li>滑动验证视图</li>\n<li>继承UIControl重新实现一个Slider</li>\n<li>步进Slider</li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"滑动验证视图\"><a href=\"#滑动验证视图\" class=\"headerlink\" title=\"滑动验证视图\"></a>滑动验证视图</h3><p>看到这了相信你可能是对这个滑动验证有些兴趣。<br>之所以写这个控件，是因为需求用到了，然而当前有没有相应的类库能让我拿来直接用。</p>\n<p>所有效果是仿照日常网页中的效果去做的，所以我们还是应该首先分析一下我们需要什么。</p>\n<ul>\n<li>首先，我们需要一张底图</li>\n<li>第二，我们要从底图上截取一小部分作为一个滑块</li>\n<li>最后，当滑块位置改变并且最终与截取的位置重合时应该验证成功</li>\n</ul>\n<p>需求在这了，可能唯一的技术点就在于如何截取图片了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark - 截取当前image对象rect区域内的图像</div><div class=\"line\">- (UIImage *)dw_SubImageWithRect:(CGRect)rect &#123;</div><div class=\"line\">    ///防止处理过image的scale不为1情况rect错误</div><div class=\"line\">    CGFloat scale = self.scale;</div><div class=\"line\">    CGRect scaleRect = CGRectMake(rect.origin.x * scale, rect.origin.y * scale, rect.size.width * scale, rect.size.height * scale);</div><div class=\"line\">    CGImageRef newImageRef = CGImageCreateWithImageInRect(self.CGImage, scaleRect);</div><div class=\"line\">    UIImage *newImage = [[UIImage imageWithCGImage:newImageRef] dw_RescaleImageToSize:rect.size];</div><div class=\"line\">    CGImageRelease(newImageRef);</div><div class=\"line\">    return newImage;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 压缩图片至指定尺寸</div><div class=\"line\">- (UIImage *)dw_RescaleImageToSize:(CGSize)size</div><div class=\"line\">&#123;</div><div class=\"line\">    CGRect rect = (CGRect)&#123;CGPointZero, size&#125;;</div><div class=\"line\">    </div><div class=\"line\">    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);</div><div class=\"line\">    </div><div class=\"line\">    [self drawInRect:rect];</div><div class=\"line\">    </div><div class=\"line\">    UIImage *resImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">    </div><div class=\"line\">    UIGraphicsEndImageContext();</div><div class=\"line\">    </div><div class=\"line\">    return resImage;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>这些代码是老司机写在一个UIImage的category里面的，所以你应该知道所有的self都是一个UIImage实例。</strong>恩，在这个分类里面老司机封装了很多UIImage常用的方法，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">///高性能按图片名称检索本地图片</div><div class=\"line\">+(UIImage *)dw_ImageNamed:(NSString *)name;</div><div class=\"line\">///高性能返回无延迟立即解压的图片实例</div><div class=\"line\">+(UIImage *)dw_ImageWithUrl:(NSURL *)url;</div><div class=\"line\">///转换图片为Base64字符串</div><div class=\"line\">-(NSString *)dw_ImageToBase64String;</div><div class=\"line\">///Base64转换为图片</div><div class=\"line\">+ (UIImage *)dw_ImageWithBase64String:(NSString *)base64String;</div><div class=\"line\">///取图片某点颜色</div><div class=\"line\">-(UIColor *)dw_ColorAtPoint:(CGPoint)point;</div><div class=\"line\">///按给定颜色生层图片</div><div class=\"line\">+(UIImage *)dw_ImageWithColor:(UIColor *)color;</div><div class=\"line\">///以灰色空间生成图片</div><div class=\"line\">-(UIImage *)dw_ConvertToGrayImage;</div><div class=\"line\">///生成图片的反色图片对象</div><div class=\"line\">-(UIImage *)dw_ConvertToReversedColor;</div><div class=\"line\">///以给定颜色生成图像剪影</div><div class=\"line\">-(UIImage *)dw_ConvertToSketchWithColor:(UIColor *)color;</div><div class=\"line\">///生成处理每像素颜色后的图片</div><div class=\"line\">-(UIImage *)dw_ConvertImageWithPixelHandler:(void(^)(UInt8 * pixel,int x,int y))handler;</div><div class=\"line\">///获取带圆角的图片</div><div class=\"line\">-(UIImage *)dw_CornerRadius:(CGFloat)radius withWidth:(CGFloat)width contentMode:(DWContentMode)mode;</div><div class=\"line\">///按给定path剪裁图片</div><div class=\"line\">-(UIImage *)dw_ClipImageWithPath:(UIBezierPath *)path mode:(DWContentMode)mode;</div><div class=\"line\">///获取旋转角度的图片</div><div class=\"line\">-(UIImage *)dw_RotateImageWithAngle:(CGFloat)angle;</div><div class=\"line\">///按给定的方向旋转图片</div><div class=\"line\">-(UIImage*)dw_RotateWithOrient:(UIImageOrientation)orient;</div><div class=\"line\">///垂直翻转</div><div class=\"line\">-(UIImage *)dw_FlipVertical;</div><div class=\"line\">///水平翻转</div><div class=\"line\">-(UIImage *)dw_FlipHorizontal;</div><div class=\"line\">///压缩图片至指定尺寸</div><div class=\"line\">-(UIImage *)dw_RescaleImageToSize:(CGSize)size;</div><div class=\"line\">///压缩图片至指定像素</div><div class=\"line\">-(UIImage *)dw_RescaleImageToPX:(CGFloat )toPX;</div><div class=\"line\">///纠正图片方向</div><div class=\"line\">-(UIImage *)dw_FixOrientation;</div><div class=\"line\">///截取当前image对象rect区域内的图像</div><div class=\"line\">-(UIImage *)dw_SubImageWithRect:(CGRect)rect;</div><div class=\"line\">///在指定的size里面生成一个平铺的图片</div><div class=\"line\">-(UIImage *)dw_GetTiledImageWithSize:(CGSize)size;</div><div class=\"line\">///UIView转化为UIImage</div><div class=\"line\">+(UIImage *)dw_ImageFromView:(UIView *)view;</div><div class=\"line\">///将两个图片生成一张图片</div><div class=\"line\">+(UIImage*)dw_MergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage;</div></pre></td></tr></table></figure></p>\n<p>这个分类还是比较全的，老司机还是比较推荐的，给个<a href=\"https://github.com/CodeWicky/-Tools/tree/master/DWImageUtils\" target=\"_blank\" rel=\"external\">传送门</a>，觉得好的话给我个star吧。</p>\n<p>所以说借助这个分类，你应该可以从一整张图片上截取一部分图片了，接下来你只需要：</p>\n<ul>\n<li>随意生成一个区域将它定为验证区域，并在该区域覆盖滑块形状的白色半透明的覆盖层</li>\n<li>创建一个与上面的区域形状相同的Layer，将截取好的图片赋给Layer，同时用贝塞尔曲线将Layer绘制成滑块的形状</li>\n<li>最后当验证视图滑块的位置改变至验证区域时，验证成功即可。</li>\n</ul>\n<p>思路比较简单，实现起来也比较简单，300多行代码，老司机就直接放全部代码了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame &#123;</div><div class=\"line\">    NSAssert((frame.size.width &gt;= 100 &amp;&amp; frame.size.height &gt;= 40), @&quot;To get a better experience,you may set the width more than 100 and height more than 50.&quot;);</div><div class=\"line\">    if (self = [super initWithFrame:frame]) &#123;</div><div class=\"line\">        _useRandomValue = YES;</div><div class=\"line\">        _targetValue = DWSlideCaptchaUndefineValue;</div><div class=\"line\">        _thumbCenterY = DWSlideCaptchaUndefineValue;</div><div class=\"line\">        _tolerance = DWSlideCaptchaUndefineValue;</div><div class=\"line\">        _thumbSize = puzzlePath().bounds.size;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame bgImage:(UIImage *)bgImage &#123;</div><div class=\"line\">    if (self = [self initWithFrame:frame]) &#123;</div><div class=\"line\">        [self beginConfiguration];</div><div class=\"line\">        self.bgImage = bgImage;</div><div class=\"line\">        [self commitConfiguration];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)beginConfiguration &#123;</div><div class=\"line\">    _configurating = YES;</div><div class=\"line\">    self.resetTargetPoint = YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)commitConfiguration &#123;</div><div class=\"line\">    if (!self.configurating) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _configurating = NO;</div><div class=\"line\">    self.layer.contents = (id)self.bgImage.CGImage;</div><div class=\"line\">    [self handlePositionLayer];</div><div class=\"line\">    [self handleThumbLayer];</div><div class=\"line\">    [self hideThumbWithAnimated:NO];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)reset &#123;</div><div class=\"line\">    _successed = NO;</div><div class=\"line\">    [self beginConfiguration];</div><div class=\"line\">    [self commitConfiguration];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)indentifyWithAnimated:(BOOL)animated result:(void(^)(BOOL success))result &#123;</div><div class=\"line\">    BOOL isSuccess = fabs(self.targetPoint.x - self.currentPoint.x) &lt; self.tolerance;</div><div class=\"line\">    isSuccess &amp;= fabs(self.targetPoint.y - self.currentPoint.y) &lt; self.tolerance;</div><div class=\"line\">    _successed = isSuccess;</div><div class=\"line\">    _indentified = YES;</div><div class=\"line\">    if (isSuccess) &#123;</div><div class=\"line\">        if (animated) &#123;</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationWillStartWithSuccess:)]) &#123;///动画开始回调</div><div class=\"line\">                [self.delegate dw_CaptchaView:self animationWillStartWithSuccess:YES];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!self.successAnimation) &#123;///未指定动画使用默认动画</div><div class=\"line\">                [self.layer addAnimation:defaultSuccessAnimaiton(self) forKey:@&quot;successAnimation&quot;];</div><div class=\"line\">                [self hideThumbWithAnimated:NO];</div><div class=\"line\">                DWLayerTransactionWithAnimation(NO, ^()&#123;</div><div class=\"line\">                    self.positionLayer.opacity = 0;</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125; else &#123;///使用指定动画</div><div class=\"line\">                [self.thumbLayer addAnimation:self.successAnimation forKey:@&quot;successAnimation&quot;];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (result) result(YES);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (animated) &#123;</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationWillStartWithSuccess:)]) &#123;///动画开始回调</div><div class=\"line\">                [self.delegate dw_CaptchaView:self animationWillStartWithSuccess:YES];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!self.failAnimation) &#123;///未指定动画则使用默认动画</div><div class=\"line\">                [self.thumbLayer addAnimation:defaultFailAnimation(self) forKey:@&quot;failAnimation&quot;];</div><div class=\"line\">            &#125; else &#123;///使用指定动画</div><div class=\"line\">                [self.thumbLayer addAnimation:self.failAnimation forKey:@&quot;failAnimation&quot;];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (result) result(NO);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)moveToPoint:(CGPoint)point animated:(BOOL)animated &#123;</div><div class=\"line\">    if (self.successed) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _indentified = NO;</div><div class=\"line\">    point = fixPointWithLimit(point, self.validSize, self.thumbSize);</div><div class=\"line\">    self.currentPoint = point;</div><div class=\"line\">    if (self.thumbLayer.opacity != 1) &#123;</div><div class=\"line\">        [self showThumbWithAnimated:YES];</div><div class=\"line\">    &#125;</div><div class=\"line\">    DWLayerTransactionWithAnimation(animated, ^()&#123;</div><div class=\"line\">        self.thumbLayer.position = transformLocation2Center(point, self.thumbSize);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setValue:(CGFloat)value animated:(BOOL)animated &#123;</div><div class=\"line\">    CGFloat x = value * self.validSize.width + self.thumbSize.width / 2;</div><div class=\"line\">    CGFloat y = self.targetPoint.y + self.thumbSize.height / 2;</div><div class=\"line\">    [self moveToPoint:CGPointMake(x, y) animated:animated];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)showThumbWithAnimated:(BOOL)animated &#123;</div><div class=\"line\">    DWLayerTransactionWithAnimation(animated,^()&#123;</div><div class=\"line\">        self.thumbLayer.opacity = 1;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)hideThumbWithAnimated:(BOOL)animated &#123;</div><div class=\"line\">    DWLayerTransactionWithAnimation(animated, ^()&#123;</div><div class=\"line\">        self.thumbLayer.opacity = 0;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- tool Method ---</div><div class=\"line\">-(void)handleThumbLayer &#123;</div><div class=\"line\">    UIImage * thumbImage = [self.bgImage dw_SubImageWithRect:self.positionLayer.frame];</div><div class=\"line\">    thumbImage = [thumbImage dw_ClipImageWithPath:self.thumbShape mode:(DWContentModeScaleToFill)];</div><div class=\"line\">    self.thumbLayer.contents = (id)thumbImage.CGImage;</div><div class=\"line\">    self.thumbLayer.frame = self.positionLayer.frame;</div><div class=\"line\">    [self setValue:0 animated:NO];</div><div class=\"line\">    if (!self.thumbLayer.superlayer) &#123;</div><div class=\"line\">        [self.layer addSublayer:self.thumbLayer];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)handlePositionLayer &#123;</div><div class=\"line\">    UIBezierPath * path = [self.thumbShape copy];</div><div class=\"line\">    self.positionLayer.fillColor = [UIColor colorWithWhite:1 alpha:0.7].CGColor;</div><div class=\"line\">    self.positionLayer.path = path.CGPath;</div><div class=\"line\">    self.positionLayer.frame = CGRectMake(self.targetPoint.x, self.targetPoint.y, (int)path.bounds.size.width, (int)path.bounds.size.height);</div><div class=\"line\">    if (!self.positionLayer.superlayer) &#123;</div><div class=\"line\">        [self.layer addSublayer:self.positionLayer];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- animation delegate ---</div><div class=\"line\">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag &#123;</div><div class=\"line\">    if (self.isSuccessed) &#123;</div><div class=\"line\">        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationCompletionWithSuccess:)]) &#123;</div><div class=\"line\">            [self.delegate dw_CaptchaView:self animationCompletionWithSuccess:YES];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationCompletionWithSuccess:)]) &#123;</div><div class=\"line\">            [self.delegate dw_CaptchaView:self animationCompletionWithSuccess:NO];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 内联方法 ---</div><div class=\"line\">///默认滑块形状</div><div class=\"line\">static inline UIBezierPath * puzzlePath ()&#123;</div><div class=\"line\">    UIBezierPath * path = [UIBezierPath bezierPathWithPathMaker:^(DWPathMaker *maker) &#123;</div><div class=\"line\">        maker.MoveTo(0, 8).</div><div class=\"line\">        AddLineTo(12, 8).AddArcWithPoint(12, 8, 20, 8, 5, YES, YES).AddLineTo(32, 8).</div><div class=\"line\">        AddLineTo(32, 20).AddArcWithPoint(32, 20, 32, 28, 5, YES, YES).AddLineTo(32, 40).</div><div class=\"line\">        AddLineTo(20, 40).AddArcWithPoint(20, 40, 12, 40, 5, NO, YES).AddLineTo(0, 40).</div><div class=\"line\">        AddLineTo(0, 28).AddArcWithPoint(0, 28, 0, 20, 5, NO, YES).ClosePath();</div><div class=\"line\">    &#125;];</div><div class=\"line\">    return path;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///指定尺寸内的随机点</div><div class=\"line\">static inline CGPoint randomPointInSize(CGSize size) &#123;</div><div class=\"line\">    CGPoint point = CGPointZero;</div><div class=\"line\">    point.x = randomValueInLength((int)size.width);</div><div class=\"line\">    point.y = randomValueInLength((int)size.height);</div><div class=\"line\">    return point;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///指定范围内的随机值</div><div class=\"line\">static inline int randomValueInLength(int length) &#123;</div><div class=\"line\">    return arc4random() % ((int)(length + 1));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///修正centerY值合适的值</div><div class=\"line\">static inline CGFloat fixCenterYWithSize(CGSize thumbSize,CGSize validSize,CGFloat centerY) &#123;</div><div class=\"line\">    CGFloat y = centerY - thumbSize.height / 2;</div><div class=\"line\">    return fixValueWithLimit(y, validSize.height);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///将值修正至指定范围</div><div class=\"line\">static inline CGFloat fixValueWithLimit(CGFloat value,CGFloat limitLength) &#123;</div><div class=\"line\">    return value &lt; 0 ? 0 : (value &gt; limitLength ? limitLength : value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///将点修正值有效范围内</div><div class=\"line\">static inline CGPoint fixPointWithLimit(CGPoint point,CGSize validSize,CGSize thumbSize) &#123;</div><div class=\"line\">    CGFloat x = point.x - thumbSize.width / 2;</div><div class=\"line\">    CGFloat y = point.y - thumbSize.height / 2;</div><div class=\"line\">    return CGPointMake(fixValueWithLimit(x, validSize.width), fixValueWithLimit(y, validSize.height));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///将验证位置转换为layer中心点</div><div class=\"line\">static inline CGPoint transformLocation2Center(CGPoint origin,CGSize thumbSize) &#123;</div><div class=\"line\">    return CGPointMake(origin.x + thumbSize.width / 2, origin.y + thumbSize.height / 2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///Point转value</div><div class=\"line\">static inline NSValue * valueOfPoint(CGPoint point) &#123;</div><div class=\"line\">    return [NSValue valueWithCGPoint:point];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///默认成功动画</div><div class=\"line\">static inline CAAnimation * defaultSuccessAnimaiton(id&lt;CAAnimationDelegate&gt; delegate) &#123;</div><div class=\"line\">    CABasicAnimation * animation = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];</div><div class=\"line\">    animation.duration = 0.2;</div><div class=\"line\">    animation.autoreverses = YES;</div><div class=\"line\">    animation.fromValue = @1;</div><div class=\"line\">    animation.toValue = @0;</div><div class=\"line\">    animation.removedOnCompletion = YES;</div><div class=\"line\">    animation.delegate = delegate;</div><div class=\"line\">    return animation;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///默认失败动画</div><div class=\"line\">static inline CAAnimation * defaultFailAnimation(id&lt;CAAnimationDelegate&gt; delegate) &#123;</div><div class=\"line\">    DWSlideCaptchaView * captcha = (DWSlideCaptchaView *)delegate;</div><div class=\"line\">    CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class=\"line\">    CGFloat a = 3;</div><div class=\"line\">    CGPoint Cp = captcha.thumbLayer.position;</div><div class=\"line\">    CGPoint Lp = CGPointMake(Cp.x - a, Cp.y);</div><div class=\"line\">    CGPoint Rp = CGPointMake(Cp.x + a, Cp.y);</div><div class=\"line\">    animation.values = @[valueOfPoint(Cp),valueOfPoint(Lp),valueOfPoint(Rp),valueOfPoint(Cp)];</div><div class=\"line\">    animation.repeatCount = 2;</div><div class=\"line\">    animation.removedOnCompletion = YES;</div><div class=\"line\">    animation.duration = 0.2;</div><div class=\"line\">    animation.delegate = captcha;</div><div class=\"line\">    return animation;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- setter/getter ---</div><div class=\"line\">-(CAShapeLayer *)positionLayer &#123;</div><div class=\"line\">    if (!_positionLayer) &#123;</div><div class=\"line\">        _positionLayer = [CAShapeLayer layer];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _positionLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CAShapeLayer *)thumbLayer &#123;</div><div class=\"line\">    if (!_thumbLayer) &#123;</div><div class=\"line\">        _thumbLayer = [CAShapeLayer layer];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _thumbLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setThumbShape:(UIBezierPath *)thumbShape &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    CGSize size = thumbShape.bounds.size;</div><div class=\"line\">    if (!(size.width &gt;= 40 &amp;&amp; size.height &gt;= 40)) &#123;</div><div class=\"line\">        NSAssert(NO, @&quot;To get a better experience,the width and height of thumbShape both should be more than 40.&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    _thumbShape = thumbShape;</div><div class=\"line\">    _thumbSize = size;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(UIBezierPath *)thumbShape &#123;</div><div class=\"line\">    if (!_thumbShape) &#123;</div><div class=\"line\">        return puzzlePath();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _thumbShape;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setTargetValue:(CGFloat)targetValue &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _targetValue = fixValueWithLimit(targetValue, 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setThumbCenterY:(CGFloat)thumbCenterY &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _thumbCenterY = thumbCenterY;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setUseRandomValue:(BOOL)useRandomValue &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _useRandomValue = useRandomValue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setTolerance:(CGFloat)tolerance &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _tolerance = tolerance;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGFloat)tolerance &#123;</div><div class=\"line\">    if (_tolerance &lt; 0) &#123;</div><div class=\"line\">        return 3;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _tolerance;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setSuccessAnimation:(CAAnimation *)successAnimation &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _successAnimation = successAnimation;</div><div class=\"line\">    _successAnimation.delegate = self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setFailAnimation:(CAAnimation *)failAnimation &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _failAnimation = failAnimation;</div><div class=\"line\">    _failAnimation.delegate = self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setBgImage:(UIImage *)bgImage &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    if (bgImage) &#123;</div><div class=\"line\">        _bgImage = [bgImage dw_RescaleImageToSize:self.frame.size];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        _bgImage = nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setThumbSize:(CGSize)thumbSize &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    if (!CGSizeEqualToSize(_thumbSize, thumbSize)) &#123;</div><div class=\"line\">        _thumbSize = thumbSize;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGPoint)targetPoint &#123;</div><div class=\"line\">    if (!self.resetTargetPoint) &#123;</div><div class=\"line\">        return _targetPoint;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.resetTargetPoint = NO;</div><div class=\"line\">    if (self.useRandomValue) &#123;</div><div class=\"line\">        _targetPoint = randomPointInSize(self.validSize);</div><div class=\"line\">        return _targetPoint;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat x = (self.targetValue != DWSlideCaptchaUndefineValue) ? self.targetValue : randomValueInLength((int)self.validSize.width);</div><div class=\"line\">    CGFloat y = (self.thumbCenterY != DWSlideCaptchaUndefineValue) ? fixCenterYWithSize(self.thumbSize, self.validSize, self.thumbCenterY) : randomValueInLength((int)self.validSize.height);</div><div class=\"line\">    _targetPoint = CGPointMake(x, y);</div><div class=\"line\">    return _targetPoint;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGSize)validSize &#123;</div><div class=\"line\">    return CGSizeMake(self.bounds.size.width - self.thumbSize.width, self.bounds.size.height - self.thumbSize.height);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>恩，这个库老司机不仅上传到GitHub上面，还让他支持了Cocoapods，你可以通过 <code>pod &#39;DWSlideCaptchaView&#39;, &#39;~&gt; 1.0.2&#39;</code>来集成这个视图，觉得好请Star。</p>\n<p>说到这里老司机说一下，现在你可以通过<code>pod search wicky</code>命令搜索老司机上传到Cocoapods上面的类库，目前有三个：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-03eb96944d07d1fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"当前支持Cocoapods的库\"></p>\n<p>老司机这里还是主推DWCoreTextLabel，他是一个基于CoreText的异步绘制的图文混排控件，并且支持图片的异步加载与缓存，基本上可以完美的实现图文混排需求。你值得使用。</p>\n<p>DWCheckBox就是单选复选框了，也是一个快捷使用并且有着高定制型的类库。</p>\n<hr>\n<h3 id=\"继承UIControl重新实现一个Slider\"><a href=\"#继承UIControl重新实现一个Slider\" class=\"headerlink\" title=\"继承UIControl重新实现一个Slider\"></a>继承UIControl重新实现一个Slider</h3><p>广告打完了咱们来看第二环节，slider。<br>最初的时候其实我就是想实现后面那个步进Slider，最初的想法继承UISlider去重写，奈何转了一大圈，各种私有属性用一遍也无法完美的完成我的需求。</p>\n<p>主要是由于UISlider中对于滑块和滑竿的定制性很困难，所以自己重写一个Slider吧。</p>\n<p>所以为什么想到继承自UIControl去写呢？第一是UISlider继承自UIControl，第二是UIControl封装了<code>-addTarget:selector:events</code>以及事件追踪的一系列方法。</p>\n<p>其实UIControl有四个核心的方法，是用于控制事件追踪的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">///判断是否开始事件追踪</div><div class=\"line\">-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</div><div class=\"line\">///判断事件追踪是否继续</div><div class=\"line\">-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</div><div class=\"line\">///事件追踪取消时处理</div><div class=\"line\">-(void)cancelTrackingWithEvent:(UIEvent *)event;</div><div class=\"line\">///事件追踪结束时处理</div><div class=\"line\">-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</div></pre></td></tr></table></figure></p>\n<p>使用方法无非就是判断当视图接收到事件是如何追踪，可以看一下老司机写Slider的处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- tracking Method ---</div><div class=\"line\">-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    location = [self.thumbLayer convertPoint:location fromLayer:self.layer];</div><div class=\"line\">    if ([PathWithBounds(self.thumbLayer.bounds, FitCornerRadius(self.thumbLayer, self.thumbCornerRadius)) containsPoint:location]) &#123;</div><div class=\"line\">        self.clickOnThumb = YES;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    location = [self.trackBgLayer convertPoint:location fromLayer:self.thumbLayer];</div><div class=\"line\">    if ([PathWithBounds(self.trackBgLayer.bounds, FitCornerRadius(self.trackBgLayer, self.trackCornerRadius)) containsPoint:location]) &#123;</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    CGFloat margin = FitMarginForThumb(self.thumbSize, [self thumbMarginForBounds:self.bounds]);</div><div class=\"line\">    location.x -= margin;</div><div class=\"line\">    CGFloat actualW = CGRectGetWidth([self trackRectForBounds:self.bounds]) - margin * 2;</div><div class=\"line\">    if (location.x &lt; 0) &#123;</div><div class=\"line\">        location.x = 0;</div><div class=\"line\">    &#125; else if (location.x &gt; actualW) &#123;</div><div class=\"line\">        location.x = actualW;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat percent = location.x / actualW;</div><div class=\"line\">    CGFloat value = self.minimumValue + (self.maximumValue - self.minimumValue) * percent;</div><div class=\"line\">    if (value == self.value) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _value = value;</div><div class=\"line\">    [self sendActionsForControlEvents:UIControlEventValueChanged];</div><div class=\"line\">    if (self.clickOnThumb) &#123;</div><div class=\"line\">        [self updateValueAnimated:NO];</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [self updateValueAnimated:YES];</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancelTrackingWithEvent:(UIEvent *)event &#123;</div><div class=\"line\">    self.clickOnThumb = NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    self.clickOnThumb = NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>处理过事件追踪，我们只要处理好视图相关的内容即可。</p>\n<p>此处可以分为两种思路，一种是通过DrawRect方法去追踪行为后不断绘制，另一种是通过Layer展示各个图层并追踪行为。这里呢，老司机更加推荐使用Layer去处理图层，因为本身DrawRect方法中的代码是使用CPU进行预算然后将bitmap提交给GPU，他处理绘制的速度远不如CALayer直接使用GPU来的快。</p>\n<p>图层的绘制老司机在CoreAnimation系列中已经写得很细了，在这也就不多写了。<br>老司机重写的DWSlider是一个UISlider的替换类，它具备UISlider的所有功能，并且还能自由定制你的Slider的各个属性，相比UISlider来讲可玩性更强，老司机这里放一个<a href=\"https://github.com/CodeWicky/-Tools/tree/master/DWSlider\" target=\"_blank\" rel=\"external\">传送门</a>。</p>\n<hr>\n<h3 id=\"步进Slider\"><a href=\"#步进Slider\" class=\"headerlink\" title=\"步进Slider\"></a>步进Slider</h3><p>DWStepSlider是一个分段的Slider，继承自DWSlider。<br>主要是实现分段的Slider至实现，主要思想还是通过更改事件追踪后的赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- tracking Method ---</div><div class=\"line\">-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    location = [self.thumbLayer convertPoint:location fromLayer:self.layer];</div><div class=\"line\">    if ([PathWithBounds(self.thumbLayer.bounds, FitCornerRadius(self.thumbLayer, self.thumbCornerRadius)) containsPoint:location]) &#123;</div><div class=\"line\">        self.clickOnThumb = YES;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    location = [self.trackBgLayer convertPoint:location fromLayer:self.thumbLayer];</div><div class=\"line\">    if ([PathWithBounds(self.trackBgLayer.bounds, FitCornerRadius(self.trackBgLayer, self.trackCornerRadius)) containsPoint:location]) &#123;</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    CGFloat margin = FitMarginForThumb(self.thumbSize, [self thumbMarginForBounds:self.bounds]);</div><div class=\"line\">    location.x -= margin;</div><div class=\"line\">    CGFloat actualW = CGRectGetWidth([self trackRectForBounds:self.bounds]) - margin * 2;</div><div class=\"line\">    if (location.x &lt; 0) &#123;</div><div class=\"line\">        location.x = 0;</div><div class=\"line\">    &#125; else if (location.x &gt; actualW) &#123;</div><div class=\"line\">        location.x = actualW;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat percent = location.x / actualW;</div><div class=\"line\">    CGFloat value = self.minimumValue + (self.maximumValue - self.minimumValue) * percent;</div><div class=\"line\">    if (value == self.value) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self setValue:value updateThumb:NO];</div><div class=\"line\">    [self sendActionsForControlEvents:UIControlEventValueChanged];</div><div class=\"line\">    if (self.clickOnThumb) &#123;</div><div class=\"line\">        [self updateValueAnimated:NO];</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [self setValue:FixValue(value, _nodes.count) updateThumb:NO];</div><div class=\"line\">        [self updateValueAnimated:YES];</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancelTrackingWithEvent:(UIEvent *)event &#123;</div><div class=\"line\">    if (self.clickOnThumb) &#123;</div><div class=\"line\">        self.value = FixValue(self.value, _nodes.count);</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    if (self.clickOnThumb) &#123;</div><div class=\"line\">        self.value = FixValue(self.value, _nodes.count);</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至于图形还是CAShapeLayer的各种形状，老司机也早就说过了，还是<a href=\"https://github.com/CodeWicky/Components/blob/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF\" target=\"_blank\" rel=\"external\">传送门</a>吧。</p>\n<hr>\n<p>好吧，今天其实也没什么新鲜内容，毕竟都是一些UI控件的封装。<br>不过也是捋一下思路，控件要如何封装，所以还是不要脸的发出来了。<br>喜欢哪个给哪个<strong>Star</strong>吧~恩，就是这么好意思~<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1f4614d93cbc24e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图文无关\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-68fa83a613cc526f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"滑动验证码\"></p>\n<p>消失了好久，大家放心，我还活着。<br>要问我为什么消失了这么久，如果你知道什么叫封闭开发或许你会懂我。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ea822f41d102e85b.gif?imageMogr2/auto-orient/strip\" alt=\"笑不出来\"><br>然而最近一直也没时间搞什么飞机，也没有什么能拿出来跟大家分享的，就把最近开发过程中写的一些小东西贴出来给大家看吧。<br>因为东西比较少，而且没有什么新鲜的技术点，所以老司机先把效果图放出来，这样的话如果你不感兴趣可能看到这就够了。</p>\n<p><img src=\"https://github.com/CodeWicky/DWSlideCaptchaView/raw/master/%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA.gif\" alt=\"[滑块验证视图,点我跳到仓库哟](https://github.com/CodeWicky/DWSlideCaptchaView)\"></p>\n<p><img src=\"https://github.com/CodeWicky/Components/raw/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF/%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA.gif\" alt=\"[步进滑竿,点我跳到仓库哟](https://github.com/CodeWicky/Components/tree/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF)\"></p>\n<p>在这篇文章中，你会看到以下内容：</p>\n<ul>\n<li>滑动验证视图</li>\n<li>继承UIControl重新实现一个Slider</li>\n<li>步进Slider</li>\n</ul>","more":"<hr>\n<h3 id=\"滑动验证视图\"><a href=\"#滑动验证视图\" class=\"headerlink\" title=\"滑动验证视图\"></a>滑动验证视图</h3><p>看到这了相信你可能是对这个滑动验证有些兴趣。<br>之所以写这个控件，是因为需求用到了，然而当前有没有相应的类库能让我拿来直接用。</p>\n<p>所有效果是仿照日常网页中的效果去做的，所以我们还是应该首先分析一下我们需要什么。</p>\n<ul>\n<li>首先，我们需要一张底图</li>\n<li>第二，我们要从底图上截取一小部分作为一个滑块</li>\n<li>最后，当滑块位置改变并且最终与截取的位置重合时应该验证成功</li>\n</ul>\n<p>需求在这了，可能唯一的技术点就在于如何截取图片了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark - 截取当前image对象rect区域内的图像</div><div class=\"line\">- (UIImage *)dw_SubImageWithRect:(CGRect)rect &#123;</div><div class=\"line\">    ///防止处理过image的scale不为1情况rect错误</div><div class=\"line\">    CGFloat scale = self.scale;</div><div class=\"line\">    CGRect scaleRect = CGRectMake(rect.origin.x * scale, rect.origin.y * scale, rect.size.width * scale, rect.size.height * scale);</div><div class=\"line\">    CGImageRef newImageRef = CGImageCreateWithImageInRect(self.CGImage, scaleRect);</div><div class=\"line\">    UIImage *newImage = [[UIImage imageWithCGImage:newImageRef] dw_RescaleImageToSize:rect.size];</div><div class=\"line\">    CGImageRelease(newImageRef);</div><div class=\"line\">    return newImage;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 压缩图片至指定尺寸</div><div class=\"line\">- (UIImage *)dw_RescaleImageToSize:(CGSize)size</div><div class=\"line\">&#123;</div><div class=\"line\">    CGRect rect = (CGRect)&#123;CGPointZero, size&#125;;</div><div class=\"line\">    </div><div class=\"line\">    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);</div><div class=\"line\">    </div><div class=\"line\">    [self drawInRect:rect];</div><div class=\"line\">    </div><div class=\"line\">    UIImage *resImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">    </div><div class=\"line\">    UIGraphicsEndImageContext();</div><div class=\"line\">    </div><div class=\"line\">    return resImage;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>这些代码是老司机写在一个UIImage的category里面的，所以你应该知道所有的self都是一个UIImage实例。</strong>恩，在这个分类里面老司机封装了很多UIImage常用的方法，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">///高性能按图片名称检索本地图片</div><div class=\"line\">+(UIImage *)dw_ImageNamed:(NSString *)name;</div><div class=\"line\">///高性能返回无延迟立即解压的图片实例</div><div class=\"line\">+(UIImage *)dw_ImageWithUrl:(NSURL *)url;</div><div class=\"line\">///转换图片为Base64字符串</div><div class=\"line\">-(NSString *)dw_ImageToBase64String;</div><div class=\"line\">///Base64转换为图片</div><div class=\"line\">+ (UIImage *)dw_ImageWithBase64String:(NSString *)base64String;</div><div class=\"line\">///取图片某点颜色</div><div class=\"line\">-(UIColor *)dw_ColorAtPoint:(CGPoint)point;</div><div class=\"line\">///按给定颜色生层图片</div><div class=\"line\">+(UIImage *)dw_ImageWithColor:(UIColor *)color;</div><div class=\"line\">///以灰色空间生成图片</div><div class=\"line\">-(UIImage *)dw_ConvertToGrayImage;</div><div class=\"line\">///生成图片的反色图片对象</div><div class=\"line\">-(UIImage *)dw_ConvertToReversedColor;</div><div class=\"line\">///以给定颜色生成图像剪影</div><div class=\"line\">-(UIImage *)dw_ConvertToSketchWithColor:(UIColor *)color;</div><div class=\"line\">///生成处理每像素颜色后的图片</div><div class=\"line\">-(UIImage *)dw_ConvertImageWithPixelHandler:(void(^)(UInt8 * pixel,int x,int y))handler;</div><div class=\"line\">///获取带圆角的图片</div><div class=\"line\">-(UIImage *)dw_CornerRadius:(CGFloat)radius withWidth:(CGFloat)width contentMode:(DWContentMode)mode;</div><div class=\"line\">///按给定path剪裁图片</div><div class=\"line\">-(UIImage *)dw_ClipImageWithPath:(UIBezierPath *)path mode:(DWContentMode)mode;</div><div class=\"line\">///获取旋转角度的图片</div><div class=\"line\">-(UIImage *)dw_RotateImageWithAngle:(CGFloat)angle;</div><div class=\"line\">///按给定的方向旋转图片</div><div class=\"line\">-(UIImage*)dw_RotateWithOrient:(UIImageOrientation)orient;</div><div class=\"line\">///垂直翻转</div><div class=\"line\">-(UIImage *)dw_FlipVertical;</div><div class=\"line\">///水平翻转</div><div class=\"line\">-(UIImage *)dw_FlipHorizontal;</div><div class=\"line\">///压缩图片至指定尺寸</div><div class=\"line\">-(UIImage *)dw_RescaleImageToSize:(CGSize)size;</div><div class=\"line\">///压缩图片至指定像素</div><div class=\"line\">-(UIImage *)dw_RescaleImageToPX:(CGFloat )toPX;</div><div class=\"line\">///纠正图片方向</div><div class=\"line\">-(UIImage *)dw_FixOrientation;</div><div class=\"line\">///截取当前image对象rect区域内的图像</div><div class=\"line\">-(UIImage *)dw_SubImageWithRect:(CGRect)rect;</div><div class=\"line\">///在指定的size里面生成一个平铺的图片</div><div class=\"line\">-(UIImage *)dw_GetTiledImageWithSize:(CGSize)size;</div><div class=\"line\">///UIView转化为UIImage</div><div class=\"line\">+(UIImage *)dw_ImageFromView:(UIView *)view;</div><div class=\"line\">///将两个图片生成一张图片</div><div class=\"line\">+(UIImage*)dw_MergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage;</div></pre></td></tr></table></figure></p>\n<p>这个分类还是比较全的，老司机还是比较推荐的，给个<a href=\"https://github.com/CodeWicky/-Tools/tree/master/DWImageUtils\" target=\"_blank\" rel=\"external\">传送门</a>，觉得好的话给我个star吧。</p>\n<p>所以说借助这个分类，你应该可以从一整张图片上截取一部分图片了，接下来你只需要：</p>\n<ul>\n<li>随意生成一个区域将它定为验证区域，并在该区域覆盖滑块形状的白色半透明的覆盖层</li>\n<li>创建一个与上面的区域形状相同的Layer，将截取好的图片赋给Layer，同时用贝塞尔曲线将Layer绘制成滑块的形状</li>\n<li>最后当验证视图滑块的位置改变至验证区域时，验证成功即可。</li>\n</ul>\n<p>思路比较简单，实现起来也比较简单，300多行代码，老司机就直接放全部代码了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame &#123;</div><div class=\"line\">    NSAssert((frame.size.width &gt;= 100 &amp;&amp; frame.size.height &gt;= 40), @&quot;To get a better experience,you may set the width more than 100 and height more than 50.&quot;);</div><div class=\"line\">    if (self = [super initWithFrame:frame]) &#123;</div><div class=\"line\">        _useRandomValue = YES;</div><div class=\"line\">        _targetValue = DWSlideCaptchaUndefineValue;</div><div class=\"line\">        _thumbCenterY = DWSlideCaptchaUndefineValue;</div><div class=\"line\">        _tolerance = DWSlideCaptchaUndefineValue;</div><div class=\"line\">        _thumbSize = puzzlePath().bounds.size;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame bgImage:(UIImage *)bgImage &#123;</div><div class=\"line\">    if (self = [self initWithFrame:frame]) &#123;</div><div class=\"line\">        [self beginConfiguration];</div><div class=\"line\">        self.bgImage = bgImage;</div><div class=\"line\">        [self commitConfiguration];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)beginConfiguration &#123;</div><div class=\"line\">    _configurating = YES;</div><div class=\"line\">    self.resetTargetPoint = YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)commitConfiguration &#123;</div><div class=\"line\">    if (!self.configurating) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _configurating = NO;</div><div class=\"line\">    self.layer.contents = (id)self.bgImage.CGImage;</div><div class=\"line\">    [self handlePositionLayer];</div><div class=\"line\">    [self handleThumbLayer];</div><div class=\"line\">    [self hideThumbWithAnimated:NO];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)reset &#123;</div><div class=\"line\">    _successed = NO;</div><div class=\"line\">    [self beginConfiguration];</div><div class=\"line\">    [self commitConfiguration];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)indentifyWithAnimated:(BOOL)animated result:(void(^)(BOOL success))result &#123;</div><div class=\"line\">    BOOL isSuccess = fabs(self.targetPoint.x - self.currentPoint.x) &lt; self.tolerance;</div><div class=\"line\">    isSuccess &amp;= fabs(self.targetPoint.y - self.currentPoint.y) &lt; self.tolerance;</div><div class=\"line\">    _successed = isSuccess;</div><div class=\"line\">    _indentified = YES;</div><div class=\"line\">    if (isSuccess) &#123;</div><div class=\"line\">        if (animated) &#123;</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationWillStartWithSuccess:)]) &#123;///动画开始回调</div><div class=\"line\">                [self.delegate dw_CaptchaView:self animationWillStartWithSuccess:YES];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!self.successAnimation) &#123;///未指定动画使用默认动画</div><div class=\"line\">                [self.layer addAnimation:defaultSuccessAnimaiton(self) forKey:@&quot;successAnimation&quot;];</div><div class=\"line\">                [self hideThumbWithAnimated:NO];</div><div class=\"line\">                DWLayerTransactionWithAnimation(NO, ^()&#123;</div><div class=\"line\">                    self.positionLayer.opacity = 0;</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125; else &#123;///使用指定动画</div><div class=\"line\">                [self.thumbLayer addAnimation:self.successAnimation forKey:@&quot;successAnimation&quot;];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (result) result(YES);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (animated) &#123;</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationWillStartWithSuccess:)]) &#123;///动画开始回调</div><div class=\"line\">                [self.delegate dw_CaptchaView:self animationWillStartWithSuccess:YES];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!self.failAnimation) &#123;///未指定动画则使用默认动画</div><div class=\"line\">                [self.thumbLayer addAnimation:defaultFailAnimation(self) forKey:@&quot;failAnimation&quot;];</div><div class=\"line\">            &#125; else &#123;///使用指定动画</div><div class=\"line\">                [self.thumbLayer addAnimation:self.failAnimation forKey:@&quot;failAnimation&quot;];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (result) result(NO);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)moveToPoint:(CGPoint)point animated:(BOOL)animated &#123;</div><div class=\"line\">    if (self.successed) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _indentified = NO;</div><div class=\"line\">    point = fixPointWithLimit(point, self.validSize, self.thumbSize);</div><div class=\"line\">    self.currentPoint = point;</div><div class=\"line\">    if (self.thumbLayer.opacity != 1) &#123;</div><div class=\"line\">        [self showThumbWithAnimated:YES];</div><div class=\"line\">    &#125;</div><div class=\"line\">    DWLayerTransactionWithAnimation(animated, ^()&#123;</div><div class=\"line\">        self.thumbLayer.position = transformLocation2Center(point, self.thumbSize);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setValue:(CGFloat)value animated:(BOOL)animated &#123;</div><div class=\"line\">    CGFloat x = value * self.validSize.width + self.thumbSize.width / 2;</div><div class=\"line\">    CGFloat y = self.targetPoint.y + self.thumbSize.height / 2;</div><div class=\"line\">    [self moveToPoint:CGPointMake(x, y) animated:animated];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)showThumbWithAnimated:(BOOL)animated &#123;</div><div class=\"line\">    DWLayerTransactionWithAnimation(animated,^()&#123;</div><div class=\"line\">        self.thumbLayer.opacity = 1;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)hideThumbWithAnimated:(BOOL)animated &#123;</div><div class=\"line\">    DWLayerTransactionWithAnimation(animated, ^()&#123;</div><div class=\"line\">        self.thumbLayer.opacity = 0;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- tool Method ---</div><div class=\"line\">-(void)handleThumbLayer &#123;</div><div class=\"line\">    UIImage * thumbImage = [self.bgImage dw_SubImageWithRect:self.positionLayer.frame];</div><div class=\"line\">    thumbImage = [thumbImage dw_ClipImageWithPath:self.thumbShape mode:(DWContentModeScaleToFill)];</div><div class=\"line\">    self.thumbLayer.contents = (id)thumbImage.CGImage;</div><div class=\"line\">    self.thumbLayer.frame = self.positionLayer.frame;</div><div class=\"line\">    [self setValue:0 animated:NO];</div><div class=\"line\">    if (!self.thumbLayer.superlayer) &#123;</div><div class=\"line\">        [self.layer addSublayer:self.thumbLayer];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)handlePositionLayer &#123;</div><div class=\"line\">    UIBezierPath * path = [self.thumbShape copy];</div><div class=\"line\">    self.positionLayer.fillColor = [UIColor colorWithWhite:1 alpha:0.7].CGColor;</div><div class=\"line\">    self.positionLayer.path = path.CGPath;</div><div class=\"line\">    self.positionLayer.frame = CGRectMake(self.targetPoint.x, self.targetPoint.y, (int)path.bounds.size.width, (int)path.bounds.size.height);</div><div class=\"line\">    if (!self.positionLayer.superlayer) &#123;</div><div class=\"line\">        [self.layer addSublayer:self.positionLayer];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- animation delegate ---</div><div class=\"line\">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag &#123;</div><div class=\"line\">    if (self.isSuccessed) &#123;</div><div class=\"line\">        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationCompletionWithSuccess:)]) &#123;</div><div class=\"line\">            [self.delegate dw_CaptchaView:self animationCompletionWithSuccess:YES];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dw_CaptchaView:animationCompletionWithSuccess:)]) &#123;</div><div class=\"line\">            [self.delegate dw_CaptchaView:self animationCompletionWithSuccess:NO];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- 内联方法 ---</div><div class=\"line\">///默认滑块形状</div><div class=\"line\">static inline UIBezierPath * puzzlePath ()&#123;</div><div class=\"line\">    UIBezierPath * path = [UIBezierPath bezierPathWithPathMaker:^(DWPathMaker *maker) &#123;</div><div class=\"line\">        maker.MoveTo(0, 8).</div><div class=\"line\">        AddLineTo(12, 8).AddArcWithPoint(12, 8, 20, 8, 5, YES, YES).AddLineTo(32, 8).</div><div class=\"line\">        AddLineTo(32, 20).AddArcWithPoint(32, 20, 32, 28, 5, YES, YES).AddLineTo(32, 40).</div><div class=\"line\">        AddLineTo(20, 40).AddArcWithPoint(20, 40, 12, 40, 5, NO, YES).AddLineTo(0, 40).</div><div class=\"line\">        AddLineTo(0, 28).AddArcWithPoint(0, 28, 0, 20, 5, NO, YES).ClosePath();</div><div class=\"line\">    &#125;];</div><div class=\"line\">    return path;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///指定尺寸内的随机点</div><div class=\"line\">static inline CGPoint randomPointInSize(CGSize size) &#123;</div><div class=\"line\">    CGPoint point = CGPointZero;</div><div class=\"line\">    point.x = randomValueInLength((int)size.width);</div><div class=\"line\">    point.y = randomValueInLength((int)size.height);</div><div class=\"line\">    return point;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///指定范围内的随机值</div><div class=\"line\">static inline int randomValueInLength(int length) &#123;</div><div class=\"line\">    return arc4random() % ((int)(length + 1));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///修正centerY值合适的值</div><div class=\"line\">static inline CGFloat fixCenterYWithSize(CGSize thumbSize,CGSize validSize,CGFloat centerY) &#123;</div><div class=\"line\">    CGFloat y = centerY - thumbSize.height / 2;</div><div class=\"line\">    return fixValueWithLimit(y, validSize.height);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///将值修正至指定范围</div><div class=\"line\">static inline CGFloat fixValueWithLimit(CGFloat value,CGFloat limitLength) &#123;</div><div class=\"line\">    return value &lt; 0 ? 0 : (value &gt; limitLength ? limitLength : value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///将点修正值有效范围内</div><div class=\"line\">static inline CGPoint fixPointWithLimit(CGPoint point,CGSize validSize,CGSize thumbSize) &#123;</div><div class=\"line\">    CGFloat x = point.x - thumbSize.width / 2;</div><div class=\"line\">    CGFloat y = point.y - thumbSize.height / 2;</div><div class=\"line\">    return CGPointMake(fixValueWithLimit(x, validSize.width), fixValueWithLimit(y, validSize.height));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///将验证位置转换为layer中心点</div><div class=\"line\">static inline CGPoint transformLocation2Center(CGPoint origin,CGSize thumbSize) &#123;</div><div class=\"line\">    return CGPointMake(origin.x + thumbSize.width / 2, origin.y + thumbSize.height / 2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///Point转value</div><div class=\"line\">static inline NSValue * valueOfPoint(CGPoint point) &#123;</div><div class=\"line\">    return [NSValue valueWithCGPoint:point];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///默认成功动画</div><div class=\"line\">static inline CAAnimation * defaultSuccessAnimaiton(id&lt;CAAnimationDelegate&gt; delegate) &#123;</div><div class=\"line\">    CABasicAnimation * animation = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];</div><div class=\"line\">    animation.duration = 0.2;</div><div class=\"line\">    animation.autoreverses = YES;</div><div class=\"line\">    animation.fromValue = @1;</div><div class=\"line\">    animation.toValue = @0;</div><div class=\"line\">    animation.removedOnCompletion = YES;</div><div class=\"line\">    animation.delegate = delegate;</div><div class=\"line\">    return animation;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///默认失败动画</div><div class=\"line\">static inline CAAnimation * defaultFailAnimation(id&lt;CAAnimationDelegate&gt; delegate) &#123;</div><div class=\"line\">    DWSlideCaptchaView * captcha = (DWSlideCaptchaView *)delegate;</div><div class=\"line\">    CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class=\"line\">    CGFloat a = 3;</div><div class=\"line\">    CGPoint Cp = captcha.thumbLayer.position;</div><div class=\"line\">    CGPoint Lp = CGPointMake(Cp.x - a, Cp.y);</div><div class=\"line\">    CGPoint Rp = CGPointMake(Cp.x + a, Cp.y);</div><div class=\"line\">    animation.values = @[valueOfPoint(Cp),valueOfPoint(Lp),valueOfPoint(Rp),valueOfPoint(Cp)];</div><div class=\"line\">    animation.repeatCount = 2;</div><div class=\"line\">    animation.removedOnCompletion = YES;</div><div class=\"line\">    animation.duration = 0.2;</div><div class=\"line\">    animation.delegate = captcha;</div><div class=\"line\">    return animation;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark --- setter/getter ---</div><div class=\"line\">-(CAShapeLayer *)positionLayer &#123;</div><div class=\"line\">    if (!_positionLayer) &#123;</div><div class=\"line\">        _positionLayer = [CAShapeLayer layer];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _positionLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CAShapeLayer *)thumbLayer &#123;</div><div class=\"line\">    if (!_thumbLayer) &#123;</div><div class=\"line\">        _thumbLayer = [CAShapeLayer layer];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _thumbLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setThumbShape:(UIBezierPath *)thumbShape &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    CGSize size = thumbShape.bounds.size;</div><div class=\"line\">    if (!(size.width &gt;= 40 &amp;&amp; size.height &gt;= 40)) &#123;</div><div class=\"line\">        NSAssert(NO, @&quot;To get a better experience,the width and height of thumbShape both should be more than 40.&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    _thumbShape = thumbShape;</div><div class=\"line\">    _thumbSize = size;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(UIBezierPath *)thumbShape &#123;</div><div class=\"line\">    if (!_thumbShape) &#123;</div><div class=\"line\">        return puzzlePath();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _thumbShape;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setTargetValue:(CGFloat)targetValue &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _targetValue = fixValueWithLimit(targetValue, 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setThumbCenterY:(CGFloat)thumbCenterY &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _thumbCenterY = thumbCenterY;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setUseRandomValue:(BOOL)useRandomValue &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _useRandomValue = useRandomValue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setTolerance:(CGFloat)tolerance &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _tolerance = tolerance;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGFloat)tolerance &#123;</div><div class=\"line\">    if (_tolerance &lt; 0) &#123;</div><div class=\"line\">        return 3;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _tolerance;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setSuccessAnimation:(CAAnimation *)successAnimation &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _successAnimation = successAnimation;</div><div class=\"line\">    _successAnimation.delegate = self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setFailAnimation:(CAAnimation *)failAnimation &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    _failAnimation = failAnimation;</div><div class=\"line\">    _failAnimation.delegate = self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setBgImage:(UIImage *)bgImage &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    if (bgImage) &#123;</div><div class=\"line\">        _bgImage = [bgImage dw_RescaleImageToSize:self.frame.size];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        _bgImage = nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setThumbSize:(CGSize)thumbSize &#123;</div><div class=\"line\">    SafeConfiguration</div><div class=\"line\">    if (!CGSizeEqualToSize(_thumbSize, thumbSize)) &#123;</div><div class=\"line\">        _thumbSize = thumbSize;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGPoint)targetPoint &#123;</div><div class=\"line\">    if (!self.resetTargetPoint) &#123;</div><div class=\"line\">        return _targetPoint;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.resetTargetPoint = NO;</div><div class=\"line\">    if (self.useRandomValue) &#123;</div><div class=\"line\">        _targetPoint = randomPointInSize(self.validSize);</div><div class=\"line\">        return _targetPoint;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat x = (self.targetValue != DWSlideCaptchaUndefineValue) ? self.targetValue : randomValueInLength((int)self.validSize.width);</div><div class=\"line\">    CGFloat y = (self.thumbCenterY != DWSlideCaptchaUndefineValue) ? fixCenterYWithSize(self.thumbSize, self.validSize, self.thumbCenterY) : randomValueInLength((int)self.validSize.height);</div><div class=\"line\">    _targetPoint = CGPointMake(x, y);</div><div class=\"line\">    return _targetPoint;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGSize)validSize &#123;</div><div class=\"line\">    return CGSizeMake(self.bounds.size.width - self.thumbSize.width, self.bounds.size.height - self.thumbSize.height);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>恩，这个库老司机不仅上传到GitHub上面，还让他支持了Cocoapods，你可以通过 <code>pod &#39;DWSlideCaptchaView&#39;, &#39;~&gt; 1.0.2&#39;</code>来集成这个视图，觉得好请Star。</p>\n<p>说到这里老司机说一下，现在你可以通过<code>pod search wicky</code>命令搜索老司机上传到Cocoapods上面的类库，目前有三个：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-03eb96944d07d1fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"当前支持Cocoapods的库\"></p>\n<p>老司机这里还是主推DWCoreTextLabel，他是一个基于CoreText的异步绘制的图文混排控件，并且支持图片的异步加载与缓存，基本上可以完美的实现图文混排需求。你值得使用。</p>\n<p>DWCheckBox就是单选复选框了，也是一个快捷使用并且有着高定制型的类库。</p>\n<hr>\n<h3 id=\"继承UIControl重新实现一个Slider\"><a href=\"#继承UIControl重新实现一个Slider\" class=\"headerlink\" title=\"继承UIControl重新实现一个Slider\"></a>继承UIControl重新实现一个Slider</h3><p>广告打完了咱们来看第二环节，slider。<br>最初的时候其实我就是想实现后面那个步进Slider，最初的想法继承UISlider去重写，奈何转了一大圈，各种私有属性用一遍也无法完美的完成我的需求。</p>\n<p>主要是由于UISlider中对于滑块和滑竿的定制性很困难，所以自己重写一个Slider吧。</p>\n<p>所以为什么想到继承自UIControl去写呢？第一是UISlider继承自UIControl，第二是UIControl封装了<code>-addTarget:selector:events</code>以及事件追踪的一系列方法。</p>\n<p>其实UIControl有四个核心的方法，是用于控制事件追踪的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">///判断是否开始事件追踪</div><div class=\"line\">-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</div><div class=\"line\">///判断事件追踪是否继续</div><div class=\"line\">-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</div><div class=\"line\">///事件追踪取消时处理</div><div class=\"line\">-(void)cancelTrackingWithEvent:(UIEvent *)event;</div><div class=\"line\">///事件追踪结束时处理</div><div class=\"line\">-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</div></pre></td></tr></table></figure></p>\n<p>使用方法无非就是判断当视图接收到事件是如何追踪，可以看一下老司机写Slider的处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- tracking Method ---</div><div class=\"line\">-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    location = [self.thumbLayer convertPoint:location fromLayer:self.layer];</div><div class=\"line\">    if ([PathWithBounds(self.thumbLayer.bounds, FitCornerRadius(self.thumbLayer, self.thumbCornerRadius)) containsPoint:location]) &#123;</div><div class=\"line\">        self.clickOnThumb = YES;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    location = [self.trackBgLayer convertPoint:location fromLayer:self.thumbLayer];</div><div class=\"line\">    if ([PathWithBounds(self.trackBgLayer.bounds, FitCornerRadius(self.trackBgLayer, self.trackCornerRadius)) containsPoint:location]) &#123;</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    CGFloat margin = FitMarginForThumb(self.thumbSize, [self thumbMarginForBounds:self.bounds]);</div><div class=\"line\">    location.x -= margin;</div><div class=\"line\">    CGFloat actualW = CGRectGetWidth([self trackRectForBounds:self.bounds]) - margin * 2;</div><div class=\"line\">    if (location.x &lt; 0) &#123;</div><div class=\"line\">        location.x = 0;</div><div class=\"line\">    &#125; else if (location.x &gt; actualW) &#123;</div><div class=\"line\">        location.x = actualW;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat percent = location.x / actualW;</div><div class=\"line\">    CGFloat value = self.minimumValue + (self.maximumValue - self.minimumValue) * percent;</div><div class=\"line\">    if (value == self.value) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _value = value;</div><div class=\"line\">    [self sendActionsForControlEvents:UIControlEventValueChanged];</div><div class=\"line\">    if (self.clickOnThumb) &#123;</div><div class=\"line\">        [self updateValueAnimated:NO];</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [self updateValueAnimated:YES];</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancelTrackingWithEvent:(UIEvent *)event &#123;</div><div class=\"line\">    self.clickOnThumb = NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    self.clickOnThumb = NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>处理过事件追踪，我们只要处理好视图相关的内容即可。</p>\n<p>此处可以分为两种思路，一种是通过DrawRect方法去追踪行为后不断绘制，另一种是通过Layer展示各个图层并追踪行为。这里呢，老司机更加推荐使用Layer去处理图层，因为本身DrawRect方法中的代码是使用CPU进行预算然后将bitmap提交给GPU，他处理绘制的速度远不如CALayer直接使用GPU来的快。</p>\n<p>图层的绘制老司机在CoreAnimation系列中已经写得很细了，在这也就不多写了。<br>老司机重写的DWSlider是一个UISlider的替换类，它具备UISlider的所有功能，并且还能自由定制你的Slider的各个属性，相比UISlider来讲可玩性更强，老司机这里放一个<a href=\"https://github.com/CodeWicky/-Tools/tree/master/DWSlider\" target=\"_blank\" rel=\"external\">传送门</a>。</p>\n<hr>\n<h3 id=\"步进Slider\"><a href=\"#步进Slider\" class=\"headerlink\" title=\"步进Slider\"></a>步进Slider</h3><p>DWStepSlider是一个分段的Slider，继承自DWSlider。<br>主要是实现分段的Slider至实现，主要思想还是通过更改事件追踪后的赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark --- tracking Method ---</div><div class=\"line\">-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    location = [self.thumbLayer convertPoint:location fromLayer:self.layer];</div><div class=\"line\">    if ([PathWithBounds(self.thumbLayer.bounds, FitCornerRadius(self.thumbLayer, self.thumbCornerRadius)) containsPoint:location]) &#123;</div><div class=\"line\">        self.clickOnThumb = YES;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    location = [self.trackBgLayer convertPoint:location fromLayer:self.thumbLayer];</div><div class=\"line\">    if ([PathWithBounds(self.trackBgLayer.bounds, FitCornerRadius(self.trackBgLayer, self.trackCornerRadius)) containsPoint:location]) &#123;</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    CGPoint location = [touch locationInView:self];</div><div class=\"line\">    CGFloat margin = FitMarginForThumb(self.thumbSize, [self thumbMarginForBounds:self.bounds]);</div><div class=\"line\">    location.x -= margin;</div><div class=\"line\">    CGFloat actualW = CGRectGetWidth([self trackRectForBounds:self.bounds]) - margin * 2;</div><div class=\"line\">    if (location.x &lt; 0) &#123;</div><div class=\"line\">        location.x = 0;</div><div class=\"line\">    &#125; else if (location.x &gt; actualW) &#123;</div><div class=\"line\">        location.x = actualW;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CGFloat percent = location.x / actualW;</div><div class=\"line\">    CGFloat value = self.minimumValue + (self.maximumValue - self.minimumValue) * percent;</div><div class=\"line\">    if (value == self.value) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self setValue:value updateThumb:NO];</div><div class=\"line\">    [self sendActionsForControlEvents:UIControlEventValueChanged];</div><div class=\"line\">    if (self.clickOnThumb) &#123;</div><div class=\"line\">        [self updateValueAnimated:NO];</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [self setValue:FixValue(value, _nodes.count) updateThumb:NO];</div><div class=\"line\">        [self updateValueAnimated:YES];</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancelTrackingWithEvent:(UIEvent *)event &#123;</div><div class=\"line\">    if (self.clickOnThumb) &#123;</div><div class=\"line\">        self.value = FixValue(self.value, _nodes.count);</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    if (self.clickOnThumb) &#123;</div><div class=\"line\">        self.value = FixValue(self.value, _nodes.count);</div><div class=\"line\">        self.clickOnThumb = NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至于图形还是CAShapeLayer的各种形状，老司机也早就说过了，还是<a href=\"https://github.com/CodeWicky/Components/blob/master/%E6%AD%A5%E8%BF%9B%E6%BB%91%E7%AB%BF\" target=\"_blank\" rel=\"external\">传送门</a>吧。</p>\n<hr>\n<p>好吧，今天其实也没什么新鲜内容，毕竟都是一些UI控件的封装。<br>不过也是捋一下思路，控件要如何封装，所以还是不要脸的发出来了。<br>喜欢哪个给哪个<strong>Star</strong>吧~恩，就是这么好意思~<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1f4614d93cbc24e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图文无关\"></p>"},{"title":"老司机出品——包教包会之玩转正则表达式","layout":"post","date":"2017-02-14T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![玩转正则表达式](http://upload-images.jianshu.io/upload_images/1835430-eab975ab3f151634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> **2017年2月16日14时11分更新Level3详解**\n\n结束了CoreAnimation系列之后，老司机心里仿佛也轻松了许多。今天说说开发中的一个利器吧，`正则表达式`。\n\n### 正则表达式是什么\n\n\n> 正则表达式，又称规则表达式。（英语：Regular Expression，在代 码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。\n\n其实借助正则表达式，我们可以对`字符串进行很多操作`，最大的优势就是从字符串中`获取字符串以及判断字符串`是否符合条件。\n\n然而事实上有很多程序员都抱怨，正则表达式的语法晦涩难懂，的确，一个个符号看似毫无规律的拼凑在一起让人看起来确实头疼。\n\n幸运的是，老司机曾经拿出两个下午来认真的研究了一下正则表达式，所以老司机也是目前我们组唯一一个`手撸正则`表达式的骚年，so，让老司机沾沾自喜一下可好~\n\n![沾沾自喜](http://upload-images.jianshu.io/upload_images/1835430-f2fc446ab22a9826.gif?imageMogr2/auto-orient/strip)\n\n当然，嘚瑟完还是要来干货的，那老司机用老司机的方式带你看一下正则。\n\n<!-- more -->\n\n- - -\n\n### 元字符\n\n让我们先啃一下硬骨头，`元字符`。\n\n所谓元字符，就是几个特定的符号组合在一起，其代表的含义已经不是原先符号本身的含义，而更像是一个表达式。\n\n正则表达式正是因为元字符而变的晦涩，也正是因为元字符而变的简洁。\n\n![元字符1](http://upload-images.jianshu.io/upload_images/1835430-d2ba2eb18b01d763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![元字符2](http://upload-images.jianshu.io/upload_images/1835430-7b59460c9d2dccfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![元字符3](http://upload-images.jianshu.io/upload_images/1835430-8fa4634e2d4738c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n以上图片截自百度百科[正则表达式](http://baike.baidu.com/link?url=hPmdeeyjNvVV2j63KFbzPtL6Ry0hG3Rt5YNHZhrcID7ghrgZiLYAir9Ozm1aYtrmr6lyOj4RpSnadJcoJUzW_saC-uAmU1ySO7RLzboZs9nQH463j6k0VAiPjtl-eUdOpktwGYvWAWKuL5WWnQIQGK)\n\n- - - \n#### Level1\n\n元字符之多，多到让人记不住，不过老司机之前说过，元字符不过是`带有特定含义的表达式`用来让表达式简洁，所以你不用表达式，用最基本的字符完全可以组成表达式，比如下面这种情况：\n\n- [0123456789] 你可以用这个表达式来代表一个数字元素\n- [0-9] 你同样可以用这个表达式代表一个数字元素\n- \\d 你更可以用这个表达式代表一个数字元素\n\n从上至下，表达式形式越来越简单，不过其书写形式却越来越难懂。\n所以即使你记不住`\\d`,你也可以用`[0123456789]`来替代，当你熟练了，自然也就记住`\\d`了对不对。\n\n所以说，并不是所有元字符你都需要记住的，不过老司机挑了这么几个出来，是能大幅度提高你书写速度的几个元字符：\n\n- []\t对于他，我的命名是元素枚举表达式，表示中括号之间的任意一个元素均可以当做作为一个元素存在。\n- {n,m} 这个，我姑且称他为范围表达式。他的含义是表示他前面的元素有x个，x介于[n,m]之间的闭区间（即包含n,m）。\n\n> eg.\t\t结合上面两个表达式，我们可以这样写一个表达式：`[0123456789]{1,2}`，其含义是一个1到2位的纯数字。当然`\\d{1,2}`会让你的表达式看起来更加简洁。\n\n- ()\t括号表达式，他的含义仅仅是将括号间的所有表达式作为一个整体看做新的元素。\n\n> eg.\t\t到这里你可以写这样一个表达式：\n`([a-z]{1,2}[\\d]{1,2}){1,2}`，恩，是不是已经乱七八糟了，我们一点一点拆解，`[a-z]{1,2}`表示`1或2个小写字母`，`[\\d]{1,2}`表示`1或2个数字`，两个表达式连一起就是`1或2个小写字母后面紧跟1或2个数字`（例如`ab12`），然后[a-z]{1,2}[\\d]{1,2}被扩在小括号表达式中，他们已经`作为一个整体被视为一个元素`，这样的`元素又有1或2个`，所以符合这个表达式的字符串可能是这个样子的：`a12bc1`\n\n所以说这么一个难看的表达式一点一点拆解我们也是能看懂的是吧\n\n- . 点表达式，标识除“\\r\\n”之外的任何单个字符\n\n- |\t\t或表达式，表示 | 前后的两个元素中任意一种情况\n\n到了这里，你已经可以写出任意一个表达式了，这些就够了。\n\n\n> 比如说既包含字母又包含数字的字符串：\n> \n>`\\d{0,}([a-z]{1,}\\d{1,}){1,}[a-z]{0,}`\n>\n>这是一个比较丑的表达式，不过他真的能匹配所有情况，你可以慢慢想一下（别太仔细想，虽然可以这么用不过太单纯了，没人这么用的）。\n>\n\n如果说你不介意，到这里，你已经学够了，我似乎看到了你满足的表情。\n\n![满足了](http://upload-images.jianshu.io/upload_images/1835430-5737d4049d454ba3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- - -\n#### Level2\n\n你的手没有因为看到上面那张图而离开鼠标😏，而是继续看到这说明你已经不是随随便便就能春心荡漾的小朋友了，那么现在请你系好安全带，要发车了！\n\n![要发车了！](http://upload-images.jianshu.io/upload_images/1835430-f253237e28f7c6e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以说单纯一个同时包含数字字母就要这么臭又长的表达式的话，正则表达式也就真没有存在的意义了。这种有先决条件的表达式我们要怎么处理呢？\n是否能先处理先决条件再进行匹配呢？\n\n答案当然是肯定的，你要了解`预查模式`。\n\n所谓预查模式就是`首先检查整个元素`是否满足条件，`满足后再进行逐一匹配`。\n\n预查有下面几种形式：（下列pattern均代表表达式）\n\n- (?=pattern)\t\t正向肯定预查\n- (?!pattern)\t\t正向否定预查\n\n所谓正向就是固定字符串在前，条件字符串在后。肯定就是包含条件中的字符串，否定就是不包含条件中的字符串。\n\n> 经典的例子就是windows(?=2000|Vista)，首先固定字符串是windows，即字符串中一定要包含windows。条件字符串是包含2000或者Vista，所以windows2000和windowsVista都可以正确匹配，这是正向肯定预查。举一反三的你相信正向否定，反向肯定，反向否定都能理解了吧知道怎么用了吧。\n\n此处我已经假设你通过自己的感悟已经理解了反向预查，只写式子了（如果没明白在慢慢想会，想累了就回头看看Level1最后的图片😏）。\n\n- (?<=pattern)\t反向肯定预查\n- (?<!pattern)\t反向否定预查\n\n到这了你应该已经明白预查的含义，但是你跟我说你记不住这稀奇古怪的表达式。没关系，看好了，划重点啊，考试专门考这啊，老司机给你拆开：\n\n> “？”代表预查\n> \n> “=”代表肯定\n> \n> “!”代表否定\n> \n> “<”代表反向\n\n好了，你可以准备好仰天长啸了，大喊还有谁！\n\n![还有谁！](http://upload-images.jianshu.io/upload_images/1835430-0b147d01fc08c8d3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n恩，别嘚瑟，还有我！\n\n事实上，我们用预查方式，更多的用到的是正向预查（反向预查通常有点反人类思维），而且用到他的变体更多：\n\n- (?=[pattern]+$)\t告诉我这是什么？“?”看到没有，预查，“=”看到没有？肯定预查，有没有“<”？没有，正向肯定预查！简不简单！！！！！额外解释一下，+等价于{1,}，$代表的是字符串结尾（所以说一些特殊的助记符真的是可以多学学的）。\n\n> 所以这个条件如果放在一个表达式的最开始就说明：\n> \n> 1.固定字符串没有，那么条件字符串就是开头了\n> \n> 2.条件字符串至少一个\n> \n> 3.条件字符串匹配到字符串结尾，所以条件字符串就是字符串结尾了\n> \n> 所以说结论是什么？就是字符串从头到尾都由pattern组成，也就是allIs。\n\n- (?!.\\*[pattern].\\*) 告诉我这是啥？诶对了，正向否定预查！老司机再带你捋一个啊。\n\n> 1.固定字符串没有，条件字符串开头了\n> \n> 2.条件字符串由任意任意字符开头，中间是条件字符串，后面又是任意个数任意字符，说明什么，条件就是包含pattern对吧！\n> \n> 3.这是什么？否定预查，所以是什么？不包含！\n> \n> 结论？字符串不包含pattern，什么意思？从头到尾都不是pattern，对不对？！！！allNot，诶，英语就是这么溜！\n\n那么老司机就不一一带着你捋了，自己感悟啊！\n\n- (?![pattern]+$) 直接给我说答案？是什么？诶，不全是pattern对不对？英语是什么？？notAll！\n\n- (?=.*[pattern]) 是不是包含？是不是！诶，对了！contain！对不对！！！！就问你对不对！\n\n现在来，给我回到上面的需求，同时包含字母和数字怎么写？\n\n是不是`((?=.*\\d)(?=.*[a-zA-Z]))[\\da-zA-Z]*`?!简单不简单，透彻不透彻！！！\n这回是不是又觉得自己无敌了！还有谁！！！\n\n**别闹，还有我啊~**\n\n![还有我啊~](http://upload-images.jianshu.io/upload_images/1835430-22cc41a2b7b6b50d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n- - -\n#### Level3\n\n还有什么？还有多着呢，那么多助记符、那么多控制符、负值字符范围、边界匹配、获取匹配、贪婪模式等等。。。\n\n恩，我发现关注的人很多，所以今天来把Level3中内容补充一下。\n\n- ^  负字符范围。表示排除此字符集的其他范围。`[^\\d]`即标识除数字外的其他字符合集。\n\n实际使用中，他是可以配合预查来完成一些任务。\n比如说要表示除了4的数字合集，你可以有几种表达方式：\n> - [012356789]\n- [0-3,5-9]\n- (?=\\d+$)([^4]*)\n\n前两个不说了，可读性很强，第三个，先是`预查并且是allIs模式`对吧，就`限制了全由数字`组成，然后用`负字符范围排除了4`，这样就是排除了4的数组集合。不过你可能说你用`第二种方式可读性高且也符合`，不过如果需求编程全部中文排除“我们”这两个字符呢，你要怎么搞。。所以说它是有它的`应用范围`的。`没有最合理的，只有最适合的`。\n\n- \\b 边界匹配，要求表达式要在字符串的边界。此处边界通常以结尾或者空格进行区分。\n\n> eg.比如说要匹配所有以er结尾的字符串，你可以这样`[a-z]*(er)\\b`，他能匹配her，但是verb就不行。\n同样的`\\B`就是不在边界。\n\n- 贪婪模式，及尽可能的多去匹配。我们的正则引擎一般是默认贪婪模式的。如果想切换为非贪婪模式则在范围表达式后添加\"?\"来表示当前为非贪婪模式。\n\n> eg.字符串abcdefg，你要获取不重复的所有长度至少为2的子串，你可以这样写`[a-z]{2,}`,这时你获得的结果将只有一个`abcdefg`,因为贪婪模式下会尽可能的多匹配，而下限是2上限没有，所以匹配到整串结果。如果你这样写`[a-z]{2,}?`，那么当前条件被转换为非贪婪模式。你获得的结果是`ab`、`cd`、`ef`三个结果。\n\n- 获取与非获取，准确的说这不是作为条件出现的。上文中提到的括号表达式，就是否会获取结果。如上述中提到的预查模式，实际上都是非获取模式，就是并不会保存结果，只是提前对整串进行校验。而获取匹配到的结果并供后面的表达式使用。这个还是比较难以理解的，老司机要配合例子或许你才能懂。\n\n> eg.需求1. 找出字符串abbbccc中任意连续出现3次的字母。\n乍一看任意连续出现三次的字母你怎么写？`[a-z]{3}`这样么？这样子可不行，这可没规定连续。首先我们知道，一个正则表达式是由多个正则表达式组成的。所以你现在想的是不是我获取到一个符合结果的字符串，他的表达式应该由两部分组成，第一部分是匹配我要的第一个字母，第二部分是把第一部分匹配的字母重复两次。`([a-z])`这样你获取到的第一个字母，然后我要使用第一个表达式的结果重复两次。所以你应该这么写`([a-z])\\1{2}`。老司机解释一下，这个表达式的意思是分成两部分([a-z])获取任意字符并将其保存在临时的地方作为一个后面可用的条件子串。`\\1`代表取出第一个临时子串，`{2}`就是范围限定符，将前面取出的元素重复两次。所以abbbcbb中，当第一个字母a作为`([a-z])`所保存的临时子串时，`\\1`就代表a，然而并没有连续的三个a，所以不符合。当b作为临时子串时，`\\1`代表b，后面有两个连续的b，符合结果。\n\n> 再来一个深入理解一下。如果我想取出abbbccc中的bccc怎么办呢？我们的表达式应该由3部分组成，第一部分匹配一个字母,第二部分匹配一个字母，第三部分是第二部分重复两次。`([a-z])([a-z])\\2{2}`么？不对，为什么？这样你将获取到abbb。因为a配[a-z]，然后b匹配第二个[a-z]，然后取出第二个结果b重复两次，那就是abbb。然后将从c开始继续检查后面的字符串。不过至少我们思路对了，只要我们不然abbb符合结果即可，简单修改`([^a])([a-z])\\2{2}`。这时a就不能作为第一个字母出现了，所以就轮到bccc了是吧。\n\n> 最后一个例子不分拆讲解，想获取abbbcbb中的bcbb怎么办？看看是不是这个表达式：`([a-z])([a-z])\\1{2}`。对的，不解释。\n\n其余就是助记符了，虽然多，但都是等价替换，老司机不细讲，看看最开始的表吧。\n\n\n助记符不算，另一种表达方式，控制符也就是几个特殊符号，负值、边界用起来也很简单，获取匹配、贪婪模式，多看看也能消化。而且这些Level3的东西都是锦上添花的东西，不必须掌握。\n\n> 所以大声告诉我，正则会没会！！！\n> \n> 会！\n> \n> 简不简单！！！\n> \n> 简单！\n> \n> 老司机屌不屌！！！\n> \n> 屌！真屌！太屌了！非常之屌！24K纯屌！\n\n- - - \n然后放一些老司机搜集并验证过的常用正则吧：\n\n|类别                |表格                |\n|:-------------:|:-------------:|\n|数字|  \\d+|\n| 字母 | [a-zA-Z]+ |\n|中文 |[\\\\u4E00-\\\\u9FA5]+|\n| 所有符号|[\\\\W_]+|\n|Email|^[A-Za-z\\\\d]+([-_.][A-Za-z\\\\d]+)*@([A-Za-z\\\\d]+[-.])*([A-Za-z\\\\d]+[.])+[A-Za-z\\\\d]{2,5}$|\n|手机号码|1[34578]\\\\d{9}|\n|座机电话|(0[\\\\d]{2,3}-)?([2-9][\\\\d]{6,7})(-[\\\\d]{1,4})?|\n|自然数|\\\\d+(\\\\.\\\\d+)?|\nURL这个放在表格里面格式就不对了，我就放外面了：\nURL = ((http|ftp|https)://)?((([a-zA-Z0-9]+[a-zA-Z0-9_-]\\*\\\\.)+[a-zA-Z]{2,6})|(([0-9]{1,3}\\\\.){3}[0-9]{1,3}(:[0-9]{1,4})?))((/[a-zA-Z\\\\d_]+)\\*(\\\\?([a-zA-Z\\\\d_]+=[a-zA-Z\\\\d\\\\u4E00-\\\\u9FA5\\\\s\\\\+%#\\_-]+&)*([a-zA-Z\\\\d\\_]+=[a-zA-Z\\\\d\\\\u4E00-\\\\u9FA5\\\\s\\\\+%#_-]+))?)?\n\n\n\n- - -\n\n冲着老司机情人节不开房开博客的情怀，是不是应该有一大波赞！！！一大波关注！！！！一大波star！！！！！\n\n- - -\n\n不过熟悉老司机的童靴是知道老司机的套路的，老司机讲课要什么？\n\n要赞！要关注！！要star！！！\n\n这期带来的小工具：\n\n[DWRegexUtils](https://github.com/CodeWicky/-Tools/tree/master/DWRegExpUtils)\n\n正则工具类，这也是老司机的心血结晶啊，提供自然人思维的链式语法优雅的返回正则表达式。\n\n![虽然这点难以解释](http://upload-images.jianshu.io/upload_images/1835430-c34ec5e64aa0c67d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n预置常用正则表达式。\n\n![预置校验1](http://upload-images.jianshu.io/upload_images/1835430-ac8a766a7c4742c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![预置校验2](http://upload-images.jianshu.io/upload_images/1835430-b1e12f10f021e21f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n提供正则判断的工具类！\n\n如果觉得好用可以给整个仓库一个star哟！整个仓库里面全都是工具类哟！上哪里去找这么好的仓库！！！[仓库传送门](https://github.com/CodeWicky/-Tools)\n- - -\n\n有童鞋说这个工具类不会使用，恩，我理解！因为提供的自由度较广所以传参比较多，所以老司机昨天发博客的时候自己想捋捋怎么用也回忆了一小下，那我就简单说一下吧。\n\n首先，需明确的概念是，在这个工具类中，老司机是想以一种`组件`的形式去生成正则表达式。组件对应的就是`正则表达式中元素`的概念。\n从头文件中可以看到，老司机使用一个枚举（严格点这是按位掩码）定义了组件类型DWRegexComponent。使用的时候你可以\n`DWRegexComponentNumber |DWRegexComponentUppercaseLetter`这样来表示数字和大写字母同时作为组件元素。\n\n第二个概念是`条件`。其实上面的教程里你应该发现了正则就是用`一个个小的表达式组成一个大的表达式`。而老司机这里就是一`添加条件的方式来添加表达式`。我用了另一个枚举类型DWRegexCondition定义了6种条件方式。其中4种是预查，allIs，allNot，notAll，contain，这些都是预查条件，所有都有PreSearch前缀。还有两种子式条件contain和without，即包含与非包含。\n\n恩，两个枚举完事了，搞定剩下三个api，你就能用它写出正则了。\n\n说说为什么会是链式语句呢？因为`链式语句从形式上更能代表人的顺向思维`，所谓想到哪写到哪，所以采用了链式语句生成正则，用过masonry的童鞋一定可以很快上手。\n\n首先调用`+dw_GetRegexStringWithMaker:`方法来以block形式生成正则语句。\n\n一下三个api都可以通过maker的点语法点出来，类比masonry就好了。\n\n> AddConditionWithComponentType()\n\n这个方法你要传6个参数，有点多呵呵🙃。\n分别是`组件、额外字符串、条件、最小匹配数、最大匹配数及是否为贪婪模式`。\n有了枚举的介绍其实你应该仅不知道额外字符串是什么鬼。\n首先`以组件来做成基本元素`，然而老司机预置的组件中可能`不能代表全部你要的元素`，所以可以`通过额外字符串来对组件进行补充`。然后`以组件和额外字符串作为元素`，`配合条件即范围生成一条正则表达式`。\n上图例子中的，详情请见上面图的第一个表达式。\n\n> AddConditionWithComponentRegexString()\n\n举一反三的想一下，套路是一样的。你需要5个参数，`子串、条件、两端范围及贪婪模式`。\n应用场景就是你不想用组件模式生成元素，而是想`手撸一个元素集合`时，子串即传入你的元素集合，在`添加条件、范围即可`，例子见第二个表达式。\n\n> AddConditionWithCompleteRegexString()\n\n仅需要传入两个参数，即你连范围都能自己撸，你就写一个`完整的正则表达式作为元素`，`添加条件组成一个更加丰富的正则表达式`。\n\n所以说`借助这三个api加以你灵活的使用`你就能生成所有你想要的表达式，只要你能够把大需求拆分成一个个小条件。`事实上第一个api自由度最高，你熟练使用这个就行`。\n\n最后，这三个api中如果你的`条件模式为预查`，则`无论你在什么位置`添加条件，最后都会`自动的拼接在正则表达式的前方`。而`子式条件添加的顺序即为子式的顺序`。\n\n恩，有了讲解配合上面的例子，这个工具类应该就可以使用了。不是吹捧自己的东西，只要`熟练使用第一个api`你真的能写出所有正则，你需要的只是学习一个api的成本。另外，`用多了或许你就能很好的拆分了，然后自己也就能写了`。\n\n- - -\n另外，DWCoreTextLabel已经全面支持自动链接匹配了，包括数字、email、url链接、手机号等。欢迎star！！！跪求star！！！这是老司机主力推的库😢。\n\n### 软广\n\nDWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。\n\n>version 1.1.0\n>全面支持自动链接支持、定制检测规则、图文混排、响应事件\n>优化大部分算法，提高响应效率及绘制效率\n \n>version 1.1.1\n>高亮取消逻辑优化\n>自动检测逻辑优化\n>部分常用方法改为内联函数，提高运行效率\n \n>version 1.1.2\n>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）\n \n>version 1.1.3\n>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中\n \n>version 1.1.4\n>事务管理类去除，异步绘制文件抽出\n \n>version 1.1.5\n>添加网络图片异步加载库，支持绘制网络图片\n>\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n\n\n![爱你哟](http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/老司机出品——包教包会之玩转正则表达式.md","raw":"\n---\ntitle: 老司机出品——包教包会之玩转正则表达式\nlayout: post\ndate: 2017-02-15 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- 正则表达式 \ncategories: 正则表达式\n---\n\n![玩转正则表达式](http://upload-images.jianshu.io/upload_images/1835430-eab975ab3f151634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> **2017年2月16日14时11分更新Level3详解**\n\n结束了CoreAnimation系列之后，老司机心里仿佛也轻松了许多。今天说说开发中的一个利器吧，`正则表达式`。\n\n### 正则表达式是什么\n\n\n> 正则表达式，又称规则表达式。（英语：Regular Expression，在代 码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。\n\n其实借助正则表达式，我们可以对`字符串进行很多操作`，最大的优势就是从字符串中`获取字符串以及判断字符串`是否符合条件。\n\n然而事实上有很多程序员都抱怨，正则表达式的语法晦涩难懂，的确，一个个符号看似毫无规律的拼凑在一起让人看起来确实头疼。\n\n幸运的是，老司机曾经拿出两个下午来认真的研究了一下正则表达式，所以老司机也是目前我们组唯一一个`手撸正则`表达式的骚年，so，让老司机沾沾自喜一下可好~\n\n![沾沾自喜](http://upload-images.jianshu.io/upload_images/1835430-f2fc446ab22a9826.gif?imageMogr2/auto-orient/strip)\n\n当然，嘚瑟完还是要来干货的，那老司机用老司机的方式带你看一下正则。\n\n<!-- more -->\n\n- - -\n\n### 元字符\n\n让我们先啃一下硬骨头，`元字符`。\n\n所谓元字符，就是几个特定的符号组合在一起，其代表的含义已经不是原先符号本身的含义，而更像是一个表达式。\n\n正则表达式正是因为元字符而变的晦涩，也正是因为元字符而变的简洁。\n\n![元字符1](http://upload-images.jianshu.io/upload_images/1835430-d2ba2eb18b01d763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![元字符2](http://upload-images.jianshu.io/upload_images/1835430-7b59460c9d2dccfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![元字符3](http://upload-images.jianshu.io/upload_images/1835430-8fa4634e2d4738c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n以上图片截自百度百科[正则表达式](http://baike.baidu.com/link?url=hPmdeeyjNvVV2j63KFbzPtL6Ry0hG3Rt5YNHZhrcID7ghrgZiLYAir9Ozm1aYtrmr6lyOj4RpSnadJcoJUzW_saC-uAmU1ySO7RLzboZs9nQH463j6k0VAiPjtl-eUdOpktwGYvWAWKuL5WWnQIQGK)\n\n- - - \n#### Level1\n\n元字符之多，多到让人记不住，不过老司机之前说过，元字符不过是`带有特定含义的表达式`用来让表达式简洁，所以你不用表达式，用最基本的字符完全可以组成表达式，比如下面这种情况：\n\n- [0123456789] 你可以用这个表达式来代表一个数字元素\n- [0-9] 你同样可以用这个表达式代表一个数字元素\n- \\d 你更可以用这个表达式代表一个数字元素\n\n从上至下，表达式形式越来越简单，不过其书写形式却越来越难懂。\n所以即使你记不住`\\d`,你也可以用`[0123456789]`来替代，当你熟练了，自然也就记住`\\d`了对不对。\n\n所以说，并不是所有元字符你都需要记住的，不过老司机挑了这么几个出来，是能大幅度提高你书写速度的几个元字符：\n\n- []\t对于他，我的命名是元素枚举表达式，表示中括号之间的任意一个元素均可以当做作为一个元素存在。\n- {n,m} 这个，我姑且称他为范围表达式。他的含义是表示他前面的元素有x个，x介于[n,m]之间的闭区间（即包含n,m）。\n\n> eg.\t\t结合上面两个表达式，我们可以这样写一个表达式：`[0123456789]{1,2}`，其含义是一个1到2位的纯数字。当然`\\d{1,2}`会让你的表达式看起来更加简洁。\n\n- ()\t括号表达式，他的含义仅仅是将括号间的所有表达式作为一个整体看做新的元素。\n\n> eg.\t\t到这里你可以写这样一个表达式：\n`([a-z]{1,2}[\\d]{1,2}){1,2}`，恩，是不是已经乱七八糟了，我们一点一点拆解，`[a-z]{1,2}`表示`1或2个小写字母`，`[\\d]{1,2}`表示`1或2个数字`，两个表达式连一起就是`1或2个小写字母后面紧跟1或2个数字`（例如`ab12`），然后[a-z]{1,2}[\\d]{1,2}被扩在小括号表达式中，他们已经`作为一个整体被视为一个元素`，这样的`元素又有1或2个`，所以符合这个表达式的字符串可能是这个样子的：`a12bc1`\n\n所以说这么一个难看的表达式一点一点拆解我们也是能看懂的是吧\n\n- . 点表达式，标识除“\\r\\n”之外的任何单个字符\n\n- |\t\t或表达式，表示 | 前后的两个元素中任意一种情况\n\n到了这里，你已经可以写出任意一个表达式了，这些就够了。\n\n\n> 比如说既包含字母又包含数字的字符串：\n> \n>`\\d{0,}([a-z]{1,}\\d{1,}){1,}[a-z]{0,}`\n>\n>这是一个比较丑的表达式，不过他真的能匹配所有情况，你可以慢慢想一下（别太仔细想，虽然可以这么用不过太单纯了，没人这么用的）。\n>\n\n如果说你不介意，到这里，你已经学够了，我似乎看到了你满足的表情。\n\n![满足了](http://upload-images.jianshu.io/upload_images/1835430-5737d4049d454ba3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- - -\n#### Level2\n\n你的手没有因为看到上面那张图而离开鼠标😏，而是继续看到这说明你已经不是随随便便就能春心荡漾的小朋友了，那么现在请你系好安全带，要发车了！\n\n![要发车了！](http://upload-images.jianshu.io/upload_images/1835430-f253237e28f7c6e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以说单纯一个同时包含数字字母就要这么臭又长的表达式的话，正则表达式也就真没有存在的意义了。这种有先决条件的表达式我们要怎么处理呢？\n是否能先处理先决条件再进行匹配呢？\n\n答案当然是肯定的，你要了解`预查模式`。\n\n所谓预查模式就是`首先检查整个元素`是否满足条件，`满足后再进行逐一匹配`。\n\n预查有下面几种形式：（下列pattern均代表表达式）\n\n- (?=pattern)\t\t正向肯定预查\n- (?!pattern)\t\t正向否定预查\n\n所谓正向就是固定字符串在前，条件字符串在后。肯定就是包含条件中的字符串，否定就是不包含条件中的字符串。\n\n> 经典的例子就是windows(?=2000|Vista)，首先固定字符串是windows，即字符串中一定要包含windows。条件字符串是包含2000或者Vista，所以windows2000和windowsVista都可以正确匹配，这是正向肯定预查。举一反三的你相信正向否定，反向肯定，反向否定都能理解了吧知道怎么用了吧。\n\n此处我已经假设你通过自己的感悟已经理解了反向预查，只写式子了（如果没明白在慢慢想会，想累了就回头看看Level1最后的图片😏）。\n\n- (?<=pattern)\t反向肯定预查\n- (?<!pattern)\t反向否定预查\n\n到这了你应该已经明白预查的含义，但是你跟我说你记不住这稀奇古怪的表达式。没关系，看好了，划重点啊，考试专门考这啊，老司机给你拆开：\n\n> “？”代表预查\n> \n> “=”代表肯定\n> \n> “!”代表否定\n> \n> “<”代表反向\n\n好了，你可以准备好仰天长啸了，大喊还有谁！\n\n![还有谁！](http://upload-images.jianshu.io/upload_images/1835430-0b147d01fc08c8d3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n恩，别嘚瑟，还有我！\n\n事实上，我们用预查方式，更多的用到的是正向预查（反向预查通常有点反人类思维），而且用到他的变体更多：\n\n- (?=[pattern]+$)\t告诉我这是什么？“?”看到没有，预查，“=”看到没有？肯定预查，有没有“<”？没有，正向肯定预查！简不简单！！！！！额外解释一下，+等价于{1,}，$代表的是字符串结尾（所以说一些特殊的助记符真的是可以多学学的）。\n\n> 所以这个条件如果放在一个表达式的最开始就说明：\n> \n> 1.固定字符串没有，那么条件字符串就是开头了\n> \n> 2.条件字符串至少一个\n> \n> 3.条件字符串匹配到字符串结尾，所以条件字符串就是字符串结尾了\n> \n> 所以说结论是什么？就是字符串从头到尾都由pattern组成，也就是allIs。\n\n- (?!.\\*[pattern].\\*) 告诉我这是啥？诶对了，正向否定预查！老司机再带你捋一个啊。\n\n> 1.固定字符串没有，条件字符串开头了\n> \n> 2.条件字符串由任意任意字符开头，中间是条件字符串，后面又是任意个数任意字符，说明什么，条件就是包含pattern对吧！\n> \n> 3.这是什么？否定预查，所以是什么？不包含！\n> \n> 结论？字符串不包含pattern，什么意思？从头到尾都不是pattern，对不对？！！！allNot，诶，英语就是这么溜！\n\n那么老司机就不一一带着你捋了，自己感悟啊！\n\n- (?![pattern]+$) 直接给我说答案？是什么？诶，不全是pattern对不对？英语是什么？？notAll！\n\n- (?=.*[pattern]) 是不是包含？是不是！诶，对了！contain！对不对！！！！就问你对不对！\n\n现在来，给我回到上面的需求，同时包含字母和数字怎么写？\n\n是不是`((?=.*\\d)(?=.*[a-zA-Z]))[\\da-zA-Z]*`?!简单不简单，透彻不透彻！！！\n这回是不是又觉得自己无敌了！还有谁！！！\n\n**别闹，还有我啊~**\n\n![还有我啊~](http://upload-images.jianshu.io/upload_images/1835430-22cc41a2b7b6b50d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n- - -\n#### Level3\n\n还有什么？还有多着呢，那么多助记符、那么多控制符、负值字符范围、边界匹配、获取匹配、贪婪模式等等。。。\n\n恩，我发现关注的人很多，所以今天来把Level3中内容补充一下。\n\n- ^  负字符范围。表示排除此字符集的其他范围。`[^\\d]`即标识除数字外的其他字符合集。\n\n实际使用中，他是可以配合预查来完成一些任务。\n比如说要表示除了4的数字合集，你可以有几种表达方式：\n> - [012356789]\n- [0-3,5-9]\n- (?=\\d+$)([^4]*)\n\n前两个不说了，可读性很强，第三个，先是`预查并且是allIs模式`对吧，就`限制了全由数字`组成，然后用`负字符范围排除了4`，这样就是排除了4的数组集合。不过你可能说你用`第二种方式可读性高且也符合`，不过如果需求编程全部中文排除“我们”这两个字符呢，你要怎么搞。。所以说它是有它的`应用范围`的。`没有最合理的，只有最适合的`。\n\n- \\b 边界匹配，要求表达式要在字符串的边界。此处边界通常以结尾或者空格进行区分。\n\n> eg.比如说要匹配所有以er结尾的字符串，你可以这样`[a-z]*(er)\\b`，他能匹配her，但是verb就不行。\n同样的`\\B`就是不在边界。\n\n- 贪婪模式，及尽可能的多去匹配。我们的正则引擎一般是默认贪婪模式的。如果想切换为非贪婪模式则在范围表达式后添加\"?\"来表示当前为非贪婪模式。\n\n> eg.字符串abcdefg，你要获取不重复的所有长度至少为2的子串，你可以这样写`[a-z]{2,}`,这时你获得的结果将只有一个`abcdefg`,因为贪婪模式下会尽可能的多匹配，而下限是2上限没有，所以匹配到整串结果。如果你这样写`[a-z]{2,}?`，那么当前条件被转换为非贪婪模式。你获得的结果是`ab`、`cd`、`ef`三个结果。\n\n- 获取与非获取，准确的说这不是作为条件出现的。上文中提到的括号表达式，就是否会获取结果。如上述中提到的预查模式，实际上都是非获取模式，就是并不会保存结果，只是提前对整串进行校验。而获取匹配到的结果并供后面的表达式使用。这个还是比较难以理解的，老司机要配合例子或许你才能懂。\n\n> eg.需求1. 找出字符串abbbccc中任意连续出现3次的字母。\n乍一看任意连续出现三次的字母你怎么写？`[a-z]{3}`这样么？这样子可不行，这可没规定连续。首先我们知道，一个正则表达式是由多个正则表达式组成的。所以你现在想的是不是我获取到一个符合结果的字符串，他的表达式应该由两部分组成，第一部分是匹配我要的第一个字母，第二部分是把第一部分匹配的字母重复两次。`([a-z])`这样你获取到的第一个字母，然后我要使用第一个表达式的结果重复两次。所以你应该这么写`([a-z])\\1{2}`。老司机解释一下，这个表达式的意思是分成两部分([a-z])获取任意字符并将其保存在临时的地方作为一个后面可用的条件子串。`\\1`代表取出第一个临时子串，`{2}`就是范围限定符，将前面取出的元素重复两次。所以abbbcbb中，当第一个字母a作为`([a-z])`所保存的临时子串时，`\\1`就代表a，然而并没有连续的三个a，所以不符合。当b作为临时子串时，`\\1`代表b，后面有两个连续的b，符合结果。\n\n> 再来一个深入理解一下。如果我想取出abbbccc中的bccc怎么办呢？我们的表达式应该由3部分组成，第一部分匹配一个字母,第二部分匹配一个字母，第三部分是第二部分重复两次。`([a-z])([a-z])\\2{2}`么？不对，为什么？这样你将获取到abbb。因为a配[a-z]，然后b匹配第二个[a-z]，然后取出第二个结果b重复两次，那就是abbb。然后将从c开始继续检查后面的字符串。不过至少我们思路对了，只要我们不然abbb符合结果即可，简单修改`([^a])([a-z])\\2{2}`。这时a就不能作为第一个字母出现了，所以就轮到bccc了是吧。\n\n> 最后一个例子不分拆讲解，想获取abbbcbb中的bcbb怎么办？看看是不是这个表达式：`([a-z])([a-z])\\1{2}`。对的，不解释。\n\n其余就是助记符了，虽然多，但都是等价替换，老司机不细讲，看看最开始的表吧。\n\n\n助记符不算，另一种表达方式，控制符也就是几个特殊符号，负值、边界用起来也很简单，获取匹配、贪婪模式，多看看也能消化。而且这些Level3的东西都是锦上添花的东西，不必须掌握。\n\n> 所以大声告诉我，正则会没会！！！\n> \n> 会！\n> \n> 简不简单！！！\n> \n> 简单！\n> \n> 老司机屌不屌！！！\n> \n> 屌！真屌！太屌了！非常之屌！24K纯屌！\n\n- - - \n然后放一些老司机搜集并验证过的常用正则吧：\n\n|类别                |表格                |\n|:-------------:|:-------------:|\n|数字|  \\d+|\n| 字母 | [a-zA-Z]+ |\n|中文 |[\\\\u4E00-\\\\u9FA5]+|\n| 所有符号|[\\\\W_]+|\n|Email|^[A-Za-z\\\\d]+([-_.][A-Za-z\\\\d]+)*@([A-Za-z\\\\d]+[-.])*([A-Za-z\\\\d]+[.])+[A-Za-z\\\\d]{2,5}$|\n|手机号码|1[34578]\\\\d{9}|\n|座机电话|(0[\\\\d]{2,3}-)?([2-9][\\\\d]{6,7})(-[\\\\d]{1,4})?|\n|自然数|\\\\d+(\\\\.\\\\d+)?|\nURL这个放在表格里面格式就不对了，我就放外面了：\nURL = ((http|ftp|https)://)?((([a-zA-Z0-9]+[a-zA-Z0-9_-]\\*\\\\.)+[a-zA-Z]{2,6})|(([0-9]{1,3}\\\\.){3}[0-9]{1,3}(:[0-9]{1,4})?))((/[a-zA-Z\\\\d_]+)\\*(\\\\?([a-zA-Z\\\\d_]+=[a-zA-Z\\\\d\\\\u4E00-\\\\u9FA5\\\\s\\\\+%#\\_-]+&)*([a-zA-Z\\\\d\\_]+=[a-zA-Z\\\\d\\\\u4E00-\\\\u9FA5\\\\s\\\\+%#_-]+))?)?\n\n\n\n- - -\n\n冲着老司机情人节不开房开博客的情怀，是不是应该有一大波赞！！！一大波关注！！！！一大波star！！！！！\n\n- - -\n\n不过熟悉老司机的童靴是知道老司机的套路的，老司机讲课要什么？\n\n要赞！要关注！！要star！！！\n\n这期带来的小工具：\n\n[DWRegexUtils](https://github.com/CodeWicky/-Tools/tree/master/DWRegExpUtils)\n\n正则工具类，这也是老司机的心血结晶啊，提供自然人思维的链式语法优雅的返回正则表达式。\n\n![虽然这点难以解释](http://upload-images.jianshu.io/upload_images/1835430-c34ec5e64aa0c67d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n预置常用正则表达式。\n\n![预置校验1](http://upload-images.jianshu.io/upload_images/1835430-ac8a766a7c4742c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![预置校验2](http://upload-images.jianshu.io/upload_images/1835430-b1e12f10f021e21f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n提供正则判断的工具类！\n\n如果觉得好用可以给整个仓库一个star哟！整个仓库里面全都是工具类哟！上哪里去找这么好的仓库！！！[仓库传送门](https://github.com/CodeWicky/-Tools)\n- - -\n\n有童鞋说这个工具类不会使用，恩，我理解！因为提供的自由度较广所以传参比较多，所以老司机昨天发博客的时候自己想捋捋怎么用也回忆了一小下，那我就简单说一下吧。\n\n首先，需明确的概念是，在这个工具类中，老司机是想以一种`组件`的形式去生成正则表达式。组件对应的就是`正则表达式中元素`的概念。\n从头文件中可以看到，老司机使用一个枚举（严格点这是按位掩码）定义了组件类型DWRegexComponent。使用的时候你可以\n`DWRegexComponentNumber |DWRegexComponentUppercaseLetter`这样来表示数字和大写字母同时作为组件元素。\n\n第二个概念是`条件`。其实上面的教程里你应该发现了正则就是用`一个个小的表达式组成一个大的表达式`。而老司机这里就是一`添加条件的方式来添加表达式`。我用了另一个枚举类型DWRegexCondition定义了6种条件方式。其中4种是预查，allIs，allNot，notAll，contain，这些都是预查条件，所有都有PreSearch前缀。还有两种子式条件contain和without，即包含与非包含。\n\n恩，两个枚举完事了，搞定剩下三个api，你就能用它写出正则了。\n\n说说为什么会是链式语句呢？因为`链式语句从形式上更能代表人的顺向思维`，所谓想到哪写到哪，所以采用了链式语句生成正则，用过masonry的童鞋一定可以很快上手。\n\n首先调用`+dw_GetRegexStringWithMaker:`方法来以block形式生成正则语句。\n\n一下三个api都可以通过maker的点语法点出来，类比masonry就好了。\n\n> AddConditionWithComponentType()\n\n这个方法你要传6个参数，有点多呵呵🙃。\n分别是`组件、额外字符串、条件、最小匹配数、最大匹配数及是否为贪婪模式`。\n有了枚举的介绍其实你应该仅不知道额外字符串是什么鬼。\n首先`以组件来做成基本元素`，然而老司机预置的组件中可能`不能代表全部你要的元素`，所以可以`通过额外字符串来对组件进行补充`。然后`以组件和额外字符串作为元素`，`配合条件即范围生成一条正则表达式`。\n上图例子中的，详情请见上面图的第一个表达式。\n\n> AddConditionWithComponentRegexString()\n\n举一反三的想一下，套路是一样的。你需要5个参数，`子串、条件、两端范围及贪婪模式`。\n应用场景就是你不想用组件模式生成元素，而是想`手撸一个元素集合`时，子串即传入你的元素集合，在`添加条件、范围即可`，例子见第二个表达式。\n\n> AddConditionWithCompleteRegexString()\n\n仅需要传入两个参数，即你连范围都能自己撸，你就写一个`完整的正则表达式作为元素`，`添加条件组成一个更加丰富的正则表达式`。\n\n所以说`借助这三个api加以你灵活的使用`你就能生成所有你想要的表达式，只要你能够把大需求拆分成一个个小条件。`事实上第一个api自由度最高，你熟练使用这个就行`。\n\n最后，这三个api中如果你的`条件模式为预查`，则`无论你在什么位置`添加条件，最后都会`自动的拼接在正则表达式的前方`。而`子式条件添加的顺序即为子式的顺序`。\n\n恩，有了讲解配合上面的例子，这个工具类应该就可以使用了。不是吹捧自己的东西，只要`熟练使用第一个api`你真的能写出所有正则，你需要的只是学习一个api的成本。另外，`用多了或许你就能很好的拆分了，然后自己也就能写了`。\n\n- - -\n另外，DWCoreTextLabel已经全面支持自动链接匹配了，包括数字、email、url链接、手机号等。欢迎star！！！跪求star！！！这是老司机主力推的库😢。\n\n### 软广\n\nDWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。\n\n>version 1.1.0\n>全面支持自动链接支持、定制检测规则、图文混排、响应事件\n>优化大部分算法，提高响应效率及绘制效率\n \n>version 1.1.1\n>高亮取消逻辑优化\n>自动检测逻辑优化\n>部分常用方法改为内联函数，提高运行效率\n \n>version 1.1.2\n>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）\n \n>version 1.1.3\n>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中\n \n>version 1.1.4\n>事务管理类去除，异步绘制文件抽出\n \n>version 1.1.5\n>添加网络图片异步加载库，支持绘制网络图片\n>\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n\n\n![爱你哟](http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"老司机出品——包教包会之玩转正则表达式","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htph000ljigbyf2ubrcl","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-eab975ab3f151634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"玩转正则表达式\"></p>\n<blockquote>\n<p><strong>2017年2月16日14时11分更新Level3详解</strong></p>\n</blockquote>\n<p>结束了CoreAnimation系列之后，老司机心里仿佛也轻松了许多。今天说说开发中的一个利器吧，<code>正则表达式</code>。</p>\n<h3 id=\"正则表达式是什么\"><a href=\"#正则表达式是什么\" class=\"headerlink\" title=\"正则表达式是什么\"></a>正则表达式是什么</h3><blockquote>\n<p>正则表达式，又称规则表达式。（英语：Regular Expression，在代 码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。</p>\n</blockquote>\n<p>其实借助正则表达式，我们可以对<code>字符串进行很多操作</code>，最大的优势就是从字符串中<code>获取字符串以及判断字符串</code>是否符合条件。</p>\n<p>然而事实上有很多程序员都抱怨，正则表达式的语法晦涩难懂，的确，一个个符号看似毫无规律的拼凑在一起让人看起来确实头疼。</p>\n<p>幸运的是，老司机曾经拿出两个下午来认真的研究了一下正则表达式，所以老司机也是目前我们组唯一一个<code>手撸正则</code>表达式的骚年，so，让老司机沾沾自喜一下可好~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-f2fc446ab22a9826.gif?imageMogr2/auto-orient/strip\" alt=\"沾沾自喜\"></p>\n<p>当然，嘚瑟完还是要来干货的，那老司机用老司机的方式带你看一下正则。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><p>让我们先啃一下硬骨头，<code>元字符</code>。</p>\n<p>所谓元字符，就是几个特定的符号组合在一起，其代表的含义已经不是原先符号本身的含义，而更像是一个表达式。</p>\n<p>正则表达式正是因为元字符而变的晦涩，也正是因为元字符而变的简洁。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d2ba2eb18b01d763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"元字符1\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-7b59460c9d2dccfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"元字符2\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-8fa4634e2d4738c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"元字符3\"></p>\n<p>以上图片截自百度百科<a href=\"http://baike.baidu.com/link?url=hPmdeeyjNvVV2j63KFbzPtL6Ry0hG3Rt5YNHZhrcID7ghrgZiLYAir9Ozm1aYtrmr6lyOj4RpSnadJcoJUzW_saC-uAmU1ySO7RLzboZs9nQH463j6k0VAiPjtl-eUdOpktwGYvWAWKuL5WWnQIQGK\" target=\"_blank\" rel=\"external\">正则表达式</a></p>\n<hr>\n<h4 id=\"Level1\"><a href=\"#Level1\" class=\"headerlink\" title=\"Level1\"></a>Level1</h4><p>元字符之多，多到让人记不住，不过老司机之前说过，元字符不过是<code>带有特定含义的表达式</code>用来让表达式简洁，所以你不用表达式，用最基本的字符完全可以组成表达式，比如下面这种情况：</p>\n<ul>\n<li>[0123456789] 你可以用这个表达式来代表一个数字元素</li>\n<li>[0-9] 你同样可以用这个表达式代表一个数字元素</li>\n<li>\\d 你更可以用这个表达式代表一个数字元素</li>\n</ul>\n<p>从上至下，表达式形式越来越简单，不过其书写形式却越来越难懂。<br>所以即使你记不住<code>\\d</code>,你也可以用<code>[0123456789]</code>来替代，当你熟练了，自然也就记住<code>\\d</code>了对不对。</p>\n<p>所以说，并不是所有元字符你都需要记住的，不过老司机挑了这么几个出来，是能大幅度提高你书写速度的几个元字符：</p>\n<ul>\n<li>[]    对于他，我的命名是元素枚举表达式，表示中括号之间的任意一个元素均可以当做作为一个元素存在。</li>\n<li>{n,m} 这个，我姑且称他为范围表达式。他的含义是表示他前面的元素有x个，x介于[n,m]之间的闭区间（即包含n,m）。</li>\n</ul>\n<blockquote>\n<p>eg.        结合上面两个表达式，我们可以这样写一个表达式：<code>[0123456789]{1,2}</code>，其含义是一个1到2位的纯数字。当然<code>\\d{1,2}</code>会让你的表达式看起来更加简洁。</p>\n</blockquote>\n<ul>\n<li>()    括号表达式，他的含义仅仅是将括号间的所有表达式作为一个整体看做新的元素。</li>\n</ul>\n<blockquote>\n<p>eg.        到这里你可以写这样一个表达式：<br><code>([a-z]{1,2}[\\d]{1,2}){1,2}</code>，恩，是不是已经乱七八糟了，我们一点一点拆解，<code>[a-z]{1,2}</code>表示<code>1或2个小写字母</code>，<code>[\\d]{1,2}</code>表示<code>1或2个数字</code>，两个表达式连一起就是<code>1或2个小写字母后面紧跟1或2个数字</code>（例如<code>ab12</code>），然后[a-z]{1,2}[\\d]{1,2}被扩在小括号表达式中，他们已经<code>作为一个整体被视为一个元素</code>，这样的<code>元素又有1或2个</code>，所以符合这个表达式的字符串可能是这个样子的：<code>a12bc1</code></p>\n</blockquote>\n<p>所以说这么一个难看的表达式一点一点拆解我们也是能看懂的是吧</p>\n<ul>\n<li><p>. 点表达式，标识除“\\r\\n”之外的任何单个字符</p>\n</li>\n<li><p>|        或表达式，表示 | 前后的两个元素中任意一种情况</p>\n</li>\n</ul>\n<p>到了这里，你已经可以写出任意一个表达式了，这些就够了。</p>\n<blockquote>\n<p>比如说既包含字母又包含数字的字符串：</p>\n<p><code>\\d{0,}([a-z]{1,}\\d{1,}){1,}[a-z]{0,}</code></p>\n<p>这是一个比较丑的表达式，不过他真的能匹配所有情况，你可以慢慢想一下（别太仔细想，虽然可以这么用不过太单纯了，没人这么用的）。</p>\n</blockquote>\n<p>如果说你不介意，到这里，你已经学够了，我似乎看到了你满足的表情。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-5737d4049d454ba3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"满足了\"></p>\n<hr>\n<h4 id=\"Level2\"><a href=\"#Level2\" class=\"headerlink\" title=\"Level2\"></a>Level2</h4><p>你的手没有因为看到上面那张图而离开鼠标😏，而是继续看到这说明你已经不是随随便便就能春心荡漾的小朋友了，那么现在请你系好安全带，要发车了！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-f253237e28f7c6e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"要发车了！\"></p>\n<p>所以说单纯一个同时包含数字字母就要这么臭又长的表达式的话，正则表达式也就真没有存在的意义了。这种有先决条件的表达式我们要怎么处理呢？<br>是否能先处理先决条件再进行匹配呢？</p>\n<p>答案当然是肯定的，你要了解<code>预查模式</code>。</p>\n<p>所谓预查模式就是<code>首先检查整个元素</code>是否满足条件，<code>满足后再进行逐一匹配</code>。</p>\n<p>预查有下面几种形式：（下列pattern均代表表达式）</p>\n<ul>\n<li>(?=pattern)        正向肯定预查</li>\n<li>(?!pattern)        正向否定预查</li>\n</ul>\n<p>所谓正向就是固定字符串在前，条件字符串在后。肯定就是包含条件中的字符串，否定就是不包含条件中的字符串。</p>\n<blockquote>\n<p>经典的例子就是windows(?=2000|Vista)，首先固定字符串是windows，即字符串中一定要包含windows。条件字符串是包含2000或者Vista，所以windows2000和windowsVista都可以正确匹配，这是正向肯定预查。举一反三的你相信正向否定，反向肯定，反向否定都能理解了吧知道怎么用了吧。</p>\n</blockquote>\n<p>此处我已经假设你通过自己的感悟已经理解了反向预查，只写式子了（如果没明白在慢慢想会，想累了就回头看看Level1最后的图片😏）。</p>\n<ul>\n<li>(?&lt;=pattern)    反向肯定预查</li>\n<li>(?&lt;!pattern)    反向否定预查</li>\n</ul>\n<p>到这了你应该已经明白预查的含义，但是你跟我说你记不住这稀奇古怪的表达式。没关系，看好了，划重点啊，考试专门考这啊，老司机给你拆开：</p>\n<blockquote>\n<p>“？”代表预查</p>\n<p>“=”代表肯定</p>\n<p>“!”代表否定</p>\n<p>“&lt;”代表反向</p>\n</blockquote>\n<p>好了，你可以准备好仰天长啸了，大喊还有谁！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0b147d01fc08c8d3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"还有谁！\"></p>\n<p>恩，别嘚瑟，还有我！</p>\n<p>事实上，我们用预查方式，更多的用到的是正向预查（反向预查通常有点反人类思维），而且用到他的变体更多：</p>\n<ul>\n<li>(?=[pattern]+$)    告诉我这是什么？“?”看到没有，预查，“=”看到没有？肯定预查，有没有“&lt;”？没有，正向肯定预查！简不简单！！！！！额外解释一下，+等价于{1,}，$代表的是字符串结尾（所以说一些特殊的助记符真的是可以多学学的）。</li>\n</ul>\n<blockquote>\n<p>所以这个条件如果放在一个表达式的最开始就说明：</p>\n<p>1.固定字符串没有，那么条件字符串就是开头了</p>\n<p>2.条件字符串至少一个</p>\n<p>3.条件字符串匹配到字符串结尾，所以条件字符串就是字符串结尾了</p>\n<p>所以说结论是什么？就是字符串从头到尾都由pattern组成，也就是allIs。</p>\n</blockquote>\n<ul>\n<li>(?!.*[pattern].*) 告诉我这是啥？诶对了，正向否定预查！老司机再带你捋一个啊。</li>\n</ul>\n<blockquote>\n<p>1.固定字符串没有，条件字符串开头了</p>\n<p>2.条件字符串由任意任意字符开头，中间是条件字符串，后面又是任意个数任意字符，说明什么，条件就是包含pattern对吧！</p>\n<p>3.这是什么？否定预查，所以是什么？不包含！</p>\n<p>结论？字符串不包含pattern，什么意思？从头到尾都不是pattern，对不对？！！！allNot，诶，英语就是这么溜！</p>\n</blockquote>\n<p>那么老司机就不一一带着你捋了，自己感悟啊！</p>\n<ul>\n<li><p>(?![pattern]+$) 直接给我说答案？是什么？诶，不全是pattern对不对？英语是什么？？notAll！</p>\n</li>\n<li><p>(?=.*[pattern]) 是不是包含？是不是！诶，对了！contain！对不对！！！！就问你对不对！</p>\n</li>\n</ul>\n<p>现在来，给我回到上面的需求，同时包含字母和数字怎么写？</p>\n<p>是不是<code>((?=.*\\d)(?=.*[a-zA-Z]))[\\da-zA-Z]*</code>?!简单不简单，透彻不透彻！！！<br>这回是不是又觉得自己无敌了！还有谁！！！</p>\n<p><strong>别闹，还有我啊~</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-22cc41a2b7b6b50d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"还有我啊~\"></p>\n<hr>\n<h4 id=\"Level3\"><a href=\"#Level3\" class=\"headerlink\" title=\"Level3\"></a>Level3</h4><p>还有什么？还有多着呢，那么多助记符、那么多控制符、负值字符范围、边界匹配、获取匹配、贪婪模式等等。。。</p>\n<p>恩，我发现关注的人很多，所以今天来把Level3中内容补充一下。</p>\n<ul>\n<li>^  负字符范围。表示排除此字符集的其他范围。<code>[^\\d]</code>即标识除数字外的其他字符合集。</li>\n</ul>\n<p>实际使用中，他是可以配合预查来完成一些任务。<br>比如说要表示除了4的数字合集，你可以有几种表达方式：</p>\n<blockquote>\n<ul>\n<li>[012356789]</li>\n<li>[0-3,5-9]</li>\n<li>(?=\\d+$)([^4]*)</li>\n</ul>\n</blockquote>\n<p>前两个不说了，可读性很强，第三个，先是<code>预查并且是allIs模式</code>对吧，就<code>限制了全由数字</code>组成，然后用<code>负字符范围排除了4</code>，这样就是排除了4的数组集合。不过你可能说你用<code>第二种方式可读性高且也符合</code>，不过如果需求编程全部中文排除“我们”这两个字符呢，你要怎么搞。。所以说它是有它的<code>应用范围</code>的。<code>没有最合理的，只有最适合的</code>。</p>\n<ul>\n<li>\\b 边界匹配，要求表达式要在字符串的边界。此处边界通常以结尾或者空格进行区分。</li>\n</ul>\n<blockquote>\n<p>eg.比如说要匹配所有以er结尾的字符串，你可以这样<code>[a-z]*(er)\\b</code>，他能匹配her，但是verb就不行。<br>同样的<code>\\B</code>就是不在边界。</p>\n</blockquote>\n<ul>\n<li>贪婪模式，及尽可能的多去匹配。我们的正则引擎一般是默认贪婪模式的。如果想切换为非贪婪模式则在范围表达式后添加”?”来表示当前为非贪婪模式。</li>\n</ul>\n<blockquote>\n<p>eg.字符串abcdefg，你要获取不重复的所有长度至少为2的子串，你可以这样写<code>[a-z]{2,}</code>,这时你获得的结果将只有一个<code>abcdefg</code>,因为贪婪模式下会尽可能的多匹配，而下限是2上限没有，所以匹配到整串结果。如果你这样写<code>[a-z]{2,}?</code>，那么当前条件被转换为非贪婪模式。你获得的结果是<code>ab</code>、<code>cd</code>、<code>ef</code>三个结果。</p>\n</blockquote>\n<ul>\n<li>获取与非获取，准确的说这不是作为条件出现的。上文中提到的括号表达式，就是否会获取结果。如上述中提到的预查模式，实际上都是非获取模式，就是并不会保存结果，只是提前对整串进行校验。而获取匹配到的结果并供后面的表达式使用。这个还是比较难以理解的，老司机要配合例子或许你才能懂。</li>\n</ul>\n<blockquote>\n<p>eg.需求1. 找出字符串abbbccc中任意连续出现3次的字母。<br>乍一看任意连续出现三次的字母你怎么写？<code>[a-z]{3}</code>这样么？这样子可不行，这可没规定连续。首先我们知道，一个正则表达式是由多个正则表达式组成的。所以你现在想的是不是我获取到一个符合结果的字符串，他的表达式应该由两部分组成，第一部分是匹配我要的第一个字母，第二部分是把第一部分匹配的字母重复两次。<code>([a-z])</code>这样你获取到的第一个字母，然后我要使用第一个表达式的结果重复两次。所以你应该这么写<code>([a-z])\\1{2}</code>。老司机解释一下，这个表达式的意思是分成两部分([a-z])获取任意字符并将其保存在临时的地方作为一个后面可用的条件子串。<code>\\1</code>代表取出第一个临时子串，<code>{2}</code>就是范围限定符，将前面取出的元素重复两次。所以abbbcbb中，当第一个字母a作为<code>([a-z])</code>所保存的临时子串时，<code>\\1</code>就代表a，然而并没有连续的三个a，所以不符合。当b作为临时子串时，<code>\\1</code>代表b，后面有两个连续的b，符合结果。</p>\n<p>再来一个深入理解一下。如果我想取出abbbccc中的bccc怎么办呢？我们的表达式应该由3部分组成，第一部分匹配一个字母,第二部分匹配一个字母，第三部分是第二部分重复两次。<code>([a-z])([a-z])\\2{2}</code>么？不对，为什么？这样你将获取到abbb。因为a配[a-z]，然后b匹配第二个[a-z]，然后取出第二个结果b重复两次，那就是abbb。然后将从c开始继续检查后面的字符串。不过至少我们思路对了，只要我们不然abbb符合结果即可，简单修改<code>([^a])([a-z])\\2{2}</code>。这时a就不能作为第一个字母出现了，所以就轮到bccc了是吧。</p>\n<p>最后一个例子不分拆讲解，想获取abbbcbb中的bcbb怎么办？看看是不是这个表达式：<code>([a-z])([a-z])\\1{2}</code>。对的，不解释。</p>\n</blockquote>\n<p>其余就是助记符了，虽然多，但都是等价替换，老司机不细讲，看看最开始的表吧。</p>\n<p>助记符不算，另一种表达方式，控制符也就是几个特殊符号，负值、边界用起来也很简单，获取匹配、贪婪模式，多看看也能消化。而且这些Level3的东西都是锦上添花的东西，不必须掌握。</p>\n<blockquote>\n<p>所以大声告诉我，正则会没会！！！</p>\n<p>会！</p>\n<p>简不简单！！！</p>\n<p>简单！</p>\n<p>老司机屌不屌！！！</p>\n<p>屌！真屌！太屌了！非常之屌！24K纯屌！</p>\n</blockquote>\n<hr>\n<p>然后放一些老司机搜集并验证过的常用正则吧：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类别</th>\n<th style=\"text-align:center\">表格</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">数字</td>\n<td style=\"text-align:center\">\\d+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">字母</td>\n<td style=\"text-align:center\">[a-zA-Z]+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">中文</td>\n<td style=\"text-align:center\">[\\u4E00-\\u9FA5]+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">所有符号</td>\n<td style=\"text-align:center\">[\\W_]+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Email</td>\n<td style=\"text-align:center\">^[A-Za-z\\d]+([-_.][A-Za-z\\d]+)<em>@([A-Za-z\\d]+[-.])</em>([A-Za-z\\d]+[.])+[A-Za-z\\d]{2,5}$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">手机号码</td>\n<td style=\"text-align:center\">1[34578]\\d{9}</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">座机电话</td>\n<td style=\"text-align:center\">(0[\\d]{2,3}-)?([2-9][\\d]{6,7})(-[\\d]{1,4})?</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">自然数</td>\n<td style=\"text-align:center\">\\d+(\\.\\d+)?</td>\n</tr>\n</tbody>\n</table>\n<p>URL这个放在表格里面格式就不对了，我就放外面了：<br>URL = ((http|ftp|https)://)?((([a-zA-Z0-9]+[a-zA-Z0-9<em>-]*\\.)+[a-zA-Z]{2,6})|(([0-9]{1,3}\\.){3}[0-9]{1,3}(:[0-9]{1,4})?))((/[a-zA-Z\\d</em>]+)*(\\?([a-zA-Z\\d<em>]+=[a-zA-Z\\d\\u4E00-\\u9FA5\\s\\+%#\\</em>-]+&amp;)*([a-zA-Z\\d_]+=[a-zA-Z\\d\\u4E00-\\u9FA5\\s\\+%#_-]+))?)?</p>\n<hr>\n<p>冲着老司机情人节不开房开博客的情怀，是不是应该有一大波赞！！！一大波关注！！！！一大波star！！！！！</p>\n<hr>\n<p>不过熟悉老司机的童靴是知道老司机的套路的，老司机讲课要什么？</p>\n<p>要赞！要关注！！要star！！！</p>\n<p>这期带来的小工具：</p>\n<p><a href=\"https://github.com/CodeWicky/-Tools/tree/master/DWRegExpUtils\" target=\"_blank\" rel=\"external\">DWRegexUtils</a></p>\n<p>正则工具类，这也是老司机的心血结晶啊，提供自然人思维的链式语法优雅的返回正则表达式。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-c34ec5e64aa0c67d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"虽然这点难以解释\"></p>\n<p>预置常用正则表达式。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ac8a766a7c4742c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"预置校验1\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b1e12f10f021e21f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"预置校验2\"></p>\n<p>提供正则判断的工具类！</p>\n<p>如果觉得好用可以给整个仓库一个star哟！整个仓库里面全都是工具类哟！上哪里去找这么好的仓库！！！<a href=\"https://github.com/CodeWicky/-Tools\" target=\"_blank\" rel=\"external\">仓库传送门</a></p>\n<hr>\n<p>有童鞋说这个工具类不会使用，恩，我理解！因为提供的自由度较广所以传参比较多，所以老司机昨天发博客的时候自己想捋捋怎么用也回忆了一小下，那我就简单说一下吧。</p>\n<p>首先，需明确的概念是，在这个工具类中，老司机是想以一种<code>组件</code>的形式去生成正则表达式。组件对应的就是<code>正则表达式中元素</code>的概念。<br>从头文件中可以看到，老司机使用一个枚举（严格点这是按位掩码）定义了组件类型DWRegexComponent。使用的时候你可以<br><code>DWRegexComponentNumber |DWRegexComponentUppercaseLetter</code>这样来表示数字和大写字母同时作为组件元素。</p>\n<p>第二个概念是<code>条件</code>。其实上面的教程里你应该发现了正则就是用<code>一个个小的表达式组成一个大的表达式</code>。而老司机这里就是一<code>添加条件的方式来添加表达式</code>。我用了另一个枚举类型DWRegexCondition定义了6种条件方式。其中4种是预查，allIs，allNot，notAll，contain，这些都是预查条件，所有都有PreSearch前缀。还有两种子式条件contain和without，即包含与非包含。</p>\n<p>恩，两个枚举完事了，搞定剩下三个api，你就能用它写出正则了。</p>\n<p>说说为什么会是链式语句呢？因为<code>链式语句从形式上更能代表人的顺向思维</code>，所谓想到哪写到哪，所以采用了链式语句生成正则，用过masonry的童鞋一定可以很快上手。</p>\n<p>首先调用<code>+dw_GetRegexStringWithMaker:</code>方法来以block形式生成正则语句。</p>\n<p>一下三个api都可以通过maker的点语法点出来，类比masonry就好了。</p>\n<blockquote>\n<p>AddConditionWithComponentType()</p>\n</blockquote>\n<p>这个方法你要传6个参数，有点多呵呵🙃。<br>分别是<code>组件、额外字符串、条件、最小匹配数、最大匹配数及是否为贪婪模式</code>。<br>有了枚举的介绍其实你应该仅不知道额外字符串是什么鬼。<br>首先<code>以组件来做成基本元素</code>，然而老司机预置的组件中可能<code>不能代表全部你要的元素</code>，所以可以<code>通过额外字符串来对组件进行补充</code>。然后<code>以组件和额外字符串作为元素</code>，<code>配合条件即范围生成一条正则表达式</code>。<br>上图例子中的，详情请见上面图的第一个表达式。</p>\n<blockquote>\n<p>AddConditionWithComponentRegexString()</p>\n</blockquote>\n<p>举一反三的想一下，套路是一样的。你需要5个参数，<code>子串、条件、两端范围及贪婪模式</code>。<br>应用场景就是你不想用组件模式生成元素，而是想<code>手撸一个元素集合</code>时，子串即传入你的元素集合，在<code>添加条件、范围即可</code>，例子见第二个表达式。</p>\n<blockquote>\n<p>AddConditionWithCompleteRegexString()</p>\n</blockquote>\n<p>仅需要传入两个参数，即你连范围都能自己撸，你就写一个<code>完整的正则表达式作为元素</code>，<code>添加条件组成一个更加丰富的正则表达式</code>。</p>\n<p>所以说<code>借助这三个api加以你灵活的使用</code>你就能生成所有你想要的表达式，只要你能够把大需求拆分成一个个小条件。<code>事实上第一个api自由度最高，你熟练使用这个就行</code>。</p>\n<p>最后，这三个api中如果你的<code>条件模式为预查</code>，则<code>无论你在什么位置</code>添加条件，最后都会<code>自动的拼接在正则表达式的前方</code>。而<code>子式条件添加的顺序即为子式的顺序</code>。</p>\n<p>恩，有了讲解配合上面的例子，这个工具类应该就可以使用了。不是吹捧自己的东西，只要<code>熟练使用第一个api</code>你真的能写出所有正则，你需要的只是学习一个api的成本。另外，<code>用多了或许你就能很好的拆分了，然后自己也就能写了</code>。</p>\n<hr>\n<p>另外，DWCoreTextLabel已经全面支持自动链接匹配了，包括数字、email、url链接、手机号等。欢迎star！！！跪求star！！！这是老司机主力推的库😢。</p>\n<h3 id=\"软广\"><a href=\"#软广\" class=\"headerlink\" title=\"软广\"></a>软广</h3><p>DWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。</p>\n<blockquote>\n<p>version 1.1.0<br>全面支持自动链接支持、定制检测规则、图文混排、响应事件<br>优化大部分算法，提高响应效率及绘制效率</p>\n<p>version 1.1.1<br>高亮取消逻辑优化<br>自动检测逻辑优化<br>部分常用方法改为内联函数，提高运行效率</p>\n<p>version 1.1.2<br>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）</p>\n<p>version 1.1.3<br>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中</p>\n<p>version 1.1.4<br>事务管理类去除，异步绘制文件抽出</p>\n<p>version 1.1.5<br>添加网络图片异步加载库，支持绘制网络图片</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你哟\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-eab975ab3f151634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"玩转正则表达式\"></p>\n<blockquote>\n<p><strong>2017年2月16日14时11分更新Level3详解</strong></p>\n</blockquote>\n<p>结束了CoreAnimation系列之后，老司机心里仿佛也轻松了许多。今天说说开发中的一个利器吧，<code>正则表达式</code>。</p>\n<h3 id=\"正则表达式是什么\"><a href=\"#正则表达式是什么\" class=\"headerlink\" title=\"正则表达式是什么\"></a>正则表达式是什么</h3><blockquote>\n<p>正则表达式，又称规则表达式。（英语：Regular Expression，在代 码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。</p>\n</blockquote>\n<p>其实借助正则表达式，我们可以对<code>字符串进行很多操作</code>，最大的优势就是从字符串中<code>获取字符串以及判断字符串</code>是否符合条件。</p>\n<p>然而事实上有很多程序员都抱怨，正则表达式的语法晦涩难懂，的确，一个个符号看似毫无规律的拼凑在一起让人看起来确实头疼。</p>\n<p>幸运的是，老司机曾经拿出两个下午来认真的研究了一下正则表达式，所以老司机也是目前我们组唯一一个<code>手撸正则</code>表达式的骚年，so，让老司机沾沾自喜一下可好~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-f2fc446ab22a9826.gif?imageMogr2/auto-orient/strip\" alt=\"沾沾自喜\"></p>\n<p>当然，嘚瑟完还是要来干货的，那老司机用老司机的方式带你看一下正则。</p>","more":"<hr>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><p>让我们先啃一下硬骨头，<code>元字符</code>。</p>\n<p>所谓元字符，就是几个特定的符号组合在一起，其代表的含义已经不是原先符号本身的含义，而更像是一个表达式。</p>\n<p>正则表达式正是因为元字符而变的晦涩，也正是因为元字符而变的简洁。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d2ba2eb18b01d763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"元字符1\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-7b59460c9d2dccfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"元字符2\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-8fa4634e2d4738c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"元字符3\"></p>\n<p>以上图片截自百度百科<a href=\"http://baike.baidu.com/link?url=hPmdeeyjNvVV2j63KFbzPtL6Ry0hG3Rt5YNHZhrcID7ghrgZiLYAir9Ozm1aYtrmr6lyOj4RpSnadJcoJUzW_saC-uAmU1ySO7RLzboZs9nQH463j6k0VAiPjtl-eUdOpktwGYvWAWKuL5WWnQIQGK\" target=\"_blank\" rel=\"external\">正则表达式</a></p>\n<hr>\n<h4 id=\"Level1\"><a href=\"#Level1\" class=\"headerlink\" title=\"Level1\"></a>Level1</h4><p>元字符之多，多到让人记不住，不过老司机之前说过，元字符不过是<code>带有特定含义的表达式</code>用来让表达式简洁，所以你不用表达式，用最基本的字符完全可以组成表达式，比如下面这种情况：</p>\n<ul>\n<li>[0123456789] 你可以用这个表达式来代表一个数字元素</li>\n<li>[0-9] 你同样可以用这个表达式代表一个数字元素</li>\n<li>\\d 你更可以用这个表达式代表一个数字元素</li>\n</ul>\n<p>从上至下，表达式形式越来越简单，不过其书写形式却越来越难懂。<br>所以即使你记不住<code>\\d</code>,你也可以用<code>[0123456789]</code>来替代，当你熟练了，自然也就记住<code>\\d</code>了对不对。</p>\n<p>所以说，并不是所有元字符你都需要记住的，不过老司机挑了这么几个出来，是能大幅度提高你书写速度的几个元字符：</p>\n<ul>\n<li>[]    对于他，我的命名是元素枚举表达式，表示中括号之间的任意一个元素均可以当做作为一个元素存在。</li>\n<li>{n,m} 这个，我姑且称他为范围表达式。他的含义是表示他前面的元素有x个，x介于[n,m]之间的闭区间（即包含n,m）。</li>\n</ul>\n<blockquote>\n<p>eg.        结合上面两个表达式，我们可以这样写一个表达式：<code>[0123456789]{1,2}</code>，其含义是一个1到2位的纯数字。当然<code>\\d{1,2}</code>会让你的表达式看起来更加简洁。</p>\n</blockquote>\n<ul>\n<li>()    括号表达式，他的含义仅仅是将括号间的所有表达式作为一个整体看做新的元素。</li>\n</ul>\n<blockquote>\n<p>eg.        到这里你可以写这样一个表达式：<br><code>([a-z]{1,2}[\\d]{1,2}){1,2}</code>，恩，是不是已经乱七八糟了，我们一点一点拆解，<code>[a-z]{1,2}</code>表示<code>1或2个小写字母</code>，<code>[\\d]{1,2}</code>表示<code>1或2个数字</code>，两个表达式连一起就是<code>1或2个小写字母后面紧跟1或2个数字</code>（例如<code>ab12</code>），然后[a-z]{1,2}[\\d]{1,2}被扩在小括号表达式中，他们已经<code>作为一个整体被视为一个元素</code>，这样的<code>元素又有1或2个</code>，所以符合这个表达式的字符串可能是这个样子的：<code>a12bc1</code></p>\n</blockquote>\n<p>所以说这么一个难看的表达式一点一点拆解我们也是能看懂的是吧</p>\n<ul>\n<li><p>. 点表达式，标识除“\\r\\n”之外的任何单个字符</p>\n</li>\n<li><p>|        或表达式，表示 | 前后的两个元素中任意一种情况</p>\n</li>\n</ul>\n<p>到了这里，你已经可以写出任意一个表达式了，这些就够了。</p>\n<blockquote>\n<p>比如说既包含字母又包含数字的字符串：</p>\n<p><code>\\d{0,}([a-z]{1,}\\d{1,}){1,}[a-z]{0,}</code></p>\n<p>这是一个比较丑的表达式，不过他真的能匹配所有情况，你可以慢慢想一下（别太仔细想，虽然可以这么用不过太单纯了，没人这么用的）。</p>\n</blockquote>\n<p>如果说你不介意，到这里，你已经学够了，我似乎看到了你满足的表情。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-5737d4049d454ba3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"满足了\"></p>\n<hr>\n<h4 id=\"Level2\"><a href=\"#Level2\" class=\"headerlink\" title=\"Level2\"></a>Level2</h4><p>你的手没有因为看到上面那张图而离开鼠标😏，而是继续看到这说明你已经不是随随便便就能春心荡漾的小朋友了，那么现在请你系好安全带，要发车了！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-f253237e28f7c6e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"要发车了！\"></p>\n<p>所以说单纯一个同时包含数字字母就要这么臭又长的表达式的话，正则表达式也就真没有存在的意义了。这种有先决条件的表达式我们要怎么处理呢？<br>是否能先处理先决条件再进行匹配呢？</p>\n<p>答案当然是肯定的，你要了解<code>预查模式</code>。</p>\n<p>所谓预查模式就是<code>首先检查整个元素</code>是否满足条件，<code>满足后再进行逐一匹配</code>。</p>\n<p>预查有下面几种形式：（下列pattern均代表表达式）</p>\n<ul>\n<li>(?=pattern)        正向肯定预查</li>\n<li>(?!pattern)        正向否定预查</li>\n</ul>\n<p>所谓正向就是固定字符串在前，条件字符串在后。肯定就是包含条件中的字符串，否定就是不包含条件中的字符串。</p>\n<blockquote>\n<p>经典的例子就是windows(?=2000|Vista)，首先固定字符串是windows，即字符串中一定要包含windows。条件字符串是包含2000或者Vista，所以windows2000和windowsVista都可以正确匹配，这是正向肯定预查。举一反三的你相信正向否定，反向肯定，反向否定都能理解了吧知道怎么用了吧。</p>\n</blockquote>\n<p>此处我已经假设你通过自己的感悟已经理解了反向预查，只写式子了（如果没明白在慢慢想会，想累了就回头看看Level1最后的图片😏）。</p>\n<ul>\n<li>(?&lt;=pattern)    反向肯定预查</li>\n<li>(?&lt;!pattern)    反向否定预查</li>\n</ul>\n<p>到这了你应该已经明白预查的含义，但是你跟我说你记不住这稀奇古怪的表达式。没关系，看好了，划重点啊，考试专门考这啊，老司机给你拆开：</p>\n<blockquote>\n<p>“？”代表预查</p>\n<p>“=”代表肯定</p>\n<p>“!”代表否定</p>\n<p>“&lt;”代表反向</p>\n</blockquote>\n<p>好了，你可以准备好仰天长啸了，大喊还有谁！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0b147d01fc08c8d3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"还有谁！\"></p>\n<p>恩，别嘚瑟，还有我！</p>\n<p>事实上，我们用预查方式，更多的用到的是正向预查（反向预查通常有点反人类思维），而且用到他的变体更多：</p>\n<ul>\n<li>(?=[pattern]+$)    告诉我这是什么？“?”看到没有，预查，“=”看到没有？肯定预查，有没有“&lt;”？没有，正向肯定预查！简不简单！！！！！额外解释一下，+等价于{1,}，$代表的是字符串结尾（所以说一些特殊的助记符真的是可以多学学的）。</li>\n</ul>\n<blockquote>\n<p>所以这个条件如果放在一个表达式的最开始就说明：</p>\n<p>1.固定字符串没有，那么条件字符串就是开头了</p>\n<p>2.条件字符串至少一个</p>\n<p>3.条件字符串匹配到字符串结尾，所以条件字符串就是字符串结尾了</p>\n<p>所以说结论是什么？就是字符串从头到尾都由pattern组成，也就是allIs。</p>\n</blockquote>\n<ul>\n<li>(?!.*[pattern].*) 告诉我这是啥？诶对了，正向否定预查！老司机再带你捋一个啊。</li>\n</ul>\n<blockquote>\n<p>1.固定字符串没有，条件字符串开头了</p>\n<p>2.条件字符串由任意任意字符开头，中间是条件字符串，后面又是任意个数任意字符，说明什么，条件就是包含pattern对吧！</p>\n<p>3.这是什么？否定预查，所以是什么？不包含！</p>\n<p>结论？字符串不包含pattern，什么意思？从头到尾都不是pattern，对不对？！！！allNot，诶，英语就是这么溜！</p>\n</blockquote>\n<p>那么老司机就不一一带着你捋了，自己感悟啊！</p>\n<ul>\n<li><p>(?![pattern]+$) 直接给我说答案？是什么？诶，不全是pattern对不对？英语是什么？？notAll！</p>\n</li>\n<li><p>(?=.*[pattern]) 是不是包含？是不是！诶，对了！contain！对不对！！！！就问你对不对！</p>\n</li>\n</ul>\n<p>现在来，给我回到上面的需求，同时包含字母和数字怎么写？</p>\n<p>是不是<code>((?=.*\\d)(?=.*[a-zA-Z]))[\\da-zA-Z]*</code>?!简单不简单，透彻不透彻！！！<br>这回是不是又觉得自己无敌了！还有谁！！！</p>\n<p><strong>别闹，还有我啊~</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-22cc41a2b7b6b50d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"还有我啊~\"></p>\n<hr>\n<h4 id=\"Level3\"><a href=\"#Level3\" class=\"headerlink\" title=\"Level3\"></a>Level3</h4><p>还有什么？还有多着呢，那么多助记符、那么多控制符、负值字符范围、边界匹配、获取匹配、贪婪模式等等。。。</p>\n<p>恩，我发现关注的人很多，所以今天来把Level3中内容补充一下。</p>\n<ul>\n<li>^  负字符范围。表示排除此字符集的其他范围。<code>[^\\d]</code>即标识除数字外的其他字符合集。</li>\n</ul>\n<p>实际使用中，他是可以配合预查来完成一些任务。<br>比如说要表示除了4的数字合集，你可以有几种表达方式：</p>\n<blockquote>\n<ul>\n<li>[012356789]</li>\n<li>[0-3,5-9]</li>\n<li>(?=\\d+$)([^4]*)</li>\n</ul>\n</blockquote>\n<p>前两个不说了，可读性很强，第三个，先是<code>预查并且是allIs模式</code>对吧，就<code>限制了全由数字</code>组成，然后用<code>负字符范围排除了4</code>，这样就是排除了4的数组集合。不过你可能说你用<code>第二种方式可读性高且也符合</code>，不过如果需求编程全部中文排除“我们”这两个字符呢，你要怎么搞。。所以说它是有它的<code>应用范围</code>的。<code>没有最合理的，只有最适合的</code>。</p>\n<ul>\n<li>\\b 边界匹配，要求表达式要在字符串的边界。此处边界通常以结尾或者空格进行区分。</li>\n</ul>\n<blockquote>\n<p>eg.比如说要匹配所有以er结尾的字符串，你可以这样<code>[a-z]*(er)\\b</code>，他能匹配her，但是verb就不行。<br>同样的<code>\\B</code>就是不在边界。</p>\n</blockquote>\n<ul>\n<li>贪婪模式，及尽可能的多去匹配。我们的正则引擎一般是默认贪婪模式的。如果想切换为非贪婪模式则在范围表达式后添加”?”来表示当前为非贪婪模式。</li>\n</ul>\n<blockquote>\n<p>eg.字符串abcdefg，你要获取不重复的所有长度至少为2的子串，你可以这样写<code>[a-z]{2,}</code>,这时你获得的结果将只有一个<code>abcdefg</code>,因为贪婪模式下会尽可能的多匹配，而下限是2上限没有，所以匹配到整串结果。如果你这样写<code>[a-z]{2,}?</code>，那么当前条件被转换为非贪婪模式。你获得的结果是<code>ab</code>、<code>cd</code>、<code>ef</code>三个结果。</p>\n</blockquote>\n<ul>\n<li>获取与非获取，准确的说这不是作为条件出现的。上文中提到的括号表达式，就是否会获取结果。如上述中提到的预查模式，实际上都是非获取模式，就是并不会保存结果，只是提前对整串进行校验。而获取匹配到的结果并供后面的表达式使用。这个还是比较难以理解的，老司机要配合例子或许你才能懂。</li>\n</ul>\n<blockquote>\n<p>eg.需求1. 找出字符串abbbccc中任意连续出现3次的字母。<br>乍一看任意连续出现三次的字母你怎么写？<code>[a-z]{3}</code>这样么？这样子可不行，这可没规定连续。首先我们知道，一个正则表达式是由多个正则表达式组成的。所以你现在想的是不是我获取到一个符合结果的字符串，他的表达式应该由两部分组成，第一部分是匹配我要的第一个字母，第二部分是把第一部分匹配的字母重复两次。<code>([a-z])</code>这样你获取到的第一个字母，然后我要使用第一个表达式的结果重复两次。所以你应该这么写<code>([a-z])\\1{2}</code>。老司机解释一下，这个表达式的意思是分成两部分([a-z])获取任意字符并将其保存在临时的地方作为一个后面可用的条件子串。<code>\\1</code>代表取出第一个临时子串，<code>{2}</code>就是范围限定符，将前面取出的元素重复两次。所以abbbcbb中，当第一个字母a作为<code>([a-z])</code>所保存的临时子串时，<code>\\1</code>就代表a，然而并没有连续的三个a，所以不符合。当b作为临时子串时，<code>\\1</code>代表b，后面有两个连续的b，符合结果。</p>\n<p>再来一个深入理解一下。如果我想取出abbbccc中的bccc怎么办呢？我们的表达式应该由3部分组成，第一部分匹配一个字母,第二部分匹配一个字母，第三部分是第二部分重复两次。<code>([a-z])([a-z])\\2{2}</code>么？不对，为什么？这样你将获取到abbb。因为a配[a-z]，然后b匹配第二个[a-z]，然后取出第二个结果b重复两次，那就是abbb。然后将从c开始继续检查后面的字符串。不过至少我们思路对了，只要我们不然abbb符合结果即可，简单修改<code>([^a])([a-z])\\2{2}</code>。这时a就不能作为第一个字母出现了，所以就轮到bccc了是吧。</p>\n<p>最后一个例子不分拆讲解，想获取abbbcbb中的bcbb怎么办？看看是不是这个表达式：<code>([a-z])([a-z])\\1{2}</code>。对的，不解释。</p>\n</blockquote>\n<p>其余就是助记符了，虽然多，但都是等价替换，老司机不细讲，看看最开始的表吧。</p>\n<p>助记符不算，另一种表达方式，控制符也就是几个特殊符号，负值、边界用起来也很简单，获取匹配、贪婪模式，多看看也能消化。而且这些Level3的东西都是锦上添花的东西，不必须掌握。</p>\n<blockquote>\n<p>所以大声告诉我，正则会没会！！！</p>\n<p>会！</p>\n<p>简不简单！！！</p>\n<p>简单！</p>\n<p>老司机屌不屌！！！</p>\n<p>屌！真屌！太屌了！非常之屌！24K纯屌！</p>\n</blockquote>\n<hr>\n<p>然后放一些老司机搜集并验证过的常用正则吧：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类别</th>\n<th style=\"text-align:center\">表格</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">数字</td>\n<td style=\"text-align:center\">\\d+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">字母</td>\n<td style=\"text-align:center\">[a-zA-Z]+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">中文</td>\n<td style=\"text-align:center\">[\\u4E00-\\u9FA5]+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">所有符号</td>\n<td style=\"text-align:center\">[\\W_]+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Email</td>\n<td style=\"text-align:center\">^[A-Za-z\\d]+([-_.][A-Za-z\\d]+)<em>@([A-Za-z\\d]+[-.])</em>([A-Za-z\\d]+[.])+[A-Za-z\\d]{2,5}$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">手机号码</td>\n<td style=\"text-align:center\">1[34578]\\d{9}</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">座机电话</td>\n<td style=\"text-align:center\">(0[\\d]{2,3}-)?([2-9][\\d]{6,7})(-[\\d]{1,4})?</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">自然数</td>\n<td style=\"text-align:center\">\\d+(\\.\\d+)?</td>\n</tr>\n</tbody>\n</table>\n<p>URL这个放在表格里面格式就不对了，我就放外面了：<br>URL = ((http|ftp|https)://)?((([a-zA-Z0-9]+[a-zA-Z0-9<em>-]*\\.)+[a-zA-Z]{2,6})|(([0-9]{1,3}\\.){3}[0-9]{1,3}(:[0-9]{1,4})?))((/[a-zA-Z\\d</em>]+)*(\\?([a-zA-Z\\d<em>]+=[a-zA-Z\\d\\u4E00-\\u9FA5\\s\\+%#\\</em>-]+&amp;)*([a-zA-Z\\d_]+=[a-zA-Z\\d\\u4E00-\\u9FA5\\s\\+%#_-]+))?)?</p>\n<hr>\n<p>冲着老司机情人节不开房开博客的情怀，是不是应该有一大波赞！！！一大波关注！！！！一大波star！！！！！</p>\n<hr>\n<p>不过熟悉老司机的童靴是知道老司机的套路的，老司机讲课要什么？</p>\n<p>要赞！要关注！！要star！！！</p>\n<p>这期带来的小工具：</p>\n<p><a href=\"https://github.com/CodeWicky/-Tools/tree/master/DWRegExpUtils\" target=\"_blank\" rel=\"external\">DWRegexUtils</a></p>\n<p>正则工具类，这也是老司机的心血结晶啊，提供自然人思维的链式语法优雅的返回正则表达式。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-c34ec5e64aa0c67d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"虽然这点难以解释\"></p>\n<p>预置常用正则表达式。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ac8a766a7c4742c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"预置校验1\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b1e12f10f021e21f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"预置校验2\"></p>\n<p>提供正则判断的工具类！</p>\n<p>如果觉得好用可以给整个仓库一个star哟！整个仓库里面全都是工具类哟！上哪里去找这么好的仓库！！！<a href=\"https://github.com/CodeWicky/-Tools\" target=\"_blank\" rel=\"external\">仓库传送门</a></p>\n<hr>\n<p>有童鞋说这个工具类不会使用，恩，我理解！因为提供的自由度较广所以传参比较多，所以老司机昨天发博客的时候自己想捋捋怎么用也回忆了一小下，那我就简单说一下吧。</p>\n<p>首先，需明确的概念是，在这个工具类中，老司机是想以一种<code>组件</code>的形式去生成正则表达式。组件对应的就是<code>正则表达式中元素</code>的概念。<br>从头文件中可以看到，老司机使用一个枚举（严格点这是按位掩码）定义了组件类型DWRegexComponent。使用的时候你可以<br><code>DWRegexComponentNumber |DWRegexComponentUppercaseLetter</code>这样来表示数字和大写字母同时作为组件元素。</p>\n<p>第二个概念是<code>条件</code>。其实上面的教程里你应该发现了正则就是用<code>一个个小的表达式组成一个大的表达式</code>。而老司机这里就是一<code>添加条件的方式来添加表达式</code>。我用了另一个枚举类型DWRegexCondition定义了6种条件方式。其中4种是预查，allIs，allNot，notAll，contain，这些都是预查条件，所有都有PreSearch前缀。还有两种子式条件contain和without，即包含与非包含。</p>\n<p>恩，两个枚举完事了，搞定剩下三个api，你就能用它写出正则了。</p>\n<p>说说为什么会是链式语句呢？因为<code>链式语句从形式上更能代表人的顺向思维</code>，所谓想到哪写到哪，所以采用了链式语句生成正则，用过masonry的童鞋一定可以很快上手。</p>\n<p>首先调用<code>+dw_GetRegexStringWithMaker:</code>方法来以block形式生成正则语句。</p>\n<p>一下三个api都可以通过maker的点语法点出来，类比masonry就好了。</p>\n<blockquote>\n<p>AddConditionWithComponentType()</p>\n</blockquote>\n<p>这个方法你要传6个参数，有点多呵呵🙃。<br>分别是<code>组件、额外字符串、条件、最小匹配数、最大匹配数及是否为贪婪模式</code>。<br>有了枚举的介绍其实你应该仅不知道额外字符串是什么鬼。<br>首先<code>以组件来做成基本元素</code>，然而老司机预置的组件中可能<code>不能代表全部你要的元素</code>，所以可以<code>通过额外字符串来对组件进行补充</code>。然后<code>以组件和额外字符串作为元素</code>，<code>配合条件即范围生成一条正则表达式</code>。<br>上图例子中的，详情请见上面图的第一个表达式。</p>\n<blockquote>\n<p>AddConditionWithComponentRegexString()</p>\n</blockquote>\n<p>举一反三的想一下，套路是一样的。你需要5个参数，<code>子串、条件、两端范围及贪婪模式</code>。<br>应用场景就是你不想用组件模式生成元素，而是想<code>手撸一个元素集合</code>时，子串即传入你的元素集合，在<code>添加条件、范围即可</code>，例子见第二个表达式。</p>\n<blockquote>\n<p>AddConditionWithCompleteRegexString()</p>\n</blockquote>\n<p>仅需要传入两个参数，即你连范围都能自己撸，你就写一个<code>完整的正则表达式作为元素</code>，<code>添加条件组成一个更加丰富的正则表达式</code>。</p>\n<p>所以说<code>借助这三个api加以你灵活的使用</code>你就能生成所有你想要的表达式，只要你能够把大需求拆分成一个个小条件。<code>事实上第一个api自由度最高，你熟练使用这个就行</code>。</p>\n<p>最后，这三个api中如果你的<code>条件模式为预查</code>，则<code>无论你在什么位置</code>添加条件，最后都会<code>自动的拼接在正则表达式的前方</code>。而<code>子式条件添加的顺序即为子式的顺序</code>。</p>\n<p>恩，有了讲解配合上面的例子，这个工具类应该就可以使用了。不是吹捧自己的东西，只要<code>熟练使用第一个api</code>你真的能写出所有正则，你需要的只是学习一个api的成本。另外，<code>用多了或许你就能很好的拆分了，然后自己也就能写了</code>。</p>\n<hr>\n<p>另外，DWCoreTextLabel已经全面支持自动链接匹配了，包括数字、email、url链接、手机号等。欢迎star！！！跪求star！！！这是老司机主力推的库😢。</p>\n<h3 id=\"软广\"><a href=\"#软广\" class=\"headerlink\" title=\"软广\"></a>软广</h3><p>DWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。</p>\n<blockquote>\n<p>version 1.1.0<br>全面支持自动链接支持、定制检测规则、图文混排、响应事件<br>优化大部分算法，提高响应效率及绘制效率</p>\n<p>version 1.1.1<br>高亮取消逻辑优化<br>自动检测逻辑优化<br>部分常用方法改为内联函数，提高运行效率</p>\n<p>version 1.1.2<br>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）</p>\n<p>version 1.1.3<br>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中</p>\n<p>version 1.1.4<br>事务管理类去除，异步绘制文件抽出</p>\n<p>version 1.1.5<br>添加网络图片异步加载库，支持绘制网络图片</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你哟\"></p>"},{"title":"老司机出品——源码解析之RunLoop详解","layout":"post","date":"2017-05-01T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![RunLoop详解](http://upload-images.jianshu.io/upload_images/1835430-cccdcd8278846522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n不得不说，人的**惰性**是真可怕啊。\n从上周六就到写runLoop的建议开始，星期三告诉自己从星期四开始着手写这篇博客。然而现在戳个时间戳，现在是4.30星期日。写完发出去又不知道是什么时候啦，哈哈哈😁\n\n![懒癌](http://upload-images.jianshu.io/upload_images/1835430-eb798302dcb50708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这一期讲什么呢？这一期讲runLoop哟。一直以来，runLoop这个**玄而又玄**的东西似乎被当做了公司面试挑人的终极话题，原因不难想，日常开发用到`runLoop的地方少之又少`，没有时间的积累这方面的知识应该还是相对较于匮乏的，`所以runLoop的了解侧面也能发应开发者的开发经验`，当然就被当做甄选人才的最后杀器。你可能一脸愤怒的说平时有用不到，我不会也不影响开发啊！的确，用不到，但这只是一个过滤器而已。**但是蛋疼的是，在于国内的环境下，runLoop的相关资料又是少之又少，开发者又难以有一个深入的了解**。\n\n出于以上原因，老司机今天就以**老司机个人的角度**，尽可能将老司机所了解到的runLoop知识。\n\n在今天的文章中你可能会看到以下内容：\n\n- runLoop相关知识\n\n<!-- more -->\n\n- - -\n# runLoop是什么\n\n直译以下，跑圈。翻译以下，`事件循环`吧。\n为什么要有这个事件循环呢？我们知道，任何程序如果执行到程序的最后一句之后都会结束运行。然而对于我们要的手机应用程序而言，他显然不可以执行一个事件后就结束运行，他应该具有`持续接受事件`的能力从而不断地处理事件。所以最基本的思路就是用于个`while循环`让程序不能走到最后一句结束，而是在循环体内不断的接受事件。所以我们需要runLoop。不过值得注意的是，runLoop并不是iOS独有的概念，因为准去的来说`runLoop应该是一个模式，在其他平台同样存在这种模式`，不过叫不叫runLoop我就不知道了。\n\n\n![循环](http://upload-images.jianshu.io/upload_images/1835430-9f5079fdc39bf56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- - - \n# runLoop是如何实现的\n\n首先要明确的一点事，在平时我们使用的是Foundation框架的NSRunLoop类去做一些实现，而其实NSRunLoop是基于CoreFoundation框架中的CFRunLoop进行的一层简单的封装。所以我们这里着重介绍**CFRunLoop**，毕竟我们能拿到[CFRunLoop的源码](http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz)。\n\n## runLoop的组成\n\n```\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t\t\t/* locked for accessing mode list */\n    __CFPort _wakeUpPort;\t\t\t// used for CFRunLoopWakeUp \n    Boolean _unused;\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread;\n    uint32_t _winthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    struct _block_item *_blocks_head;\n    struct _block_item *_blocks_tail;\n    CFTypeRef _counterpart;\n};\n```\n我们大概可以CFRunLoop是这么一个结构体。\n我们可以看到结构体重有用来保证线程安全的锁`_lock`，有用来唤醒runLoop的端口`_wakeUpPort`（这里后面会说到，不用执着），有线程对象`_pthread`，还有一个模式集合`_modes`以及一些其他辅助的属性。\n\n\n### _pthread\n这里我要说的是，runLoop与线程是一一对应的。也就是说**一个runLoop对应着一个线程，一个线程对应着一个runLoop**。这里我们从runLoop的构造函数和获取函数即可看出：\n\n```\nstatic CFRunLoopRef __CFRunLoopCreate(pthread_t t) {\n    CFRunLoopRef loop = NULL;\n    CFRunLoopModeRef rlm;\n    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);\n    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);\n    if (NULL == loop) {\n\treturn NULL;\n    }\n    (void)__CFRunLoopPushPerRunData(loop);\n    __CFRunLoopLockInit(&loop->_lock);\n    loop->_wakeUpPort = __CFPortAllocate();\n    if (CFPORT_NULL == loop->_wakeUpPort) HALT;\n    __CFRunLoopSetIgnoreWakeUps(loop);\n    loop->_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);\n    CFSetAddValue(loop->_commonModes, kCFRunLoopDefaultMode);\n    loop->_commonModeItems = NULL;\n    loop->_currentMode = NULL;\n    loop->_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);\n    loop->_blocks_head = NULL;\n    loop->_blocks_tail = NULL;\n    loop->_counterpart = NULL;\n    loop->_pthread = t;\n#if DEPLOYMENT_TARGET_WINDOWS\n    loop->_winthread = GetCurrentThreadId();\n#else\n    loop->_winthread = 0;\n#endif\n    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);\n    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);\n    return loop;\n}\n```\n可以看出构造一个runLoop对象仅需要一个**pthread_t**线程即可。即一个runLoop对应一个线程。\n\n```\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {\n    if (pthread_equal(t, kNilPthreadT)) {//如果传入线程为空指针则默认取主线程对应的runLoop\n\tt = pthread_main_thread_np();\n    }\n    __CFSpinLock(&loopsLock);\n    if (!__CFRunLoops) {//__CFRunLoops就是一个全局字典，以下代码为如果全局字典不存在则创建全局字典，并将主线程对应的mainLoop存入字典中\n        __CFSpinUnlock(&loopsLock);\n        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);\n        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);\n        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {\n            CFRelease(dict);\n        }\n        CFRelease(mainLoop);\n        __CFSpinLock(&loopsLock);\n    }\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));//从全局字典中，取出对应线程的runLoop\n    __CFSpinUnlock(&loopsLock);\n    if (!loop) {//若对应线程的runLoop为空，则创建对应相乘的runLoop并保存在全局字典中\n        CFRunLoopRef newLoop = __CFRunLoopCreate(t);\n        __CFSpinLock(&loopsLock);\n        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n        if (!loop) {\n            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\n            loop = newLoop;\n        }\n        // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it\n        __CFSpinUnlock(&loopsLock);\n        CFRelease(newLoop);\n    }\n    if (pthread_equal(t, pthread_self())) {\n        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);\n        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {\n            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);\n        }\n    }\n    return loop;\n}\n```\n\n这是runLoop的获取函数，我们看到系统从一个**全局字典中取出runLoop**，key就是一个线程，这足以说明runLoop与线程是`一一对应`的关系。\n\n值得一提的是，`一个线程最开始是没有对应的runLoop`的，是`在调用获取函数的时候才对应了一个runLoop的`。**因为本身这个对应关系是有runLoop类管理的，而不是线程**。\n\n\n当然上述两个为私有api，CF真正对外暴露的只有两个接口：\n\n```\nCF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);\nCF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);\n```\n\n两个方法的实现很简单，只要把对应的线程传入获取函数即可：\n\n```\nCFRunLoopRef CFRunLoopGetMain(void) {\n    CHECK_FOR_FORK();\n    static CFRunLoopRef __main = NULL; // no retain needed\n    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed\n    return __main;\n}\n\nCFRunLoopRef CFRunLoopGetCurrent(void) {\n    CHECK_FOR_FORK();\n    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);\n    if (rl) return rl;\n    return _CFRunLoopGet0(pthread_self());\n}\n```\n\n- - -\n### _modes\n\n我们看到，一个runLoop中同时还维护着一个集合，_modes。那么这个modes是做什么的呢？应该说，_modes才是`runLoop的核心`。咳咳（敲黑板），划重点了啊。\n\n首先我们看一下这个_modes里面到底都装了些什么？\n答案是`__CFRunLoopMode`对象。那么他又是什么呢？\n\n```\nstruct __CFRunLoopMode {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */\n    CFStringRef _name;\n    Boolean _stopped;\n    char _padding[3];\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n    CFMutableDictionaryRef _portToV1SourceMap;\n    __CFPortSet _portSet;\n    CFIndex _observerMask;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    dispatch_source_t _timerSource;\n    dispatch_queue_t _queue;\n    Boolean _timerFired; // set to true by the source when a timer has fired\n    Boolean _dispatchTimerArmed;\n#endif\n#if USE_MK_TIMER_TOO\n    mach_port_t _timerPort;\n    Boolean _mkTimerArmed;\n#endif\n#if DEPLOYMENT_TARGET_WINDOWS\n    DWORD _msgQMask;\n    void (*_msgPump)(void);\n#endif\n    uint64_t _timerSoftDeadline; /* TSR */\n    uint64_t _timerHardDeadline; /* TSR */\n};\n```\n这里老司机挑出了几个重点，有用来标志runLoopMode的标志`_name`，有两个事件源的集合`_sources0、_sources1`，有一组观察者`_obeserver`，有一组被加入到runLoop中的`_timers`，还有Mode本身维护着的一个用于计时的`_timerSource`，`_timerPort`。这两个一个是GCD时钟一个是内核时钟。\n\n至于runLoopMode为什么长这样，老司机会在下面runLoopRun的实现中结合代码讲到。\n- - - \n## runLoop代码实现\n\n恩，接下来代码有点长，先给你们看一下大概流程，然后对着流程去看一下代码。\n\n![图是我盗的](http://upload-images.jianshu.io/upload_images/1835430-a84a8802abc125cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n前方高能预警，代码很多！\n\nrunLoop核心代码\n\n```\n/* rl, rlm are locked on entrance and exit */\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    uint64_t startTSR = mach_absolute_time();//获取当前内核时间\n    \n    if (__CFRunLoopIsStopped(rl)) {//如果当前runLoop或者runLoopMode为停止状态的话直接返回\n        __CFRunLoopUnsetStopped(rl);\n        return kCFRunLoopRunStopped;\n    } else if (rlm->_stopped) {\n        rlm->_stopped = false;\n        return kCFRunLoopRunStopped;\n    }\n    \n    //判断是否是第一次在主线程中启动RunLoop,如果是且当前RunLoop为主线程的RunLoop，那么就给分发一个队列调度端口\n    mach_port_name_t dispatchPort = MACH_PORT_NULL;\n    Boolean libdispatchQSafe = pthread_main_np() && ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));\n    if (libdispatchQSafe && (CFRunLoopGetMain() == rl) && CFSetContainsValue(rl->_commonModes, rlm->_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();\n    \n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n\n\t//给当前模式分发队列端口\n    mach_port_name_t modeQueuePort = MACH_PORT_NULL;\n    if (rlm->_queue) {\n        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm->_queue);\n        if (!modeQueuePort) {\n            CRASH(\"Unable to get port for run loop mode queue (%d)\", -1);\n        }\n    }\n#endif\n    \n    //初始化一个GCD计时器，用于管理当前模式的超时\n    dispatch_source_t timeout_timer = NULL;\n    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));\n    if (seconds <= 0.0) { // instant timeout\n        seconds = 0.0;\n        timeout_context->termTSR = 0ULL;\n    } else if (seconds <= TIMER_INTERVAL_LIMIT) {\n        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);\n        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n        dispatch_retain(timeout_timer);\n        timeout_context->ds = timeout_timer;\n        timeout_context->rl = (CFRunLoopRef)CFRetain(rl);\n        timeout_context->termTSR = startTSR + __CFTimeIntervalToTSR(seconds);\n        dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context\n        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);\n        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);\n        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);\n        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);\n        dispatch_resume(timeout_timer);\n    } else { // infinite timeout\n        seconds = 9999999999.0;\n        timeout_context->termTSR = UINT64_MAX;\n    }\n    \n    // 第一步，进入循环\n    Boolean didDispatchPortLastTime = true;\n    int32_t retVal = 0;\n    do {\n        uint8_t msg_buffer[3 * 1024];\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        mach_msg_header_t *msg = NULL;\n        mach_port_t livePort = MACH_PORT_NULL;\n#elif DEPLOYMENT_TARGET_WINDOWS\n        HANDLE livePort = NULL;\n        Boolean windowsMessageReceived = false;\n#endif\n        __CFPortSet waitSet = rlm->_portSet;\n        \n        //设置当前循环监听端口的唤醒\n        __CFRunLoopUnsetIgnoreWakeUps(rl);\n        \n        // 第二步，通知观察者准备开始处理Timer源事件\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n        \n        // 第三步，通知观察者准备开始处理Source源事件\n        if (rlm->_observerMask & kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n        \n        //执行提交到runLoop中的block\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        // 第四步，执行source0中的源事件\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        \n        //如果当前source0源事件处理完成后执行提交到runLoop中的block\n        if (sourceHandledThisLoop) {\n            __CFRunLoopDoBlocks(rl, rlm);\n        }\n        \n        //标志是否等待端口唤醒\n        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n        \n        // 第五步，检测端口，如果端口有事件则跳转至handle_msg（首次执行不会进入判断，因为didDispatchPortLastTime为true）\n        if (MACH_PORT_NULL != dispatchPort && !didDispatchPortLastTime) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n            msg = (mach_msg_header_t *)msg_buffer;\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0)) {\n                goto handle_msg;\n            }\n#elif DEPLOYMENT_TARGET_WINDOWS\n            if (__CFRunLoopWaitForMultipleObjects(NULL, &dispatchPort, 0, 0, &livePort, NULL)) {\n                goto handle_msg;\n            }\n#endif\n        }\n        \n        didDispatchPortLastTime = false;\n        \n        // 第六步，通知观察者线程进入休眠\n        if (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n        \n        // 标志当前runLoop为休眠状态\n        __CFRunLoopSetSleeping(rl);\n        \n        // do not do any user callouts after this point (after notifying of sleeping)\n        \n        // Must push the local-to-this-activation ports in on every loop\n        // iteration, as this mode could be run re-entrantly and we don't\n        // want these ports to get serviced.\n        \n        __CFPortSetInsert(dispatchPort, waitSet);\n        \n        __CFRunLoopModeUnlock(rlm);\n        __CFRunLoopUnlock(rl);\n   \n   \n   \t\t// 第七步，进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop     \n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        do {\n            if (kCFUseCollectableAllocator) {\n                objc_clear_stack(0);\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY);\n            \n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.\n                while (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n                    // Leave livePort as the queue port, and service timers below\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n        } while (1);\n#else\n        if (kCFUseCollectableAllocator) {\n            objc_clear_stack(0);\n            memset(msg_buffer, 0, sizeof(msg_buffer));\n        }\n        msg = (mach_msg_header_t *)msg_buffer;\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY);\n#endif\n        \n        \n#elif DEPLOYMENT_TARGET_WINDOWS\n        // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.\n        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm->_msgQMask, &livePort, &windowsMessageReceived);\n#endif\n        \n        __CFRunLoopLock(rl);\n        __CFRunLoopModeLock(rlm);\n        \n        // Must remove the local-to-this-activation ports in on every loop\n        // iteration, as this mode could be run re-entrantly and we don't\n        // want these ports to get serviced. Also, we don't want them left\n        // in there if this function returns.\n        \n        __CFPortSetRemove(dispatchPort, waitSet);\n        \n        //标志当前runLoop为唤醒状态\n        __CFRunLoopSetIgnoreWakeUps(rl);\n        \n        // user callouts now OK again\n        __CFRunLoopUnsetSleeping(rl);\n        \n        // 第八步，通知观察者线程被唤醒了\n        if (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n        \n        //执行端口的事件\n    handle_msg:;\n    \n    \t//设置此时runLoop忽略端口唤醒（保证线程安全）\n        __CFRunLoopSetIgnoreWakeUps(rl);\n        \n#if DEPLOYMENT_TARGET_WINDOWS\n        if (windowsMessageReceived) {\n            // These Win32 APIs cause a callout, so make sure we're unlocked first and relocked after\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            \n            if (rlm->_msgPump) {\n                rlm->_msgPump();\n            } else {\n                MSG msg;\n                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) {\n                    TranslateMessage(&msg);\n                    DispatchMessage(&msg);\n                }\n            }\n            \n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            sourceHandledThisLoop = true;\n            \n            // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced\n            // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we're just checking to see if the things are signalled right now -- we will wait on them again later.\n            // NOTE: Ignore the dispatch source (it's not in the wait set anymore) and also don't run the observers here since we are polling.\n            __CFRunLoopSetSleeping(rl);\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            \n            __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &livePort, NULL);\n            \n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            __CFRunLoopUnsetSleeping(rl);\n            // If we have a new live port then it will be handled below as normal\n        }\n        \n        \n#endif\n\n\t\t// 第九步，处理端口事件\n        if (MACH_PORT_NULL == livePort) {\n            CFRUNLOOP_WAKEUP_FOR_NOTHING();\n            // handle nothing\n        } else if (livePort == rl->_wakeUpPort) {\n            CFRUNLOOP_WAKEUP_FOR_WAKEUP();\n            // do nothing on Mac OS\n#if DEPLOYMENT_TARGET_WINDOWS\n            // Always reset the wake up port, or risk spinning forever\n            ResetEvent(rl->_wakeUpPort);\n#endif\n        }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                // Re-arm the next timer, because we apparently fired early\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n#if USE_MK_TIMER_TOO\n        else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {//处理定时器事件\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.\n            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                // Re-arm the next timer\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n\t\t//处理有GCD提交到主线程唤醒的事件\n        else if (livePort == dispatchPort) {\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);\n#if DEPLOYMENT_TARGET_WINDOWS\n            void *msg = 0;\n#endif\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);\n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            sourceHandledThisLoop = true;\n            didDispatchPortLastTime = true;\n        } else {\n        \n\t        //处理source1唤醒的事件\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            // Despite the name, this works for windows handles as well\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n            if (rls) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n                mach_msg_header_t *reply = NULL;\n                // 处理Source1(基于端口的源)\n                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n                if (NULL != reply) {\n                    (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);\n                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);\n                }\n#elif DEPLOYMENT_TARGET_WINDOWS\n                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;\n#endif\n            }\n        }\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n#endif\n        \n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        //返回对应的返回值并跳出循环\n        if (sourceHandledThisLoop && stopAfterHandle) {\n            retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n        } else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n            retVal = kCFRunLoopRunStopped;\n        } else if (rlm->_stopped) {\n            rlm->_stopped = false;\n            retVal = kCFRunLoopRunStopped;\n        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n            retVal = kCFRunLoopRunFinished;\n        }\n    } while (0 == retVal);\n    \n    // 第十步，释放定时器\n    if (timeout_timer) {\n        dispatch_source_cancel(timeout_timer);\n        dispatch_release(timeout_timer);\n    } else {\n        free(timeout_context);\n    }\n    \n    return retVal;\n}\n```\n\n这个方法有点有点长，300行代码=。=\n\n这300行的流程其实就是上面归纳的10步：\n\n> 首先进入runLoop对应的Mode并开始循环，然后在休眠之前做了三件事：DoBlocks、DoSource0、检测source1端口是否有消息，如果有则跳过稍后的休眠。\n然后runLoop就进入了休眠状态，直到有端口事件唤醒runLoop，被唤醒后则处理响应的端口事件然后再次开始循环。直到runLoop超时或者runLoop被停止后在结束runLoop。\n\n不过好在代码很全，在这里我们能出到很多问题。\n\n### source0，source1\n\n首先这个源事件分为两种，一种是不基于端口的source0，一直是基于端口的source1。\n\n\n> Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n\n> Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。\n\n> ————[引自深入理解RunLoop\n](http://blog.ibireme.com/2015/05/18/runloop/)\n\n- - -\n\n> source0呢主要处理App内部事件、App自己负责管理（触发），如UIEvent、CFSocket\n\n> source1呢主要有Runloop和内核管理，Mach port驱动，如CFMahPort、CFMessagePort\n\n> ————引自孙源runLoop线下分享会视频 \n\n\n\n\n### NSTimer事件是借助runLoop实现的。\n这点老司机早在CoreAnimation系列中第三篇介绍三个Timer的时候老司机就有提到过，在初始化Timer的时候要将Timer提交到runLoop中，并且要指定mode，才可以工作。今天我们可以深入讲一下。\n\n> 这个事件是怎么执行的？并且为什么有的时候会延迟？为什么子线程中创建的Timer并不执行？\n\n> 首先，在进入循环开始以后，就要处理source0事件，处理后检测一下source1端口是否有消息，如果一个Timer的时间间隔刚好到了则此处有可能会得到一个消息，则runLoop直接跳转至端口激活处从而去处理Timer事件。\n\n> 第二，为什么会延迟？我们知道，两次端口事件是在两个runLoop循环中分别执行的。比如Timer的时间间隔为1秒，在第一次Timer回调结束后，在很短时间内立即进入runLoop的下一次循环，这次并不是Timer回调并且是一个计算量非常大的任务，计算时间超过了1秒，那么runLoop的第二个循环就要执行很久，无法进入下一个循环等待有可能即将到来的Timer第二次回调的信号，所以Timer第二次回调就会推迟了。\n\n> 第三，为什么在子线程中创建的Timer并且提交到当前runLoop中并不会运行？这还是要从runLoop的获取函数中看，当调用currentRunLoop的时候会取当前线程对应的runLoop，而首次是取不到的，则会创建一个新的runLoop。但是！这个runLoop并没有run。就是没有开启=。=\n\n- - -\n### 同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？\n\n从runLoop的结构我们可以知道，一个runLoop会包含多种runLoopMode，runLoop是不停的在这些mode之间进行切换去完成对应Mode中的相关任务。\n\n![runLoop中多个mode](http://upload-images.jianshu.io/upload_images/1835430-1a9ffd190ef7c73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n首先为什么说runLoop只能在各种Mode之间切换，同一时间只能存在一个呢？\n因为上面那个方法必须要传一个runLoopMode，然后这个方法贯穿始终，都在用。\n\n\n我们看到，上面的方法中首先就要传入一个指定的mode才能执行对应mode中的事件。那么所谓的CommonMode是如何实现的呢？\n\n我们看到runLoop中执行任务有调到CFRunLoopDoBlocks这么一个函数，那么这个函数是什么样的呢？\n\n```\nstatic Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) { // Call with rl and rlm locked\n    if (!rl->_blocks_head) return false;\n    if (!rlm || !rlm->_name) return false;\n    ...省略一些非重点...\n    while (item) {\n        struct _block_item *curr = item;\n        item = item->_next;\n\tBoolean doit = false;\n\tif (CFStringGetTypeID() == CFGetTypeID(curr->_mode)) {\n\t    doit = CFEqual(curr->_mode, curMode) || (CFEqual(curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode));\n        } else {\n\t    doit = CFSetContainsValue((CFSetRef)curr->_mode, curMode) || (CFSetContainsValue((CFSetRef)curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode));\n\t}\n\tif (!doit) prev = curr;\n\tif (doit) {\n\t    if (prev) prev->_next = item;\n\t    if (curr == head) head = item;\n\t    if (curr == tail) tail = prev;\n\t    void (^block)(void) = curr->_block;\n            CFRelease(curr->_mode);\n            free(curr);\n\t    if (doit) {\n                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n\t        did = true;\n\t    }\n    ...省略一些非重点...\n    return did;\n}\n```\n\n我们看到`doit`这个bool变量完全决定了当前block是否执行。默认他是No的，而他被置为true的条件就是`CFEqual(curr->_mode, curMode) || (CFEqual(curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode))`。就是当前mode与制定mode相等或者当前mode为commonMode（此处为一个字符串）且commonMode（此处为一个集合，若有不懂，请看runLoop结构）这个集合中包含指定mode。\n\n这是因为这个判断的存在才允许commondMode可以在任意Mode下执行。\n当然这是提交到runLoop里的代码块才会走到`__CFRunLoopDoBlocks`这个方法。\n\n相同的，我们通过上述代码也可以知道，runLoop通过端口唤醒的事件需要通过__CFRunLoopDoSource1和__CFRunLoopDoTimers两个方法来调用。__CFRunLoopDoSource1方法没什么说的，直接调用源事件runLoopSourceRef即可。重点我们看一下Timer的实现，核心代码如下：\n\n```\nstatic Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) {\t/* DOES CALLOUT */\n    Boolean timerHandled = false;\n    CFMutableArrayRef timers = NULL;\n    //遍历runLoopMode维护的Timers数组，取其中有效的timer并加入新临时数组\n    for (CFIndex idx = 0, cnt = rlm->_timers ? CFArrayGetCount(rlm->_timers) : 0; idx < cnt; idx++) {\n        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm->_timers, idx);\n        \n        if (__CFIsValid(rlt) && !__CFRunLoopTimerIsFiring(rlt)) {\n            if (rlt->_fireTSR <= limitTSR) {\n                if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);\n                CFArrayAppendValue(timers, rlt);\n            }\n        }\n    }\n    //遍历临时数组，每个有效Timer调用__CFRunLoopDoTimer\n    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx < cnt; idx++) {\n        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);\n        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);\n        timerHandled = timerHandled || did;\n    }\n    if (timers) CFRelease(timers);\n    return timerHandled;\n}\n```\n我们可以看到，此处Timer是否会回调完全取决于对应Mode的_Timers数组。那么当我们将Timer加入到commonModes中的时候一定是同时将Timer加入到了commonModes所包含的其他Mode中了，我们看下代码：\n\n```\nvoid CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {    \n    CHECK_FOR_FORK();\n    if (__CFRunLoopIsDeallocating(rl)) return;\n    if (!__CFIsValid(rlt) || (NULL != rlt->_runLoop && rlt->_runLoop != rl)) return;\n    __CFRunLoopLock(rl);\n    if (modeName == kCFRunLoopCommonModes) {//commonModes分支\n    \t//取到commonModes所代表的Mode的集合\n        CFSetRef set = rl->_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl->_commonModes) : NULL;\n        if (NULL == rl->_commonModeItems) {\n        \t//将commonModeItems中加入当前定时器\n            rl->_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);\n        }\n        CFSetAddValue(rl->_commonModeItems, rlt);\n        if (NULL != set) {\n            CFTypeRef context[2] = {rl, rlt};\n            /* add new item to all common-modes */\n            //最主要还是还是这句，这句的作用是集合中的所有对象均调用__CFRunLoopAddItemToCommonModes这个方法。\n            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);\n            CFRelease(set);\n        }\n    } else {//非commonModes的分支\n        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);\n        if (NULL != rlm) {\n            if (NULL == rlm->_timers) {\n                CFArrayCallBacks cb = kCFTypeArrayCallBacks;\n                cb.equal = NULL;\n                rlm->_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &cb);\n            }\n        }\n        if (NULL != rlm && !CFSetContainsValue(rlt->_rlModes, rlm->_name)) {\n            __CFRunLoopTimerLock(rlt);\n            if (NULL == rlt->_runLoop) {\n                rlt->_runLoop = rl;\n            } else if (rl != rlt->_runLoop) {\n                __CFRunLoopTimerUnlock(rlt);\n                __CFRunLoopModeUnlock(rlm);\n                __CFRunLoopUnlock(rl);\n                return;\n            }\n            CFSetAddValue(rlt->_rlModes, rlm->_name);\n            __CFRunLoopTimerUnlock(rlt);\n            __CFRunLoopTimerFireTSRLock();\n            __CFRepositionTimerInMode(rlm, rlt, false);\n            __CFRunLoopTimerFireTSRUnlock();\n            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) {\n                // Normally we don't do this on behalf of clients, but for\n                // backwards compatibility due to the change in timer handling...\n                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);\n            }\n        }\n        if (NULL != rlm) {\n            __CFRunLoopModeUnlock(rlm);\n        }\n    }\n    __CFRunLoopUnlock(rl);\n}\n\nstatic void __CFRunLoopAddItemToCommonModes(const void *value, void *ctx) {\n    CFStringRef modeName = (CFStringRef)value;\n    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);\n    CFTypeRef item = (CFTypeRef)(((CFTypeRef *)ctx)[1]);\n    if (CFGetTypeID(item) == __kCFRunLoopSourceTypeID) {\n\tCFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);\n    } else if (CFGetTypeID(item) == __kCFRunLoopObserverTypeID) {\n\tCFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);\n    } else if (CFGetTypeID(item) == __kCFRunLoopTimerTypeID) {\n\tCFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);\n    }\n}\n\n\n```\n我们可以看到，当加入到commonModes中时，实际上系统是`找出commonModes代表的所有Mode`，如defaultMode和trackingMode，让后分别将其加入了这些mode中。\n同样的方法还有`CFRunLoopAddSource`/`CFRunLoopAddObserver`都是同样的道理。\n\n\n\n\n所以说当scrollView或其子类进行滚动的时候，UIKIT会自动将当前runLoopMode切换为UITrackingRunLoopMode，所以你加在defaultMode中的计时器当然不会走了。\n\n\n\n---\n### runLoop是如何休眠有如何被唤醒的？\n\n从第7步开始，我们看到runLoop进入了休眠状态。然而所谓的休眠状态指示将当前runLoop标记为休眠之后，**进入了一个while死循环**。然后在循环内就不断的去读取端口消息。如果说从端口中**读取到一个唤醒信息的话，break掉while循环从而进入唤醒状态**。\n\n\n关于runLoop的几种mode老司机之前也有讲过，在CoreAnimation中的第三篇中有讲到，这里就只罗列一下。\n\n- NSDefaultRunLoopMode\n- NSConnectionReplyMode\n- NSModalPanelRunLoopMode\n- UITrackingRunLoopMode\n- NSRunLoopCommonModes\n\n- - -\n### 可以唤醒runLoop的都有哪些事件？\n从源码中我们可以看出，所谓的runLoop进入休眠状态不过是一个while循环，如下：\n\n```\ndo {\n            if (kCFUseCollectableAllocator) {\n                objc_clear_stack(0);\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY);\n            \n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.\n                while (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n                    // Leave livePort as the queue port, and service timers below\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n } while (1);\n```\n\n相应的我们还得看一个函数，`__CFRunLoopServiceMachPort`：\n\n```\nstatic Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t**buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout) {\n    Boolean originalBuffer = true;\n    kern_return_t ret = KERN_SUCCESS;\n    for (;;) {\t\t/* In that sleep of death what nightmares may come ... */\n        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;\n        msg->msgh_bits = 0;\n        msg->msgh_local_port = port;\n        msg->msgh_remote_port = MACH_PORT_NULL;\n        msg->msgh_size = buffer_size;\n        msg->msgh_id = 0;\n        if (TIMEOUT_INFINITY == timeout) { CFRUNLOOP_SLEEP(); } else { CFRUNLOOP_POLL(); }\n        ret = mach_msg(msg, MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg->msgh_size, port, timeout, MACH_PORT_NULL);\n        CFRUNLOOP_WAKEUP(ret);\n        if (MACH_MSG_SUCCESS == ret) {\n            *livePort = msg ? msg->msgh_local_port : MACH_PORT_NULL;\n            return true;\n        }\n        if (MACH_RCV_TIMED_OUT == ret) {\n            if (!originalBuffer) free(msg);\n            *buffer = NULL;\n            *livePort = MACH_PORT_NULL;\n            return false;\n        }\n        if (MACH_RCV_TOO_LARGE != ret) break;\n        buffer_size = round_msg(msg->msgh_size + MAX_TRAILER_SIZE);\n        if (originalBuffer) *buffer = NULL;\n        originalBuffer = false;\n        *buffer = realloc(*buffer, buffer_size);\n    }\n    HALT;\n    return false;\n}\n```\n\n我们先看后面这个函数，在这里仅有`两种情况会对livePort进行赋值`，一种是**成功获取到消息后**，会根据情况赋值为msg->msgh_local_port或者MACH_PORT_NULL，而另一种**获取消息超时**的情况会赋值为MACH_PORT_NULL。首先请先记住这两个结论。\n\n然后我们把目光聚焦到while循环中，在调用`__CFRunLoopServiceMachPort`后如果livePort变成了`modeQueuePort`(livePort初值为MACH_PORT_NULL)，则代表为当前队列的检测端口，那么在`_dispatch_runloop_root_queue_perform_4CF`的条件下再次进入二级循环，知道Timer被激活了才跳出二级循环继续循环一级循环。（这一步的目的不好意思老司机真没看懂）。\n\n那么如果livePort不为modeQueuePort时我们的runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：`一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口`。\n\n所以我们可以看到后面runLoop处理端口时间的方法如下的判断：\n\n```\n        if (MACH_PORT_NULL == livePort) {//什么都不做，有肯能是超时之类的或者是信息过大\n            CFRUNLOOP_WAKEUP_FOR_NOTHING();\n            // handle nothing\n        } else if (livePort == rl->_wakeUpPort) {//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口\n            CFRUNLOOP_WAKEUP_FOR_WAKEUP();\n            // do nothing on Mac OS\n        }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {//这里不是从runLoop休眠后唤醒到这里的，而是在runLoop10步中的第五步跳转过来的，是处理计时器事件\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            ...省略处理计时器事件的代码...\n        }\n#endif\n        else if (livePort == dispatchPort) {//这里是处理GCD提交到mainQueue的block的端口事件\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            ...省略处理GCD的代码...\n        } else {//之前所有情况都不是，那么唤醒runLoop的就只可能是source1的源事件了。\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            ...省略处理source1源事件的代码...\n            }\n        }\n```\n\n`runLoop的唤醒过程，及唤醒过后的时间处理就是上面的流程`，大家可以看看每个分支后的注释。同时runLoopRun的核心代码也就解读完毕了。\n\n剩下的几个run方法事实上都是对这个核心方法的封装了老司机不都说了：\n\n- CFRunLoopRunSpecific\n- CFRunLoopRun\n- CFRunLoopRunInMode\n\n\n至此，整个runLoop中的核心流程老司机也算带着大家分析了一遍~\n\n\n![喘一口气](http://upload-images.jianshu.io/upload_images/1835430-c01c74630903d263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- - -\n# runLoop都能做什么\n\n说了这么多，那么runLoop都能做些什么呢?\n\n以下内容整理自[深入理解RunLoop\n](http://blog.ibireme.com/2015/05/18/runloop/)、孙源runLoop线下分享会视频：\n\n## AutoReleasePool：\n\n\n>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。\n\n>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。\n\n>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。\n\n>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。\n\n## CAAnimation\n我们知道CAAniamtion为我们提供的是`补间动画`，开发者只要给出始末状态后中间状态有系统自动生成。那么动画是怎么出现的呢，是开发者给出始末状态后，`系统计算出每一个中间态的各项参数`，`然后启一个定时器不断去回调并改变属性`。\n\n## 事件响应\n\n>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。\n\n>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n\n>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n## 手势识别\n\n>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n## 定时器\n不多说了这个就。\n\n## PerformSelecter\n\n>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n基本也就差不多了。\n- - -\n老司机写这篇博客呢，`也是应盆友的要求写的`，基本上也是针`对前人博客的总结`以及`自己对源码的解读`。**毕竟有了源码以后runLoop也就没有那么神秘了**。只是希望大家明白**runLoop并不是什么多么可怕的东西**，只要我们一点一点去看，他**也是人写的代码啊**=。=不过老司机懒到连伪代码都没给你们写直接上的源码。`原谅一个懒癌晚期的人吧`。\n\n还是要感谢两位大神**郭耀源**和**孙源**两位大神之前的博客和视频讲解让我很受用。大神名里都带源字，我要不要改成`老源`=。=\n\n- --\n参考资料：\n\n- [深入理解RunLoop\n](http://blog.ibireme.com/2015/05/18/runloop/)\n- [孙源runLoop线下分享会视频](https://pan.baidu.com/s/1dFIfLAD)\n- [关于RunLoop部分源码的注释](http://blog.csdn.net/ssirreplaceable/article/details/53793456)\n- [CFRunLoop的源码](http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz)\n\n另外你如果想看孙源的视频，老司机已经给了下载链接，然后从**最开始到1小时10分钟**的时候都是干货，后面35分钟偏讨论，时间紧的童靴可以跳过，但是后面也有很好的思路分享，听听也是不错的。\n\n如果你想看runLoop源码，因为源码里面有4000多行，老司机读源码的时候讲有用的方法的行数都记了下来，你可以对应的找一下：\n\n|方法名|行数|\n|:---:|:---:|\n| __CFRunLoopFindMode   \t|#754|\n| __CFRunLoopCreate     \t|#1321|\n| _CFRunLoopGet0\t\t\t\t|#1358|\n|__CFRunLoopAddItemToCommonModes|#1536|\n| __CFRunLoopDoObservers\t|#1668|\n| __CFRunLoopDoSources0  \t|#1764|\n| __CFRunLoopDoSource1\t\t|#1829|\n|__CFRepositionTimerInMode\t|#1999|\n| __CFRunLoopDoTimer\t\t|#2024|\n| __CFRunLoopDoTimers\t\t|#2152|\n|__CFRunLoopServiceMachPort|#2196|\n| __CFRunLoopRun\t\t\t\t|#2308|\n| CFRunLoopRunSpecific\t\t|#2601|\n| CFRunLoopRun\t\t\t\t|#2628|\n| CFRunLoopRunInMode\t\t|#2636|\n|CFRunLoopWakeUp\t\t\t\t|#2645|\n|CFRunLoopAddSource\t\t\t|#2791|\n|CFRunLoopAddObserver\t\t|#2978|\n|CFRunLoopAddTimer\t\t\t|#3081|\n\n\n\n打完收功！\n![打完收功](http://upload-images.jianshu.io/upload_images/1835430-96b2100c0f20d96a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n老司机写这篇博客真的事废了很多心血的，好就给赞关注吧~么么哒😘~\n\n无耻的广告时间：\n\nDWCoreTextLabel支持`cocoaPods`了~\n**pod search DWCoreTextLabel**\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n","source":"_posts/老司机出品——源码解析之RunLoop详解.md","raw":"---\n\ntitle: 老司机出品——源码解析之RunLoop详解\nlayout: post\ndate: 2017-05-02 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- RunLoop \ncategories: 源码解析\n\n---\n\n![RunLoop详解](http://upload-images.jianshu.io/upload_images/1835430-cccdcd8278846522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n不得不说，人的**惰性**是真可怕啊。\n从上周六就到写runLoop的建议开始，星期三告诉自己从星期四开始着手写这篇博客。然而现在戳个时间戳，现在是4.30星期日。写完发出去又不知道是什么时候啦，哈哈哈😁\n\n![懒癌](http://upload-images.jianshu.io/upload_images/1835430-eb798302dcb50708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这一期讲什么呢？这一期讲runLoop哟。一直以来，runLoop这个**玄而又玄**的东西似乎被当做了公司面试挑人的终极话题，原因不难想，日常开发用到`runLoop的地方少之又少`，没有时间的积累这方面的知识应该还是相对较于匮乏的，`所以runLoop的了解侧面也能发应开发者的开发经验`，当然就被当做甄选人才的最后杀器。你可能一脸愤怒的说平时有用不到，我不会也不影响开发啊！的确，用不到，但这只是一个过滤器而已。**但是蛋疼的是，在于国内的环境下，runLoop的相关资料又是少之又少，开发者又难以有一个深入的了解**。\n\n出于以上原因，老司机今天就以**老司机个人的角度**，尽可能将老司机所了解到的runLoop知识。\n\n在今天的文章中你可能会看到以下内容：\n\n- runLoop相关知识\n\n<!-- more -->\n\n- - -\n# runLoop是什么\n\n直译以下，跑圈。翻译以下，`事件循环`吧。\n为什么要有这个事件循环呢？我们知道，任何程序如果执行到程序的最后一句之后都会结束运行。然而对于我们要的手机应用程序而言，他显然不可以执行一个事件后就结束运行，他应该具有`持续接受事件`的能力从而不断地处理事件。所以最基本的思路就是用于个`while循环`让程序不能走到最后一句结束，而是在循环体内不断的接受事件。所以我们需要runLoop。不过值得注意的是，runLoop并不是iOS独有的概念，因为准去的来说`runLoop应该是一个模式，在其他平台同样存在这种模式`，不过叫不叫runLoop我就不知道了。\n\n\n![循环](http://upload-images.jianshu.io/upload_images/1835430-9f5079fdc39bf56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- - - \n# runLoop是如何实现的\n\n首先要明确的一点事，在平时我们使用的是Foundation框架的NSRunLoop类去做一些实现，而其实NSRunLoop是基于CoreFoundation框架中的CFRunLoop进行的一层简单的封装。所以我们这里着重介绍**CFRunLoop**，毕竟我们能拿到[CFRunLoop的源码](http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz)。\n\n## runLoop的组成\n\n```\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t\t\t/* locked for accessing mode list */\n    __CFPort _wakeUpPort;\t\t\t// used for CFRunLoopWakeUp \n    Boolean _unused;\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread;\n    uint32_t _winthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    struct _block_item *_blocks_head;\n    struct _block_item *_blocks_tail;\n    CFTypeRef _counterpart;\n};\n```\n我们大概可以CFRunLoop是这么一个结构体。\n我们可以看到结构体重有用来保证线程安全的锁`_lock`，有用来唤醒runLoop的端口`_wakeUpPort`（这里后面会说到，不用执着），有线程对象`_pthread`，还有一个模式集合`_modes`以及一些其他辅助的属性。\n\n\n### _pthread\n这里我要说的是，runLoop与线程是一一对应的。也就是说**一个runLoop对应着一个线程，一个线程对应着一个runLoop**。这里我们从runLoop的构造函数和获取函数即可看出：\n\n```\nstatic CFRunLoopRef __CFRunLoopCreate(pthread_t t) {\n    CFRunLoopRef loop = NULL;\n    CFRunLoopModeRef rlm;\n    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);\n    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);\n    if (NULL == loop) {\n\treturn NULL;\n    }\n    (void)__CFRunLoopPushPerRunData(loop);\n    __CFRunLoopLockInit(&loop->_lock);\n    loop->_wakeUpPort = __CFPortAllocate();\n    if (CFPORT_NULL == loop->_wakeUpPort) HALT;\n    __CFRunLoopSetIgnoreWakeUps(loop);\n    loop->_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);\n    CFSetAddValue(loop->_commonModes, kCFRunLoopDefaultMode);\n    loop->_commonModeItems = NULL;\n    loop->_currentMode = NULL;\n    loop->_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);\n    loop->_blocks_head = NULL;\n    loop->_blocks_tail = NULL;\n    loop->_counterpart = NULL;\n    loop->_pthread = t;\n#if DEPLOYMENT_TARGET_WINDOWS\n    loop->_winthread = GetCurrentThreadId();\n#else\n    loop->_winthread = 0;\n#endif\n    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);\n    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);\n    return loop;\n}\n```\n可以看出构造一个runLoop对象仅需要一个**pthread_t**线程即可。即一个runLoop对应一个线程。\n\n```\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {\n    if (pthread_equal(t, kNilPthreadT)) {//如果传入线程为空指针则默认取主线程对应的runLoop\n\tt = pthread_main_thread_np();\n    }\n    __CFSpinLock(&loopsLock);\n    if (!__CFRunLoops) {//__CFRunLoops就是一个全局字典，以下代码为如果全局字典不存在则创建全局字典，并将主线程对应的mainLoop存入字典中\n        __CFSpinUnlock(&loopsLock);\n        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);\n        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);\n        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {\n            CFRelease(dict);\n        }\n        CFRelease(mainLoop);\n        __CFSpinLock(&loopsLock);\n    }\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));//从全局字典中，取出对应线程的runLoop\n    __CFSpinUnlock(&loopsLock);\n    if (!loop) {//若对应线程的runLoop为空，则创建对应相乘的runLoop并保存在全局字典中\n        CFRunLoopRef newLoop = __CFRunLoopCreate(t);\n        __CFSpinLock(&loopsLock);\n        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n        if (!loop) {\n            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\n            loop = newLoop;\n        }\n        // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it\n        __CFSpinUnlock(&loopsLock);\n        CFRelease(newLoop);\n    }\n    if (pthread_equal(t, pthread_self())) {\n        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);\n        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {\n            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);\n        }\n    }\n    return loop;\n}\n```\n\n这是runLoop的获取函数，我们看到系统从一个**全局字典中取出runLoop**，key就是一个线程，这足以说明runLoop与线程是`一一对应`的关系。\n\n值得一提的是，`一个线程最开始是没有对应的runLoop`的，是`在调用获取函数的时候才对应了一个runLoop的`。**因为本身这个对应关系是有runLoop类管理的，而不是线程**。\n\n\n当然上述两个为私有api，CF真正对外暴露的只有两个接口：\n\n```\nCF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);\nCF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);\n```\n\n两个方法的实现很简单，只要把对应的线程传入获取函数即可：\n\n```\nCFRunLoopRef CFRunLoopGetMain(void) {\n    CHECK_FOR_FORK();\n    static CFRunLoopRef __main = NULL; // no retain needed\n    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed\n    return __main;\n}\n\nCFRunLoopRef CFRunLoopGetCurrent(void) {\n    CHECK_FOR_FORK();\n    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);\n    if (rl) return rl;\n    return _CFRunLoopGet0(pthread_self());\n}\n```\n\n- - -\n### _modes\n\n我们看到，一个runLoop中同时还维护着一个集合，_modes。那么这个modes是做什么的呢？应该说，_modes才是`runLoop的核心`。咳咳（敲黑板），划重点了啊。\n\n首先我们看一下这个_modes里面到底都装了些什么？\n答案是`__CFRunLoopMode`对象。那么他又是什么呢？\n\n```\nstruct __CFRunLoopMode {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */\n    CFStringRef _name;\n    Boolean _stopped;\n    char _padding[3];\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n    CFMutableDictionaryRef _portToV1SourceMap;\n    __CFPortSet _portSet;\n    CFIndex _observerMask;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    dispatch_source_t _timerSource;\n    dispatch_queue_t _queue;\n    Boolean _timerFired; // set to true by the source when a timer has fired\n    Boolean _dispatchTimerArmed;\n#endif\n#if USE_MK_TIMER_TOO\n    mach_port_t _timerPort;\n    Boolean _mkTimerArmed;\n#endif\n#if DEPLOYMENT_TARGET_WINDOWS\n    DWORD _msgQMask;\n    void (*_msgPump)(void);\n#endif\n    uint64_t _timerSoftDeadline; /* TSR */\n    uint64_t _timerHardDeadline; /* TSR */\n};\n```\n这里老司机挑出了几个重点，有用来标志runLoopMode的标志`_name`，有两个事件源的集合`_sources0、_sources1`，有一组观察者`_obeserver`，有一组被加入到runLoop中的`_timers`，还有Mode本身维护着的一个用于计时的`_timerSource`，`_timerPort`。这两个一个是GCD时钟一个是内核时钟。\n\n至于runLoopMode为什么长这样，老司机会在下面runLoopRun的实现中结合代码讲到。\n- - - \n## runLoop代码实现\n\n恩，接下来代码有点长，先给你们看一下大概流程，然后对着流程去看一下代码。\n\n![图是我盗的](http://upload-images.jianshu.io/upload_images/1835430-a84a8802abc125cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n前方高能预警，代码很多！\n\nrunLoop核心代码\n\n```\n/* rl, rlm are locked on entrance and exit */\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    uint64_t startTSR = mach_absolute_time();//获取当前内核时间\n    \n    if (__CFRunLoopIsStopped(rl)) {//如果当前runLoop或者runLoopMode为停止状态的话直接返回\n        __CFRunLoopUnsetStopped(rl);\n        return kCFRunLoopRunStopped;\n    } else if (rlm->_stopped) {\n        rlm->_stopped = false;\n        return kCFRunLoopRunStopped;\n    }\n    \n    //判断是否是第一次在主线程中启动RunLoop,如果是且当前RunLoop为主线程的RunLoop，那么就给分发一个队列调度端口\n    mach_port_name_t dispatchPort = MACH_PORT_NULL;\n    Boolean libdispatchQSafe = pthread_main_np() && ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));\n    if (libdispatchQSafe && (CFRunLoopGetMain() == rl) && CFSetContainsValue(rl->_commonModes, rlm->_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();\n    \n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n\n\t//给当前模式分发队列端口\n    mach_port_name_t modeQueuePort = MACH_PORT_NULL;\n    if (rlm->_queue) {\n        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm->_queue);\n        if (!modeQueuePort) {\n            CRASH(\"Unable to get port for run loop mode queue (%d)\", -1);\n        }\n    }\n#endif\n    \n    //初始化一个GCD计时器，用于管理当前模式的超时\n    dispatch_source_t timeout_timer = NULL;\n    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));\n    if (seconds <= 0.0) { // instant timeout\n        seconds = 0.0;\n        timeout_context->termTSR = 0ULL;\n    } else if (seconds <= TIMER_INTERVAL_LIMIT) {\n        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);\n        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n        dispatch_retain(timeout_timer);\n        timeout_context->ds = timeout_timer;\n        timeout_context->rl = (CFRunLoopRef)CFRetain(rl);\n        timeout_context->termTSR = startTSR + __CFTimeIntervalToTSR(seconds);\n        dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context\n        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);\n        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);\n        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);\n        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);\n        dispatch_resume(timeout_timer);\n    } else { // infinite timeout\n        seconds = 9999999999.0;\n        timeout_context->termTSR = UINT64_MAX;\n    }\n    \n    // 第一步，进入循环\n    Boolean didDispatchPortLastTime = true;\n    int32_t retVal = 0;\n    do {\n        uint8_t msg_buffer[3 * 1024];\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        mach_msg_header_t *msg = NULL;\n        mach_port_t livePort = MACH_PORT_NULL;\n#elif DEPLOYMENT_TARGET_WINDOWS\n        HANDLE livePort = NULL;\n        Boolean windowsMessageReceived = false;\n#endif\n        __CFPortSet waitSet = rlm->_portSet;\n        \n        //设置当前循环监听端口的唤醒\n        __CFRunLoopUnsetIgnoreWakeUps(rl);\n        \n        // 第二步，通知观察者准备开始处理Timer源事件\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n        \n        // 第三步，通知观察者准备开始处理Source源事件\n        if (rlm->_observerMask & kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n        \n        //执行提交到runLoop中的block\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        // 第四步，执行source0中的源事件\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        \n        //如果当前source0源事件处理完成后执行提交到runLoop中的block\n        if (sourceHandledThisLoop) {\n            __CFRunLoopDoBlocks(rl, rlm);\n        }\n        \n        //标志是否等待端口唤醒\n        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n        \n        // 第五步，检测端口，如果端口有事件则跳转至handle_msg（首次执行不会进入判断，因为didDispatchPortLastTime为true）\n        if (MACH_PORT_NULL != dispatchPort && !didDispatchPortLastTime) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n            msg = (mach_msg_header_t *)msg_buffer;\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0)) {\n                goto handle_msg;\n            }\n#elif DEPLOYMENT_TARGET_WINDOWS\n            if (__CFRunLoopWaitForMultipleObjects(NULL, &dispatchPort, 0, 0, &livePort, NULL)) {\n                goto handle_msg;\n            }\n#endif\n        }\n        \n        didDispatchPortLastTime = false;\n        \n        // 第六步，通知观察者线程进入休眠\n        if (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n        \n        // 标志当前runLoop为休眠状态\n        __CFRunLoopSetSleeping(rl);\n        \n        // do not do any user callouts after this point (after notifying of sleeping)\n        \n        // Must push the local-to-this-activation ports in on every loop\n        // iteration, as this mode could be run re-entrantly and we don't\n        // want these ports to get serviced.\n        \n        __CFPortSetInsert(dispatchPort, waitSet);\n        \n        __CFRunLoopModeUnlock(rlm);\n        __CFRunLoopUnlock(rl);\n   \n   \n   \t\t// 第七步，进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop     \n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        do {\n            if (kCFUseCollectableAllocator) {\n                objc_clear_stack(0);\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY);\n            \n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.\n                while (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n                    // Leave livePort as the queue port, and service timers below\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n        } while (1);\n#else\n        if (kCFUseCollectableAllocator) {\n            objc_clear_stack(0);\n            memset(msg_buffer, 0, sizeof(msg_buffer));\n        }\n        msg = (mach_msg_header_t *)msg_buffer;\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY);\n#endif\n        \n        \n#elif DEPLOYMENT_TARGET_WINDOWS\n        // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.\n        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm->_msgQMask, &livePort, &windowsMessageReceived);\n#endif\n        \n        __CFRunLoopLock(rl);\n        __CFRunLoopModeLock(rlm);\n        \n        // Must remove the local-to-this-activation ports in on every loop\n        // iteration, as this mode could be run re-entrantly and we don't\n        // want these ports to get serviced. Also, we don't want them left\n        // in there if this function returns.\n        \n        __CFPortSetRemove(dispatchPort, waitSet);\n        \n        //标志当前runLoop为唤醒状态\n        __CFRunLoopSetIgnoreWakeUps(rl);\n        \n        // user callouts now OK again\n        __CFRunLoopUnsetSleeping(rl);\n        \n        // 第八步，通知观察者线程被唤醒了\n        if (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n        \n        //执行端口的事件\n    handle_msg:;\n    \n    \t//设置此时runLoop忽略端口唤醒（保证线程安全）\n        __CFRunLoopSetIgnoreWakeUps(rl);\n        \n#if DEPLOYMENT_TARGET_WINDOWS\n        if (windowsMessageReceived) {\n            // These Win32 APIs cause a callout, so make sure we're unlocked first and relocked after\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            \n            if (rlm->_msgPump) {\n                rlm->_msgPump();\n            } else {\n                MSG msg;\n                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) {\n                    TranslateMessage(&msg);\n                    DispatchMessage(&msg);\n                }\n            }\n            \n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            sourceHandledThisLoop = true;\n            \n            // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced\n            // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we're just checking to see if the things are signalled right now -- we will wait on them again later.\n            // NOTE: Ignore the dispatch source (it's not in the wait set anymore) and also don't run the observers here since we are polling.\n            __CFRunLoopSetSleeping(rl);\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            \n            __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &livePort, NULL);\n            \n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            __CFRunLoopUnsetSleeping(rl);\n            // If we have a new live port then it will be handled below as normal\n        }\n        \n        \n#endif\n\n\t\t// 第九步，处理端口事件\n        if (MACH_PORT_NULL == livePort) {\n            CFRUNLOOP_WAKEUP_FOR_NOTHING();\n            // handle nothing\n        } else if (livePort == rl->_wakeUpPort) {\n            CFRUNLOOP_WAKEUP_FOR_WAKEUP();\n            // do nothing on Mac OS\n#if DEPLOYMENT_TARGET_WINDOWS\n            // Always reset the wake up port, or risk spinning forever\n            ResetEvent(rl->_wakeUpPort);\n#endif\n        }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                // Re-arm the next timer, because we apparently fired early\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n#if USE_MK_TIMER_TOO\n        else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {//处理定时器事件\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.\n            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                // Re-arm the next timer\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n\t\t//处理有GCD提交到主线程唤醒的事件\n        else if (livePort == dispatchPort) {\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);\n#if DEPLOYMENT_TARGET_WINDOWS\n            void *msg = 0;\n#endif\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);\n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            sourceHandledThisLoop = true;\n            didDispatchPortLastTime = true;\n        } else {\n        \n\t        //处理source1唤醒的事件\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            // Despite the name, this works for windows handles as well\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n            if (rls) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n                mach_msg_header_t *reply = NULL;\n                // 处理Source1(基于端口的源)\n                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n                if (NULL != reply) {\n                    (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);\n                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);\n                }\n#elif DEPLOYMENT_TARGET_WINDOWS\n                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;\n#endif\n            }\n        }\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n#endif\n        \n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        //返回对应的返回值并跳出循环\n        if (sourceHandledThisLoop && stopAfterHandle) {\n            retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n        } else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n            retVal = kCFRunLoopRunStopped;\n        } else if (rlm->_stopped) {\n            rlm->_stopped = false;\n            retVal = kCFRunLoopRunStopped;\n        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n            retVal = kCFRunLoopRunFinished;\n        }\n    } while (0 == retVal);\n    \n    // 第十步，释放定时器\n    if (timeout_timer) {\n        dispatch_source_cancel(timeout_timer);\n        dispatch_release(timeout_timer);\n    } else {\n        free(timeout_context);\n    }\n    \n    return retVal;\n}\n```\n\n这个方法有点有点长，300行代码=。=\n\n这300行的流程其实就是上面归纳的10步：\n\n> 首先进入runLoop对应的Mode并开始循环，然后在休眠之前做了三件事：DoBlocks、DoSource0、检测source1端口是否有消息，如果有则跳过稍后的休眠。\n然后runLoop就进入了休眠状态，直到有端口事件唤醒runLoop，被唤醒后则处理响应的端口事件然后再次开始循环。直到runLoop超时或者runLoop被停止后在结束runLoop。\n\n不过好在代码很全，在这里我们能出到很多问题。\n\n### source0，source1\n\n首先这个源事件分为两种，一种是不基于端口的source0，一直是基于端口的source1。\n\n\n> Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n\n> Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。\n\n> ————[引自深入理解RunLoop\n](http://blog.ibireme.com/2015/05/18/runloop/)\n\n- - -\n\n> source0呢主要处理App内部事件、App自己负责管理（触发），如UIEvent、CFSocket\n\n> source1呢主要有Runloop和内核管理，Mach port驱动，如CFMahPort、CFMessagePort\n\n> ————引自孙源runLoop线下分享会视频 \n\n\n\n\n### NSTimer事件是借助runLoop实现的。\n这点老司机早在CoreAnimation系列中第三篇介绍三个Timer的时候老司机就有提到过，在初始化Timer的时候要将Timer提交到runLoop中，并且要指定mode，才可以工作。今天我们可以深入讲一下。\n\n> 这个事件是怎么执行的？并且为什么有的时候会延迟？为什么子线程中创建的Timer并不执行？\n\n> 首先，在进入循环开始以后，就要处理source0事件，处理后检测一下source1端口是否有消息，如果一个Timer的时间间隔刚好到了则此处有可能会得到一个消息，则runLoop直接跳转至端口激活处从而去处理Timer事件。\n\n> 第二，为什么会延迟？我们知道，两次端口事件是在两个runLoop循环中分别执行的。比如Timer的时间间隔为1秒，在第一次Timer回调结束后，在很短时间内立即进入runLoop的下一次循环，这次并不是Timer回调并且是一个计算量非常大的任务，计算时间超过了1秒，那么runLoop的第二个循环就要执行很久，无法进入下一个循环等待有可能即将到来的Timer第二次回调的信号，所以Timer第二次回调就会推迟了。\n\n> 第三，为什么在子线程中创建的Timer并且提交到当前runLoop中并不会运行？这还是要从runLoop的获取函数中看，当调用currentRunLoop的时候会取当前线程对应的runLoop，而首次是取不到的，则会创建一个新的runLoop。但是！这个runLoop并没有run。就是没有开启=。=\n\n- - -\n### 同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？\n\n从runLoop的结构我们可以知道，一个runLoop会包含多种runLoopMode，runLoop是不停的在这些mode之间进行切换去完成对应Mode中的相关任务。\n\n![runLoop中多个mode](http://upload-images.jianshu.io/upload_images/1835430-1a9ffd190ef7c73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n首先为什么说runLoop只能在各种Mode之间切换，同一时间只能存在一个呢？\n因为上面那个方法必须要传一个runLoopMode，然后这个方法贯穿始终，都在用。\n\n\n我们看到，上面的方法中首先就要传入一个指定的mode才能执行对应mode中的事件。那么所谓的CommonMode是如何实现的呢？\n\n我们看到runLoop中执行任务有调到CFRunLoopDoBlocks这么一个函数，那么这个函数是什么样的呢？\n\n```\nstatic Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) { // Call with rl and rlm locked\n    if (!rl->_blocks_head) return false;\n    if (!rlm || !rlm->_name) return false;\n    ...省略一些非重点...\n    while (item) {\n        struct _block_item *curr = item;\n        item = item->_next;\n\tBoolean doit = false;\n\tif (CFStringGetTypeID() == CFGetTypeID(curr->_mode)) {\n\t    doit = CFEqual(curr->_mode, curMode) || (CFEqual(curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode));\n        } else {\n\t    doit = CFSetContainsValue((CFSetRef)curr->_mode, curMode) || (CFSetContainsValue((CFSetRef)curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode));\n\t}\n\tif (!doit) prev = curr;\n\tif (doit) {\n\t    if (prev) prev->_next = item;\n\t    if (curr == head) head = item;\n\t    if (curr == tail) tail = prev;\n\t    void (^block)(void) = curr->_block;\n            CFRelease(curr->_mode);\n            free(curr);\n\t    if (doit) {\n                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n\t        did = true;\n\t    }\n    ...省略一些非重点...\n    return did;\n}\n```\n\n我们看到`doit`这个bool变量完全决定了当前block是否执行。默认他是No的，而他被置为true的条件就是`CFEqual(curr->_mode, curMode) || (CFEqual(curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode))`。就是当前mode与制定mode相等或者当前mode为commonMode（此处为一个字符串）且commonMode（此处为一个集合，若有不懂，请看runLoop结构）这个集合中包含指定mode。\n\n这是因为这个判断的存在才允许commondMode可以在任意Mode下执行。\n当然这是提交到runLoop里的代码块才会走到`__CFRunLoopDoBlocks`这个方法。\n\n相同的，我们通过上述代码也可以知道，runLoop通过端口唤醒的事件需要通过__CFRunLoopDoSource1和__CFRunLoopDoTimers两个方法来调用。__CFRunLoopDoSource1方法没什么说的，直接调用源事件runLoopSourceRef即可。重点我们看一下Timer的实现，核心代码如下：\n\n```\nstatic Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) {\t/* DOES CALLOUT */\n    Boolean timerHandled = false;\n    CFMutableArrayRef timers = NULL;\n    //遍历runLoopMode维护的Timers数组，取其中有效的timer并加入新临时数组\n    for (CFIndex idx = 0, cnt = rlm->_timers ? CFArrayGetCount(rlm->_timers) : 0; idx < cnt; idx++) {\n        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm->_timers, idx);\n        \n        if (__CFIsValid(rlt) && !__CFRunLoopTimerIsFiring(rlt)) {\n            if (rlt->_fireTSR <= limitTSR) {\n                if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);\n                CFArrayAppendValue(timers, rlt);\n            }\n        }\n    }\n    //遍历临时数组，每个有效Timer调用__CFRunLoopDoTimer\n    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx < cnt; idx++) {\n        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);\n        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);\n        timerHandled = timerHandled || did;\n    }\n    if (timers) CFRelease(timers);\n    return timerHandled;\n}\n```\n我们可以看到，此处Timer是否会回调完全取决于对应Mode的_Timers数组。那么当我们将Timer加入到commonModes中的时候一定是同时将Timer加入到了commonModes所包含的其他Mode中了，我们看下代码：\n\n```\nvoid CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {    \n    CHECK_FOR_FORK();\n    if (__CFRunLoopIsDeallocating(rl)) return;\n    if (!__CFIsValid(rlt) || (NULL != rlt->_runLoop && rlt->_runLoop != rl)) return;\n    __CFRunLoopLock(rl);\n    if (modeName == kCFRunLoopCommonModes) {//commonModes分支\n    \t//取到commonModes所代表的Mode的集合\n        CFSetRef set = rl->_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl->_commonModes) : NULL;\n        if (NULL == rl->_commonModeItems) {\n        \t//将commonModeItems中加入当前定时器\n            rl->_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);\n        }\n        CFSetAddValue(rl->_commonModeItems, rlt);\n        if (NULL != set) {\n            CFTypeRef context[2] = {rl, rlt};\n            /* add new item to all common-modes */\n            //最主要还是还是这句，这句的作用是集合中的所有对象均调用__CFRunLoopAddItemToCommonModes这个方法。\n            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);\n            CFRelease(set);\n        }\n    } else {//非commonModes的分支\n        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);\n        if (NULL != rlm) {\n            if (NULL == rlm->_timers) {\n                CFArrayCallBacks cb = kCFTypeArrayCallBacks;\n                cb.equal = NULL;\n                rlm->_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &cb);\n            }\n        }\n        if (NULL != rlm && !CFSetContainsValue(rlt->_rlModes, rlm->_name)) {\n            __CFRunLoopTimerLock(rlt);\n            if (NULL == rlt->_runLoop) {\n                rlt->_runLoop = rl;\n            } else if (rl != rlt->_runLoop) {\n                __CFRunLoopTimerUnlock(rlt);\n                __CFRunLoopModeUnlock(rlm);\n                __CFRunLoopUnlock(rl);\n                return;\n            }\n            CFSetAddValue(rlt->_rlModes, rlm->_name);\n            __CFRunLoopTimerUnlock(rlt);\n            __CFRunLoopTimerFireTSRLock();\n            __CFRepositionTimerInMode(rlm, rlt, false);\n            __CFRunLoopTimerFireTSRUnlock();\n            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) {\n                // Normally we don't do this on behalf of clients, but for\n                // backwards compatibility due to the change in timer handling...\n                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);\n            }\n        }\n        if (NULL != rlm) {\n            __CFRunLoopModeUnlock(rlm);\n        }\n    }\n    __CFRunLoopUnlock(rl);\n}\n\nstatic void __CFRunLoopAddItemToCommonModes(const void *value, void *ctx) {\n    CFStringRef modeName = (CFStringRef)value;\n    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);\n    CFTypeRef item = (CFTypeRef)(((CFTypeRef *)ctx)[1]);\n    if (CFGetTypeID(item) == __kCFRunLoopSourceTypeID) {\n\tCFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);\n    } else if (CFGetTypeID(item) == __kCFRunLoopObserverTypeID) {\n\tCFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);\n    } else if (CFGetTypeID(item) == __kCFRunLoopTimerTypeID) {\n\tCFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);\n    }\n}\n\n\n```\n我们可以看到，当加入到commonModes中时，实际上系统是`找出commonModes代表的所有Mode`，如defaultMode和trackingMode，让后分别将其加入了这些mode中。\n同样的方法还有`CFRunLoopAddSource`/`CFRunLoopAddObserver`都是同样的道理。\n\n\n\n\n所以说当scrollView或其子类进行滚动的时候，UIKIT会自动将当前runLoopMode切换为UITrackingRunLoopMode，所以你加在defaultMode中的计时器当然不会走了。\n\n\n\n---\n### runLoop是如何休眠有如何被唤醒的？\n\n从第7步开始，我们看到runLoop进入了休眠状态。然而所谓的休眠状态指示将当前runLoop标记为休眠之后，**进入了一个while死循环**。然后在循环内就不断的去读取端口消息。如果说从端口中**读取到一个唤醒信息的话，break掉while循环从而进入唤醒状态**。\n\n\n关于runLoop的几种mode老司机之前也有讲过，在CoreAnimation中的第三篇中有讲到，这里就只罗列一下。\n\n- NSDefaultRunLoopMode\n- NSConnectionReplyMode\n- NSModalPanelRunLoopMode\n- UITrackingRunLoopMode\n- NSRunLoopCommonModes\n\n- - -\n### 可以唤醒runLoop的都有哪些事件？\n从源码中我们可以看出，所谓的runLoop进入休眠状态不过是一个while循环，如下：\n\n```\ndo {\n            if (kCFUseCollectableAllocator) {\n                objc_clear_stack(0);\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY);\n            \n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.\n                while (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n                    // Leave livePort as the queue port, and service timers below\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n } while (1);\n```\n\n相应的我们还得看一个函数，`__CFRunLoopServiceMachPort`：\n\n```\nstatic Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t**buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout) {\n    Boolean originalBuffer = true;\n    kern_return_t ret = KERN_SUCCESS;\n    for (;;) {\t\t/* In that sleep of death what nightmares may come ... */\n        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;\n        msg->msgh_bits = 0;\n        msg->msgh_local_port = port;\n        msg->msgh_remote_port = MACH_PORT_NULL;\n        msg->msgh_size = buffer_size;\n        msg->msgh_id = 0;\n        if (TIMEOUT_INFINITY == timeout) { CFRUNLOOP_SLEEP(); } else { CFRUNLOOP_POLL(); }\n        ret = mach_msg(msg, MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg->msgh_size, port, timeout, MACH_PORT_NULL);\n        CFRUNLOOP_WAKEUP(ret);\n        if (MACH_MSG_SUCCESS == ret) {\n            *livePort = msg ? msg->msgh_local_port : MACH_PORT_NULL;\n            return true;\n        }\n        if (MACH_RCV_TIMED_OUT == ret) {\n            if (!originalBuffer) free(msg);\n            *buffer = NULL;\n            *livePort = MACH_PORT_NULL;\n            return false;\n        }\n        if (MACH_RCV_TOO_LARGE != ret) break;\n        buffer_size = round_msg(msg->msgh_size + MAX_TRAILER_SIZE);\n        if (originalBuffer) *buffer = NULL;\n        originalBuffer = false;\n        *buffer = realloc(*buffer, buffer_size);\n    }\n    HALT;\n    return false;\n}\n```\n\n我们先看后面这个函数，在这里仅有`两种情况会对livePort进行赋值`，一种是**成功获取到消息后**，会根据情况赋值为msg->msgh_local_port或者MACH_PORT_NULL，而另一种**获取消息超时**的情况会赋值为MACH_PORT_NULL。首先请先记住这两个结论。\n\n然后我们把目光聚焦到while循环中，在调用`__CFRunLoopServiceMachPort`后如果livePort变成了`modeQueuePort`(livePort初值为MACH_PORT_NULL)，则代表为当前队列的检测端口，那么在`_dispatch_runloop_root_queue_perform_4CF`的条件下再次进入二级循环，知道Timer被激活了才跳出二级循环继续循环一级循环。（这一步的目的不好意思老司机真没看懂）。\n\n那么如果livePort不为modeQueuePort时我们的runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：`一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口`。\n\n所以我们可以看到后面runLoop处理端口时间的方法如下的判断：\n\n```\n        if (MACH_PORT_NULL == livePort) {//什么都不做，有肯能是超时之类的或者是信息过大\n            CFRUNLOOP_WAKEUP_FOR_NOTHING();\n            // handle nothing\n        } else if (livePort == rl->_wakeUpPort) {//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口\n            CFRUNLOOP_WAKEUP_FOR_WAKEUP();\n            // do nothing on Mac OS\n        }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {//这里不是从runLoop休眠后唤醒到这里的，而是在runLoop10步中的第五步跳转过来的，是处理计时器事件\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            ...省略处理计时器事件的代码...\n        }\n#endif\n        else if (livePort == dispatchPort) {//这里是处理GCD提交到mainQueue的block的端口事件\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            ...省略处理GCD的代码...\n        } else {//之前所有情况都不是，那么唤醒runLoop的就只可能是source1的源事件了。\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            ...省略处理source1源事件的代码...\n            }\n        }\n```\n\n`runLoop的唤醒过程，及唤醒过后的时间处理就是上面的流程`，大家可以看看每个分支后的注释。同时runLoopRun的核心代码也就解读完毕了。\n\n剩下的几个run方法事实上都是对这个核心方法的封装了老司机不都说了：\n\n- CFRunLoopRunSpecific\n- CFRunLoopRun\n- CFRunLoopRunInMode\n\n\n至此，整个runLoop中的核心流程老司机也算带着大家分析了一遍~\n\n\n![喘一口气](http://upload-images.jianshu.io/upload_images/1835430-c01c74630903d263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- - -\n# runLoop都能做什么\n\n说了这么多，那么runLoop都能做些什么呢?\n\n以下内容整理自[深入理解RunLoop\n](http://blog.ibireme.com/2015/05/18/runloop/)、孙源runLoop线下分享会视频：\n\n## AutoReleasePool：\n\n\n>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。\n\n>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。\n\n>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。\n\n>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。\n\n## CAAnimation\n我们知道CAAniamtion为我们提供的是`补间动画`，开发者只要给出始末状态后中间状态有系统自动生成。那么动画是怎么出现的呢，是开发者给出始末状态后，`系统计算出每一个中间态的各项参数`，`然后启一个定时器不断去回调并改变属性`。\n\n## 事件响应\n\n>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。\n\n>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n\n>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n## 手势识别\n\n>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n## 定时器\n不多说了这个就。\n\n## PerformSelecter\n\n>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n基本也就差不多了。\n- - -\n老司机写这篇博客呢，`也是应盆友的要求写的`，基本上也是针`对前人博客的总结`以及`自己对源码的解读`。**毕竟有了源码以后runLoop也就没有那么神秘了**。只是希望大家明白**runLoop并不是什么多么可怕的东西**，只要我们一点一点去看，他**也是人写的代码啊**=。=不过老司机懒到连伪代码都没给你们写直接上的源码。`原谅一个懒癌晚期的人吧`。\n\n还是要感谢两位大神**郭耀源**和**孙源**两位大神之前的博客和视频讲解让我很受用。大神名里都带源字，我要不要改成`老源`=。=\n\n- --\n参考资料：\n\n- [深入理解RunLoop\n](http://blog.ibireme.com/2015/05/18/runloop/)\n- [孙源runLoop线下分享会视频](https://pan.baidu.com/s/1dFIfLAD)\n- [关于RunLoop部分源码的注释](http://blog.csdn.net/ssirreplaceable/article/details/53793456)\n- [CFRunLoop的源码](http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz)\n\n另外你如果想看孙源的视频，老司机已经给了下载链接，然后从**最开始到1小时10分钟**的时候都是干货，后面35分钟偏讨论，时间紧的童靴可以跳过，但是后面也有很好的思路分享，听听也是不错的。\n\n如果你想看runLoop源码，因为源码里面有4000多行，老司机读源码的时候讲有用的方法的行数都记了下来，你可以对应的找一下：\n\n|方法名|行数|\n|:---:|:---:|\n| __CFRunLoopFindMode   \t|#754|\n| __CFRunLoopCreate     \t|#1321|\n| _CFRunLoopGet0\t\t\t\t|#1358|\n|__CFRunLoopAddItemToCommonModes|#1536|\n| __CFRunLoopDoObservers\t|#1668|\n| __CFRunLoopDoSources0  \t|#1764|\n| __CFRunLoopDoSource1\t\t|#1829|\n|__CFRepositionTimerInMode\t|#1999|\n| __CFRunLoopDoTimer\t\t|#2024|\n| __CFRunLoopDoTimers\t\t|#2152|\n|__CFRunLoopServiceMachPort|#2196|\n| __CFRunLoopRun\t\t\t\t|#2308|\n| CFRunLoopRunSpecific\t\t|#2601|\n| CFRunLoopRun\t\t\t\t|#2628|\n| CFRunLoopRunInMode\t\t|#2636|\n|CFRunLoopWakeUp\t\t\t\t|#2645|\n|CFRunLoopAddSource\t\t\t|#2791|\n|CFRunLoopAddObserver\t\t|#2978|\n|CFRunLoopAddTimer\t\t\t|#3081|\n\n\n\n打完收功！\n![打完收功](http://upload-images.jianshu.io/upload_images/1835430-96b2100c0f20d96a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n老司机写这篇博客真的事废了很多心血的，好就给赞关注吧~么么哒😘~\n\n无耻的广告时间：\n\nDWCoreTextLabel支持`cocoaPods`了~\n**pod search DWCoreTextLabel**\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n","slug":"老司机出品——源码解析之RunLoop详解","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htpl000qjigb94mw3dum","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-cccdcd8278846522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RunLoop详解\"></p>\n<p>不得不说，人的<strong>惰性</strong>是真可怕啊。<br>从上周六就到写runLoop的建议开始，星期三告诉自己从星期四开始着手写这篇博客。然而现在戳个时间戳，现在是4.30星期日。写完发出去又不知道是什么时候啦，哈哈哈😁</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-eb798302dcb50708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"懒癌\"></p>\n<p>这一期讲什么呢？这一期讲runLoop哟。一直以来，runLoop这个<strong>玄而又玄</strong>的东西似乎被当做了公司面试挑人的终极话题，原因不难想，日常开发用到<code>runLoop的地方少之又少</code>，没有时间的积累这方面的知识应该还是相对较于匮乏的，<code>所以runLoop的了解侧面也能发应开发者的开发经验</code>，当然就被当做甄选人才的最后杀器。你可能一脸愤怒的说平时有用不到，我不会也不影响开发啊！的确，用不到，但这只是一个过滤器而已。<strong>但是蛋疼的是，在于国内的环境下，runLoop的相关资料又是少之又少，开发者又难以有一个深入的了解</strong>。</p>\n<p>出于以上原因，老司机今天就以<strong>老司机个人的角度</strong>，尽可能将老司机所了解到的runLoop知识。</p>\n<p>在今天的文章中你可能会看到以下内容：</p>\n<ul>\n<li>runLoop相关知识</li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"runLoop是什么\"><a href=\"#runLoop是什么\" class=\"headerlink\" title=\"runLoop是什么\"></a>runLoop是什么</h1><p>直译以下，跑圈。翻译以下，<code>事件循环</code>吧。<br>为什么要有这个事件循环呢？我们知道，任何程序如果执行到程序的最后一句之后都会结束运行。然而对于我们要的手机应用程序而言，他显然不可以执行一个事件后就结束运行，他应该具有<code>持续接受事件</code>的能力从而不断地处理事件。所以最基本的思路就是用于个<code>while循环</code>让程序不能走到最后一句结束，而是在循环体内不断的接受事件。所以我们需要runLoop。不过值得注意的是，runLoop并不是iOS独有的概念，因为准去的来说<code>runLoop应该是一个模式，在其他平台同样存在这种模式</code>，不过叫不叫runLoop我就不知道了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-9f5079fdc39bf56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"循环\"></p>\n<hr>\n<h1 id=\"runLoop是如何实现的\"><a href=\"#runLoop是如何实现的\" class=\"headerlink\" title=\"runLoop是如何实现的\"></a>runLoop是如何实现的</h1><p>首先要明确的一点事，在平时我们使用的是Foundation框架的NSRunLoop类去做一些实现，而其实NSRunLoop是基于CoreFoundation框架中的CFRunLoop进行的一层简单的封装。所以我们这里着重介绍<strong>CFRunLoop</strong>，毕竟我们能拿到<a href=\"http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz\" target=\"_blank\" rel=\"external\">CFRunLoop的源码</a>。</p>\n<h2 id=\"runLoop的组成\"><a href=\"#runLoop的组成\" class=\"headerlink\" title=\"runLoop的组成\"></a>runLoop的组成</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoop &#123;</div><div class=\"line\">    CFRuntimeBase _base;</div><div class=\"line\">    pthread_mutex_t _lock;\t\t\t/* locked for accessing mode list */</div><div class=\"line\">    __CFPort _wakeUpPort;\t\t\t// used for CFRunLoopWakeUp </div><div class=\"line\">    Boolean _unused;</div><div class=\"line\">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</div><div class=\"line\">    pthread_t _pthread;</div><div class=\"line\">    uint32_t _winthread;</div><div class=\"line\">    CFMutableSetRef _commonModes;</div><div class=\"line\">    CFMutableSetRef _commonModeItems;</div><div class=\"line\">    CFRunLoopModeRef _currentMode;</div><div class=\"line\">    CFMutableSetRef _modes;</div><div class=\"line\">    struct _block_item *_blocks_head;</div><div class=\"line\">    struct _block_item *_blocks_tail;</div><div class=\"line\">    CFTypeRef _counterpart;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们大概可以CFRunLoop是这么一个结构体。<br>我们可以看到结构体重有用来保证线程安全的锁<code>_lock</code>，有用来唤醒runLoop的端口<code>_wakeUpPort</code>（这里后面会说到，不用执着），有线程对象<code>_pthread</code>，还有一个模式集合<code>_modes</code>以及一些其他辅助的属性。</p>\n<h3 id=\"pthread\"><a href=\"#pthread\" class=\"headerlink\" title=\"_pthread\"></a>_pthread</h3><p>这里我要说的是，runLoop与线程是一一对应的。也就是说<strong>一个runLoop对应着一个线程，一个线程对应着一个runLoop</strong>。这里我们从runLoop的构造函数和获取函数即可看出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</div><div class=\"line\">    CFRunLoopRef loop = NULL;</div><div class=\"line\">    CFRunLoopModeRef rlm;</div><div class=\"line\">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</div><div class=\"line\">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</div><div class=\"line\">    if (NULL == loop) &#123;</div><div class=\"line\">\treturn NULL;</div><div class=\"line\">    &#125;</div><div class=\"line\">    (void)__CFRunLoopPushPerRunData(loop);</div><div class=\"line\">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</div><div class=\"line\">    loop-&gt;_wakeUpPort = __CFPortAllocate();</div><div class=\"line\">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</div><div class=\"line\">    __CFRunLoopSetIgnoreWakeUps(loop);</div><div class=\"line\">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class=\"line\">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</div><div class=\"line\">    loop-&gt;_commonModeItems = NULL;</div><div class=\"line\">    loop-&gt;_currentMode = NULL;</div><div class=\"line\">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class=\"line\">    loop-&gt;_blocks_head = NULL;</div><div class=\"line\">    loop-&gt;_blocks_tail = NULL;</div><div class=\"line\">    loop-&gt;_counterpart = NULL;</div><div class=\"line\">    loop-&gt;_pthread = t;</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">    loop-&gt;_winthread = GetCurrentThreadId();</div><div class=\"line\">#else</div><div class=\"line\">    loop-&gt;_winthread = 0;</div><div class=\"line\">#endif</div><div class=\"line\">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</div><div class=\"line\">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">    return loop;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出构造一个runLoop对象仅需要一个<strong>pthread_t</strong>线程即可。即一个runLoop对应一个线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</div><div class=\"line\">    if (pthread_equal(t, kNilPthreadT)) &#123;//如果传入线程为空指针则默认取主线程对应的runLoop</div><div class=\"line\">\tt = pthread_main_thread_np();</div><div class=\"line\">    &#125;</div><div class=\"line\">    __CFSpinLock(&amp;loopsLock);</div><div class=\"line\">    if (!__CFRunLoops) &#123;//__CFRunLoops就是一个全局字典，以下代码为如果全局字典不存在则创建全局字典，并将主线程对应的mainLoop存入字典中</div><div class=\"line\">        __CFSpinUnlock(&amp;loopsLock);</div><div class=\"line\">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</div><div class=\"line\">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class=\"line\">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class=\"line\">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</div><div class=\"line\">            CFRelease(dict);</div><div class=\"line\">        &#125;</div><div class=\"line\">        CFRelease(mainLoop);</div><div class=\"line\">        __CFSpinLock(&amp;loopsLock);</div><div class=\"line\">    &#125;</div><div class=\"line\">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));//从全局字典中，取出对应线程的runLoop</div><div class=\"line\">    __CFSpinUnlock(&amp;loopsLock);</div><div class=\"line\">    if (!loop) &#123;//若对应线程的runLoop为空，则创建对应相乘的runLoop并保存在全局字典中</div><div class=\"line\">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class=\"line\">        __CFSpinLock(&amp;loopsLock);</div><div class=\"line\">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class=\"line\">        if (!loop) &#123;</div><div class=\"line\">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class=\"line\">            loop = newLoop;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</div><div class=\"line\">        __CFSpinUnlock(&amp;loopsLock);</div><div class=\"line\">        CFRelease(newLoop);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (pthread_equal(t, pthread_self())) &#123;</div><div class=\"line\">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</div><div class=\"line\">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return loop;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是runLoop的获取函数，我们看到系统从一个<strong>全局字典中取出runLoop</strong>，key就是一个线程，这足以说明runLoop与线程是<code>一一对应</code>的关系。</p>\n<p>值得一提的是，<code>一个线程最开始是没有对应的runLoop</code>的，是<code>在调用获取函数的时候才对应了一个runLoop的</code>。<strong>因为本身这个对应关系是有runLoop类管理的，而不是线程</strong>。</p>\n<p>当然上述两个为私有api，CF真正对外暴露的只有两个接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);</div><div class=\"line\">CF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);</div></pre></td></tr></table></figure>\n<p>两个方法的实现很简单，只要把对应的线程传入获取函数即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRunLoopRef CFRunLoopGetMain(void) &#123;</div><div class=\"line\">    CHECK_FOR_FORK();</div><div class=\"line\">    static CFRunLoopRef __main = NULL; // no retain needed</div><div class=\"line\">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</div><div class=\"line\">    return __main;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class=\"line\">    CHECK_FOR_FORK();</div><div class=\"line\">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class=\"line\">    if (rl) return rl;</div><div class=\"line\">    return _CFRunLoopGet0(pthread_self());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"modes\"><a href=\"#modes\" class=\"headerlink\" title=\"_modes\"></a>_modes</h3><p>我们看到，一个runLoop中同时还维护着一个集合，_modes。那么这个modes是做什么的呢？应该说，_modes才是<code>runLoop的核心</code>。咳咳（敲黑板），划重点了啊。</p>\n<p>首先我们看一下这个_modes里面到底都装了些什么？<br>答案是<code>__CFRunLoopMode</code>对象。那么他又是什么呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoopMode &#123;</div><div class=\"line\">    CFRuntimeBase _base;</div><div class=\"line\">    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */</div><div class=\"line\">    CFStringRef _name;</div><div class=\"line\">    Boolean _stopped;</div><div class=\"line\">    char _padding[3];</div><div class=\"line\">    CFMutableSetRef _sources0;</div><div class=\"line\">    CFMutableSetRef _sources1;</div><div class=\"line\">    CFMutableArrayRef _observers;</div><div class=\"line\">    CFMutableArrayRef _timers;</div><div class=\"line\">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class=\"line\">    __CFPortSet _portSet;</div><div class=\"line\">    CFIndex _observerMask;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">    dispatch_source_t _timerSource;</div><div class=\"line\">    dispatch_queue_t _queue;</div><div class=\"line\">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class=\"line\">    Boolean _dispatchTimerArmed;</div><div class=\"line\">#endif</div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">    mach_port_t _timerPort;</div><div class=\"line\">    Boolean _mkTimerArmed;</div><div class=\"line\">#endif</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">    DWORD _msgQMask;</div><div class=\"line\">    void (*_msgPump)(void);</div><div class=\"line\">#endif</div><div class=\"line\">    uint64_t _timerSoftDeadline; /* TSR */</div><div class=\"line\">    uint64_t _timerHardDeadline; /* TSR */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里老司机挑出了几个重点，有用来标志runLoopMode的标志<code>_name</code>，有两个事件源的集合<code>_sources0、_sources1</code>，有一组观察者<code>_obeserver</code>，有一组被加入到runLoop中的<code>_timers</code>，还有Mode本身维护着的一个用于计时的<code>_timerSource</code>，<code>_timerPort</code>。这两个一个是GCD时钟一个是内核时钟。</p>\n<p>至于runLoopMode为什么长这样，老司机会在下面runLoopRun的实现中结合代码讲到。</p>\n<hr>\n<h2 id=\"runLoop代码实现\"><a href=\"#runLoop代码实现\" class=\"headerlink\" title=\"runLoop代码实现\"></a>runLoop代码实现</h2><p>恩，接下来代码有点长，先给你们看一下大概流程，然后对着流程去看一下代码。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a84a8802abc125cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图是我盗的\"></p>\n<p>前方高能预警，代码很多！</p>\n<p>runLoop核心代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* rl, rlm are locked on entrance and exit */</div><div class=\"line\">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class=\"line\">    uint64_t startTSR = mach_absolute_time();//获取当前内核时间</div><div class=\"line\">    </div><div class=\"line\">    if (__CFRunLoopIsStopped(rl)) &#123;//如果当前runLoop或者runLoopMode为停止状态的话直接返回</div><div class=\"line\">        __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">        return kCFRunLoopRunStopped;</div><div class=\"line\">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">        rlm-&gt;_stopped = false;</div><div class=\"line\">        return kCFRunLoopRunStopped;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //判断是否是第一次在主线程中启动RunLoop,如果是且当前RunLoop为主线程的RunLoop，那么就给分发一个队列调度端口</div><div class=\"line\">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class=\"line\">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class=\"line\">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class=\"line\">    </div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\"></div><div class=\"line\">\t//给当前模式分发队列端口</div><div class=\"line\">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class=\"line\">    if (rlm-&gt;_queue) &#123;</div><div class=\"line\">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class=\"line\">        if (!modeQueuePort) &#123;</div><div class=\"line\">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\">    </div><div class=\"line\">    //初始化一个GCD计时器，用于管理当前模式的超时</div><div class=\"line\">    dispatch_source_t timeout_timer = NULL;</div><div class=\"line\">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class=\"line\">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class=\"line\">        seconds = 0.0;</div><div class=\"line\">        timeout_context-&gt;termTSR = 0ULL;</div><div class=\"line\">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class=\"line\">        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</div><div class=\"line\">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">        dispatch_retain(timeout_timer);</div><div class=\"line\">        timeout_context-&gt;ds = timeout_timer;</div><div class=\"line\">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class=\"line\">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class=\"line\">        dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class=\"line\">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class=\"line\">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class=\"line\">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class=\"line\">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class=\"line\">        dispatch_resume(timeout_timer);</div><div class=\"line\">    &#125; else &#123; // infinite timeout</div><div class=\"line\">        seconds = 9999999999.0;</div><div class=\"line\">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // 第一步，进入循环</div><div class=\"line\">    Boolean didDispatchPortLastTime = true;</div><div class=\"line\">    int32_t retVal = 0;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        uint8_t msg_buffer[3 * 1024];</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        mach_msg_header_t *msg = NULL;</div><div class=\"line\">        mach_port_t livePort = MACH_PORT_NULL;</div><div class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">        HANDLE livePort = NULL;</div><div class=\"line\">        Boolean windowsMessageReceived = false;</div><div class=\"line\">#endif</div><div class=\"line\">        __CFPortSet waitSet = rlm-&gt;_portSet;</div><div class=\"line\">        </div><div class=\"line\">        //设置当前循环监听端口的唤醒</div><div class=\"line\">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class=\"line\">        </div><div class=\"line\">        // 第二步，通知观察者准备开始处理Timer源事件</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class=\"line\">        </div><div class=\"line\">        // 第三步，通知观察者准备开始处理Source源事件</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class=\"line\">        </div><div class=\"line\">        //执行提交到runLoop中的block</div><div class=\"line\">        __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        </div><div class=\"line\">        // 第四步，执行source0中的源事件</div><div class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class=\"line\">        </div><div class=\"line\">        //如果当前source0源事件处理完成后执行提交到runLoop中的block</div><div class=\"line\">        if (sourceHandledThisLoop) &#123;</div><div class=\"line\">            __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        //标志是否等待端口唤醒</div><div class=\"line\">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class=\"line\">        </div><div class=\"line\">        // 第五步，检测端口，如果端口有事件则跳转至handle_msg（首次执行不会进入判断，因为didDispatchPortLastTime为true）</div><div class=\"line\">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) &#123;</div><div class=\"line\">                goto handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">            if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</div><div class=\"line\">                goto handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        didDispatchPortLastTime = false;</div><div class=\"line\">        </div><div class=\"line\">        // 第六步，通知观察者线程进入休眠</div><div class=\"line\">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 标志当前runLoop为休眠状态</div><div class=\"line\">        __CFRunLoopSetSleeping(rl);</div><div class=\"line\">        </div><div class=\"line\">        // do not do any user callouts after this point (after notifying of sleeping)</div><div class=\"line\">        </div><div class=\"line\">        // Must push the local-to-this-activation ports in on every loop</div><div class=\"line\">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class=\"line\">        // want these ports to get serviced.</div><div class=\"line\">        </div><div class=\"line\">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">        __CFRunLoopUnlock(rl);</div><div class=\"line\">   </div><div class=\"line\">   </div><div class=\"line\">   \t\t// 第七步，进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop     </div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        do &#123;</div><div class=\"line\">            if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\">                objc_clear_stack(0);</div><div class=\"line\">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class=\"line\">            </div><div class=\"line\">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class=\"line\">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class=\"line\">                if (rlm-&gt;_timerFired) &#123;</div><div class=\"line\">                    // Leave livePort as the queue port, and service timers below</div><div class=\"line\">                    rlm-&gt;_timerFired = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Go ahead and leave the inner loop.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; while (1);</div><div class=\"line\">#else</div><div class=\"line\">        if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\">            objc_clear_stack(0);</div><div class=\"line\">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class=\"line\">#endif</div><div class=\"line\">        </div><div class=\"line\">        </div><div class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">        // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.</div><div class=\"line\">        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);</div><div class=\"line\">#endif</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopLock(rl);</div><div class=\"line\">        __CFRunLoopModeLock(rlm);</div><div class=\"line\">        </div><div class=\"line\">        // Must remove the local-to-this-activation ports in on every loop</div><div class=\"line\">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class=\"line\">        // want these ports to get serviced. Also, we don&apos;t want them left</div><div class=\"line\">        // in there if this function returns.</div><div class=\"line\">        </div><div class=\"line\">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class=\"line\">        </div><div class=\"line\">        //标志当前runLoop为唤醒状态</div><div class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class=\"line\">        </div><div class=\"line\">        // user callouts now OK again</div><div class=\"line\">        __CFRunLoopUnsetSleeping(rl);</div><div class=\"line\">        </div><div class=\"line\">        // 第八步，通知观察者线程被唤醒了</div><div class=\"line\">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class=\"line\">        </div><div class=\"line\">        //执行端口的事件</div><div class=\"line\">    handle_msg:;</div><div class=\"line\">    </div><div class=\"line\">    \t//设置此时runLoop忽略端口唤醒（保证线程安全）</div><div class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class=\"line\">        </div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">        if (windowsMessageReceived) &#123;</div><div class=\"line\">            // These Win32 APIs cause a callout, so make sure we&apos;re unlocked first and relocked after</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">            __CFRunLoopUnlock(rl);</div><div class=\"line\">            </div><div class=\"line\">            if (rlm-&gt;_msgPump) &#123;</div><div class=\"line\">                rlm-&gt;_msgPump();</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                MSG msg;</div><div class=\"line\">                if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) &#123;</div><div class=\"line\">                    TranslateMessage(&amp;msg);</div><div class=\"line\">                    DispatchMessage(&amp;msg);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            __CFRunLoopLock(rl);</div><div class=\"line\">            __CFRunLoopModeLock(rlm);</div><div class=\"line\">            sourceHandledThisLoop = true;</div><div class=\"line\">            </div><div class=\"line\">            // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced</div><div class=\"line\">            // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we&apos;re just checking to see if the things are signalled right now -- we will wait on them again later.</div><div class=\"line\">            // NOTE: Ignore the dispatch source (it&apos;s not in the wait set anymore) and also don&apos;t run the observers here since we are polling.</div><div class=\"line\">            __CFRunLoopSetSleeping(rl);</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">            __CFRunLoopUnlock(rl);</div><div class=\"line\">            </div><div class=\"line\">            __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &amp;livePort, NULL);</div><div class=\"line\">            </div><div class=\"line\">            __CFRunLoopLock(rl);</div><div class=\"line\">            __CFRunLoopModeLock(rlm);</div><div class=\"line\">            __CFRunLoopUnsetSleeping(rl);</div><div class=\"line\">            // If we have a new live port then it will be handled below as normal</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        </div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\t\t// 第九步，处理端口事件</div><div class=\"line\">        if (MACH_PORT_NULL == livePort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class=\"line\">            // handle nothing</div><div class=\"line\">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class=\"line\">            // do nothing on Mac OS</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">            // Always reset the wake up port, or risk spinning forever</div><div class=\"line\">            ResetEvent(rl-&gt;_wakeUpPort);</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                // Re-arm the next timer, because we apparently fired early</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;//处理定时器事件</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</div><div class=\"line\">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                // Re-arm the next timer</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">\t\t//处理有GCD提交到主线程唤醒的事件</div><div class=\"line\">        else if (livePort == dispatchPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">            __CFRunLoopUnlock(rl);</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">            void *msg = 0;</div><div class=\"line\">#endif</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class=\"line\">            __CFRunLoopLock(rl);</div><div class=\"line\">            __CFRunLoopModeLock(rlm);</div><div class=\"line\">            sourceHandledThisLoop = true;</div><div class=\"line\">            didDispatchPortLastTime = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">        </div><div class=\"line\">\t        //处理source1唤醒的事件</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class=\"line\">            // Despite the name, this works for windows handles as well</div><div class=\"line\">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class=\"line\">            if (rls) &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">                mach_msg_header_t *reply = NULL;</div><div class=\"line\">                // 处理Source1(基于端口的源)</div><div class=\"line\">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class=\"line\">                if (NULL != reply) &#123;</div><div class=\"line\">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class=\"line\">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class=\"line\">                &#125;</div><div class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</div><div class=\"line\">#endif</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class=\"line\">#endif</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        </div><div class=\"line\">        //返回对应的返回值并跳出循环</div><div class=\"line\">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunHandledSource;</div><div class=\"line\">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunTimedOut;</div><div class=\"line\">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">            __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">            retVal = kCFRunLoopRunStopped;</div><div class=\"line\">        &#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">            rlm-&gt;_stopped = false;</div><div class=\"line\">            retVal = kCFRunLoopRunStopped;</div><div class=\"line\">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunFinished;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; while (0 == retVal);</div><div class=\"line\">    </div><div class=\"line\">    // 第十步，释放定时器</div><div class=\"line\">    if (timeout_timer) &#123;</div><div class=\"line\">        dispatch_source_cancel(timeout_timer);</div><div class=\"line\">        dispatch_release(timeout_timer);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        free(timeout_context);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return retVal;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法有点有点长，300行代码=。=</p>\n<p>这300行的流程其实就是上面归纳的10步：</p>\n<blockquote>\n<p>首先进入runLoop对应的Mode并开始循环，然后在休眠之前做了三件事：DoBlocks、DoSource0、检测source1端口是否有消息，如果有则跳过稍后的休眠。<br>然后runLoop就进入了休眠状态，直到有端口事件唤醒runLoop，被唤醒后则处理响应的端口事件然后再次开始循环。直到runLoop超时或者runLoop被停止后在结束runLoop。</p>\n</blockquote>\n<p>不过好在代码很全，在这里我们能出到很多问题。</p>\n<h3 id=\"source0，source1\"><a href=\"#source0，source1\" class=\"headerlink\" title=\"source0，source1\"></a>source0，source1</h3><p>首先这个源事件分为两种，一种是不基于端口的source0，一直是基于端口的source1。</p>\n<blockquote>\n<p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>\n<p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>\n<p>————<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"external\">引自深入理解RunLoop\n</a></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>source0呢主要处理App内部事件、App自己负责管理（触发），如UIEvent、CFSocket</p>\n<p>source1呢主要有Runloop和内核管理，Mach port驱动，如CFMahPort、CFMessagePort</p>\n<p>————引自孙源runLoop线下分享会视频 </p>\n</blockquote>\n<h3 id=\"NSTimer事件是借助runLoop实现的。\"><a href=\"#NSTimer事件是借助runLoop实现的。\" class=\"headerlink\" title=\"NSTimer事件是借助runLoop实现的。\"></a>NSTimer事件是借助runLoop实现的。</h3><p>这点老司机早在CoreAnimation系列中第三篇介绍三个Timer的时候老司机就有提到过，在初始化Timer的时候要将Timer提交到runLoop中，并且要指定mode，才可以工作。今天我们可以深入讲一下。</p>\n<blockquote>\n<p>这个事件是怎么执行的？并且为什么有的时候会延迟？为什么子线程中创建的Timer并不执行？</p>\n<p>首先，在进入循环开始以后，就要处理source0事件，处理后检测一下source1端口是否有消息，如果一个Timer的时间间隔刚好到了则此处有可能会得到一个消息，则runLoop直接跳转至端口激活处从而去处理Timer事件。</p>\n<p>第二，为什么会延迟？我们知道，两次端口事件是在两个runLoop循环中分别执行的。比如Timer的时间间隔为1秒，在第一次Timer回调结束后，在很短时间内立即进入runLoop的下一次循环，这次并不是Timer回调并且是一个计算量非常大的任务，计算时间超过了1秒，那么runLoop的第二个循环就要执行很久，无法进入下一个循环等待有可能即将到来的Timer第二次回调的信号，所以Timer第二次回调就会推迟了。</p>\n<p>第三，为什么在子线程中创建的Timer并且提交到当前runLoop中并不会运行？这还是要从runLoop的获取函数中看，当调用currentRunLoop的时候会取当前线程对应的runLoop，而首次是取不到的，则会创建一个新的runLoop。但是！这个runLoop并没有run。就是没有开启=。=</p>\n</blockquote>\n<hr>\n<h3 id=\"同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？\"><a href=\"#同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？\" class=\"headerlink\" title=\"同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？\"></a>同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？</h3><p>从runLoop的结构我们可以知道，一个runLoop会包含多种runLoopMode，runLoop是不停的在这些mode之间进行切换去完成对应Mode中的相关任务。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a9ffd190ef7c73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"runLoop中多个mode\"></p>\n<p>首先为什么说runLoop只能在各种Mode之间切换，同一时间只能存在一个呢？<br>因为上面那个方法必须要传一个runLoopMode，然后这个方法贯穿始终，都在用。</p>\n<p>我们看到，上面的方法中首先就要传入一个指定的mode才能执行对应mode中的事件。那么所谓的CommonMode是如何实现的呢？</p>\n<p>我们看到runLoop中执行任务有调到CFRunLoopDoBlocks这么一个函数，那么这个函数是什么样的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked</div><div class=\"line\">    if (!rl-&gt;_blocks_head) return false;</div><div class=\"line\">    if (!rlm || !rlm-&gt;_name) return false;</div><div class=\"line\">    ...省略一些非重点...</div><div class=\"line\">    while (item) &#123;</div><div class=\"line\">        struct _block_item *curr = item;</div><div class=\"line\">        item = item-&gt;_next;</div><div class=\"line\">\tBoolean doit = false;</div><div class=\"line\">\tif (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class=\"line\">\t    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">\t    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (!doit) prev = curr;</div><div class=\"line\">\tif (doit) &#123;</div><div class=\"line\">\t    if (prev) prev-&gt;_next = item;</div><div class=\"line\">\t    if (curr == head) head = item;</div><div class=\"line\">\t    if (curr == tail) tail = prev;</div><div class=\"line\">\t    void (^block)(void) = curr-&gt;_block;</div><div class=\"line\">            CFRelease(curr-&gt;_mode);</div><div class=\"line\">            free(curr);</div><div class=\"line\">\t    if (doit) &#123;</div><div class=\"line\">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class=\"line\">\t        did = true;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">    ...省略一些非重点...</div><div class=\"line\">    return did;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到<code>doit</code>这个bool变量完全决定了当前block是否执行。默认他是No的，而他被置为true的条件就是<code>CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode))</code>。就是当前mode与制定mode相等或者当前mode为commonMode（此处为一个字符串）且commonMode（此处为一个集合，若有不懂，请看runLoop结构）这个集合中包含指定mode。</p>\n<p>这是因为这个判断的存在才允许commondMode可以在任意Mode下执行。<br>当然这是提交到runLoop里的代码块才会走到<code>__CFRunLoopDoBlocks</code>这个方法。</p>\n<p>相同的，我们通过上述代码也可以知道，runLoop通过端口唤醒的事件需要通过<strong>CFRunLoopDoSource1和</strong>CFRunLoopDoTimers两个方法来调用。__CFRunLoopDoSource1方法没什么说的，直接调用源事件runLoopSourceRef即可。重点我们看一下Timer的实现，核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;\t/* DOES CALLOUT */</div><div class=\"line\">    Boolean timerHandled = false;</div><div class=\"line\">    CFMutableArrayRef timers = NULL;</div><div class=\"line\">    //遍历runLoopMode维护的Timers数组，取其中有效的timer并加入新临时数组</div><div class=\"line\">    for (CFIndex idx = 0, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : 0; idx &lt; cnt; idx++) &#123;</div><div class=\"line\">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);</div><div class=\"line\">        </div><div class=\"line\">        if (__CFIsValid(rlt) &amp;&amp; !__CFRunLoopTimerIsFiring(rlt)) &#123;</div><div class=\"line\">            if (rlt-&gt;_fireTSR &lt;= limitTSR) &#123;</div><div class=\"line\">                if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</div><div class=\"line\">                CFArrayAppendValue(timers, rlt);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //遍历临时数组，每个有效Timer调用__CFRunLoopDoTimer</div><div class=\"line\">    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</div><div class=\"line\">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</div><div class=\"line\">        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);</div><div class=\"line\">        timerHandled = timerHandled || did;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (timers) CFRelease(timers);</div><div class=\"line\">    return timerHandled;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到，此处Timer是否会回调完全取决于对应Mode的_Timers数组。那么当我们将Timer加入到commonModes中的时候一定是同时将Timer加入到了commonModes所包含的其他Mode中了，我们看下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;    </div><div class=\"line\">    CHECK_FOR_FORK();</div><div class=\"line\">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class=\"line\">    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</div><div class=\"line\">    __CFRunLoopLock(rl);</div><div class=\"line\">    if (modeName == kCFRunLoopCommonModes) &#123;//commonModes分支</div><div class=\"line\">    \t//取到commonModes所代表的Mode的集合</div><div class=\"line\">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class=\"line\">        if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class=\"line\">        \t//将commonModeItems中加入当前定时器</div><div class=\"line\">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class=\"line\">        &#125;</div><div class=\"line\">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</div><div class=\"line\">        if (NULL != set) &#123;</div><div class=\"line\">            CFTypeRef context[2] = &#123;rl, rlt&#125;;</div><div class=\"line\">            /* add new item to all common-modes */</div><div class=\"line\">            //最主要还是还是这句，这句的作用是集合中的所有对象均调用__CFRunLoopAddItemToCommonModes这个方法。</div><div class=\"line\">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class=\"line\">            CFRelease(set);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;//非commonModes的分支</div><div class=\"line\">        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class=\"line\">        if (NULL != rlm) &#123;</div><div class=\"line\">            if (NULL == rlm-&gt;_timers) &#123;</div><div class=\"line\">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</div><div class=\"line\">                cb.equal = NULL;</div><div class=\"line\">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</div><div class=\"line\">            __CFRunLoopTimerLock(rlt);</div><div class=\"line\">            if (NULL == rlt-&gt;_runLoop) &#123;</div><div class=\"line\">                rlt-&gt;_runLoop = rl;</div><div class=\"line\">            &#125; else if (rl != rlt-&gt;_runLoop) &#123;</div><div class=\"line\">                __CFRunLoopTimerUnlock(rlt);</div><div class=\"line\">                __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">                __CFRunLoopUnlock(rl);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</div><div class=\"line\">            __CFRunLoopTimerUnlock(rlt);</div><div class=\"line\">            __CFRunLoopTimerFireTSRLock();</div><div class=\"line\">            __CFRepositionTimerInMode(rlm, rlt, false);</div><div class=\"line\">            __CFRunLoopTimerFireTSRUnlock();</div><div class=\"line\">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</div><div class=\"line\">                // Normally we don&apos;t do this on behalf of clients, but for</div><div class=\"line\">                // backwards compatibility due to the change in timer handling...</div><div class=\"line\">                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (NULL != rlm) &#123;</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    __CFRunLoopUnlock(rl);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static void __CFRunLoopAddItemToCommonModes(const void *value, void *ctx) &#123;</div><div class=\"line\">    CFStringRef modeName = (CFStringRef)value;</div><div class=\"line\">    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);</div><div class=\"line\">    CFTypeRef item = (CFTypeRef)(((CFTypeRef *)ctx)[1]);</div><div class=\"line\">    if (CFGetTypeID(item) == __kCFRunLoopSourceTypeID) &#123;</div><div class=\"line\">\tCFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);</div><div class=\"line\">    &#125; else if (CFGetTypeID(item) == __kCFRunLoopObserverTypeID) &#123;</div><div class=\"line\">\tCFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);</div><div class=\"line\">    &#125; else if (CFGetTypeID(item) == __kCFRunLoopTimerTypeID) &#123;</div><div class=\"line\">\tCFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到，当加入到commonModes中时，实际上系统是<code>找出commonModes代表的所有Mode</code>，如defaultMode和trackingMode，让后分别将其加入了这些mode中。<br>同样的方法还有<code>CFRunLoopAddSource</code>/<code>CFRunLoopAddObserver</code>都是同样的道理。</p>\n<p>所以说当scrollView或其子类进行滚动的时候，UIKIT会自动将当前runLoopMode切换为UITrackingRunLoopMode，所以你加在defaultMode中的计时器当然不会走了。</p>\n<hr>\n<h3 id=\"runLoop是如何休眠有如何被唤醒的？\"><a href=\"#runLoop是如何休眠有如何被唤醒的？\" class=\"headerlink\" title=\"runLoop是如何休眠有如何被唤醒的？\"></a>runLoop是如何休眠有如何被唤醒的？</h3><p>从第7步开始，我们看到runLoop进入了休眠状态。然而所谓的休眠状态指示将当前runLoop标记为休眠之后，<strong>进入了一个while死循环</strong>。然后在循环内就不断的去读取端口消息。如果说从端口中<strong>读取到一个唤醒信息的话，break掉while循环从而进入唤醒状态</strong>。</p>\n<p>关于runLoop的几种mode老司机之前也有讲过，在CoreAnimation中的第三篇中有讲到，这里就只罗列一下。</p>\n<ul>\n<li>NSDefaultRunLoopMode</li>\n<li>NSConnectionReplyMode</li>\n<li>NSModalPanelRunLoopMode</li>\n<li>UITrackingRunLoopMode</li>\n<li>NSRunLoopCommonModes</li>\n</ul>\n<hr>\n<h3 id=\"可以唤醒runLoop的都有哪些事件？\"><a href=\"#可以唤醒runLoop的都有哪些事件？\" class=\"headerlink\" title=\"可以唤醒runLoop的都有哪些事件？\"></a>可以唤醒runLoop的都有哪些事件？</h3><p>从源码中我们可以看出，所谓的runLoop进入休眠状态不过是一个while循环，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">do &#123;</div><div class=\"line\">            if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\">                objc_clear_stack(0);</div><div class=\"line\">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class=\"line\">            </div><div class=\"line\">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class=\"line\">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class=\"line\">                if (rlm-&gt;_timerFired) &#123;</div><div class=\"line\">                    // Leave livePort as the queue port, and service timers below</div><div class=\"line\">                    rlm-&gt;_timerFired = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Go ahead and leave the inner loop.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"> &#125; while (1);</div></pre></td></tr></table></figure>\n<p>相应的我们还得看一个函数，<code>__CFRunLoopServiceMachPort</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t**buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout) &#123;</div><div class=\"line\">    Boolean originalBuffer = true;</div><div class=\"line\">    kern_return_t ret = KERN_SUCCESS;</div><div class=\"line\">    for (;;) &#123;\t\t/* In that sleep of death what nightmares may come ... */</div><div class=\"line\">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class=\"line\">        msg-&gt;msgh_bits = 0;</div><div class=\"line\">        msg-&gt;msgh_local_port = port;</div><div class=\"line\">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</div><div class=\"line\">        msg-&gt;msgh_size = buffer_size;</div><div class=\"line\">        msg-&gt;msgh_id = 0;</div><div class=\"line\">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class=\"line\">        ret = mach_msg(msg, MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</div><div class=\"line\">        CFRUNLOOP_WAKEUP(ret);</div><div class=\"line\">        if (MACH_MSG_SUCCESS == ret) &#123;</div><div class=\"line\">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (MACH_RCV_TIMED_OUT == ret) &#123;</div><div class=\"line\">            if (!originalBuffer) free(msg);</div><div class=\"line\">            *buffer = NULL;</div><div class=\"line\">            *livePort = MACH_PORT_NULL;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class=\"line\">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class=\"line\">        if (originalBuffer) *buffer = NULL;</div><div class=\"line\">        originalBuffer = false;</div><div class=\"line\">        *buffer = realloc(*buffer, buffer_size);</div><div class=\"line\">    &#125;</div><div class=\"line\">    HALT;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先看后面这个函数，在这里仅有<code>两种情况会对livePort进行赋值</code>，一种是<strong>成功获取到消息后</strong>，会根据情况赋值为msg-&gt;msgh_local_port或者MACH_PORT_NULL，而另一种<strong>获取消息超时</strong>的情况会赋值为MACH_PORT_NULL。首先请先记住这两个结论。</p>\n<p>然后我们把目光聚焦到while循环中，在调用<code>__CFRunLoopServiceMachPort</code>后如果livePort变成了<code>modeQueuePort</code>(livePort初值为MACH_PORT_NULL)，则代表为当前队列的检测端口，那么在<code>_dispatch_runloop_root_queue_perform_4CF</code>的条件下再次进入二级循环，知道Timer被激活了才跳出二级循环继续循环一级循环。（这一步的目的不好意思老司机真没看懂）。</p>\n<p>那么如果livePort不为modeQueuePort时我们的runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：<code>一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口</code>。</p>\n<p>所以我们可以看到后面runLoop处理端口时间的方法如下的判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">        if (MACH_PORT_NULL == livePort) &#123;//什么都不做，有肯能是超时之类的或者是信息过大</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class=\"line\">            // handle nothing</div><div class=\"line\">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class=\"line\">            // do nothing on Mac OS</div><div class=\"line\">        &#125;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;//这里不是从runLoop休眠后唤醒到这里的，而是在runLoop10步中的第五步跳转过来的，是处理计时器事件</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            ...省略处理计时器事件的代码...</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">        else if (livePort == dispatchPort) &#123;//这里是处理GCD提交到mainQueue的block的端口事件</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class=\"line\">            ...省略处理GCD的代码...</div><div class=\"line\">        &#125; else &#123;//之前所有情况都不是，那么唤醒runLoop的就只可能是source1的源事件了。</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class=\"line\">            ...省略处理source1源事件的代码...</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p><code>runLoop的唤醒过程，及唤醒过后的时间处理就是上面的流程</code>，大家可以看看每个分支后的注释。同时runLoopRun的核心代码也就解读完毕了。</p>\n<p>剩下的几个run方法事实上都是对这个核心方法的封装了老司机不都说了：</p>\n<ul>\n<li>CFRunLoopRunSpecific</li>\n<li>CFRunLoopRun</li>\n<li>CFRunLoopRunInMode</li>\n</ul>\n<p>至此，整个runLoop中的核心流程老司机也算带着大家分析了一遍~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-c01c74630903d263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"喘一口气\"></p>\n<hr>\n<h1 id=\"runLoop都能做什么\"><a href=\"#runLoop都能做什么\" class=\"headerlink\" title=\"runLoop都能做什么\"></a>runLoop都能做什么</h1><p>说了这么多，那么runLoop都能做些什么呢?</p>\n<p>以下内容整理自<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"external\">深入理解RunLoop\n</a>、孙源runLoop线下分享会视频：</p>\n<h2 id=\"AutoReleasePool：\"><a href=\"#AutoReleasePool：\" class=\"headerlink\" title=\"AutoReleasePool：\"></a>AutoReleasePool：</h2><blockquote>\n<p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>\n<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>\n</blockquote>\n<h2 id=\"CAAnimation\"><a href=\"#CAAnimation\" class=\"headerlink\" title=\"CAAnimation\"></a>CAAnimation</h2><p>我们知道CAAniamtion为我们提供的是<code>补间动画</code>，开发者只要给出始末状态后中间状态有系统自动生成。那么动画是怎么出现的呢，是开发者给出始末状态后，<code>系统计算出每一个中间态的各项参数</code>，<code>然后启一个定时器不断去回调并改变属性</code>。</p>\n<h2 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h2><blockquote>\n<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n</blockquote>\n<h2 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h2><blockquote>\n<p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n</blockquote>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>不多说了这个就。</p>\n<h2 id=\"PerformSelecter\"><a href=\"#PerformSelecter\" class=\"headerlink\" title=\"PerformSelecter\"></a>PerformSelecter</h2><blockquote>\n<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n</blockquote>\n<p>基本也就差不多了。</p>\n<hr>\n<p>老司机写这篇博客呢，<code>也是应盆友的要求写的</code>，基本上也是针<code>对前人博客的总结</code>以及<code>自己对源码的解读</code>。<strong>毕竟有了源码以后runLoop也就没有那么神秘了</strong>。只是希望大家明白<strong>runLoop并不是什么多么可怕的东西</strong>，只要我们一点一点去看，他<strong>也是人写的代码啊</strong>=。=不过老司机懒到连伪代码都没给你们写直接上的源码。<code>原谅一个懒癌晚期的人吧</code>。</p>\n<p>还是要感谢两位大神<strong>郭耀源</strong>和<strong>孙源</strong>两位大神之前的博客和视频讲解让我很受用。大神名里都带源字，我要不要改成<code>老源</code>=。=</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"external\">深入理解RunLoop\n</a></li>\n<li><a href=\"https://pan.baidu.com/s/1dFIfLAD\" target=\"_blank\" rel=\"external\">孙源runLoop线下分享会视频</a></li>\n<li><a href=\"http://blog.csdn.net/ssirreplaceable/article/details/53793456\" target=\"_blank\" rel=\"external\">关于RunLoop部分源码的注释</a></li>\n<li><a href=\"http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz\" target=\"_blank\" rel=\"external\">CFRunLoop的源码</a></li>\n</ul>\n<p>另外你如果想看孙源的视频，老司机已经给了下载链接，然后从<strong>最开始到1小时10分钟</strong>的时候都是干货，后面35分钟偏讨论，时间紧的童靴可以跳过，但是后面也有很好的思路分享，听听也是不错的。</p>\n<p>如果你想看runLoop源码，因为源码里面有4000多行，老司机读源码的时候讲有用的方法的行数都记了下来，你可以对应的找一下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th style=\"text-align:center\">行数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopFindMode</td>\n<td style=\"text-align:center\">#754</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopCreate</td>\n<td style=\"text-align:center\">#1321</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">_CFRunLoopGet0</td>\n<td style=\"text-align:center\">#1358</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopAddItemToCommonModes</td>\n<td style=\"text-align:center\">#1536</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoObservers</td>\n<td style=\"text-align:center\">#1668</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoSources0</td>\n<td style=\"text-align:center\">#1764</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoSource1</td>\n<td style=\"text-align:center\">#1829</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRepositionTimerInMode</td>\n<td style=\"text-align:center\">#1999</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoTimer</td>\n<td style=\"text-align:center\">#2024</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoTimers</td>\n<td style=\"text-align:center\">#2152</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopServiceMachPort</td>\n<td style=\"text-align:center\">#2196</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopRun</td>\n<td style=\"text-align:center\">#2308</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopRunSpecific</td>\n<td style=\"text-align:center\">#2601</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopRun</td>\n<td style=\"text-align:center\">#2628</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopRunInMode</td>\n<td style=\"text-align:center\">#2636</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopWakeUp</td>\n<td style=\"text-align:center\">#2645</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopAddSource</td>\n<td style=\"text-align:center\">#2791</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopAddObserver</td>\n<td style=\"text-align:center\">#2978</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopAddTimer</td>\n<td style=\"text-align:center\">#3081</td>\n</tr>\n</tbody>\n</table>\n<p>打完收功！<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-96b2100c0f20d96a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"打完收功\"></p>\n<p>老司机写这篇博客真的事废了很多心血的，好就给赞关注吧~么么哒😘~</p>\n<p>无耻的广告时间：</p>\n<p>DWCoreTextLabel支持<code>cocoaPods</code>了~<br><strong>pod search DWCoreTextLabel</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-cccdcd8278846522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RunLoop详解\"></p>\n<p>不得不说，人的<strong>惰性</strong>是真可怕啊。<br>从上周六就到写runLoop的建议开始，星期三告诉自己从星期四开始着手写这篇博客。然而现在戳个时间戳，现在是4.30星期日。写完发出去又不知道是什么时候啦，哈哈哈😁</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-eb798302dcb50708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"懒癌\"></p>\n<p>这一期讲什么呢？这一期讲runLoop哟。一直以来，runLoop这个<strong>玄而又玄</strong>的东西似乎被当做了公司面试挑人的终极话题，原因不难想，日常开发用到<code>runLoop的地方少之又少</code>，没有时间的积累这方面的知识应该还是相对较于匮乏的，<code>所以runLoop的了解侧面也能发应开发者的开发经验</code>，当然就被当做甄选人才的最后杀器。你可能一脸愤怒的说平时有用不到，我不会也不影响开发啊！的确，用不到，但这只是一个过滤器而已。<strong>但是蛋疼的是，在于国内的环境下，runLoop的相关资料又是少之又少，开发者又难以有一个深入的了解</strong>。</p>\n<p>出于以上原因，老司机今天就以<strong>老司机个人的角度</strong>，尽可能将老司机所了解到的runLoop知识。</p>\n<p>在今天的文章中你可能会看到以下内容：</p>\n<ul>\n<li>runLoop相关知识</li>\n</ul>","more":"<hr>\n<h1 id=\"runLoop是什么\"><a href=\"#runLoop是什么\" class=\"headerlink\" title=\"runLoop是什么\"></a>runLoop是什么</h1><p>直译以下，跑圈。翻译以下，<code>事件循环</code>吧。<br>为什么要有这个事件循环呢？我们知道，任何程序如果执行到程序的最后一句之后都会结束运行。然而对于我们要的手机应用程序而言，他显然不可以执行一个事件后就结束运行，他应该具有<code>持续接受事件</code>的能力从而不断地处理事件。所以最基本的思路就是用于个<code>while循环</code>让程序不能走到最后一句结束，而是在循环体内不断的接受事件。所以我们需要runLoop。不过值得注意的是，runLoop并不是iOS独有的概念，因为准去的来说<code>runLoop应该是一个模式，在其他平台同样存在这种模式</code>，不过叫不叫runLoop我就不知道了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-9f5079fdc39bf56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"循环\"></p>\n<hr>\n<h1 id=\"runLoop是如何实现的\"><a href=\"#runLoop是如何实现的\" class=\"headerlink\" title=\"runLoop是如何实现的\"></a>runLoop是如何实现的</h1><p>首先要明确的一点事，在平时我们使用的是Foundation框架的NSRunLoop类去做一些实现，而其实NSRunLoop是基于CoreFoundation框架中的CFRunLoop进行的一层简单的封装。所以我们这里着重介绍<strong>CFRunLoop</strong>，毕竟我们能拿到<a href=\"http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz\" target=\"_blank\" rel=\"external\">CFRunLoop的源码</a>。</p>\n<h2 id=\"runLoop的组成\"><a href=\"#runLoop的组成\" class=\"headerlink\" title=\"runLoop的组成\"></a>runLoop的组成</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoop &#123;</div><div class=\"line\">    CFRuntimeBase _base;</div><div class=\"line\">    pthread_mutex_t _lock;\t\t\t/* locked for accessing mode list */</div><div class=\"line\">    __CFPort _wakeUpPort;\t\t\t// used for CFRunLoopWakeUp </div><div class=\"line\">    Boolean _unused;</div><div class=\"line\">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</div><div class=\"line\">    pthread_t _pthread;</div><div class=\"line\">    uint32_t _winthread;</div><div class=\"line\">    CFMutableSetRef _commonModes;</div><div class=\"line\">    CFMutableSetRef _commonModeItems;</div><div class=\"line\">    CFRunLoopModeRef _currentMode;</div><div class=\"line\">    CFMutableSetRef _modes;</div><div class=\"line\">    struct _block_item *_blocks_head;</div><div class=\"line\">    struct _block_item *_blocks_tail;</div><div class=\"line\">    CFTypeRef _counterpart;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们大概可以CFRunLoop是这么一个结构体。<br>我们可以看到结构体重有用来保证线程安全的锁<code>_lock</code>，有用来唤醒runLoop的端口<code>_wakeUpPort</code>（这里后面会说到，不用执着），有线程对象<code>_pthread</code>，还有一个模式集合<code>_modes</code>以及一些其他辅助的属性。</p>\n<h3 id=\"pthread\"><a href=\"#pthread\" class=\"headerlink\" title=\"_pthread\"></a>_pthread</h3><p>这里我要说的是，runLoop与线程是一一对应的。也就是说<strong>一个runLoop对应着一个线程，一个线程对应着一个runLoop</strong>。这里我们从runLoop的构造函数和获取函数即可看出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</div><div class=\"line\">    CFRunLoopRef loop = NULL;</div><div class=\"line\">    CFRunLoopModeRef rlm;</div><div class=\"line\">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</div><div class=\"line\">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</div><div class=\"line\">    if (NULL == loop) &#123;</div><div class=\"line\">\treturn NULL;</div><div class=\"line\">    &#125;</div><div class=\"line\">    (void)__CFRunLoopPushPerRunData(loop);</div><div class=\"line\">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</div><div class=\"line\">    loop-&gt;_wakeUpPort = __CFPortAllocate();</div><div class=\"line\">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</div><div class=\"line\">    __CFRunLoopSetIgnoreWakeUps(loop);</div><div class=\"line\">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class=\"line\">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</div><div class=\"line\">    loop-&gt;_commonModeItems = NULL;</div><div class=\"line\">    loop-&gt;_currentMode = NULL;</div><div class=\"line\">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class=\"line\">    loop-&gt;_blocks_head = NULL;</div><div class=\"line\">    loop-&gt;_blocks_tail = NULL;</div><div class=\"line\">    loop-&gt;_counterpart = NULL;</div><div class=\"line\">    loop-&gt;_pthread = t;</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">    loop-&gt;_winthread = GetCurrentThreadId();</div><div class=\"line\">#else</div><div class=\"line\">    loop-&gt;_winthread = 0;</div><div class=\"line\">#endif</div><div class=\"line\">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</div><div class=\"line\">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">    return loop;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出构造一个runLoop对象仅需要一个<strong>pthread_t</strong>线程即可。即一个runLoop对应一个线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</div><div class=\"line\">    if (pthread_equal(t, kNilPthreadT)) &#123;//如果传入线程为空指针则默认取主线程对应的runLoop</div><div class=\"line\">\tt = pthread_main_thread_np();</div><div class=\"line\">    &#125;</div><div class=\"line\">    __CFSpinLock(&amp;loopsLock);</div><div class=\"line\">    if (!__CFRunLoops) &#123;//__CFRunLoops就是一个全局字典，以下代码为如果全局字典不存在则创建全局字典，并将主线程对应的mainLoop存入字典中</div><div class=\"line\">        __CFSpinUnlock(&amp;loopsLock);</div><div class=\"line\">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</div><div class=\"line\">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class=\"line\">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class=\"line\">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</div><div class=\"line\">            CFRelease(dict);</div><div class=\"line\">        &#125;</div><div class=\"line\">        CFRelease(mainLoop);</div><div class=\"line\">        __CFSpinLock(&amp;loopsLock);</div><div class=\"line\">    &#125;</div><div class=\"line\">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));//从全局字典中，取出对应线程的runLoop</div><div class=\"line\">    __CFSpinUnlock(&amp;loopsLock);</div><div class=\"line\">    if (!loop) &#123;//若对应线程的runLoop为空，则创建对应相乘的runLoop并保存在全局字典中</div><div class=\"line\">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class=\"line\">        __CFSpinLock(&amp;loopsLock);</div><div class=\"line\">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class=\"line\">        if (!loop) &#123;</div><div class=\"line\">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class=\"line\">            loop = newLoop;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</div><div class=\"line\">        __CFSpinUnlock(&amp;loopsLock);</div><div class=\"line\">        CFRelease(newLoop);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (pthread_equal(t, pthread_self())) &#123;</div><div class=\"line\">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</div><div class=\"line\">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return loop;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是runLoop的获取函数，我们看到系统从一个<strong>全局字典中取出runLoop</strong>，key就是一个线程，这足以说明runLoop与线程是<code>一一对应</code>的关系。</p>\n<p>值得一提的是，<code>一个线程最开始是没有对应的runLoop</code>的，是<code>在调用获取函数的时候才对应了一个runLoop的</code>。<strong>因为本身这个对应关系是有runLoop类管理的，而不是线程</strong>。</p>\n<p>当然上述两个为私有api，CF真正对外暴露的只有两个接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);</div><div class=\"line\">CF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);</div></pre></td></tr></table></figure>\n<p>两个方法的实现很简单，只要把对应的线程传入获取函数即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRunLoopRef CFRunLoopGetMain(void) &#123;</div><div class=\"line\">    CHECK_FOR_FORK();</div><div class=\"line\">    static CFRunLoopRef __main = NULL; // no retain needed</div><div class=\"line\">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</div><div class=\"line\">    return __main;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class=\"line\">    CHECK_FOR_FORK();</div><div class=\"line\">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class=\"line\">    if (rl) return rl;</div><div class=\"line\">    return _CFRunLoopGet0(pthread_self());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"modes\"><a href=\"#modes\" class=\"headerlink\" title=\"_modes\"></a>_modes</h3><p>我们看到，一个runLoop中同时还维护着一个集合，_modes。那么这个modes是做什么的呢？应该说，_modes才是<code>runLoop的核心</code>。咳咳（敲黑板），划重点了啊。</p>\n<p>首先我们看一下这个_modes里面到底都装了些什么？<br>答案是<code>__CFRunLoopMode</code>对象。那么他又是什么呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoopMode &#123;</div><div class=\"line\">    CFRuntimeBase _base;</div><div class=\"line\">    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */</div><div class=\"line\">    CFStringRef _name;</div><div class=\"line\">    Boolean _stopped;</div><div class=\"line\">    char _padding[3];</div><div class=\"line\">    CFMutableSetRef _sources0;</div><div class=\"line\">    CFMutableSetRef _sources1;</div><div class=\"line\">    CFMutableArrayRef _observers;</div><div class=\"line\">    CFMutableArrayRef _timers;</div><div class=\"line\">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class=\"line\">    __CFPortSet _portSet;</div><div class=\"line\">    CFIndex _observerMask;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">    dispatch_source_t _timerSource;</div><div class=\"line\">    dispatch_queue_t _queue;</div><div class=\"line\">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class=\"line\">    Boolean _dispatchTimerArmed;</div><div class=\"line\">#endif</div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">    mach_port_t _timerPort;</div><div class=\"line\">    Boolean _mkTimerArmed;</div><div class=\"line\">#endif</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">    DWORD _msgQMask;</div><div class=\"line\">    void (*_msgPump)(void);</div><div class=\"line\">#endif</div><div class=\"line\">    uint64_t _timerSoftDeadline; /* TSR */</div><div class=\"line\">    uint64_t _timerHardDeadline; /* TSR */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里老司机挑出了几个重点，有用来标志runLoopMode的标志<code>_name</code>，有两个事件源的集合<code>_sources0、_sources1</code>，有一组观察者<code>_obeserver</code>，有一组被加入到runLoop中的<code>_timers</code>，还有Mode本身维护着的一个用于计时的<code>_timerSource</code>，<code>_timerPort</code>。这两个一个是GCD时钟一个是内核时钟。</p>\n<p>至于runLoopMode为什么长这样，老司机会在下面runLoopRun的实现中结合代码讲到。</p>\n<hr>\n<h2 id=\"runLoop代码实现\"><a href=\"#runLoop代码实现\" class=\"headerlink\" title=\"runLoop代码实现\"></a>runLoop代码实现</h2><p>恩，接下来代码有点长，先给你们看一下大概流程，然后对着流程去看一下代码。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a84a8802abc125cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图是我盗的\"></p>\n<p>前方高能预警，代码很多！</p>\n<p>runLoop核心代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* rl, rlm are locked on entrance and exit */</div><div class=\"line\">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class=\"line\">    uint64_t startTSR = mach_absolute_time();//获取当前内核时间</div><div class=\"line\">    </div><div class=\"line\">    if (__CFRunLoopIsStopped(rl)) &#123;//如果当前runLoop或者runLoopMode为停止状态的话直接返回</div><div class=\"line\">        __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">        return kCFRunLoopRunStopped;</div><div class=\"line\">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">        rlm-&gt;_stopped = false;</div><div class=\"line\">        return kCFRunLoopRunStopped;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //判断是否是第一次在主线程中启动RunLoop,如果是且当前RunLoop为主线程的RunLoop，那么就给分发一个队列调度端口</div><div class=\"line\">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class=\"line\">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class=\"line\">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class=\"line\">    </div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\"></div><div class=\"line\">\t//给当前模式分发队列端口</div><div class=\"line\">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class=\"line\">    if (rlm-&gt;_queue) &#123;</div><div class=\"line\">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class=\"line\">        if (!modeQueuePort) &#123;</div><div class=\"line\">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\">    </div><div class=\"line\">    //初始化一个GCD计时器，用于管理当前模式的超时</div><div class=\"line\">    dispatch_source_t timeout_timer = NULL;</div><div class=\"line\">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class=\"line\">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class=\"line\">        seconds = 0.0;</div><div class=\"line\">        timeout_context-&gt;termTSR = 0ULL;</div><div class=\"line\">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class=\"line\">        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</div><div class=\"line\">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">        dispatch_retain(timeout_timer);</div><div class=\"line\">        timeout_context-&gt;ds = timeout_timer;</div><div class=\"line\">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class=\"line\">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class=\"line\">        dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class=\"line\">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class=\"line\">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class=\"line\">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class=\"line\">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class=\"line\">        dispatch_resume(timeout_timer);</div><div class=\"line\">    &#125; else &#123; // infinite timeout</div><div class=\"line\">        seconds = 9999999999.0;</div><div class=\"line\">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // 第一步，进入循环</div><div class=\"line\">    Boolean didDispatchPortLastTime = true;</div><div class=\"line\">    int32_t retVal = 0;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        uint8_t msg_buffer[3 * 1024];</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        mach_msg_header_t *msg = NULL;</div><div class=\"line\">        mach_port_t livePort = MACH_PORT_NULL;</div><div class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">        HANDLE livePort = NULL;</div><div class=\"line\">        Boolean windowsMessageReceived = false;</div><div class=\"line\">#endif</div><div class=\"line\">        __CFPortSet waitSet = rlm-&gt;_portSet;</div><div class=\"line\">        </div><div class=\"line\">        //设置当前循环监听端口的唤醒</div><div class=\"line\">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class=\"line\">        </div><div class=\"line\">        // 第二步，通知观察者准备开始处理Timer源事件</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class=\"line\">        </div><div class=\"line\">        // 第三步，通知观察者准备开始处理Source源事件</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class=\"line\">        </div><div class=\"line\">        //执行提交到runLoop中的block</div><div class=\"line\">        __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        </div><div class=\"line\">        // 第四步，执行source0中的源事件</div><div class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class=\"line\">        </div><div class=\"line\">        //如果当前source0源事件处理完成后执行提交到runLoop中的block</div><div class=\"line\">        if (sourceHandledThisLoop) &#123;</div><div class=\"line\">            __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        //标志是否等待端口唤醒</div><div class=\"line\">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class=\"line\">        </div><div class=\"line\">        // 第五步，检测端口，如果端口有事件则跳转至handle_msg（首次执行不会进入判断，因为didDispatchPortLastTime为true）</div><div class=\"line\">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) &#123;</div><div class=\"line\">                goto handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">            if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</div><div class=\"line\">                goto handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        didDispatchPortLastTime = false;</div><div class=\"line\">        </div><div class=\"line\">        // 第六步，通知观察者线程进入休眠</div><div class=\"line\">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 标志当前runLoop为休眠状态</div><div class=\"line\">        __CFRunLoopSetSleeping(rl);</div><div class=\"line\">        </div><div class=\"line\">        // do not do any user callouts after this point (after notifying of sleeping)</div><div class=\"line\">        </div><div class=\"line\">        // Must push the local-to-this-activation ports in on every loop</div><div class=\"line\">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class=\"line\">        // want these ports to get serviced.</div><div class=\"line\">        </div><div class=\"line\">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">        __CFRunLoopUnlock(rl);</div><div class=\"line\">   </div><div class=\"line\">   </div><div class=\"line\">   \t\t// 第七步，进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop     </div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        do &#123;</div><div class=\"line\">            if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\">                objc_clear_stack(0);</div><div class=\"line\">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class=\"line\">            </div><div class=\"line\">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class=\"line\">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class=\"line\">                if (rlm-&gt;_timerFired) &#123;</div><div class=\"line\">                    // Leave livePort as the queue port, and service timers below</div><div class=\"line\">                    rlm-&gt;_timerFired = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Go ahead and leave the inner loop.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; while (1);</div><div class=\"line\">#else</div><div class=\"line\">        if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\">            objc_clear_stack(0);</div><div class=\"line\">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class=\"line\">#endif</div><div class=\"line\">        </div><div class=\"line\">        </div><div class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">        // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.</div><div class=\"line\">        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);</div><div class=\"line\">#endif</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopLock(rl);</div><div class=\"line\">        __CFRunLoopModeLock(rlm);</div><div class=\"line\">        </div><div class=\"line\">        // Must remove the local-to-this-activation ports in on every loop</div><div class=\"line\">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class=\"line\">        // want these ports to get serviced. Also, we don&apos;t want them left</div><div class=\"line\">        // in there if this function returns.</div><div class=\"line\">        </div><div class=\"line\">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class=\"line\">        </div><div class=\"line\">        //标志当前runLoop为唤醒状态</div><div class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class=\"line\">        </div><div class=\"line\">        // user callouts now OK again</div><div class=\"line\">        __CFRunLoopUnsetSleeping(rl);</div><div class=\"line\">        </div><div class=\"line\">        // 第八步，通知观察者线程被唤醒了</div><div class=\"line\">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class=\"line\">        </div><div class=\"line\">        //执行端口的事件</div><div class=\"line\">    handle_msg:;</div><div class=\"line\">    </div><div class=\"line\">    \t//设置此时runLoop忽略端口唤醒（保证线程安全）</div><div class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class=\"line\">        </div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">        if (windowsMessageReceived) &#123;</div><div class=\"line\">            // These Win32 APIs cause a callout, so make sure we&apos;re unlocked first and relocked after</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">            __CFRunLoopUnlock(rl);</div><div class=\"line\">            </div><div class=\"line\">            if (rlm-&gt;_msgPump) &#123;</div><div class=\"line\">                rlm-&gt;_msgPump();</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                MSG msg;</div><div class=\"line\">                if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) &#123;</div><div class=\"line\">                    TranslateMessage(&amp;msg);</div><div class=\"line\">                    DispatchMessage(&amp;msg);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            __CFRunLoopLock(rl);</div><div class=\"line\">            __CFRunLoopModeLock(rlm);</div><div class=\"line\">            sourceHandledThisLoop = true;</div><div class=\"line\">            </div><div class=\"line\">            // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced</div><div class=\"line\">            // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we&apos;re just checking to see if the things are signalled right now -- we will wait on them again later.</div><div class=\"line\">            // NOTE: Ignore the dispatch source (it&apos;s not in the wait set anymore) and also don&apos;t run the observers here since we are polling.</div><div class=\"line\">            __CFRunLoopSetSleeping(rl);</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">            __CFRunLoopUnlock(rl);</div><div class=\"line\">            </div><div class=\"line\">            __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &amp;livePort, NULL);</div><div class=\"line\">            </div><div class=\"line\">            __CFRunLoopLock(rl);</div><div class=\"line\">            __CFRunLoopModeLock(rlm);</div><div class=\"line\">            __CFRunLoopUnsetSleeping(rl);</div><div class=\"line\">            // If we have a new live port then it will be handled below as normal</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        </div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\t\t// 第九步，处理端口事件</div><div class=\"line\">        if (MACH_PORT_NULL == livePort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class=\"line\">            // handle nothing</div><div class=\"line\">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class=\"line\">            // do nothing on Mac OS</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">            // Always reset the wake up port, or risk spinning forever</div><div class=\"line\">            ResetEvent(rl-&gt;_wakeUpPort);</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                // Re-arm the next timer, because we apparently fired early</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;//处理定时器事件</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</div><div class=\"line\">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                // Re-arm the next timer</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">\t\t//处理有GCD提交到主线程唤醒的事件</div><div class=\"line\">        else if (livePort == dispatchPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">            __CFRunLoopUnlock(rl);</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">            void *msg = 0;</div><div class=\"line\">#endif</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class=\"line\">            __CFRunLoopLock(rl);</div><div class=\"line\">            __CFRunLoopModeLock(rlm);</div><div class=\"line\">            sourceHandledThisLoop = true;</div><div class=\"line\">            didDispatchPortLastTime = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">        </div><div class=\"line\">\t        //处理source1唤醒的事件</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class=\"line\">            // Despite the name, this works for windows handles as well</div><div class=\"line\">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class=\"line\">            if (rls) &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">                mach_msg_header_t *reply = NULL;</div><div class=\"line\">                // 处理Source1(基于端口的源)</div><div class=\"line\">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class=\"line\">                if (NULL != reply) &#123;</div><div class=\"line\">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class=\"line\">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class=\"line\">                &#125;</div><div class=\"line\">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</div><div class=\"line\">#endif</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class=\"line\">#endif</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        </div><div class=\"line\">        //返回对应的返回值并跳出循环</div><div class=\"line\">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunHandledSource;</div><div class=\"line\">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunTimedOut;</div><div class=\"line\">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">            __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">            retVal = kCFRunLoopRunStopped;</div><div class=\"line\">        &#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">            rlm-&gt;_stopped = false;</div><div class=\"line\">            retVal = kCFRunLoopRunStopped;</div><div class=\"line\">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunFinished;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; while (0 == retVal);</div><div class=\"line\">    </div><div class=\"line\">    // 第十步，释放定时器</div><div class=\"line\">    if (timeout_timer) &#123;</div><div class=\"line\">        dispatch_source_cancel(timeout_timer);</div><div class=\"line\">        dispatch_release(timeout_timer);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        free(timeout_context);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return retVal;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法有点有点长，300行代码=。=</p>\n<p>这300行的流程其实就是上面归纳的10步：</p>\n<blockquote>\n<p>首先进入runLoop对应的Mode并开始循环，然后在休眠之前做了三件事：DoBlocks、DoSource0、检测source1端口是否有消息，如果有则跳过稍后的休眠。<br>然后runLoop就进入了休眠状态，直到有端口事件唤醒runLoop，被唤醒后则处理响应的端口事件然后再次开始循环。直到runLoop超时或者runLoop被停止后在结束runLoop。</p>\n</blockquote>\n<p>不过好在代码很全，在这里我们能出到很多问题。</p>\n<h3 id=\"source0，source1\"><a href=\"#source0，source1\" class=\"headerlink\" title=\"source0，source1\"></a>source0，source1</h3><p>首先这个源事件分为两种，一种是不基于端口的source0，一直是基于端口的source1。</p>\n<blockquote>\n<p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>\n<p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>\n<p>————<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"external\">引自深入理解RunLoop\n</a></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>source0呢主要处理App内部事件、App自己负责管理（触发），如UIEvent、CFSocket</p>\n<p>source1呢主要有Runloop和内核管理，Mach port驱动，如CFMahPort、CFMessagePort</p>\n<p>————引自孙源runLoop线下分享会视频 </p>\n</blockquote>\n<h3 id=\"NSTimer事件是借助runLoop实现的。\"><a href=\"#NSTimer事件是借助runLoop实现的。\" class=\"headerlink\" title=\"NSTimer事件是借助runLoop实现的。\"></a>NSTimer事件是借助runLoop实现的。</h3><p>这点老司机早在CoreAnimation系列中第三篇介绍三个Timer的时候老司机就有提到过，在初始化Timer的时候要将Timer提交到runLoop中，并且要指定mode，才可以工作。今天我们可以深入讲一下。</p>\n<blockquote>\n<p>这个事件是怎么执行的？并且为什么有的时候会延迟？为什么子线程中创建的Timer并不执行？</p>\n<p>首先，在进入循环开始以后，就要处理source0事件，处理后检测一下source1端口是否有消息，如果一个Timer的时间间隔刚好到了则此处有可能会得到一个消息，则runLoop直接跳转至端口激活处从而去处理Timer事件。</p>\n<p>第二，为什么会延迟？我们知道，两次端口事件是在两个runLoop循环中分别执行的。比如Timer的时间间隔为1秒，在第一次Timer回调结束后，在很短时间内立即进入runLoop的下一次循环，这次并不是Timer回调并且是一个计算量非常大的任务，计算时间超过了1秒，那么runLoop的第二个循环就要执行很久，无法进入下一个循环等待有可能即将到来的Timer第二次回调的信号，所以Timer第二次回调就会推迟了。</p>\n<p>第三，为什么在子线程中创建的Timer并且提交到当前runLoop中并不会运行？这还是要从runLoop的获取函数中看，当调用currentRunLoop的时候会取当前线程对应的runLoop，而首次是取不到的，则会创建一个新的runLoop。但是！这个runLoop并没有run。就是没有开启=。=</p>\n</blockquote>\n<hr>\n<h3 id=\"同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？\"><a href=\"#同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？\" class=\"headerlink\" title=\"同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？\"></a>同一时间内，runLoop只能运行同一种mode。那commonMode是怎么实现的？</h3><p>从runLoop的结构我们可以知道，一个runLoop会包含多种runLoopMode，runLoop是不停的在这些mode之间进行切换去完成对应Mode中的相关任务。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a9ffd190ef7c73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"runLoop中多个mode\"></p>\n<p>首先为什么说runLoop只能在各种Mode之间切换，同一时间只能存在一个呢？<br>因为上面那个方法必须要传一个runLoopMode，然后这个方法贯穿始终，都在用。</p>\n<p>我们看到，上面的方法中首先就要传入一个指定的mode才能执行对应mode中的事件。那么所谓的CommonMode是如何实现的呢？</p>\n<p>我们看到runLoop中执行任务有调到CFRunLoopDoBlocks这么一个函数，那么这个函数是什么样的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked</div><div class=\"line\">    if (!rl-&gt;_blocks_head) return false;</div><div class=\"line\">    if (!rlm || !rlm-&gt;_name) return false;</div><div class=\"line\">    ...省略一些非重点...</div><div class=\"line\">    while (item) &#123;</div><div class=\"line\">        struct _block_item *curr = item;</div><div class=\"line\">        item = item-&gt;_next;</div><div class=\"line\">\tBoolean doit = false;</div><div class=\"line\">\tif (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class=\"line\">\t    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">\t    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (!doit) prev = curr;</div><div class=\"line\">\tif (doit) &#123;</div><div class=\"line\">\t    if (prev) prev-&gt;_next = item;</div><div class=\"line\">\t    if (curr == head) head = item;</div><div class=\"line\">\t    if (curr == tail) tail = prev;</div><div class=\"line\">\t    void (^block)(void) = curr-&gt;_block;</div><div class=\"line\">            CFRelease(curr-&gt;_mode);</div><div class=\"line\">            free(curr);</div><div class=\"line\">\t    if (doit) &#123;</div><div class=\"line\">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class=\"line\">\t        did = true;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">    ...省略一些非重点...</div><div class=\"line\">    return did;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到<code>doit</code>这个bool变量完全决定了当前block是否执行。默认他是No的，而他被置为true的条件就是<code>CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode))</code>。就是当前mode与制定mode相等或者当前mode为commonMode（此处为一个字符串）且commonMode（此处为一个集合，若有不懂，请看runLoop结构）这个集合中包含指定mode。</p>\n<p>这是因为这个判断的存在才允许commondMode可以在任意Mode下执行。<br>当然这是提交到runLoop里的代码块才会走到<code>__CFRunLoopDoBlocks</code>这个方法。</p>\n<p>相同的，我们通过上述代码也可以知道，runLoop通过端口唤醒的事件需要通过<strong>CFRunLoopDoSource1和</strong>CFRunLoopDoTimers两个方法来调用。__CFRunLoopDoSource1方法没什么说的，直接调用源事件runLoopSourceRef即可。重点我们看一下Timer的实现，核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;\t/* DOES CALLOUT */</div><div class=\"line\">    Boolean timerHandled = false;</div><div class=\"line\">    CFMutableArrayRef timers = NULL;</div><div class=\"line\">    //遍历runLoopMode维护的Timers数组，取其中有效的timer并加入新临时数组</div><div class=\"line\">    for (CFIndex idx = 0, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : 0; idx &lt; cnt; idx++) &#123;</div><div class=\"line\">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);</div><div class=\"line\">        </div><div class=\"line\">        if (__CFIsValid(rlt) &amp;&amp; !__CFRunLoopTimerIsFiring(rlt)) &#123;</div><div class=\"line\">            if (rlt-&gt;_fireTSR &lt;= limitTSR) &#123;</div><div class=\"line\">                if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</div><div class=\"line\">                CFArrayAppendValue(timers, rlt);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //遍历临时数组，每个有效Timer调用__CFRunLoopDoTimer</div><div class=\"line\">    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</div><div class=\"line\">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</div><div class=\"line\">        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);</div><div class=\"line\">        timerHandled = timerHandled || did;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (timers) CFRelease(timers);</div><div class=\"line\">    return timerHandled;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到，此处Timer是否会回调完全取决于对应Mode的_Timers数组。那么当我们将Timer加入到commonModes中的时候一定是同时将Timer加入到了commonModes所包含的其他Mode中了，我们看下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;    </div><div class=\"line\">    CHECK_FOR_FORK();</div><div class=\"line\">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class=\"line\">    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</div><div class=\"line\">    __CFRunLoopLock(rl);</div><div class=\"line\">    if (modeName == kCFRunLoopCommonModes) &#123;//commonModes分支</div><div class=\"line\">    \t//取到commonModes所代表的Mode的集合</div><div class=\"line\">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class=\"line\">        if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class=\"line\">        \t//将commonModeItems中加入当前定时器</div><div class=\"line\">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class=\"line\">        &#125;</div><div class=\"line\">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</div><div class=\"line\">        if (NULL != set) &#123;</div><div class=\"line\">            CFTypeRef context[2] = &#123;rl, rlt&#125;;</div><div class=\"line\">            /* add new item to all common-modes */</div><div class=\"line\">            //最主要还是还是这句，这句的作用是集合中的所有对象均调用__CFRunLoopAddItemToCommonModes这个方法。</div><div class=\"line\">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class=\"line\">            CFRelease(set);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;//非commonModes的分支</div><div class=\"line\">        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class=\"line\">        if (NULL != rlm) &#123;</div><div class=\"line\">            if (NULL == rlm-&gt;_timers) &#123;</div><div class=\"line\">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</div><div class=\"line\">                cb.equal = NULL;</div><div class=\"line\">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</div><div class=\"line\">            __CFRunLoopTimerLock(rlt);</div><div class=\"line\">            if (NULL == rlt-&gt;_runLoop) &#123;</div><div class=\"line\">                rlt-&gt;_runLoop = rl;</div><div class=\"line\">            &#125; else if (rl != rlt-&gt;_runLoop) &#123;</div><div class=\"line\">                __CFRunLoopTimerUnlock(rlt);</div><div class=\"line\">                __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">                __CFRunLoopUnlock(rl);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</div><div class=\"line\">            __CFRunLoopTimerUnlock(rlt);</div><div class=\"line\">            __CFRunLoopTimerFireTSRLock();</div><div class=\"line\">            __CFRepositionTimerInMode(rlm, rlt, false);</div><div class=\"line\">            __CFRunLoopTimerFireTSRUnlock();</div><div class=\"line\">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</div><div class=\"line\">                // Normally we don&apos;t do this on behalf of clients, but for</div><div class=\"line\">                // backwards compatibility due to the change in timer handling...</div><div class=\"line\">                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (NULL != rlm) &#123;</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    __CFRunLoopUnlock(rl);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static void __CFRunLoopAddItemToCommonModes(const void *value, void *ctx) &#123;</div><div class=\"line\">    CFStringRef modeName = (CFStringRef)value;</div><div class=\"line\">    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);</div><div class=\"line\">    CFTypeRef item = (CFTypeRef)(((CFTypeRef *)ctx)[1]);</div><div class=\"line\">    if (CFGetTypeID(item) == __kCFRunLoopSourceTypeID) &#123;</div><div class=\"line\">\tCFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);</div><div class=\"line\">    &#125; else if (CFGetTypeID(item) == __kCFRunLoopObserverTypeID) &#123;</div><div class=\"line\">\tCFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);</div><div class=\"line\">    &#125; else if (CFGetTypeID(item) == __kCFRunLoopTimerTypeID) &#123;</div><div class=\"line\">\tCFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到，当加入到commonModes中时，实际上系统是<code>找出commonModes代表的所有Mode</code>，如defaultMode和trackingMode，让后分别将其加入了这些mode中。<br>同样的方法还有<code>CFRunLoopAddSource</code>/<code>CFRunLoopAddObserver</code>都是同样的道理。</p>\n<p>所以说当scrollView或其子类进行滚动的时候，UIKIT会自动将当前runLoopMode切换为UITrackingRunLoopMode，所以你加在defaultMode中的计时器当然不会走了。</p>\n<hr>\n<h3 id=\"runLoop是如何休眠有如何被唤醒的？\"><a href=\"#runLoop是如何休眠有如何被唤醒的？\" class=\"headerlink\" title=\"runLoop是如何休眠有如何被唤醒的？\"></a>runLoop是如何休眠有如何被唤醒的？</h3><p>从第7步开始，我们看到runLoop进入了休眠状态。然而所谓的休眠状态指示将当前runLoop标记为休眠之后，<strong>进入了一个while死循环</strong>。然后在循环内就不断的去读取端口消息。如果说从端口中<strong>读取到一个唤醒信息的话，break掉while循环从而进入唤醒状态</strong>。</p>\n<p>关于runLoop的几种mode老司机之前也有讲过，在CoreAnimation中的第三篇中有讲到，这里就只罗列一下。</p>\n<ul>\n<li>NSDefaultRunLoopMode</li>\n<li>NSConnectionReplyMode</li>\n<li>NSModalPanelRunLoopMode</li>\n<li>UITrackingRunLoopMode</li>\n<li>NSRunLoopCommonModes</li>\n</ul>\n<hr>\n<h3 id=\"可以唤醒runLoop的都有哪些事件？\"><a href=\"#可以唤醒runLoop的都有哪些事件？\" class=\"headerlink\" title=\"可以唤醒runLoop的都有哪些事件？\"></a>可以唤醒runLoop的都有哪些事件？</h3><p>从源码中我们可以看出，所谓的runLoop进入休眠状态不过是一个while循环，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">do &#123;</div><div class=\"line\">            if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\">                objc_clear_stack(0);</div><div class=\"line\">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class=\"line\">            </div><div class=\"line\">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class=\"line\">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class=\"line\">                if (rlm-&gt;_timerFired) &#123;</div><div class=\"line\">                    // Leave livePort as the queue port, and service timers below</div><div class=\"line\">                    rlm-&gt;_timerFired = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Go ahead and leave the inner loop.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"> &#125; while (1);</div></pre></td></tr></table></figure>\n<p>相应的我们还得看一个函数，<code>__CFRunLoopServiceMachPort</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t**buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout) &#123;</div><div class=\"line\">    Boolean originalBuffer = true;</div><div class=\"line\">    kern_return_t ret = KERN_SUCCESS;</div><div class=\"line\">    for (;;) &#123;\t\t/* In that sleep of death what nightmares may come ... */</div><div class=\"line\">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class=\"line\">        msg-&gt;msgh_bits = 0;</div><div class=\"line\">        msg-&gt;msgh_local_port = port;</div><div class=\"line\">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</div><div class=\"line\">        msg-&gt;msgh_size = buffer_size;</div><div class=\"line\">        msg-&gt;msgh_id = 0;</div><div class=\"line\">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class=\"line\">        ret = mach_msg(msg, MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</div><div class=\"line\">        CFRUNLOOP_WAKEUP(ret);</div><div class=\"line\">        if (MACH_MSG_SUCCESS == ret) &#123;</div><div class=\"line\">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (MACH_RCV_TIMED_OUT == ret) &#123;</div><div class=\"line\">            if (!originalBuffer) free(msg);</div><div class=\"line\">            *buffer = NULL;</div><div class=\"line\">            *livePort = MACH_PORT_NULL;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class=\"line\">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class=\"line\">        if (originalBuffer) *buffer = NULL;</div><div class=\"line\">        originalBuffer = false;</div><div class=\"line\">        *buffer = realloc(*buffer, buffer_size);</div><div class=\"line\">    &#125;</div><div class=\"line\">    HALT;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先看后面这个函数，在这里仅有<code>两种情况会对livePort进行赋值</code>，一种是<strong>成功获取到消息后</strong>，会根据情况赋值为msg-&gt;msgh_local_port或者MACH_PORT_NULL，而另一种<strong>获取消息超时</strong>的情况会赋值为MACH_PORT_NULL。首先请先记住这两个结论。</p>\n<p>然后我们把目光聚焦到while循环中，在调用<code>__CFRunLoopServiceMachPort</code>后如果livePort变成了<code>modeQueuePort</code>(livePort初值为MACH_PORT_NULL)，则代表为当前队列的检测端口，那么在<code>_dispatch_runloop_root_queue_perform_4CF</code>的条件下再次进入二级循环，知道Timer被激活了才跳出二级循环继续循环一级循环。（这一步的目的不好意思老司机真没看懂）。</p>\n<p>那么如果livePort不为modeQueuePort时我们的runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：<code>一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口</code>。</p>\n<p>所以我们可以看到后面runLoop处理端口时间的方法如下的判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">        if (MACH_PORT_NULL == livePort) &#123;//什么都不做，有肯能是超时之类的或者是信息过大</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class=\"line\">            // handle nothing</div><div class=\"line\">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class=\"line\">            // do nothing on Mac OS</div><div class=\"line\">        &#125;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;//这里不是从runLoop休眠后唤醒到这里的，而是在runLoop10步中的第五步跳转过来的，是处理计时器事件</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            ...省略处理计时器事件的代码...</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">        else if (livePort == dispatchPort) &#123;//这里是处理GCD提交到mainQueue的block的端口事件</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class=\"line\">            ...省略处理GCD的代码...</div><div class=\"line\">        &#125; else &#123;//之前所有情况都不是，那么唤醒runLoop的就只可能是source1的源事件了。</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class=\"line\">            ...省略处理source1源事件的代码...</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p><code>runLoop的唤醒过程，及唤醒过后的时间处理就是上面的流程</code>，大家可以看看每个分支后的注释。同时runLoopRun的核心代码也就解读完毕了。</p>\n<p>剩下的几个run方法事实上都是对这个核心方法的封装了老司机不都说了：</p>\n<ul>\n<li>CFRunLoopRunSpecific</li>\n<li>CFRunLoopRun</li>\n<li>CFRunLoopRunInMode</li>\n</ul>\n<p>至此，整个runLoop中的核心流程老司机也算带着大家分析了一遍~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-c01c74630903d263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"喘一口气\"></p>\n<hr>\n<h1 id=\"runLoop都能做什么\"><a href=\"#runLoop都能做什么\" class=\"headerlink\" title=\"runLoop都能做什么\"></a>runLoop都能做什么</h1><p>说了这么多，那么runLoop都能做些什么呢?</p>\n<p>以下内容整理自<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"external\">深入理解RunLoop\n</a>、孙源runLoop线下分享会视频：</p>\n<h2 id=\"AutoReleasePool：\"><a href=\"#AutoReleasePool：\" class=\"headerlink\" title=\"AutoReleasePool：\"></a>AutoReleasePool：</h2><blockquote>\n<p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>\n<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>\n</blockquote>\n<h2 id=\"CAAnimation\"><a href=\"#CAAnimation\" class=\"headerlink\" title=\"CAAnimation\"></a>CAAnimation</h2><p>我们知道CAAniamtion为我们提供的是<code>补间动画</code>，开发者只要给出始末状态后中间状态有系统自动生成。那么动画是怎么出现的呢，是开发者给出始末状态后，<code>系统计算出每一个中间态的各项参数</code>，<code>然后启一个定时器不断去回调并改变属性</code>。</p>\n<h2 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h2><blockquote>\n<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n</blockquote>\n<h2 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h2><blockquote>\n<p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n</blockquote>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>不多说了这个就。</p>\n<h2 id=\"PerformSelecter\"><a href=\"#PerformSelecter\" class=\"headerlink\" title=\"PerformSelecter\"></a>PerformSelecter</h2><blockquote>\n<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n</blockquote>\n<p>基本也就差不多了。</p>\n<hr>\n<p>老司机写这篇博客呢，<code>也是应盆友的要求写的</code>，基本上也是针<code>对前人博客的总结</code>以及<code>自己对源码的解读</code>。<strong>毕竟有了源码以后runLoop也就没有那么神秘了</strong>。只是希望大家明白<strong>runLoop并不是什么多么可怕的东西</strong>，只要我们一点一点去看，他<strong>也是人写的代码啊</strong>=。=不过老司机懒到连伪代码都没给你们写直接上的源码。<code>原谅一个懒癌晚期的人吧</code>。</p>\n<p>还是要感谢两位大神<strong>郭耀源</strong>和<strong>孙源</strong>两位大神之前的博客和视频讲解让我很受用。大神名里都带源字，我要不要改成<code>老源</code>=。=</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"external\">深入理解RunLoop\n</a></li>\n<li><a href=\"https://pan.baidu.com/s/1dFIfLAD\" target=\"_blank\" rel=\"external\">孙源runLoop线下分享会视频</a></li>\n<li><a href=\"http://blog.csdn.net/ssirreplaceable/article/details/53793456\" target=\"_blank\" rel=\"external\">关于RunLoop部分源码的注释</a></li>\n<li><a href=\"http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz\" target=\"_blank\" rel=\"external\">CFRunLoop的源码</a></li>\n</ul>\n<p>另外你如果想看孙源的视频，老司机已经给了下载链接，然后从<strong>最开始到1小时10分钟</strong>的时候都是干货，后面35分钟偏讨论，时间紧的童靴可以跳过，但是后面也有很好的思路分享，听听也是不错的。</p>\n<p>如果你想看runLoop源码，因为源码里面有4000多行，老司机读源码的时候讲有用的方法的行数都记了下来，你可以对应的找一下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th style=\"text-align:center\">行数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopFindMode</td>\n<td style=\"text-align:center\">#754</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopCreate</td>\n<td style=\"text-align:center\">#1321</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">_CFRunLoopGet0</td>\n<td style=\"text-align:center\">#1358</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopAddItemToCommonModes</td>\n<td style=\"text-align:center\">#1536</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoObservers</td>\n<td style=\"text-align:center\">#1668</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoSources0</td>\n<td style=\"text-align:center\">#1764</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoSource1</td>\n<td style=\"text-align:center\">#1829</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRepositionTimerInMode</td>\n<td style=\"text-align:center\">#1999</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoTimer</td>\n<td style=\"text-align:center\">#2024</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopDoTimers</td>\n<td style=\"text-align:center\">#2152</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopServiceMachPort</td>\n<td style=\"text-align:center\">#2196</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">__CFRunLoopRun</td>\n<td style=\"text-align:center\">#2308</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopRunSpecific</td>\n<td style=\"text-align:center\">#2601</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopRun</td>\n<td style=\"text-align:center\">#2628</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopRunInMode</td>\n<td style=\"text-align:center\">#2636</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopWakeUp</td>\n<td style=\"text-align:center\">#2645</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopAddSource</td>\n<td style=\"text-align:center\">#2791</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopAddObserver</td>\n<td style=\"text-align:center\">#2978</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CFRunLoopAddTimer</td>\n<td style=\"text-align:center\">#3081</td>\n</tr>\n</tbody>\n</table>\n<p>打完收功！<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-96b2100c0f20d96a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"打完收功\"></p>\n<p>老司机写这篇博客真的事废了很多心血的，好就给赞关注吧~么么哒😘~</p>\n<p>无耻的广告时间：</p>\n<p>DWCoreTextLabel支持<code>cocoaPods</code>了~<br><strong>pod search DWCoreTextLabel</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>"},{"title":"老司机出品——源码解析之从Block说开去","layout":"post","date":"2017-06-04T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"![从Block说开去](http://upload-images.jianshu.io/upload_images/1835430-2b26e7f92ebaaa93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n近来把《iOS与OS X多线程和内存管理》这本书又掏出来看了一遍，这本书前前后后加起来看了能有三四遍了，每次看都有新的理解。现在就把个人对Block的一些理解记录下来。\n\n今天的内容中你会看到：\n\n- Block是什么\n- Block的实质\n- 关于Block对外部的赋值操作\n- Block类型及其存储域\n- \\_\\_block说明符\n- 关于Block引起的循环引用\n\n<!-- more -->\n\n- - -\n### Block是什么？\n> 带有自动变量的匿名函数。 \n> \n> ————引自《iOS与OS X多线程和内存管理》\n\n为什么这么说呢？\n我们分别从匿名函数和带自动变量两个角度来说。\n\n- 1.匿名函数\n\n首先，Blocks是C语言的扩充功能。\n\nC语言中函数是这个样子的：\n\n```\nvoid func() {\n\tprintf(\"hello world\");\n}\n```\n\n如上，是一个C语言函数，而block是什么形式呢？\n\n```\n^void () {\n\tprintf(\"hello world\");\n}\n```\n这种不带函数名的函数就是所谓的匿名函数。\n\n- 2.带自动变量\n\n还是要从C语言函数中说起。\n\n```\nint a = 10;\nvoid func (int b) {\n\tprintf(\"%d + %d = %d\",a,b,a+b);\n}\n\nint main(int argc, char * argv[]) {\n    func(5);\n    return 0;\n}\n```\n上述的代码主要想说明一件事，C语言函数中，函数体中使用的函数外部变量只有两种：函数参数即全局变量。\n\n我们再看看Block是如何使用的。\n\n```\nint main(int argc, char * argv[]) {\n    int a = 10;\n    void(^block)(int) = ^(int b) {\n        printf(\"%d + %d = %d\\n\",a,b,a+b);\n    };\n    block(5);\n    return 0;\n}\n```\n我们看到，在此例中a已经不是全局变量了，而是一个局部变量，也就是自动变量。然而block却可以正常使用，为什么呢？因为block内部维护了一个变量a的值，所以执行正确。这里你先不用纠结，下面会有源码。由上我们就知道了什么叫做带自动变量了。\n\n- - -\n### Block的实质\n想要看Block的实质我们还是Block的实现过程。我们还是要借助clang。\n\n```\n#include <stdio.h>\n\nint main(int argc, char * argv[]) {\n    int a = 10;\n    void(^block)(int) = ^(int b) {\n        printf(\"%d + %d = %d\\n\",a,b,a+b);\n    };\n    block(5);\n    return 0;\n}\n```\n还是这个简单的函数，我们借助clang来转换一下。这里为了稍后方便，我们尽量删除其他无用头文件，引入必要头文件。\n\n```\nclang -rewrite-objc main.m\n```\n\n转换完成后我们会发现main.m同文件夹下多了一个main.cpp的文件。\n打开这个文件我们就会看到转换后的源码，而老司机让同学们换头文件的原因你也应该明白了，引入的头文件中一些相关代码也会在转换的文件中。如果你跟老司机一样只引入了`stdio.h`的话，那么现在`command + L`跳转到第62行，复制62行至67行，`command + 下`调至文件底部粘贴，再跳至510行，`command + shift + 上`选中上面所有代码，`delete`删除后就剩下干货了，大概是这个样子的：\n\n![block实现](http://upload-images.jianshu.io/upload_images/1835430-435ae974bab42f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，我们看到这就是block的相关实现。\n\n首先我们看block结构体中，三个成员变量，一个构造函数。\n\n![block](http://upload-images.jianshu.io/upload_images/1835430-72a8882606a061f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到第一个成员变量是`__block_impl`的结构体，其中有指向block实现函数的函数指针，第二个成员变量是`__main_block_desc_0`，用来负责管理block的内存管理。第三个成员变量`int型`变量a。\n\n老司机在这里解释一下，`int a`这个成员变量就是上面提到的带有的自动变量。因为**block内部引用了外部的自动变量，所以在block结构体中多了一个同类型同名的成员变量**。同样，如果没有引入外部的自动变量的话此处block结构体中也不会有这第三个成员变量。\n\n现在我们将目光集中到main函数中。可以看到，第一行声明了一个局域变量，第二行调用了`block的构造函数`，将block对应的`函数指针`和`Desc`以及`局部变量`传给了block。\n\n然后我们看到第三行调用block结构体中的函数指针指向的函数，并把`block自身`及`参数`传给了函数指针指向的函数。\n\n转过来看block指向的函数，函数中首先`从block自身中取出捕获的自动变量a复制给一个临时变量`，同时`执行原本block中的函数体`。\n\n至此就完成了一次block的调用过程。\n\n这里我们要注意一下捕获的自动变量：\n\n\t\n所谓捕获的自动变量我们可以从两方面来理解。\n\t\n- 1.我们看到在生成block的瞬间就将自动变量的值赋给了block。所以此时外界计时修改局部变量的值并不影响block中的值。\n\t\n\t```\n\tint main(int argc, char * argv[]) {\n    int a = 10;\n    void(^block)(int) = ^(int b) {\n        printf(\"%d + %d = %d\\n\",a,b,a+b);\n    };\n    a = 5;\n    block(5);///执行结果为15\n    return 0;\n}\n\t```\n\t执行结果为15，上面的话正是最好的解释。\n\t\n- 2.block中我们是不能对捕获的变量进行赋值操作的，只要这么做编译器就会警告。为什么苹果会做出这样的限制呢？因为在block里对捕获的自动变量复制其实是有歧义的。因为通过看`__main_block_func_0`内部的实现我们知道，block内部使用的都是block捕获到自动变量，当然这个自动变量是我们转换代码之前完全不知道的一个概念。也就是在编码过程中我们在block中使用的变量与实际代码运行过程中block内部操作的变量本就是两个变量，所以在这里修改block捕获的自动变量的值事实上跟开发者预期的结果完全是两个结果。所以苹果干脆在此就给出个警告来避免未知的错误。\n\n- 3.虽说不能对捕获的自动变量进行赋值操作，但这并`不影响我们使用他`，否则的话这个自动变量捕获到也没有什么用了。这点很好理解，没什么好解释的。\n\n说到这里，是时候来一个本节的扣题了，所以说block的实质事实上就是一个结构体，而且是一个可以根据自身捕获的自动变量个数自动添加自身成员变量的结构体。更多情况下，其实你把它考虑成对象更好。\n\n- - -\n### 关于Block对外部的赋值操作\n上文中老司机说到，Block不能对其捕获的局部（非静态）变量的值进行赋值操作。既然有这些限制，那么一定有可以Block中可以做赋值操作的变量，他们都有谁呢？\n\n- 静态变量 \n- 全局变量\n- __block说明符修饰的变量\n\n\n\n还是针对`带有自动变量的匿名函数`这句话来讲。这一节我们来探讨一下Block是如何使用外部变量的。`我们知道Block截获变量的意义在于想要使用Block作用于内无法使用的变量，所以他要截获变量。`接下来老司机围绕着这句话从各种变量类型做深入的展开。\n\n- 1.仅使用参数的Block\n\n```\nint main(int argc, char * argv[]) {\n    void(^block)(int) = ^(int a) {\n        a = 10;\n        printf(\"block : a = %d\\n\",a);\n    };\n    int a = 5;\n    block(a);\n    printf(\"a = %d\",a);\n    return 0;\n}\n\n///clang转换后的形式\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, int a) {\n    a = 10;\n    printf(\"block : a = %d\\n\",a);\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, char * argv[]) {\n    void(*block)(int) = ((void (*)(int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n    int a = 5;\n    ((void (*)(__block_impl *, int))((__block_impl *)block)->FuncPtr)((__block_impl *)block, a);\n    printf(\"a = %d\",a);\n    return 0;\n}\n```\n由于使用的是函数的参数，是在Block作用域内可以使用的，所以Block没有对变量进行截获。这个Block基本就是最简单的函数。\n\n- 2.使用局部变量（非静态）\n\n```\nint main(int argc, char * argv[]) {\n    int a = 10;\n    void(^block)() = ^() {\n        printf(\"n = %d\",a);\n    };\n    block();\n    return 0;\n}\n\n///clang转换后\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int a;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int a = __cself->a; // bound by copy\n    printf(\"n = %d\",a);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, char * argv[]) {\n    int a = 10;\n    void(*block)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, a));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    return 0;\n}\n```\n我们看到，这里截获了这个局部变量，具体原因在上述内容中有讲到过，此处不再赘述。\n\n- 3.局部静态变量\n\n我们知道，静态变量存储在静态区，只创建一次，随后使用的同名变量均应指向同一地址。由静态变量的特性我们应该知道，如果Block截获了一个静态局域变量，并在Block中对其值进行了更改，这个操作应该是有效的，他应该改变该变量的值。我们看下他是如何实现的？\n\n```\nint main(int argc, char * argv[]) {\n    static int a = 10;\n    void(^block)() = ^() {\n        a = 20;\n    };\n    block();\n    printf(\"a = %d\",a);\n    return 0;\n}\n///clang转换后\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int *a;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int *a = __cself->a; // bound by copy\n    (*a) = 20;\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, char * argv[]) {\n    static int a = 10;\n    void(*block)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, &a));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    printf(\"a = %d\",a);\n    return 0;\n}\n```\n我们看到了，Block截获的是局部静态变量的指针。这个思路跟C语言中函数一样。C语言中我们想更改实参的值时也是通过传址的方式实现的。形如：\n\n```\nvoid mySwap(int * a,int * b);\nint main(int argc, char * argv[]) {\n    int a = 1;\n    int b = 2;\n    mySwap(&a, &b);\n    printf(\"a = %d\",a);\n    return 0;\n}\n\nvoid mySwap(int * a,int * b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n```\n\n4.全局变量（静态与非静态）\n老司机上面说过，Block捕获变量是为了在Block中使用其作用域外的变量，那么全局变量本身作用在区域，Block可以使用，故不需要对全局变量进行捕获。以下以全局静态变量为例。\n\n```\nstatic int a = 10;\nint main(int argc, char * argv[]) {\n    void(^block)() =  ^{\n        a = 20;\n    };\n    block();\n    printf(\"a = %d\",a);\n    return 0;\n}\n\n///clang 转换后\nstatic int a = 10;\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n        a = 20;\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, char * argv[]) {\n    void(*block)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    printf(\"a = %d\",a);\n    return 0;\n}\n```\n- 5.\\_\\_block修饰的变量\n我们知道，被\\_\\_block修饰的局部变量，在Block内部对其进行赋值操作是可以的，那么他是如何实现的呢？\n\n```\nint main(int argc, char * argv[]) {\n    __block int a = 10;\n    void(^block)() =  ^{\n        a = 20;\n    };\n    block();\n    printf(\"%d\",a);\n    return 0;\n}\n///clang 转换后\nstruct __Block_byref_a_0 {\n    void *__isa;\n    __Block_byref_a_0 *__forwarding;\n    int __flags;\n    int __size;\n    int a;\n};\n\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __Block_byref_a_0 *a; // by ref\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a->__forwarding) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    __Block_byref_a_0 *a = __cself->a; // bound by ref\n    (a->__forwarding->a) = 20;\n}\n\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->a, (void*)src->a, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->a, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n    void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n\nint main(int argc, char * argv[]) {\n    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&a, 0, sizeof(__Block_byref_a_0), 10};\n    void(*block)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_a_0 *)&a, 570425344));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    printf(\"%d\",(a.__forwarding->a));\n    return 0;\n}\n```\n\n我们看到\\_\\_block修饰的变量会自动为其生成一个结构体，并在之后对变量的操作使用的都是结构体中持有的变量a。而后Block捕获了结构体，Block中对变量的复制也映射成了对结构体内部变量的赋值。我们可以发现，在上面的例子中，不仅生成了一个\\_\\_block变量的结构体，还多了`__main_block_copy_0`和`__main_block_dispose_0`两个函数，的具体作用我们稍后再表。\n- - - \n### Block类型及其存储域\n\n首先应该了解一下Block的三种类型：\n\n- _NSConcreteStackBlock///栈区Block\n- _NSConcreteMallocBlock///堆区Block\n- _NSConcreteGlobalBlock///全局Block\n\n我们设想这样一种情况，上述的例子中，我们看到我们都是在main函数中声明的Block，也就是说他其实block对象其实是一个局域变量，那么他一定会被存储在栈上。也就是说当出了变量的作用于，也就是main函数结束，block对象就会被销毁。这时我们的Block即为`_NSConcreteStackBlock`。我们可以从`__block_impl`结构体中的`isa指针`看到上述例子中的Block均为`_NSConcreteStackBlock`类型。\n\n但是平时我们使用block的时候还有这么一种情况，即`并不`是在声明的地方`立即使用`，而是在`等待`某个时机从而进行`回调`。而此时一般是已经`出了block对象的作用域`，如果跟之前一样是`栈区block`的话显然block`已经被销毁`，此时进行`回调只会引起crash`。这时我们就需要`_NSConcreteMallocBlock`区的block了，即堆区Block。回想我们持有block的时候使用什么修饰符呢？copy对吧，而`block对象执行copy操作就是将其按需复制到堆区`。\n\n我们看下下面的例子：\n\n```\n#import <Foundation/Foundation.h>\n\nint globalVar = 100;\n\nvoid(^globalBlock)() = ^{\n    NSLog(@\"global block beyond main\");\n};\n\nint main(int argc, char * argv[]) {\n    int a = 10;\n    NSLog(@\"stack block: %@\",^{NSLog(@\"here a = %d\",a);});\n    NSLog(@\"malloc block: %@\",[^{NSLog(@\"here a = %d\",a);} copy]);\n    NSLog(@\"global block: %@\",^{NSLog(@\"I use nothing\");});\n    NSLog(@\"global block beyong main: %@\",globalBlock);\n    NSLog(@\"global block use globalVar: %@\",^{NSLog(@\"%d\",globalVar);});\n    return 0;\n}\n\n///输出：\nstack block: <__NSStackBlock__: 0x7fff5d7cd578>\nmalloc block: <__NSMallocBlock__: 0x60000004ef70>\nglobal block: <__NSGlobalBlock__: 0x1024320d0>\nglobal block beyong main: <__NSGlobalBlock__: 0x102432050>\nglobal block use globalVar: <__NSGlobalBlock__: 0x102432110>\n\n```\n\n此处我们可以看到三种block类型。从源码我们可以知道默认生成的block均为`_NSConcreteStackBlock`类型，而后执行了copy操作的block为`_NSConcreteMallocBlock`类型，后面三个均为`_NSConcreteGlobalBlock`类型。\n\n这里我们先说`_NSConcreteGlobalBlock`类型的Block。在**全局范围内声明的Block即为全局Block**，并且**没有引入自动变量的也为全局Block**。\n\n现在我们知道了，调用过copy方法的block会被复制到堆区，堆区的Block均为`_NSConcreteMallocBlock`类型。那么什么情况下block会执行copy方法呢？\n\n其实我们可以从上述的分析中猜到，当block需要在其作用域外使用的我们应该将其复制到堆区。例如block作为函数返回值的时候，这时候编译器会按需调用copy方法：\n\n```\ntypedef void(^voidBlock)();\nvoidBlock func();\n\nint main(int argc, char * argv[]) {\n    NSLog(@\"the return value of func:%@\",func());\n    return 0;\n}\n\n\nvoidBlock func() {\n    int a = 10;\n    NSLog(@\"the block in func:%@\",^{NSLog(@\"block in func : a = %d\",a);});\n    return ^{\n        NSLog(@\"block in func : a = %d\",a);\n    };\n}\n\n///输出：\nthe block in func:<__NSStackBlock__: 0x7fff56877558>\nthe return value of func:<__NSMallocBlock__: 0x6080000486a0>\n\n```\n此例中我们看到函数体中，**输出了一个Block其为栈区Block**，但是当将同样的**Block作为返回值返回到main函数中的时候，他变成了堆区Block**。\n\n同学们不要说我这`不是一个Block`，我应该生成一个Block将其赋值，Log一下，在返回出去。这个真不是我不赋值，我不能啊，因为在**ARC中赋值的时候如果不附加修饰符的话默认认为生成的变量是以\\_\\_strong修饰符修饰的，而编译器遇到\\_\\_strong修饰符会自动copy**。。。我怎么给你做例子啊。。。反正老司机这么写虽然不是同一个block，但是应该是同一类型block，足以说明问题。另外老司机说过，`编译器会按需调用copy方法`。也就是说栈区block会出作用域销毁，全局block并不会，所以如果**返回值是一个全局block的话，则不会调用copy方法**。\n\n此外以下两种情况也会由系统为我们调用copy方法：\n\n- Cocoa框架的方法且方法名中含有usingBlock等时\n- GCD的API\n\n还有就是显示调用copy方法的时候，另外如果将其赋值给有copy修饰符修饰的属性的话也会调用copy方法。\n\n然而什么时候应该调用copy方法呢？我们先来看下不同类型block调用copy方法会有什么行为。\n\n> |Block类型|副本源的配置存储域|复制效果|\n|:------:|:-------------:|:-----:|\n| _NSConcreteStackBlock|栈|从栈复制到堆|\n| _NSConcreteGlobalBlock|程序的数据区域|什么也不做|\n| _NSConcreteMallocBlock|堆|引用计数增加|\n\n> 不管Block配置在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可。\n> \n> ————引自《iOS与OS X多线程和内存管理》 \n\n但是在我们确定的时候，还是要根据需要调用copy方法，不要盲目调用copy方法，毕竟这个方法是十分占用CPU资源的。\n\n- - - \n### __block说明符\n\n上文中，老司机已经讲述了block对象在调用copy方法时候的行为。然而__block说明符修饰的变量与block对象基本一致。\n\n |__block变量的配置存储域|Block从栈复制到堆时的影响|\n |:---:|:---:|\n |栈|从栈复制到堆并被Block持有|\n |堆|被Block持有|\n\n正如老司机在上文中提到的，被__block说明符的变量会自动生成一个结构体。\n值得一提的是三个地方：\n\n![forwarding.png](http://upload-images.jianshu.io/upload_images/1835430-87eaef84e4e9496a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n老司机之前说过，只有被__block说明符修饰的变量，今后使用的均为其结构体中维护的同名成员变量，不过从源码中我们看到，并不是简单地使用了成员变量，而是`a.__forwarding->a`这样一个引用方式，这是因为什么呢？\n\n首先从`__Block_byref_a_0`中我们可以看到__forwarding是一个`__Block_byref_a_0`类型的结构体指针。\n\n从main函数中第一行__block变量生成的代码我们看出，在本例中生成\\_\\_block变量a的同时将a的\\_\\_forwarding指向了a自身。这样`a.__forwarding->a`最终还是指向了__block变量a结构体中的成员变量a。\n\n既然这样，就一定存在\\_\\_forwarding并不指向block变量自身的情况，故此才需要\\_\\_forwarding存在来保证时刻能取到一个正确的值。而上文中提到的**调用copy方法的时候，就会对__forwarding指针进行操作**。\n![__forwarding](http://upload-images.jianshu.io/upload_images/1835430-ee254afd55904ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n由上图我们可以看到，当调用copy方法后，\\_\\_forwarding指针指向堆中的\\_\\_block变量。而堆中的\\_\\_block变量的\\_\\_forwarding指针则指向自身。\n\n同时我们知道，block其实是对c语言的扩充，然而OC中我们使用的是引用计数来管理对象生命周期，而不是GC。所以事实上Block需要自行管理内存。那么当我们的Block捕获了一个对象时，他又是如何管理其引用计数的呢？\n上文中老司机有提到过`__main_block_copy`和`__main_block_dispose`两个函数。**当Block结构体中捕获到的对象需要retain的时候则调用\\_\\_main\\_block\\_copy方法增加引用计数，当其需要释放的时候则调用\\_\\_main\\_block\\_dispose释放对象**。所以当block从栈上复制到堆的时候会调用copy函数，而对上的block被释放时调用dispose函数。\n\n- - -\n### 关于Block引起的循环引用\n\n一直以来，Block引起的循环引用都让不少初级工程师，甚至包括一些中级工程师(索性就叫他中级吧。。。)谈虎色变。他们不知道Block是如何引起循环引用的，只知道`__weak可以避免循环引用`。知其然不知其所以然，闹出一些笑话也是让人无语。\n\n首先说一下什么是循环引用？\n\n引用计数机制不做展开，我们只需要知道，**在OC中对象是在引用计数为0的时候进行销毁的。一个对对象的强引用会造成一次引用计数的加一。释放一个强引用会造成引用计数的减一。**\n![强引用](http://upload-images.jianshu.io/upload_images/1835430-e052aabc7507eaa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上图我们知道，对象A对对象B有一个强引用。**当对象A销毁的时候，会释放对对象B的强引用。如果此时对象B的引用计数为0则对象B被销毁**。\n\n\n![循环引用](http://upload-images.jianshu.io/upload_images/1835430-d0548d5481c4e95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n但当出现上图的情况，强引用出现了一个`闭环`的时候，就会造成**逐个等待上一个强引用释放信号，然而闭环导致任意一个对象都不会释放对下一个对象的强引用，这就是循环引用**。\n\n明确一点，造成循环引用的必要条件的`闭环`，所以循环引用不仅可以发生在两个对象之间，可以是多个对象，甚至可以是一个对象。\n\n![循环引用](http://upload-images.jianshu.io/upload_images/1835430-820d88f878f0a934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n由此看来Block引起循环引用的原因就很明白了，**Block对内部使用的自动变量造成一个强引用，而如果这个自动变量恰好对Block也有强引用的话就会造成循环引用**。\n\n既然知道了循环引用的起因，那么我们只要打破引用的闭环就可以轻松解决。**两个思路，一个是从最开始就不让强引用成为闭环，使用弱引用。另一个思路是找到一个合适的时机主动释放一个强引用，打破闭环**。\n\n![打破闭环](http://upload-images.jianshu.io/upload_images/1835430-b5663570b518b542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 弱引用\n\n```\n__weak typeof(self)weakSelf = self;\nself.block = ^{\n    NSLog(@\"%@\",weakSelf);\n};\nself.block();\n```\n上述代码中，使用__weak生成一个弱引用变量weakSelf，保持对self的弱引用。然后Block捕获到weakSelf，对weakSelf也是弱引用，然而却没有造成闭环。故避免了循环引用。\n![weakSelf](http://upload-images.jianshu.io/upload_images/1835430-2028bfe9fbf497e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 主动释放\n\n```\n__block id blockSelf = self;\nself.block = ^{\n    NSLog(@\"%@\",blockSelf);\n    blockSelf = nil;\n};\nNSLog(@\"%@\",self.block);\nself.block();\n```\n上述代码中，使用\\_\\_block生成一个block对象blockSelf，保持对self的强引用。然后Block捕获到blockSelf，强引用blockSelf，由于self对block还有一个强引用，此时形成了一个闭环。但当block调用的时候，内部最后将blockSelf对象置为nil。由于blockSelf置为nil，__block对象失去强引用被销毁，同时释放对self的强引用，从而打破闭环。\n![blockSelf](http://upload-images.jianshu.io/upload_images/1835430-1c2640ded7e6ad98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不过两种避免循环引用的方式都有各自的缺点。\n\n\\_\\_weak 的弱引用形式的缺点在于，当block执行的时候，由于对self是弱引用，不能保证self对象是否已经被销毁。事实上block执行前self被销毁还好，顶多是不执行。但是如果在block执行过程中，self被销毁就会造成不可预估的后果。所以当使用\\_\\_weak的时候我们通常会看到如下结构：\n\n```\n__weak typeof(self)weakSelf = self;\nself.block = ^{\n\t__strong typeof(weakSelf)strongSelf = weakSelf;\n    NSLog(@\"%@\",strongSelf);\n};\nself.block();\n```\n这样的结构可以保证在block执行过程中，不会因为self释放引起问题，然而如果block执行前self被释放后block也就没有机会执行了，也算是对代码的保护。更多的关于`Weak-Strong-Dance`的讨论可以看下这篇文章：\n\n> [Weak-Strong-Dance真的安全吗？](http://www.jianshu.com/p/737999a30544)\n \n\\_\\_weak有这样的缺点，为什么不适用\\_\\_block等方式呢？\n\n事实上\\_\\_block同样有着自己的烦恼，就是一定要在block体中对\\_\\_block对象置为nil，且block一定要执行才可以解决循环引用。所以开发者要根据具体情况合理的选择解决循环引用的方式。\n- - - \n至此，老司机今天的内容也就算结束了。\n\n参考资料：\n- 《iOS与OS X多线程和内存管理》\n- [Weak-Strong-Dance真的安全吗？](http://www.jianshu.com/p/737999a30544)\n","source":"_posts/老司机出品——源码解析之从Block说开去.md","raw":"\n---\ntitle: 老司机出品——源码解析之从Block说开去\nlayout: post\ndate: 2017-06-05 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- Block \n- 循环引用\ncategories: 源码解析\n---\n![从Block说开去](http://upload-images.jianshu.io/upload_images/1835430-2b26e7f92ebaaa93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n近来把《iOS与OS X多线程和内存管理》这本书又掏出来看了一遍，这本书前前后后加起来看了能有三四遍了，每次看都有新的理解。现在就把个人对Block的一些理解记录下来。\n\n今天的内容中你会看到：\n\n- Block是什么\n- Block的实质\n- 关于Block对外部的赋值操作\n- Block类型及其存储域\n- \\_\\_block说明符\n- 关于Block引起的循环引用\n\n<!-- more -->\n\n- - -\n### Block是什么？\n> 带有自动变量的匿名函数。 \n> \n> ————引自《iOS与OS X多线程和内存管理》\n\n为什么这么说呢？\n我们分别从匿名函数和带自动变量两个角度来说。\n\n- 1.匿名函数\n\n首先，Blocks是C语言的扩充功能。\n\nC语言中函数是这个样子的：\n\n```\nvoid func() {\n\tprintf(\"hello world\");\n}\n```\n\n如上，是一个C语言函数，而block是什么形式呢？\n\n```\n^void () {\n\tprintf(\"hello world\");\n}\n```\n这种不带函数名的函数就是所谓的匿名函数。\n\n- 2.带自动变量\n\n还是要从C语言函数中说起。\n\n```\nint a = 10;\nvoid func (int b) {\n\tprintf(\"%d + %d = %d\",a,b,a+b);\n}\n\nint main(int argc, char * argv[]) {\n    func(5);\n    return 0;\n}\n```\n上述的代码主要想说明一件事，C语言函数中，函数体中使用的函数外部变量只有两种：函数参数即全局变量。\n\n我们再看看Block是如何使用的。\n\n```\nint main(int argc, char * argv[]) {\n    int a = 10;\n    void(^block)(int) = ^(int b) {\n        printf(\"%d + %d = %d\\n\",a,b,a+b);\n    };\n    block(5);\n    return 0;\n}\n```\n我们看到，在此例中a已经不是全局变量了，而是一个局部变量，也就是自动变量。然而block却可以正常使用，为什么呢？因为block内部维护了一个变量a的值，所以执行正确。这里你先不用纠结，下面会有源码。由上我们就知道了什么叫做带自动变量了。\n\n- - -\n### Block的实质\n想要看Block的实质我们还是Block的实现过程。我们还是要借助clang。\n\n```\n#include <stdio.h>\n\nint main(int argc, char * argv[]) {\n    int a = 10;\n    void(^block)(int) = ^(int b) {\n        printf(\"%d + %d = %d\\n\",a,b,a+b);\n    };\n    block(5);\n    return 0;\n}\n```\n还是这个简单的函数，我们借助clang来转换一下。这里为了稍后方便，我们尽量删除其他无用头文件，引入必要头文件。\n\n```\nclang -rewrite-objc main.m\n```\n\n转换完成后我们会发现main.m同文件夹下多了一个main.cpp的文件。\n打开这个文件我们就会看到转换后的源码，而老司机让同学们换头文件的原因你也应该明白了，引入的头文件中一些相关代码也会在转换的文件中。如果你跟老司机一样只引入了`stdio.h`的话，那么现在`command + L`跳转到第62行，复制62行至67行，`command + 下`调至文件底部粘贴，再跳至510行，`command + shift + 上`选中上面所有代码，`delete`删除后就剩下干货了，大概是这个样子的：\n\n![block实现](http://upload-images.jianshu.io/upload_images/1835430-435ae974bab42f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，我们看到这就是block的相关实现。\n\n首先我们看block结构体中，三个成员变量，一个构造函数。\n\n![block](http://upload-images.jianshu.io/upload_images/1835430-72a8882606a061f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到第一个成员变量是`__block_impl`的结构体，其中有指向block实现函数的函数指针，第二个成员变量是`__main_block_desc_0`，用来负责管理block的内存管理。第三个成员变量`int型`变量a。\n\n老司机在这里解释一下，`int a`这个成员变量就是上面提到的带有的自动变量。因为**block内部引用了外部的自动变量，所以在block结构体中多了一个同类型同名的成员变量**。同样，如果没有引入外部的自动变量的话此处block结构体中也不会有这第三个成员变量。\n\n现在我们将目光集中到main函数中。可以看到，第一行声明了一个局域变量，第二行调用了`block的构造函数`，将block对应的`函数指针`和`Desc`以及`局部变量`传给了block。\n\n然后我们看到第三行调用block结构体中的函数指针指向的函数，并把`block自身`及`参数`传给了函数指针指向的函数。\n\n转过来看block指向的函数，函数中首先`从block自身中取出捕获的自动变量a复制给一个临时变量`，同时`执行原本block中的函数体`。\n\n至此就完成了一次block的调用过程。\n\n这里我们要注意一下捕获的自动变量：\n\n\t\n所谓捕获的自动变量我们可以从两方面来理解。\n\t\n- 1.我们看到在生成block的瞬间就将自动变量的值赋给了block。所以此时外界计时修改局部变量的值并不影响block中的值。\n\t\n\t```\n\tint main(int argc, char * argv[]) {\n    int a = 10;\n    void(^block)(int) = ^(int b) {\n        printf(\"%d + %d = %d\\n\",a,b,a+b);\n    };\n    a = 5;\n    block(5);///执行结果为15\n    return 0;\n}\n\t```\n\t执行结果为15，上面的话正是最好的解释。\n\t\n- 2.block中我们是不能对捕获的变量进行赋值操作的，只要这么做编译器就会警告。为什么苹果会做出这样的限制呢？因为在block里对捕获的自动变量复制其实是有歧义的。因为通过看`__main_block_func_0`内部的实现我们知道，block内部使用的都是block捕获到自动变量，当然这个自动变量是我们转换代码之前完全不知道的一个概念。也就是在编码过程中我们在block中使用的变量与实际代码运行过程中block内部操作的变量本就是两个变量，所以在这里修改block捕获的自动变量的值事实上跟开发者预期的结果完全是两个结果。所以苹果干脆在此就给出个警告来避免未知的错误。\n\n- 3.虽说不能对捕获的自动变量进行赋值操作，但这并`不影响我们使用他`，否则的话这个自动变量捕获到也没有什么用了。这点很好理解，没什么好解释的。\n\n说到这里，是时候来一个本节的扣题了，所以说block的实质事实上就是一个结构体，而且是一个可以根据自身捕获的自动变量个数自动添加自身成员变量的结构体。更多情况下，其实你把它考虑成对象更好。\n\n- - -\n### 关于Block对外部的赋值操作\n上文中老司机说到，Block不能对其捕获的局部（非静态）变量的值进行赋值操作。既然有这些限制，那么一定有可以Block中可以做赋值操作的变量，他们都有谁呢？\n\n- 静态变量 \n- 全局变量\n- __block说明符修饰的变量\n\n\n\n还是针对`带有自动变量的匿名函数`这句话来讲。这一节我们来探讨一下Block是如何使用外部变量的。`我们知道Block截获变量的意义在于想要使用Block作用于内无法使用的变量，所以他要截获变量。`接下来老司机围绕着这句话从各种变量类型做深入的展开。\n\n- 1.仅使用参数的Block\n\n```\nint main(int argc, char * argv[]) {\n    void(^block)(int) = ^(int a) {\n        a = 10;\n        printf(\"block : a = %d\\n\",a);\n    };\n    int a = 5;\n    block(a);\n    printf(\"a = %d\",a);\n    return 0;\n}\n\n///clang转换后的形式\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, int a) {\n    a = 10;\n    printf(\"block : a = %d\\n\",a);\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, char * argv[]) {\n    void(*block)(int) = ((void (*)(int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n    int a = 5;\n    ((void (*)(__block_impl *, int))((__block_impl *)block)->FuncPtr)((__block_impl *)block, a);\n    printf(\"a = %d\",a);\n    return 0;\n}\n```\n由于使用的是函数的参数，是在Block作用域内可以使用的，所以Block没有对变量进行截获。这个Block基本就是最简单的函数。\n\n- 2.使用局部变量（非静态）\n\n```\nint main(int argc, char * argv[]) {\n    int a = 10;\n    void(^block)() = ^() {\n        printf(\"n = %d\",a);\n    };\n    block();\n    return 0;\n}\n\n///clang转换后\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int a;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int a = __cself->a; // bound by copy\n    printf(\"n = %d\",a);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, char * argv[]) {\n    int a = 10;\n    void(*block)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, a));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    return 0;\n}\n```\n我们看到，这里截获了这个局部变量，具体原因在上述内容中有讲到过，此处不再赘述。\n\n- 3.局部静态变量\n\n我们知道，静态变量存储在静态区，只创建一次，随后使用的同名变量均应指向同一地址。由静态变量的特性我们应该知道，如果Block截获了一个静态局域变量，并在Block中对其值进行了更改，这个操作应该是有效的，他应该改变该变量的值。我们看下他是如何实现的？\n\n```\nint main(int argc, char * argv[]) {\n    static int a = 10;\n    void(^block)() = ^() {\n        a = 20;\n    };\n    block();\n    printf(\"a = %d\",a);\n    return 0;\n}\n///clang转换后\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int *a;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int *a = __cself->a; // bound by copy\n    (*a) = 20;\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, char * argv[]) {\n    static int a = 10;\n    void(*block)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, &a));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    printf(\"a = %d\",a);\n    return 0;\n}\n```\n我们看到了，Block截获的是局部静态变量的指针。这个思路跟C语言中函数一样。C语言中我们想更改实参的值时也是通过传址的方式实现的。形如：\n\n```\nvoid mySwap(int * a,int * b);\nint main(int argc, char * argv[]) {\n    int a = 1;\n    int b = 2;\n    mySwap(&a, &b);\n    printf(\"a = %d\",a);\n    return 0;\n}\n\nvoid mySwap(int * a,int * b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n```\n\n4.全局变量（静态与非静态）\n老司机上面说过，Block捕获变量是为了在Block中使用其作用域外的变量，那么全局变量本身作用在区域，Block可以使用，故不需要对全局变量进行捕获。以下以全局静态变量为例。\n\n```\nstatic int a = 10;\nint main(int argc, char * argv[]) {\n    void(^block)() =  ^{\n        a = 20;\n    };\n    block();\n    printf(\"a = %d\",a);\n    return 0;\n}\n\n///clang 转换后\nstatic int a = 10;\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n        a = 20;\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, char * argv[]) {\n    void(*block)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    printf(\"a = %d\",a);\n    return 0;\n}\n```\n- 5.\\_\\_block修饰的变量\n我们知道，被\\_\\_block修饰的局部变量，在Block内部对其进行赋值操作是可以的，那么他是如何实现的呢？\n\n```\nint main(int argc, char * argv[]) {\n    __block int a = 10;\n    void(^block)() =  ^{\n        a = 20;\n    };\n    block();\n    printf(\"%d\",a);\n    return 0;\n}\n///clang 转换后\nstruct __Block_byref_a_0 {\n    void *__isa;\n    __Block_byref_a_0 *__forwarding;\n    int __flags;\n    int __size;\n    int a;\n};\n\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __Block_byref_a_0 *a; // by ref\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a->__forwarding) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    __Block_byref_a_0 *a = __cself->a; // bound by ref\n    (a->__forwarding->a) = 20;\n}\n\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->a, (void*)src->a, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->a, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n    void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n\nint main(int argc, char * argv[]) {\n    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&a, 0, sizeof(__Block_byref_a_0), 10};\n    void(*block)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_a_0 *)&a, 570425344));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    printf(\"%d\",(a.__forwarding->a));\n    return 0;\n}\n```\n\n我们看到\\_\\_block修饰的变量会自动为其生成一个结构体，并在之后对变量的操作使用的都是结构体中持有的变量a。而后Block捕获了结构体，Block中对变量的复制也映射成了对结构体内部变量的赋值。我们可以发现，在上面的例子中，不仅生成了一个\\_\\_block变量的结构体，还多了`__main_block_copy_0`和`__main_block_dispose_0`两个函数，的具体作用我们稍后再表。\n- - - \n### Block类型及其存储域\n\n首先应该了解一下Block的三种类型：\n\n- _NSConcreteStackBlock///栈区Block\n- _NSConcreteMallocBlock///堆区Block\n- _NSConcreteGlobalBlock///全局Block\n\n我们设想这样一种情况，上述的例子中，我们看到我们都是在main函数中声明的Block，也就是说他其实block对象其实是一个局域变量，那么他一定会被存储在栈上。也就是说当出了变量的作用于，也就是main函数结束，block对象就会被销毁。这时我们的Block即为`_NSConcreteStackBlock`。我们可以从`__block_impl`结构体中的`isa指针`看到上述例子中的Block均为`_NSConcreteStackBlock`类型。\n\n但是平时我们使用block的时候还有这么一种情况，即`并不`是在声明的地方`立即使用`，而是在`等待`某个时机从而进行`回调`。而此时一般是已经`出了block对象的作用域`，如果跟之前一样是`栈区block`的话显然block`已经被销毁`，此时进行`回调只会引起crash`。这时我们就需要`_NSConcreteMallocBlock`区的block了，即堆区Block。回想我们持有block的时候使用什么修饰符呢？copy对吧，而`block对象执行copy操作就是将其按需复制到堆区`。\n\n我们看下下面的例子：\n\n```\n#import <Foundation/Foundation.h>\n\nint globalVar = 100;\n\nvoid(^globalBlock)() = ^{\n    NSLog(@\"global block beyond main\");\n};\n\nint main(int argc, char * argv[]) {\n    int a = 10;\n    NSLog(@\"stack block: %@\",^{NSLog(@\"here a = %d\",a);});\n    NSLog(@\"malloc block: %@\",[^{NSLog(@\"here a = %d\",a);} copy]);\n    NSLog(@\"global block: %@\",^{NSLog(@\"I use nothing\");});\n    NSLog(@\"global block beyong main: %@\",globalBlock);\n    NSLog(@\"global block use globalVar: %@\",^{NSLog(@\"%d\",globalVar);});\n    return 0;\n}\n\n///输出：\nstack block: <__NSStackBlock__: 0x7fff5d7cd578>\nmalloc block: <__NSMallocBlock__: 0x60000004ef70>\nglobal block: <__NSGlobalBlock__: 0x1024320d0>\nglobal block beyong main: <__NSGlobalBlock__: 0x102432050>\nglobal block use globalVar: <__NSGlobalBlock__: 0x102432110>\n\n```\n\n此处我们可以看到三种block类型。从源码我们可以知道默认生成的block均为`_NSConcreteStackBlock`类型，而后执行了copy操作的block为`_NSConcreteMallocBlock`类型，后面三个均为`_NSConcreteGlobalBlock`类型。\n\n这里我们先说`_NSConcreteGlobalBlock`类型的Block。在**全局范围内声明的Block即为全局Block**，并且**没有引入自动变量的也为全局Block**。\n\n现在我们知道了，调用过copy方法的block会被复制到堆区，堆区的Block均为`_NSConcreteMallocBlock`类型。那么什么情况下block会执行copy方法呢？\n\n其实我们可以从上述的分析中猜到，当block需要在其作用域外使用的我们应该将其复制到堆区。例如block作为函数返回值的时候，这时候编译器会按需调用copy方法：\n\n```\ntypedef void(^voidBlock)();\nvoidBlock func();\n\nint main(int argc, char * argv[]) {\n    NSLog(@\"the return value of func:%@\",func());\n    return 0;\n}\n\n\nvoidBlock func() {\n    int a = 10;\n    NSLog(@\"the block in func:%@\",^{NSLog(@\"block in func : a = %d\",a);});\n    return ^{\n        NSLog(@\"block in func : a = %d\",a);\n    };\n}\n\n///输出：\nthe block in func:<__NSStackBlock__: 0x7fff56877558>\nthe return value of func:<__NSMallocBlock__: 0x6080000486a0>\n\n```\n此例中我们看到函数体中，**输出了一个Block其为栈区Block**，但是当将同样的**Block作为返回值返回到main函数中的时候，他变成了堆区Block**。\n\n同学们不要说我这`不是一个Block`，我应该生成一个Block将其赋值，Log一下，在返回出去。这个真不是我不赋值，我不能啊，因为在**ARC中赋值的时候如果不附加修饰符的话默认认为生成的变量是以\\_\\_strong修饰符修饰的，而编译器遇到\\_\\_strong修饰符会自动copy**。。。我怎么给你做例子啊。。。反正老司机这么写虽然不是同一个block，但是应该是同一类型block，足以说明问题。另外老司机说过，`编译器会按需调用copy方法`。也就是说栈区block会出作用域销毁，全局block并不会，所以如果**返回值是一个全局block的话，则不会调用copy方法**。\n\n此外以下两种情况也会由系统为我们调用copy方法：\n\n- Cocoa框架的方法且方法名中含有usingBlock等时\n- GCD的API\n\n还有就是显示调用copy方法的时候，另外如果将其赋值给有copy修饰符修饰的属性的话也会调用copy方法。\n\n然而什么时候应该调用copy方法呢？我们先来看下不同类型block调用copy方法会有什么行为。\n\n> |Block类型|副本源的配置存储域|复制效果|\n|:------:|:-------------:|:-----:|\n| _NSConcreteStackBlock|栈|从栈复制到堆|\n| _NSConcreteGlobalBlock|程序的数据区域|什么也不做|\n| _NSConcreteMallocBlock|堆|引用计数增加|\n\n> 不管Block配置在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可。\n> \n> ————引自《iOS与OS X多线程和内存管理》 \n\n但是在我们确定的时候，还是要根据需要调用copy方法，不要盲目调用copy方法，毕竟这个方法是十分占用CPU资源的。\n\n- - - \n### __block说明符\n\n上文中，老司机已经讲述了block对象在调用copy方法时候的行为。然而__block说明符修饰的变量与block对象基本一致。\n\n |__block变量的配置存储域|Block从栈复制到堆时的影响|\n |:---:|:---:|\n |栈|从栈复制到堆并被Block持有|\n |堆|被Block持有|\n\n正如老司机在上文中提到的，被__block说明符的变量会自动生成一个结构体。\n值得一提的是三个地方：\n\n![forwarding.png](http://upload-images.jianshu.io/upload_images/1835430-87eaef84e4e9496a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n老司机之前说过，只有被__block说明符修饰的变量，今后使用的均为其结构体中维护的同名成员变量，不过从源码中我们看到，并不是简单地使用了成员变量，而是`a.__forwarding->a`这样一个引用方式，这是因为什么呢？\n\n首先从`__Block_byref_a_0`中我们可以看到__forwarding是一个`__Block_byref_a_0`类型的结构体指针。\n\n从main函数中第一行__block变量生成的代码我们看出，在本例中生成\\_\\_block变量a的同时将a的\\_\\_forwarding指向了a自身。这样`a.__forwarding->a`最终还是指向了__block变量a结构体中的成员变量a。\n\n既然这样，就一定存在\\_\\_forwarding并不指向block变量自身的情况，故此才需要\\_\\_forwarding存在来保证时刻能取到一个正确的值。而上文中提到的**调用copy方法的时候，就会对__forwarding指针进行操作**。\n![__forwarding](http://upload-images.jianshu.io/upload_images/1835430-ee254afd55904ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n由上图我们可以看到，当调用copy方法后，\\_\\_forwarding指针指向堆中的\\_\\_block变量。而堆中的\\_\\_block变量的\\_\\_forwarding指针则指向自身。\n\n同时我们知道，block其实是对c语言的扩充，然而OC中我们使用的是引用计数来管理对象生命周期，而不是GC。所以事实上Block需要自行管理内存。那么当我们的Block捕获了一个对象时，他又是如何管理其引用计数的呢？\n上文中老司机有提到过`__main_block_copy`和`__main_block_dispose`两个函数。**当Block结构体中捕获到的对象需要retain的时候则调用\\_\\_main\\_block\\_copy方法增加引用计数，当其需要释放的时候则调用\\_\\_main\\_block\\_dispose释放对象**。所以当block从栈上复制到堆的时候会调用copy函数，而对上的block被释放时调用dispose函数。\n\n- - -\n### 关于Block引起的循环引用\n\n一直以来，Block引起的循环引用都让不少初级工程师，甚至包括一些中级工程师(索性就叫他中级吧。。。)谈虎色变。他们不知道Block是如何引起循环引用的，只知道`__weak可以避免循环引用`。知其然不知其所以然，闹出一些笑话也是让人无语。\n\n首先说一下什么是循环引用？\n\n引用计数机制不做展开，我们只需要知道，**在OC中对象是在引用计数为0的时候进行销毁的。一个对对象的强引用会造成一次引用计数的加一。释放一个强引用会造成引用计数的减一。**\n![强引用](http://upload-images.jianshu.io/upload_images/1835430-e052aabc7507eaa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上图我们知道，对象A对对象B有一个强引用。**当对象A销毁的时候，会释放对对象B的强引用。如果此时对象B的引用计数为0则对象B被销毁**。\n\n\n![循环引用](http://upload-images.jianshu.io/upload_images/1835430-d0548d5481c4e95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n但当出现上图的情况，强引用出现了一个`闭环`的时候，就会造成**逐个等待上一个强引用释放信号，然而闭环导致任意一个对象都不会释放对下一个对象的强引用，这就是循环引用**。\n\n明确一点，造成循环引用的必要条件的`闭环`，所以循环引用不仅可以发生在两个对象之间，可以是多个对象，甚至可以是一个对象。\n\n![循环引用](http://upload-images.jianshu.io/upload_images/1835430-820d88f878f0a934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n由此看来Block引起循环引用的原因就很明白了，**Block对内部使用的自动变量造成一个强引用，而如果这个自动变量恰好对Block也有强引用的话就会造成循环引用**。\n\n既然知道了循环引用的起因，那么我们只要打破引用的闭环就可以轻松解决。**两个思路，一个是从最开始就不让强引用成为闭环，使用弱引用。另一个思路是找到一个合适的时机主动释放一个强引用，打破闭环**。\n\n![打破闭环](http://upload-images.jianshu.io/upload_images/1835430-b5663570b518b542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 弱引用\n\n```\n__weak typeof(self)weakSelf = self;\nself.block = ^{\n    NSLog(@\"%@\",weakSelf);\n};\nself.block();\n```\n上述代码中，使用__weak生成一个弱引用变量weakSelf，保持对self的弱引用。然后Block捕获到weakSelf，对weakSelf也是弱引用，然而却没有造成闭环。故避免了循环引用。\n![weakSelf](http://upload-images.jianshu.io/upload_images/1835430-2028bfe9fbf497e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 主动释放\n\n```\n__block id blockSelf = self;\nself.block = ^{\n    NSLog(@\"%@\",blockSelf);\n    blockSelf = nil;\n};\nNSLog(@\"%@\",self.block);\nself.block();\n```\n上述代码中，使用\\_\\_block生成一个block对象blockSelf，保持对self的强引用。然后Block捕获到blockSelf，强引用blockSelf，由于self对block还有一个强引用，此时形成了一个闭环。但当block调用的时候，内部最后将blockSelf对象置为nil。由于blockSelf置为nil，__block对象失去强引用被销毁，同时释放对self的强引用，从而打破闭环。\n![blockSelf](http://upload-images.jianshu.io/upload_images/1835430-1c2640ded7e6ad98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不过两种避免循环引用的方式都有各自的缺点。\n\n\\_\\_weak 的弱引用形式的缺点在于，当block执行的时候，由于对self是弱引用，不能保证self对象是否已经被销毁。事实上block执行前self被销毁还好，顶多是不执行。但是如果在block执行过程中，self被销毁就会造成不可预估的后果。所以当使用\\_\\_weak的时候我们通常会看到如下结构：\n\n```\n__weak typeof(self)weakSelf = self;\nself.block = ^{\n\t__strong typeof(weakSelf)strongSelf = weakSelf;\n    NSLog(@\"%@\",strongSelf);\n};\nself.block();\n```\n这样的结构可以保证在block执行过程中，不会因为self释放引起问题，然而如果block执行前self被释放后block也就没有机会执行了，也算是对代码的保护。更多的关于`Weak-Strong-Dance`的讨论可以看下这篇文章：\n\n> [Weak-Strong-Dance真的安全吗？](http://www.jianshu.com/p/737999a30544)\n \n\\_\\_weak有这样的缺点，为什么不适用\\_\\_block等方式呢？\n\n事实上\\_\\_block同样有着自己的烦恼，就是一定要在block体中对\\_\\_block对象置为nil，且block一定要执行才可以解决循环引用。所以开发者要根据具体情况合理的选择解决循环引用的方式。\n- - - \n至此，老司机今天的内容也就算结束了。\n\n参考资料：\n- 《iOS与OS X多线程和内存管理》\n- [Weak-Strong-Dance真的安全吗？](http://www.jianshu.com/p/737999a30544)\n","slug":"老司机出品——源码解析之从Block说开去","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htpo000rjigbnmolqqda","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-2b26e7f92ebaaa93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"从Block说开去\"></p>\n<p>近来把《iOS与OS X多线程和内存管理》这本书又掏出来看了一遍，这本书前前后后加起来看了能有三四遍了，每次看都有新的理解。现在就把个人对Block的一些理解记录下来。</p>\n<p>今天的内容中你会看到：</p>\n<ul>\n<li>Block是什么</li>\n<li>Block的实质</li>\n<li>关于Block对外部的赋值操作</li>\n<li>Block类型及其存储域</li>\n<li>__block说明符</li>\n<li>关于Block引起的循环引用</li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"Block是什么？\"><a href=\"#Block是什么？\" class=\"headerlink\" title=\"Block是什么？\"></a>Block是什么？</h3><blockquote>\n<p>带有自动变量的匿名函数。 </p>\n<p>————引自《iOS与OS X多线程和内存管理》</p>\n</blockquote>\n<p>为什么这么说呢？<br>我们分别从匿名函数和带自动变量两个角度来说。</p>\n<ul>\n<li>1.匿名函数</li>\n</ul>\n<p>首先，Blocks是C语言的扩充功能。</p>\n<p>C语言中函数是这个样子的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">void func() &#123;</div><div class=\"line\">\tprintf(&quot;hello world&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上，是一个C语言函数，而block是什么形式呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">^void () &#123;</div><div class=\"line\">\tprintf(&quot;hello world&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种不带函数名的函数就是所谓的匿名函数。</p>\n<ul>\n<li>2.带自动变量</li>\n</ul>\n<p>还是要从C语言函数中说起。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">int a = 10;</div><div class=\"line\">void func (int b) &#123;</div><div class=\"line\">\tprintf(&quot;%d + %d = %d&quot;,a,b,a+b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    func(5);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述的代码主要想说明一件事，C语言函数中，函数体中使用的函数外部变量只有两种：函数参数即全局变量。</p>\n<p>我们再看看Block是如何使用的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(^block)(int) = ^(int b) &#123;</div><div class=\"line\">        printf(&quot;%d + %d = %d\\n&quot;,a,b,a+b);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block(5);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到，在此例中a已经不是全局变量了，而是一个局部变量，也就是自动变量。然而block却可以正常使用，为什么呢？因为block内部维护了一个变量a的值，所以执行正确。这里你先不用纠结，下面会有源码。由上我们就知道了什么叫做带自动变量了。</p>\n<hr>\n<h3 id=\"Block的实质\"><a href=\"#Block的实质\" class=\"headerlink\" title=\"Block的实质\"></a>Block的实质</h3><p>想要看Block的实质我们还是Block的实现过程。我们还是要借助clang。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(^block)(int) = ^(int b) &#123;</div><div class=\"line\">        printf(&quot;%d + %d = %d\\n&quot;,a,b,a+b);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block(5);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还是这个简单的函数，我们借助clang来转换一下。这里为了稍后方便，我们尽量删除其他无用头文件，引入必要头文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -rewrite-objc main.m</div></pre></td></tr></table></figure>\n<p>转换完成后我们会发现main.m同文件夹下多了一个main.cpp的文件。<br>打开这个文件我们就会看到转换后的源码，而老司机让同学们换头文件的原因你也应该明白了，引入的头文件中一些相关代码也会在转换的文件中。如果你跟老司机一样只引入了<code>stdio.h</code>的话，那么现在<code>command + L</code>跳转到第62行，复制62行至67行，<code>command + 下</code>调至文件底部粘贴，再跳至510行，<code>command + shift + 上</code>选中上面所有代码，<code>delete</code>删除后就剩下干货了，大概是这个样子的：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-435ae974bab42f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"block实现\"></p>\n<p>恩，我们看到这就是block的相关实现。</p>\n<p>首先我们看block结构体中，三个成员变量，一个构造函数。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-72a8882606a061f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"block\"></p>\n<p>可以看到第一个成员变量是<code>__block_impl</code>的结构体，其中有指向block实现函数的函数指针，第二个成员变量是<code>__main_block_desc_0</code>，用来负责管理block的内存管理。第三个成员变量<code>int型</code>变量a。</p>\n<p>老司机在这里解释一下，<code>int a</code>这个成员变量就是上面提到的带有的自动变量。因为<strong>block内部引用了外部的自动变量，所以在block结构体中多了一个同类型同名的成员变量</strong>。同样，如果没有引入外部的自动变量的话此处block结构体中也不会有这第三个成员变量。</p>\n<p>现在我们将目光集中到main函数中。可以看到，第一行声明了一个局域变量，第二行调用了<code>block的构造函数</code>，将block对应的<code>函数指针</code>和<code>Desc</code>以及<code>局部变量</code>传给了block。</p>\n<p>然后我们看到第三行调用block结构体中的函数指针指向的函数，并把<code>block自身</code>及<code>参数</code>传给了函数指针指向的函数。</p>\n<p>转过来看block指向的函数，函数中首先<code>从block自身中取出捕获的自动变量a复制给一个临时变量</code>，同时<code>执行原本block中的函数体</code>。</p>\n<p>至此就完成了一次block的调用过程。</p>\n<p>这里我们要注意一下捕获的自动变量：</p>\n<p>所谓捕获的自动变量我们可以从两方面来理解。</p>\n<ul>\n<li><p>1.我们看到在生成block的瞬间就将自动变量的值赋给了block。所以此时外界计时修改局部变量的值并不影响block中的值。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tint main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(^block)(int) = ^(int b) &#123;</div><div class=\"line\">        printf(&quot;%d + %d = %d\\n&quot;,a,b,a+b);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    a = 5;</div><div class=\"line\">    block(5);///执行结果为15</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  执行结果为15，上面的话正是最好的解释。</p>\n</li>\n<li><p>2.block中我们是不能对捕获的变量进行赋值操作的，只要这么做编译器就会警告。为什么苹果会做出这样的限制呢？因为在block里对捕获的自动变量复制其实是有歧义的。因为通过看<code>__main_block_func_0</code>内部的实现我们知道，block内部使用的都是block捕获到自动变量，当然这个自动变量是我们转换代码之前完全不知道的一个概念。也就是在编码过程中我们在block中使用的变量与实际代码运行过程中block内部操作的变量本就是两个变量，所以在这里修改block捕获的自动变量的值事实上跟开发者预期的结果完全是两个结果。所以苹果干脆在此就给出个警告来避免未知的错误。</p>\n</li>\n<li><p>3.虽说不能对捕获的自动变量进行赋值操作，但这并<code>不影响我们使用他</code>，否则的话这个自动变量捕获到也没有什么用了。这点很好理解，没什么好解释的。</p>\n</li>\n</ul>\n<p>说到这里，是时候来一个本节的扣题了，所以说block的实质事实上就是一个结构体，而且是一个可以根据自身捕获的自动变量个数自动添加自身成员变量的结构体。更多情况下，其实你把它考虑成对象更好。</p>\n<hr>\n<h3 id=\"关于Block对外部的赋值操作\"><a href=\"#关于Block对外部的赋值操作\" class=\"headerlink\" title=\"关于Block对外部的赋值操作\"></a>关于Block对外部的赋值操作</h3><p>上文中老司机说到，Block不能对其捕获的局部（非静态）变量的值进行赋值操作。既然有这些限制，那么一定有可以Block中可以做赋值操作的变量，他们都有谁呢？</p>\n<ul>\n<li>静态变量 </li>\n<li>全局变量</li>\n<li>__block说明符修饰的变量</li>\n</ul>\n<p>还是针对<code>带有自动变量的匿名函数</code>这句话来讲。这一节我们来探讨一下Block是如何使用外部变量的。<code>我们知道Block截获变量的意义在于想要使用Block作用于内无法使用的变量，所以他要截获变量。</code>接下来老司机围绕着这句话从各种变量类型做深入的展开。</p>\n<ul>\n<li>1.仅使用参数的Block</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    void(^block)(int) = ^(int a) &#123;</div><div class=\"line\">        a = 10;</div><div class=\"line\">        printf(&quot;block : a = %d\\n&quot;,a);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    int a = 5;</div><div class=\"line\">    block(a);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///clang转换后的形式</div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself, int a) &#123;</div><div class=\"line\">    a = 10;</div><div class=\"line\">    printf(&quot;block : a = %d\\n&quot;,a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    void(*block)(int) = ((void (*)(int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class=\"line\">    int a = 5;</div><div class=\"line\">    ((void (*)(__block_impl *, int))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, a);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于使用的是函数的参数，是在Block作用域内可以使用的，所以Block没有对变量进行截获。这个Block基本就是最简单的函数。</p>\n<ul>\n<li>2.使用局部变量（非静态）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(^block)() = ^() &#123;</div><div class=\"line\">        printf(&quot;n = %d&quot;,a);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block();</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///clang转换后</div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    int a;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">    int a = __cself-&gt;a; // bound by copy</div><div class=\"line\">    printf(&quot;n = %d&quot;,a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到，这里截获了这个局部变量，具体原因在上述内容中有讲到过，此处不再赘述。</p>\n<ul>\n<li>3.局部静态变量</li>\n</ul>\n<p>我们知道，静态变量存储在静态区，只创建一次，随后使用的同名变量均应指向同一地址。由静态变量的特性我们应该知道，如果Block截获了一个静态局域变量，并在Block中对其值进行了更改，这个操作应该是有效的，他应该改变该变量的值。我们看下他是如何实现的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    static int a = 10;</div><div class=\"line\">    void(^block)() = ^() &#123;</div><div class=\"line\">        a = 20;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block();</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">///clang转换后</div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    int *a;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">    int *a = __cself-&gt;a; // bound by copy</div><div class=\"line\">    (*a) = 20;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    static int a = 10;</div><div class=\"line\">    void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;a));</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到了，Block截获的是局部静态变量的指针。这个思路跟C语言中函数一样。C语言中我们想更改实参的值时也是通过传址的方式实现的。形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mySwap(int * a,int * b);</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 1;</div><div class=\"line\">    int b = 2;</div><div class=\"line\">    mySwap(&amp;a, &amp;b);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void mySwap(int * a,int * b) &#123;</div><div class=\"line\">    int temp = *a;</div><div class=\"line\">    *a = *b;</div><div class=\"line\">    *b = temp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>4.全局变量（静态与非静态）<br>老司机上面说过，Block捕获变量是为了在Block中使用其作用域外的变量，那么全局变量本身作用在区域，Block可以使用，故不需要对全局变量进行捕获。以下以全局静态变量为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int a = 10;</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    void(^block)() =  ^&#123;</div><div class=\"line\">        a = 20;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block();</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///clang 转换后</div><div class=\"line\">static int a = 10;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">        a = 20;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>5.__block修饰的变量<br>我们知道，被__block修饰的局部变量，在Block内部对其进行赋值操作是可以的，那么他是如何实现的呢？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    __block int a = 10;</div><div class=\"line\">    void(^block)() =  ^&#123;</div><div class=\"line\">        a = 20;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block();</div><div class=\"line\">    printf(&quot;%d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">///clang 转换后</div><div class=\"line\">struct __Block_byref_a_0 &#123;</div><div class=\"line\">    void *__isa;</div><div class=\"line\">    __Block_byref_a_0 *__forwarding;</div><div class=\"line\">    int __flags;</div><div class=\"line\">    int __size;</div><div class=\"line\">    int a;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    __Block_byref_a_0 *a; // by ref</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">    __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref</div><div class=\"line\">    (a-&gt;__forwarding-&gt;a) = 20;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class=\"line\">    void (*dispose)(struct __main_block_impl_0*);</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 10&#125;;</div><div class=\"line\">    void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    printf(&quot;%d&quot;,(a.__forwarding-&gt;a));</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到__block修饰的变量会自动为其生成一个结构体，并在之后对变量的操作使用的都是结构体中持有的变量a。而后Block捕获了结构体，Block中对变量的复制也映射成了对结构体内部变量的赋值。我们可以发现，在上面的例子中，不仅生成了一个__block变量的结构体，还多了<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>两个函数，的具体作用我们稍后再表。</p>\n<hr>\n<h3 id=\"Block类型及其存储域\"><a href=\"#Block类型及其存储域\" class=\"headerlink\" title=\"Block类型及其存储域\"></a>Block类型及其存储域</h3><p>首先应该了解一下Block的三种类型：</p>\n<ul>\n<li>_NSConcreteStackBlock///栈区Block</li>\n<li>_NSConcreteMallocBlock///堆区Block</li>\n<li>_NSConcreteGlobalBlock///全局Block</li>\n</ul>\n<p>我们设想这样一种情况，上述的例子中，我们看到我们都是在main函数中声明的Block，也就是说他其实block对象其实是一个局域变量，那么他一定会被存储在栈上。也就是说当出了变量的作用于，也就是main函数结束，block对象就会被销毁。这时我们的Block即为<code>_NSConcreteStackBlock</code>。我们可以从<code>__block_impl</code>结构体中的<code>isa指针</code>看到上述例子中的Block均为<code>_NSConcreteStackBlock</code>类型。</p>\n<p>但是平时我们使用block的时候还有这么一种情况，即<code>并不</code>是在声明的地方<code>立即使用</code>，而是在<code>等待</code>某个时机从而进行<code>回调</code>。而此时一般是已经<code>出了block对象的作用域</code>，如果跟之前一样是<code>栈区block</code>的话显然block<code>已经被销毁</code>，此时进行<code>回调只会引起crash</code>。这时我们就需要<code>_NSConcreteMallocBlock</code>区的block了，即堆区Block。回想我们持有block的时候使用什么修饰符呢？copy对吧，而<code>block对象执行copy操作就是将其按需复制到堆区</code>。</p>\n<p>我们看下下面的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">int globalVar = 100;</div><div class=\"line\"></div><div class=\"line\">void(^globalBlock)() = ^&#123;</div><div class=\"line\">    NSLog(@&quot;global block beyond main&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    NSLog(@&quot;stack block: %@&quot;,^&#123;NSLog(@&quot;here a = %d&quot;,a);&#125;);</div><div class=\"line\">    NSLog(@&quot;malloc block: %@&quot;,[^&#123;NSLog(@&quot;here a = %d&quot;,a);&#125; copy]);</div><div class=\"line\">    NSLog(@&quot;global block: %@&quot;,^&#123;NSLog(@&quot;I use nothing&quot;);&#125;);</div><div class=\"line\">    NSLog(@&quot;global block beyong main: %@&quot;,globalBlock);</div><div class=\"line\">    NSLog(@&quot;global block use globalVar: %@&quot;,^&#123;NSLog(@&quot;%d&quot;,globalVar);&#125;);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///输出：</div><div class=\"line\">stack block: &lt;__NSStackBlock__: 0x7fff5d7cd578&gt;</div><div class=\"line\">malloc block: &lt;__NSMallocBlock__: 0x60000004ef70&gt;</div><div class=\"line\">global block: &lt;__NSGlobalBlock__: 0x1024320d0&gt;</div><div class=\"line\">global block beyong main: &lt;__NSGlobalBlock__: 0x102432050&gt;</div><div class=\"line\">global block use globalVar: &lt;__NSGlobalBlock__: 0x102432110&gt;</div></pre></td></tr></table></figure>\n<p>此处我们可以看到三种block类型。从源码我们可以知道默认生成的block均为<code>_NSConcreteStackBlock</code>类型，而后执行了copy操作的block为<code>_NSConcreteMallocBlock</code>类型，后面三个均为<code>_NSConcreteGlobalBlock</code>类型。</p>\n<p>这里我们先说<code>_NSConcreteGlobalBlock</code>类型的Block。在<strong>全局范围内声明的Block即为全局Block</strong>，并且<strong>没有引入自动变量的也为全局Block</strong>。</p>\n<p>现在我们知道了，调用过copy方法的block会被复制到堆区，堆区的Block均为<code>_NSConcreteMallocBlock</code>类型。那么什么情况下block会执行copy方法呢？</p>\n<p>其实我们可以从上述的分析中猜到，当block需要在其作用域外使用的我们应该将其复制到堆区。例如block作为函数返回值的时候，这时候编译器会按需调用copy方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef void(^voidBlock)();</div><div class=\"line\">voidBlock func();</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    NSLog(@&quot;the return value of func:%@&quot;,func());</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">voidBlock func() &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    NSLog(@&quot;the block in func:%@&quot;,^&#123;NSLog(@&quot;block in func : a = %d&quot;,a);&#125;);</div><div class=\"line\">    return ^&#123;</div><div class=\"line\">        NSLog(@&quot;block in func : a = %d&quot;,a);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///输出：</div><div class=\"line\">the block in func:&lt;__NSStackBlock__: 0x7fff56877558&gt;</div><div class=\"line\">the return value of func:&lt;__NSMallocBlock__: 0x6080000486a0&gt;</div></pre></td></tr></table></figure>\n<p>此例中我们看到函数体中，<strong>输出了一个Block其为栈区Block</strong>，但是当将同样的<strong>Block作为返回值返回到main函数中的时候，他变成了堆区Block</strong>。</p>\n<p>同学们不要说我这<code>不是一个Block</code>，我应该生成一个Block将其赋值，Log一下，在返回出去。这个真不是我不赋值，我不能啊，因为在<strong>ARC中赋值的时候如果不附加修饰符的话默认认为生成的变量是以__strong修饰符修饰的，而编译器遇到__strong修饰符会自动copy</strong>。。。我怎么给你做例子啊。。。反正老司机这么写虽然不是同一个block，但是应该是同一类型block，足以说明问题。另外老司机说过，<code>编译器会按需调用copy方法</code>。也就是说栈区block会出作用域销毁，全局block并不会，所以如果<strong>返回值是一个全局block的话，则不会调用copy方法</strong>。</p>\n<p>此外以下两种情况也会由系统为我们调用copy方法：</p>\n<ul>\n<li>Cocoa框架的方法且方法名中含有usingBlock等时</li>\n<li>GCD的API</li>\n</ul>\n<p>还有就是显示调用copy方法的时候，另外如果将其赋值给有copy修饰符修饰的属性的话也会调用copy方法。</p>\n<p>然而什么时候应该调用copy方法呢？我们先来看下不同类型block调用copy方法会有什么行为。</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Block类型</th>\n<th style=\"text-align:center\">副本源的配置存储域</th>\n<th style=\"text-align:center\">复制效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">_NSConcreteStackBlock</td>\n<td style=\"text-align:center\">栈</td>\n<td style=\"text-align:center\">从栈复制到堆</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">_NSConcreteGlobalBlock</td>\n<td style=\"text-align:center\">程序的数据区域</td>\n<td style=\"text-align:center\">什么也不做</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">_NSConcreteMallocBlock</td>\n<td style=\"text-align:center\">堆</td>\n<td style=\"text-align:center\">引用计数增加</td>\n</tr>\n</tbody>\n</table>\n<p>不管Block配置在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可。</p>\n<p>————引自《iOS与OS X多线程和内存管理》 </p>\n</blockquote>\n<p>但是在我们确定的时候，还是要根据需要调用copy方法，不要盲目调用copy方法，毕竟这个方法是十分占用CPU资源的。</p>\n<hr>\n<h3 id=\"block说明符\"><a href=\"#block说明符\" class=\"headerlink\" title=\"__block说明符\"></a>__block说明符</h3><p>上文中，老司机已经讲述了block对象在调用copy方法时候的行为。然而__block说明符修饰的变量与block对象基本一致。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">__block变量的配置存储域</th>\n<th style=\"text-align:center\">Block从栈复制到堆时的影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">栈</td>\n<td style=\"text-align:center\">从栈复制到堆并被Block持有</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">堆</td>\n<td style=\"text-align:center\">被Block持有</td>\n</tr>\n</tbody>\n</table>\n<p>正如老司机在上文中提到的，被__block说明符的变量会自动生成一个结构体。<br>值得一提的是三个地方：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-87eaef84e4e9496a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"forwarding.png\"></p>\n<p>老司机之前说过，只有被<strong>block说明符修饰的变量，今后使用的均为其结构体中维护的同名成员变量，不过从源码中我们看到，并不是简单地使用了成员变量，而是`a.</strong>forwarding-&gt;a`这样一个引用方式，这是因为什么呢？</p>\n<p>首先从<code>__Block_byref_a_0</code>中我们可以看到<strong>forwarding是一个`</strong>Block_byref_a_0`类型的结构体指针。</p>\n<p>从main函数中第一行<strong>block变量生成的代码我们看出，在本例中生成__block变量a的同时将a的__forwarding指向了a自身。这样`a.</strong>forwarding-&gt;a`最终还是指向了__block变量a结构体中的成员变量a。</p>\n<p>既然这样，就一定存在__forwarding并不指向block变量自身的情况，故此才需要__forwarding存在来保证时刻能取到一个正确的值。而上文中提到的<strong>调用copy方法的时候，就会对__forwarding指针进行操作</strong>。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ee254afd55904ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"__forwarding\"></p>\n<p>由上图我们可以看到，当调用copy方法后，__forwarding指针指向堆中的__block变量。而堆中的__block变量的__forwarding指针则指向自身。</p>\n<p>同时我们知道，block其实是对c语言的扩充，然而OC中我们使用的是引用计数来管理对象生命周期，而不是GC。所以事实上Block需要自行管理内存。那么当我们的Block捕获了一个对象时，他又是如何管理其引用计数的呢？<br>上文中老司机有提到过<code>__main_block_copy</code>和<code>__main_block_dispose</code>两个函数。<strong>当Block结构体中捕获到的对象需要retain的时候则调用__main_block_copy方法增加引用计数，当其需要释放的时候则调用__main_block_dispose释放对象</strong>。所以当block从栈上复制到堆的时候会调用copy函数，而对上的block被释放时调用dispose函数。</p>\n<hr>\n<h3 id=\"关于Block引起的循环引用\"><a href=\"#关于Block引起的循环引用\" class=\"headerlink\" title=\"关于Block引起的循环引用\"></a>关于Block引起的循环引用</h3><p>一直以来，Block引起的循环引用都让不少初级工程师，甚至包括一些中级工程师(索性就叫他中级吧。。。)谈虎色变。他们不知道Block是如何引起循环引用的，只知道<code>__weak可以避免循环引用</code>。知其然不知其所以然，闹出一些笑话也是让人无语。</p>\n<p>首先说一下什么是循环引用？</p>\n<p>引用计数机制不做展开，我们只需要知道，<strong>在OC中对象是在引用计数为0的时候进行销毁的。一个对对象的强引用会造成一次引用计数的加一。释放一个强引用会造成引用计数的减一。</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e052aabc7507eaa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"强引用\"></p>\n<p>上图我们知道，对象A对对象B有一个强引用。<strong>当对象A销毁的时候，会释放对对象B的强引用。如果此时对象B的引用计数为0则对象B被销毁</strong>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d0548d5481c4e95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"循环引用\"></p>\n<p>但当出现上图的情况，强引用出现了一个<code>闭环</code>的时候，就会造成<strong>逐个等待上一个强引用释放信号，然而闭环导致任意一个对象都不会释放对下一个对象的强引用，这就是循环引用</strong>。</p>\n<p>明确一点，造成循环引用的必要条件的<code>闭环</code>，所以循环引用不仅可以发生在两个对象之间，可以是多个对象，甚至可以是一个对象。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-820d88f878f0a934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"循环引用\"></p>\n<p>由此看来Block引起循环引用的原因就很明白了，<strong>Block对内部使用的自动变量造成一个强引用，而如果这个自动变量恰好对Block也有强引用的话就会造成循环引用</strong>。</p>\n<p>既然知道了循环引用的起因，那么我们只要打破引用的闭环就可以轻松解决。<strong>两个思路，一个是从最开始就不让强引用成为闭环，使用弱引用。另一个思路是找到一个合适的时机主动释放一个强引用，打破闭环</strong>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b5663570b518b542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"打破闭环\"></p>\n<ul>\n<li>弱引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">__weak typeof(self)weakSelf = self;</div><div class=\"line\">self.block = ^&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,weakSelf);</div><div class=\"line\">&#125;;</div><div class=\"line\">self.block();</div></pre></td></tr></table></figure>\n<p>上述代码中，使用__weak生成一个弱引用变量weakSelf，保持对self的弱引用。然后Block捕获到weakSelf，对weakSelf也是弱引用，然而却没有造成闭环。故避免了循环引用。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-2028bfe9fbf497e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"weakSelf\"></p>\n<ul>\n<li>主动释放</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block id blockSelf = self;</div><div class=\"line\">self.block = ^&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,blockSelf);</div><div class=\"line\">    blockSelf = nil;</div><div class=\"line\">&#125;;</div><div class=\"line\">NSLog(@&quot;%@&quot;,self.block);</div><div class=\"line\">self.block();</div></pre></td></tr></table></figure>\n<p>上述代码中，使用__block生成一个block对象blockSelf，保持对self的强引用。然后Block捕获到blockSelf，强引用blockSelf，由于self对block还有一个强引用，此时形成了一个闭环。但当block调用的时候，内部最后将blockSelf对象置为nil。由于blockSelf置为nil，__block对象失去强引用被销毁，同时释放对self的强引用，从而打破闭环。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1c2640ded7e6ad98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"blockSelf\"></p>\n<p>不过两种避免循环引用的方式都有各自的缺点。</p>\n<p>__weak 的弱引用形式的缺点在于，当block执行的时候，由于对self是弱引用，不能保证self对象是否已经被销毁。事实上block执行前self被销毁还好，顶多是不执行。但是如果在block执行过程中，self被销毁就会造成不可预估的后果。所以当使用__weak的时候我们通常会看到如下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">__weak typeof(self)weakSelf = self;</div><div class=\"line\">self.block = ^&#123;</div><div class=\"line\">\t__strong typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,strongSelf);</div><div class=\"line\">&#125;;</div><div class=\"line\">self.block();</div></pre></td></tr></table></figure>\n<p>这样的结构可以保证在block执行过程中，不会因为self释放引起问题，然而如果block执行前self被释放后block也就没有机会执行了，也算是对代码的保护。更多的关于<code>Weak-Strong-Dance</code>的讨论可以看下这篇文章：</p>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/737999a30544\" target=\"_blank\" rel=\"external\">Weak-Strong-Dance真的安全吗？</a></p>\n</blockquote>\n<p>__weak有这样的缺点，为什么不适用__block等方式呢？</p>\n<p>事实上__block同样有着自己的烦恼，就是一定要在block体中对__block对象置为nil，且block一定要执行才可以解决循环引用。所以开发者要根据具体情况合理的选择解决循环引用的方式。</p>\n<hr>\n<p>至此，老司机今天的内容也就算结束了。</p>\n<p>参考资料：</p>\n<ul>\n<li>《iOS与OS X多线程和内存管理》</li>\n<li><a href=\"http://www.jianshu.com/p/737999a30544\" target=\"_blank\" rel=\"external\">Weak-Strong-Dance真的安全吗？</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-2b26e7f92ebaaa93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"从Block说开去\"></p>\n<p>近来把《iOS与OS X多线程和内存管理》这本书又掏出来看了一遍，这本书前前后后加起来看了能有三四遍了，每次看都有新的理解。现在就把个人对Block的一些理解记录下来。</p>\n<p>今天的内容中你会看到：</p>\n<ul>\n<li>Block是什么</li>\n<li>Block的实质</li>\n<li>关于Block对外部的赋值操作</li>\n<li>Block类型及其存储域</li>\n<li>__block说明符</li>\n<li>关于Block引起的循环引用</li>\n</ul>","more":"<hr>\n<h3 id=\"Block是什么？\"><a href=\"#Block是什么？\" class=\"headerlink\" title=\"Block是什么？\"></a>Block是什么？</h3><blockquote>\n<p>带有自动变量的匿名函数。 </p>\n<p>————引自《iOS与OS X多线程和内存管理》</p>\n</blockquote>\n<p>为什么这么说呢？<br>我们分别从匿名函数和带自动变量两个角度来说。</p>\n<ul>\n<li>1.匿名函数</li>\n</ul>\n<p>首先，Blocks是C语言的扩充功能。</p>\n<p>C语言中函数是这个样子的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">void func() &#123;</div><div class=\"line\">\tprintf(&quot;hello world&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上，是一个C语言函数，而block是什么形式呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">^void () &#123;</div><div class=\"line\">\tprintf(&quot;hello world&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种不带函数名的函数就是所谓的匿名函数。</p>\n<ul>\n<li>2.带自动变量</li>\n</ul>\n<p>还是要从C语言函数中说起。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">int a = 10;</div><div class=\"line\">void func (int b) &#123;</div><div class=\"line\">\tprintf(&quot;%d + %d = %d&quot;,a,b,a+b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    func(5);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述的代码主要想说明一件事，C语言函数中，函数体中使用的函数外部变量只有两种：函数参数即全局变量。</p>\n<p>我们再看看Block是如何使用的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(^block)(int) = ^(int b) &#123;</div><div class=\"line\">        printf(&quot;%d + %d = %d\\n&quot;,a,b,a+b);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block(5);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到，在此例中a已经不是全局变量了，而是一个局部变量，也就是自动变量。然而block却可以正常使用，为什么呢？因为block内部维护了一个变量a的值，所以执行正确。这里你先不用纠结，下面会有源码。由上我们就知道了什么叫做带自动变量了。</p>\n<hr>\n<h3 id=\"Block的实质\"><a href=\"#Block的实质\" class=\"headerlink\" title=\"Block的实质\"></a>Block的实质</h3><p>想要看Block的实质我们还是Block的实现过程。我们还是要借助clang。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(^block)(int) = ^(int b) &#123;</div><div class=\"line\">        printf(&quot;%d + %d = %d\\n&quot;,a,b,a+b);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block(5);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还是这个简单的函数，我们借助clang来转换一下。这里为了稍后方便，我们尽量删除其他无用头文件，引入必要头文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -rewrite-objc main.m</div></pre></td></tr></table></figure>\n<p>转换完成后我们会发现main.m同文件夹下多了一个main.cpp的文件。<br>打开这个文件我们就会看到转换后的源码，而老司机让同学们换头文件的原因你也应该明白了，引入的头文件中一些相关代码也会在转换的文件中。如果你跟老司机一样只引入了<code>stdio.h</code>的话，那么现在<code>command + L</code>跳转到第62行，复制62行至67行，<code>command + 下</code>调至文件底部粘贴，再跳至510行，<code>command + shift + 上</code>选中上面所有代码，<code>delete</code>删除后就剩下干货了，大概是这个样子的：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-435ae974bab42f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"block实现\"></p>\n<p>恩，我们看到这就是block的相关实现。</p>\n<p>首先我们看block结构体中，三个成员变量，一个构造函数。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-72a8882606a061f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"block\"></p>\n<p>可以看到第一个成员变量是<code>__block_impl</code>的结构体，其中有指向block实现函数的函数指针，第二个成员变量是<code>__main_block_desc_0</code>，用来负责管理block的内存管理。第三个成员变量<code>int型</code>变量a。</p>\n<p>老司机在这里解释一下，<code>int a</code>这个成员变量就是上面提到的带有的自动变量。因为<strong>block内部引用了外部的自动变量，所以在block结构体中多了一个同类型同名的成员变量</strong>。同样，如果没有引入外部的自动变量的话此处block结构体中也不会有这第三个成员变量。</p>\n<p>现在我们将目光集中到main函数中。可以看到，第一行声明了一个局域变量，第二行调用了<code>block的构造函数</code>，将block对应的<code>函数指针</code>和<code>Desc</code>以及<code>局部变量</code>传给了block。</p>\n<p>然后我们看到第三行调用block结构体中的函数指针指向的函数，并把<code>block自身</code>及<code>参数</code>传给了函数指针指向的函数。</p>\n<p>转过来看block指向的函数，函数中首先<code>从block自身中取出捕获的自动变量a复制给一个临时变量</code>，同时<code>执行原本block中的函数体</code>。</p>\n<p>至此就完成了一次block的调用过程。</p>\n<p>这里我们要注意一下捕获的自动变量：</p>\n<p>所谓捕获的自动变量我们可以从两方面来理解。</p>\n<ul>\n<li><p>1.我们看到在生成block的瞬间就将自动变量的值赋给了block。所以此时外界计时修改局部变量的值并不影响block中的值。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tint main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(^block)(int) = ^(int b) &#123;</div><div class=\"line\">        printf(&quot;%d + %d = %d\\n&quot;,a,b,a+b);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    a = 5;</div><div class=\"line\">    block(5);///执行结果为15</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  执行结果为15，上面的话正是最好的解释。</p>\n</li>\n<li><p>2.block中我们是不能对捕获的变量进行赋值操作的，只要这么做编译器就会警告。为什么苹果会做出这样的限制呢？因为在block里对捕获的自动变量复制其实是有歧义的。因为通过看<code>__main_block_func_0</code>内部的实现我们知道，block内部使用的都是block捕获到自动变量，当然这个自动变量是我们转换代码之前完全不知道的一个概念。也就是在编码过程中我们在block中使用的变量与实际代码运行过程中block内部操作的变量本就是两个变量，所以在这里修改block捕获的自动变量的值事实上跟开发者预期的结果完全是两个结果。所以苹果干脆在此就给出个警告来避免未知的错误。</p>\n</li>\n<li><p>3.虽说不能对捕获的自动变量进行赋值操作，但这并<code>不影响我们使用他</code>，否则的话这个自动变量捕获到也没有什么用了。这点很好理解，没什么好解释的。</p>\n</li>\n</ul>\n<p>说到这里，是时候来一个本节的扣题了，所以说block的实质事实上就是一个结构体，而且是一个可以根据自身捕获的自动变量个数自动添加自身成员变量的结构体。更多情况下，其实你把它考虑成对象更好。</p>\n<hr>\n<h3 id=\"关于Block对外部的赋值操作\"><a href=\"#关于Block对外部的赋值操作\" class=\"headerlink\" title=\"关于Block对外部的赋值操作\"></a>关于Block对外部的赋值操作</h3><p>上文中老司机说到，Block不能对其捕获的局部（非静态）变量的值进行赋值操作。既然有这些限制，那么一定有可以Block中可以做赋值操作的变量，他们都有谁呢？</p>\n<ul>\n<li>静态变量 </li>\n<li>全局变量</li>\n<li>__block说明符修饰的变量</li>\n</ul>\n<p>还是针对<code>带有自动变量的匿名函数</code>这句话来讲。这一节我们来探讨一下Block是如何使用外部变量的。<code>我们知道Block截获变量的意义在于想要使用Block作用于内无法使用的变量，所以他要截获变量。</code>接下来老司机围绕着这句话从各种变量类型做深入的展开。</p>\n<ul>\n<li>1.仅使用参数的Block</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    void(^block)(int) = ^(int a) &#123;</div><div class=\"line\">        a = 10;</div><div class=\"line\">        printf(&quot;block : a = %d\\n&quot;,a);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    int a = 5;</div><div class=\"line\">    block(a);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///clang转换后的形式</div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself, int a) &#123;</div><div class=\"line\">    a = 10;</div><div class=\"line\">    printf(&quot;block : a = %d\\n&quot;,a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    void(*block)(int) = ((void (*)(int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class=\"line\">    int a = 5;</div><div class=\"line\">    ((void (*)(__block_impl *, int))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, a);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于使用的是函数的参数，是在Block作用域内可以使用的，所以Block没有对变量进行截获。这个Block基本就是最简单的函数。</p>\n<ul>\n<li>2.使用局部变量（非静态）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(^block)() = ^() &#123;</div><div class=\"line\">        printf(&quot;n = %d&quot;,a);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block();</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///clang转换后</div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    int a;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">    int a = __cself-&gt;a; // bound by copy</div><div class=\"line\">    printf(&quot;n = %d&quot;,a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到，这里截获了这个局部变量，具体原因在上述内容中有讲到过，此处不再赘述。</p>\n<ul>\n<li>3.局部静态变量</li>\n</ul>\n<p>我们知道，静态变量存储在静态区，只创建一次，随后使用的同名变量均应指向同一地址。由静态变量的特性我们应该知道，如果Block截获了一个静态局域变量，并在Block中对其值进行了更改，这个操作应该是有效的，他应该改变该变量的值。我们看下他是如何实现的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    static int a = 10;</div><div class=\"line\">    void(^block)() = ^() &#123;</div><div class=\"line\">        a = 20;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block();</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">///clang转换后</div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    int *a;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">    int *a = __cself-&gt;a; // bound by copy</div><div class=\"line\">    (*a) = 20;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    static int a = 10;</div><div class=\"line\">    void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;a));</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到了，Block截获的是局部静态变量的指针。这个思路跟C语言中函数一样。C语言中我们想更改实参的值时也是通过传址的方式实现的。形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mySwap(int * a,int * b);</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 1;</div><div class=\"line\">    int b = 2;</div><div class=\"line\">    mySwap(&amp;a, &amp;b);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void mySwap(int * a,int * b) &#123;</div><div class=\"line\">    int temp = *a;</div><div class=\"line\">    *a = *b;</div><div class=\"line\">    *b = temp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>4.全局变量（静态与非静态）<br>老司机上面说过，Block捕获变量是为了在Block中使用其作用域外的变量，那么全局变量本身作用在区域，Block可以使用，故不需要对全局变量进行捕获。以下以全局静态变量为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int a = 10;</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    void(^block)() =  ^&#123;</div><div class=\"line\">        a = 20;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block();</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///clang 转换后</div><div class=\"line\">static int a = 10;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">        a = 20;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    printf(&quot;a = %d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>5.__block修饰的变量<br>我们知道，被__block修饰的局部变量，在Block内部对其进行赋值操作是可以的，那么他是如何实现的呢？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    __block int a = 10;</div><div class=\"line\">    void(^block)() =  ^&#123;</div><div class=\"line\">        a = 20;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    block();</div><div class=\"line\">    printf(&quot;%d&quot;,a);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">///clang 转换后</div><div class=\"line\">struct __Block_byref_a_0 &#123;</div><div class=\"line\">    void *__isa;</div><div class=\"line\">    __Block_byref_a_0 *__forwarding;</div><div class=\"line\">    int __flags;</div><div class=\"line\">    int __size;</div><div class=\"line\">    int a;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    __Block_byref_a_0 *a; // by ref</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">    __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref</div><div class=\"line\">    (a-&gt;__forwarding-&gt;a) = 20;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class=\"line\">    void (*dispose)(struct __main_block_impl_0*);</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 10&#125;;</div><div class=\"line\">    void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    printf(&quot;%d&quot;,(a.__forwarding-&gt;a));</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到__block修饰的变量会自动为其生成一个结构体，并在之后对变量的操作使用的都是结构体中持有的变量a。而后Block捕获了结构体，Block中对变量的复制也映射成了对结构体内部变量的赋值。我们可以发现，在上面的例子中，不仅生成了一个__block变量的结构体，还多了<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>两个函数，的具体作用我们稍后再表。</p>\n<hr>\n<h3 id=\"Block类型及其存储域\"><a href=\"#Block类型及其存储域\" class=\"headerlink\" title=\"Block类型及其存储域\"></a>Block类型及其存储域</h3><p>首先应该了解一下Block的三种类型：</p>\n<ul>\n<li>_NSConcreteStackBlock///栈区Block</li>\n<li>_NSConcreteMallocBlock///堆区Block</li>\n<li>_NSConcreteGlobalBlock///全局Block</li>\n</ul>\n<p>我们设想这样一种情况，上述的例子中，我们看到我们都是在main函数中声明的Block，也就是说他其实block对象其实是一个局域变量，那么他一定会被存储在栈上。也就是说当出了变量的作用于，也就是main函数结束，block对象就会被销毁。这时我们的Block即为<code>_NSConcreteStackBlock</code>。我们可以从<code>__block_impl</code>结构体中的<code>isa指针</code>看到上述例子中的Block均为<code>_NSConcreteStackBlock</code>类型。</p>\n<p>但是平时我们使用block的时候还有这么一种情况，即<code>并不</code>是在声明的地方<code>立即使用</code>，而是在<code>等待</code>某个时机从而进行<code>回调</code>。而此时一般是已经<code>出了block对象的作用域</code>，如果跟之前一样是<code>栈区block</code>的话显然block<code>已经被销毁</code>，此时进行<code>回调只会引起crash</code>。这时我们就需要<code>_NSConcreteMallocBlock</code>区的block了，即堆区Block。回想我们持有block的时候使用什么修饰符呢？copy对吧，而<code>block对象执行copy操作就是将其按需复制到堆区</code>。</p>\n<p>我们看下下面的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">int globalVar = 100;</div><div class=\"line\"></div><div class=\"line\">void(^globalBlock)() = ^&#123;</div><div class=\"line\">    NSLog(@&quot;global block beyond main&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    NSLog(@&quot;stack block: %@&quot;,^&#123;NSLog(@&quot;here a = %d&quot;,a);&#125;);</div><div class=\"line\">    NSLog(@&quot;malloc block: %@&quot;,[^&#123;NSLog(@&quot;here a = %d&quot;,a);&#125; copy]);</div><div class=\"line\">    NSLog(@&quot;global block: %@&quot;,^&#123;NSLog(@&quot;I use nothing&quot;);&#125;);</div><div class=\"line\">    NSLog(@&quot;global block beyong main: %@&quot;,globalBlock);</div><div class=\"line\">    NSLog(@&quot;global block use globalVar: %@&quot;,^&#123;NSLog(@&quot;%d&quot;,globalVar);&#125;);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///输出：</div><div class=\"line\">stack block: &lt;__NSStackBlock__: 0x7fff5d7cd578&gt;</div><div class=\"line\">malloc block: &lt;__NSMallocBlock__: 0x60000004ef70&gt;</div><div class=\"line\">global block: &lt;__NSGlobalBlock__: 0x1024320d0&gt;</div><div class=\"line\">global block beyong main: &lt;__NSGlobalBlock__: 0x102432050&gt;</div><div class=\"line\">global block use globalVar: &lt;__NSGlobalBlock__: 0x102432110&gt;</div></pre></td></tr></table></figure>\n<p>此处我们可以看到三种block类型。从源码我们可以知道默认生成的block均为<code>_NSConcreteStackBlock</code>类型，而后执行了copy操作的block为<code>_NSConcreteMallocBlock</code>类型，后面三个均为<code>_NSConcreteGlobalBlock</code>类型。</p>\n<p>这里我们先说<code>_NSConcreteGlobalBlock</code>类型的Block。在<strong>全局范围内声明的Block即为全局Block</strong>，并且<strong>没有引入自动变量的也为全局Block</strong>。</p>\n<p>现在我们知道了，调用过copy方法的block会被复制到堆区，堆区的Block均为<code>_NSConcreteMallocBlock</code>类型。那么什么情况下block会执行copy方法呢？</p>\n<p>其实我们可以从上述的分析中猜到，当block需要在其作用域外使用的我们应该将其复制到堆区。例如block作为函数返回值的时候，这时候编译器会按需调用copy方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef void(^voidBlock)();</div><div class=\"line\">voidBlock func();</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    NSLog(@&quot;the return value of func:%@&quot;,func());</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">voidBlock func() &#123;</div><div class=\"line\">    int a = 10;</div><div class=\"line\">    NSLog(@&quot;the block in func:%@&quot;,^&#123;NSLog(@&quot;block in func : a = %d&quot;,a);&#125;);</div><div class=\"line\">    return ^&#123;</div><div class=\"line\">        NSLog(@&quot;block in func : a = %d&quot;,a);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">///输出：</div><div class=\"line\">the block in func:&lt;__NSStackBlock__: 0x7fff56877558&gt;</div><div class=\"line\">the return value of func:&lt;__NSMallocBlock__: 0x6080000486a0&gt;</div></pre></td></tr></table></figure>\n<p>此例中我们看到函数体中，<strong>输出了一个Block其为栈区Block</strong>，但是当将同样的<strong>Block作为返回值返回到main函数中的时候，他变成了堆区Block</strong>。</p>\n<p>同学们不要说我这<code>不是一个Block</code>，我应该生成一个Block将其赋值，Log一下，在返回出去。这个真不是我不赋值，我不能啊，因为在<strong>ARC中赋值的时候如果不附加修饰符的话默认认为生成的变量是以__strong修饰符修饰的，而编译器遇到__strong修饰符会自动copy</strong>。。。我怎么给你做例子啊。。。反正老司机这么写虽然不是同一个block，但是应该是同一类型block，足以说明问题。另外老司机说过，<code>编译器会按需调用copy方法</code>。也就是说栈区block会出作用域销毁，全局block并不会，所以如果<strong>返回值是一个全局block的话，则不会调用copy方法</strong>。</p>\n<p>此外以下两种情况也会由系统为我们调用copy方法：</p>\n<ul>\n<li>Cocoa框架的方法且方法名中含有usingBlock等时</li>\n<li>GCD的API</li>\n</ul>\n<p>还有就是显示调用copy方法的时候，另外如果将其赋值给有copy修饰符修饰的属性的话也会调用copy方法。</p>\n<p>然而什么时候应该调用copy方法呢？我们先来看下不同类型block调用copy方法会有什么行为。</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Block类型</th>\n<th style=\"text-align:center\">副本源的配置存储域</th>\n<th style=\"text-align:center\">复制效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">_NSConcreteStackBlock</td>\n<td style=\"text-align:center\">栈</td>\n<td style=\"text-align:center\">从栈复制到堆</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">_NSConcreteGlobalBlock</td>\n<td style=\"text-align:center\">程序的数据区域</td>\n<td style=\"text-align:center\">什么也不做</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">_NSConcreteMallocBlock</td>\n<td style=\"text-align:center\">堆</td>\n<td style=\"text-align:center\">引用计数增加</td>\n</tr>\n</tbody>\n</table>\n<p>不管Block配置在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可。</p>\n<p>————引自《iOS与OS X多线程和内存管理》 </p>\n</blockquote>\n<p>但是在我们确定的时候，还是要根据需要调用copy方法，不要盲目调用copy方法，毕竟这个方法是十分占用CPU资源的。</p>\n<hr>\n<h3 id=\"block说明符\"><a href=\"#block说明符\" class=\"headerlink\" title=\"__block说明符\"></a>__block说明符</h3><p>上文中，老司机已经讲述了block对象在调用copy方法时候的行为。然而__block说明符修饰的变量与block对象基本一致。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">__block变量的配置存储域</th>\n<th style=\"text-align:center\">Block从栈复制到堆时的影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">栈</td>\n<td style=\"text-align:center\">从栈复制到堆并被Block持有</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">堆</td>\n<td style=\"text-align:center\">被Block持有</td>\n</tr>\n</tbody>\n</table>\n<p>正如老司机在上文中提到的，被__block说明符的变量会自动生成一个结构体。<br>值得一提的是三个地方：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-87eaef84e4e9496a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"forwarding.png\"></p>\n<p>老司机之前说过，只有被<strong>block说明符修饰的变量，今后使用的均为其结构体中维护的同名成员变量，不过从源码中我们看到，并不是简单地使用了成员变量，而是`a.</strong>forwarding-&gt;a`这样一个引用方式，这是因为什么呢？</p>\n<p>首先从<code>__Block_byref_a_0</code>中我们可以看到<strong>forwarding是一个`</strong>Block_byref_a_0`类型的结构体指针。</p>\n<p>从main函数中第一行<strong>block变量生成的代码我们看出，在本例中生成__block变量a的同时将a的__forwarding指向了a自身。这样`a.</strong>forwarding-&gt;a`最终还是指向了__block变量a结构体中的成员变量a。</p>\n<p>既然这样，就一定存在__forwarding并不指向block变量自身的情况，故此才需要__forwarding存在来保证时刻能取到一个正确的值。而上文中提到的<strong>调用copy方法的时候，就会对__forwarding指针进行操作</strong>。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ee254afd55904ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"__forwarding\"></p>\n<p>由上图我们可以看到，当调用copy方法后，__forwarding指针指向堆中的__block变量。而堆中的__block变量的__forwarding指针则指向自身。</p>\n<p>同时我们知道，block其实是对c语言的扩充，然而OC中我们使用的是引用计数来管理对象生命周期，而不是GC。所以事实上Block需要自行管理内存。那么当我们的Block捕获了一个对象时，他又是如何管理其引用计数的呢？<br>上文中老司机有提到过<code>__main_block_copy</code>和<code>__main_block_dispose</code>两个函数。<strong>当Block结构体中捕获到的对象需要retain的时候则调用__main_block_copy方法增加引用计数，当其需要释放的时候则调用__main_block_dispose释放对象</strong>。所以当block从栈上复制到堆的时候会调用copy函数，而对上的block被释放时调用dispose函数。</p>\n<hr>\n<h3 id=\"关于Block引起的循环引用\"><a href=\"#关于Block引起的循环引用\" class=\"headerlink\" title=\"关于Block引起的循环引用\"></a>关于Block引起的循环引用</h3><p>一直以来，Block引起的循环引用都让不少初级工程师，甚至包括一些中级工程师(索性就叫他中级吧。。。)谈虎色变。他们不知道Block是如何引起循环引用的，只知道<code>__weak可以避免循环引用</code>。知其然不知其所以然，闹出一些笑话也是让人无语。</p>\n<p>首先说一下什么是循环引用？</p>\n<p>引用计数机制不做展开，我们只需要知道，<strong>在OC中对象是在引用计数为0的时候进行销毁的。一个对对象的强引用会造成一次引用计数的加一。释放一个强引用会造成引用计数的减一。</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e052aabc7507eaa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"强引用\"></p>\n<p>上图我们知道，对象A对对象B有一个强引用。<strong>当对象A销毁的时候，会释放对对象B的强引用。如果此时对象B的引用计数为0则对象B被销毁</strong>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d0548d5481c4e95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"循环引用\"></p>\n<p>但当出现上图的情况，强引用出现了一个<code>闭环</code>的时候，就会造成<strong>逐个等待上一个强引用释放信号，然而闭环导致任意一个对象都不会释放对下一个对象的强引用，这就是循环引用</strong>。</p>\n<p>明确一点，造成循环引用的必要条件的<code>闭环</code>，所以循环引用不仅可以发生在两个对象之间，可以是多个对象，甚至可以是一个对象。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-820d88f878f0a934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"循环引用\"></p>\n<p>由此看来Block引起循环引用的原因就很明白了，<strong>Block对内部使用的自动变量造成一个强引用，而如果这个自动变量恰好对Block也有强引用的话就会造成循环引用</strong>。</p>\n<p>既然知道了循环引用的起因，那么我们只要打破引用的闭环就可以轻松解决。<strong>两个思路，一个是从最开始就不让强引用成为闭环，使用弱引用。另一个思路是找到一个合适的时机主动释放一个强引用，打破闭环</strong>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b5663570b518b542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"打破闭环\"></p>\n<ul>\n<li>弱引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">__weak typeof(self)weakSelf = self;</div><div class=\"line\">self.block = ^&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,weakSelf);</div><div class=\"line\">&#125;;</div><div class=\"line\">self.block();</div></pre></td></tr></table></figure>\n<p>上述代码中，使用__weak生成一个弱引用变量weakSelf，保持对self的弱引用。然后Block捕获到weakSelf，对weakSelf也是弱引用，然而却没有造成闭环。故避免了循环引用。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-2028bfe9fbf497e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"weakSelf\"></p>\n<ul>\n<li>主动释放</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block id blockSelf = self;</div><div class=\"line\">self.block = ^&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,blockSelf);</div><div class=\"line\">    blockSelf = nil;</div><div class=\"line\">&#125;;</div><div class=\"line\">NSLog(@&quot;%@&quot;,self.block);</div><div class=\"line\">self.block();</div></pre></td></tr></table></figure>\n<p>上述代码中，使用__block生成一个block对象blockSelf，保持对self的强引用。然后Block捕获到blockSelf，强引用blockSelf，由于self对block还有一个强引用，此时形成了一个闭环。但当block调用的时候，内部最后将blockSelf对象置为nil。由于blockSelf置为nil，__block对象失去强引用被销毁，同时释放对self的强引用，从而打破闭环。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1c2640ded7e6ad98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"blockSelf\"></p>\n<p>不过两种避免循环引用的方式都有各自的缺点。</p>\n<p>__weak 的弱引用形式的缺点在于，当block执行的时候，由于对self是弱引用，不能保证self对象是否已经被销毁。事实上block执行前self被销毁还好，顶多是不执行。但是如果在block执行过程中，self被销毁就会造成不可预估的后果。所以当使用__weak的时候我们通常会看到如下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">__weak typeof(self)weakSelf = self;</div><div class=\"line\">self.block = ^&#123;</div><div class=\"line\">\t__strong typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,strongSelf);</div><div class=\"line\">&#125;;</div><div class=\"line\">self.block();</div></pre></td></tr></table></figure>\n<p>这样的结构可以保证在block执行过程中，不会因为self释放引起问题，然而如果block执行前self被释放后block也就没有机会执行了，也算是对代码的保护。更多的关于<code>Weak-Strong-Dance</code>的讨论可以看下这篇文章：</p>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/737999a30544\" target=\"_blank\" rel=\"external\">Weak-Strong-Dance真的安全吗？</a></p>\n</blockquote>\n<p>__weak有这样的缺点，为什么不适用__block等方式呢？</p>\n<p>事实上__block同样有着自己的烦恼，就是一定要在block体中对__block对象置为nil，且block一定要执行才可以解决循环引用。所以开发者要根据具体情况合理的选择解决循环引用的方式。</p>\n<hr>\n<p>至此，老司机今天的内容也就算结束了。</p>\n<p>参考资料：</p>\n<ul>\n<li>《iOS与OS X多线程和内存管理》</li>\n<li><a href=\"http://www.jianshu.com/p/737999a30544\" target=\"_blank\" rel=\"external\">Weak-Strong-Dance真的安全吗？</a></li>\n</ul>"},{"title":"老司机带你走进Core Animation 之CAAnimation","layout":"post","date":"2016-09-05T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![老司机带你走进Core Animation 之CAAnimation](http://upload-images.jianshu.io/upload_images/1835430-77eacb0858d3a263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n为什么时隔这么久我又回来了呢？\n###回来圈粉。\n开玩笑的，前段时间ipv6被拒啊，超级悲剧的，前后弄了好久，然后需求啊什么的又超多，所以写好的东西也没有时间整理。不过既然我现在回来了，那么这将是一个井喷的时节。（感觉给自己立下了什么死亡flag，啧啧啧）\n\n先说什么呢？说一下CAAnimation相关的吧，因为最近也刚好在研究这些东西。不过看到末尾之前，请你相信我今天讲CAAnimation绝对是有阴谋的。\n- - -\n#老司机带你走进Core Animation\n\n事实上，老司机今天讲的只是核心动画（Core Animation）中的一小部分，`动画那部分`=。=\n\n开发中，有的时候我们可爱的UI妹子或者产品妹子会说（表示一下纯属个人YY）：技术哥哥，这里能不能duang的一下弹出来呢？这里能不能转个圈出现啊？这里能不能加一些炫酷的效果啊？\n\n\n![Duang](http://upload-images.jianshu.io/upload_images/1835430-07cc02042b300306.gif?imageMogr2/auto-orient/strip)\n\n作为`高冷而又无所不能`的技术，能说不么？\n###不能！\n然后你就硬着头皮去写动画吧。\n\n好在呢，苹果已经想到**`程序员也是要撩妹`**的这个需求，所以为我们提供了CAAnimation这个好东西，当然还贴心的帮我们又进行了一层`封装`，那就是`UIView得animate相关`的方法了。\n\n然而封装好的东西，灵活度当然会降低了。所以既然是基于`CAAnimation`的，那我们就去自己调用好了！\n\n所以呢，今天我打算说说CAAnimaiton。\n\n这篇博客中可能会涉及到什么呢？\n\n- CALayer与UIView\n- CAAnimation与UIView animate\n\n<!-- more -->\n\n- - -\n\n## CALayer\n\n为什么会先说CALayer呢？以为`CAAimation实际上操作的都是Layer层`。\n\n所以不知道CALayer会很头疼的，知道的偷学去冲杯咖啡吧。\n\n>The CALayer class manages image-based content and allows you to perform animations on that content. Layers are often used to provide the backing store for views but can also be used without a view to display content. A layer’s main job is to manage the visual content that you provide but the layer itself has visual attributes that can be set, such as a background color, border, and shadow. In addition to managing visual content, the layer also maintains information about the geometry of its content (such as its position, size, and transform) that is used to present that content onscreen. Modifying the properties of the layer is how you initiate animations on the layer’s content or geometry. A layer object encapsulates the duration and pacing of a layer and its animations by adopting the CAMediaTiming protocol, which defines the layer’s timing information.\n\n>If the layer object was created by a view, the view typically assigns itself as the layer’s delegate automatically, and you should not change that relationship. For layers you create yourself, you can assign a delegate object and use that object to provide the contents of the layer dynamically and perform other tasks. A layer may also have a layout manager object (assigned to the layoutManager property) to manage the layout of subviews separately.\n\n这是官方文档对CALayer的解释，以老司机的英语水平翻译成人话就是：\n\nCALayer是用来`绘制、渲染`图形的。\n\n### 那他与UIView又有什么区别和联系呢？\n\n事实上所有的UIView及其子类图形的绘制。UIView下有一个layer属性，这个layer层就是真正绘制UIView所要展示的东西的人。然而之所以要将CALayer封装成UIView则是为了给其`添加事件响应`。\n\n因为`CALayer`是继承与NSObject的，所以他是`不具备响应`的。而`UIView是继承与UIResponder`的，UIResponder本身`可以提供事件响应`，再用CALayer给他绘制一个图像，那一个具有响应事件的对象就诞生了，他就是我们的UIView。\n\n\n当我们创建一个UIView对象时，系统自动为我们创建一个CALayer对象,这个对象就是UIView的layer属性。\n\n### CALayer有具体有什么属性呢？\n\n前面有说过，layer层负责绘制和渲染，那么图像的基本属性他是一定要有的。\n\n这里呢，老司机还是着重介绍一个常用和重要的属性吧。\n\nCALayer有`bounds，position，frame`的属性，他呢，其实就是UIView中bounds，center，frame的映射。事实上，我们在layer中一般只操作bounds和position两个属性。由于有着对应关系，所以这个理解起来就相对容易，我就不展开讲解了。\n\nCALayer还有一个非常重要的属性`anchorPoint`，即锚点。说起来这个概念还是真难解释，锚点就好像是体心，一个物体抽象成一个点的对象。还记得物理中的质点么？我们操作属性，比如移动，旋转，缩放等等都是以锚点作为`参考点`的。他是一个`CGPoint类型`的对象，他的`x、y取值范围都是0~1`。数值就是从锚点到layer的左上角（类比UIView的origin）的 横向/纵向 距离占layer得 width/height 的`比例`。\n\n\n![锚点](http://upload-images.jianshu.io/upload_images/1835430-b882c8aef33998c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`contents`，寄宿图。事实上这个属性我们操作的也很少，不过还是可以解释一下的。他可以看做是`当前图层的背景图片`。就是在当前图层的背景展示一张图片。也就是说你甚至可以用一个UIView展示一张图片了，就是这样。不过你别看他的类型是id，可不代表你给他传什么对象都可以。事实上你只能传`CGImageRef`类型的数据进去。他的id类型是为了配合OS X系统的。哦，你说为什么不能传UIIamge？是这样的，`CALayer是在QuartzCore框架下`的，他是可以跨平台的，也就是在iOS和OS X上都可以，所以他当然不能让你传入UIKit下的对象了。`CALayer的所有属性都不能传入UIKit的对象`。\n\n`transform`，仿射变换啦，这个东西其实挺多能讲的，那套图像变换的原理挺有意思的，不过我矩阵真的不会算了=。=延展的东西数学好的同学们自己看吧，其实想用还是挺简单的。\n\n`cornerRadius、masksToBounds`。这两个属性比较常用啦，切圆角时候我们用的属性。\n\n`opacity`，类比UIView的alpha。\n\n`shadowOpacity、shadowColor、shadowPath、shadowOffset、shadowRadius`，这几个阴影相关的属性。这里需要注意的是`shadowOpacity的默认值现在是0`。也就是说默认效果下你是看不到任何阴影效果的，想要实现阴影想过请先`更改shadowOpacity为一个非0得小于等于1的值`。还有一点就是由于shadow是图层外的延展效果，要想看到shadow效果请`设置masksToBounds属性为No`。\n\n`borderColor、borderWidth`，这是边框相关的属性。borderWidth默认值是0。\n\n`mask`，这也是个有趣又有用的属性，`遮罩属性`。可以以一个layerA作为另一个layerB的遮罩，即layerB.mask = layerA。那么作为遮罩的layerA中的透明区域将被过滤掉，`layerB只显示layerA的非透明区域`。借助这个属性可以实现很多神奇的效果，比如歌词、图像展开等等。\n\n\n![mask](http://upload-images.jianshu.io/upload_images/1835430-d7eec1186a9a4349.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nCALayer还有一个其他的属性，不过平时使用的也不多，老司机就不逐一介绍了，有兴趣的同学可以自行了解哈。\n\n基于CALayer的种种属性，以及CALayer还有很多子类，有了他们，我们能看到各种各样的UI控件，那我们又如何创建动画呢？\n- - -\n\n\n## CAAnimation\n\n### CAAnimation是什么呢？\n\n>CAAnimation is an abstract animation class. It provides the basic support for the CAMediaTiming and CAAction protocols. To animate Core Animation layers or Scene Kit objects, create instances of the concrete subclasses CABasicAnimation, CAKeyframeAnimation, CAAnimationGroup, or CATransition.\n\n官方对CAAnimation的描述也并不多，其实不过说的的确都很到位。\nCAAniamtion是一个`抽象类`，遵循着CAMediaTiming和CAAciotn两个协议。通过他的`4个子类`，我们可以`实现很多绚丽的动画效果`。\n\n- - -\n\nCAAnimation下有几个属性，下面逐一介绍\n\n`timingFunction`，这个呢，指定的是动画的节奏。所谓节奏是什么什么意思呢？就是动画执行的快慢交替。有如下几个可选项\n\n- kCAMediaTimingFunctionLinear//线性节奏，就是匀速\n- kCAMediaTimingFunctionEaseIn//淡入，缓慢加速进入，然后匀速\n- kCAMediaTimingFunctionEaseOut//淡出，匀速，然后缓慢减速移除\n- kCAMediaTimingFunctionEaseInEaseOut//淡入淡出，结合以上两者\n- kCAMediaTimingFunctionDefault//默认效果\n\n`delegate`，代理。设置代理以后就会执行代理方法啦。\n\n- -(void)animationDidStart:(CAAnimation *)anim;\n\n- -(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;\n\n一个是动画开始的代理，一个是动画结束的代理。\n\n值得注意的是，结束代理中，有一个flag。他的意思是如果动画正常播放完成的话，flag为YES。如果没有播放完成或者被移除则返回NO。\n\n`removedOnCompletion`，是否在播放完成后移除。这是一个非常重要的属性，有的时候我们希望动画播放完成，但是保留最终的播放效果是，这个属性一定要改为NO，否则无效。\n\n- - - \n遵循着CAMediaTiming协议，所以他自然也有duration、beginTime等一些属性。\n\n`beginTime`,动画的开始时间，准确的说应该叫滞后时间。就是当你将动画加载layer中后滞后多长时间开始播放。\n\n>/* The begin time of the object, in relation to its parent object, if\n * applicable. Defaults to 0. */\n \n这个属性很重要，我想要着重讲一下。上面是beginTime属性的注释。从中我们能够看出，这个`beginTime是与父对象有关`的。\n\n由于CALayer和CAAnimation都遵循CAMediaTiming协议，所以那他都可以作为我们animation对象的父对象。\n\n如果你将animation添加在一个动画组（CAAnimationGroup）中，那么ok，你直接按照下面的写法就好了。\n\n\n\tanimation.beginTime = beginTime;\n\n但是，如果你直接添加在一个layer上，他的父对象是layer。这个layer的时间线很可能是一个过去的时间。即使你添加上beginTime得到的仍旧是一个过去的时间。那么这个时候我们的动画就会显示在动画结束时的状态。为了避免这种状况，我们要修正我们的时间。代码如下：\n\n```\nCFTimeInterval time = [layer convertTime:CACurrentMediaTime() fromLayer:nil];\nanimation.beginTime = time + beginTime;\n```\n\nCACurrentMediaTime()是马赫时间，是全局时间，也就是设备距离上次开机的时间。\n\nconvertTime是获取本地时间。该方法有两个参数，第一个是时间，第二个是时间所对应的图层。当第二个参数为nil时，则返回的就是第一个参数的值。\n\n这样我们就能得到一个绝对时间。\n\n这里很重要，不过引申下去就远了，想了解的同学点[这里](http://blog.csdn.net/yaozhuoyu/article/details/9566511)。\n\n`duration`，是动画的持续时间。简单的概念我就一笔带过了吧，同样的还有`repeatCount，autoreverses`。这些都是一些基本属性，基本看单词就知道用途了。\n\n![duration](http://upload-images.jianshu.io/upload_images/1835430-62f9e4502e71bbfd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`speed`，这个我也要说一下，他表示的是`当前对象的时间流速`。简单来说，如果speed是2，duration是3，那么经过1.5秒，我的动画已经播放完成了。s = v * t，s就相当于已经播放的动画，也就是长度为3个单位的动画，v相当于每秒播放多少动画，即每秒播放两个单位的动画，所以1.5秒后动画其实就播放完成了。\n\n\n![speed](http://upload-images.jianshu.io/upload_images/1835430-bc4299e260ddf310.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`timeOffset`,是表示我将从动画的`第几秒开始播放`。比如一个duration = 3的动画，timeOffset = 2，那么此时我的动画从第二秒开始播放，播放到第三秒动画结束的状态后，立即变为动画的初始状态，也就是第0秒的播放状态，继续播放之第二秒的状态，然后动画结束。形象的说就好像你绕操场跑圈，以前你都是`从起点开始跑跑一圈`；这回你`从一半开始跑`，但是`同样跑一圈`，过了起点就还要再跑半圈，就是这样。\n\n\n![timeOffset](http://upload-images.jianshu.io/upload_images/1835430-d73090e071359ba4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nfillMode，是播放结束后的状态。他有四个枚举值\n\n- kCAFillModeForwards//保持结束时状态\n- kCAFillModeBackwards//保持开始时状态\n- kCAFillModeBoth//保持两者，我没懂两者是什么概念，实际使用中`与kCAFillModeBackwards相同\n`\n- kCAFillModeRemoved//移除\n\n哦，这个属性使用的时候要设置`removedOnCompletion = NO`，否则你是看不到效果的。其实除了保持结束状态有效果，其他跟没效果也没什么区别。。可能也是我没看出来。。\n\n- - -\n其实说实话，我也不想讲这么些属性，不过这些铺垫也不好讲。\n\n下面又到了我们最喜欢的淘宝推荐环节。不对，是代码环节。\n\n## CABasicAnimation\n\n前文说过，CAAnimation是一个抽象类，想要实现动画效果呢，是要使用其四个子类的。\n\n首先我们就介绍一下CABasicAnimation。\n\n看名字就知道，这是一个多么基础的动画啊=。=\n\nCABasicAnimation用来`创建基于两个状态的动画`，你只需要给出两个状态，一个初始状态一个终止状态，系统自动为你将中间的动画补全。\n\n\n\tUIView * redView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];\n    redView.backgroundColor = [UIColor redColor];\n    [self.view addSubview:redView];\n    CABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@\"position\"];\n    animaiton.removedOnCompletion = NO;\n    animaiton.fillMode = kCAFillModeForwards;\n    animaiton.duration = 2;\n    animaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n    [redView.layer addAnimation:animaiton forKey:nil];\n    \n\n\n![移动](http://upload-images.jianshu.io/upload_images/1835430-7312aedda0c07f65.gif?imageMogr2/auto-orient/strip)\n\n这已经是最简单的一个动画效果了。（无视起点位置不对=。=视频录制时机总是晚）\n\n\n下面老司机逐句讲解一下。\n\n首先呢，我创建了一个animation对象。那个`keyPath`是什么呢？是我们要修改的属性名。那，我们要给谁做动画？老司机说过，CAAnimation都是对CALayer进行展示动画的。所以这属性当然是`CALayer的属性`了。至于那些属性改变支持动画效果呢？command + 左键点进CALayer，我们能看到CALayer的每个属性。看他的注释，是不是最后一句有一个`animatable`。对了，有这个的，`就是支持动画`的。\n\n\n![支持动画的属性](http://upload-images.jianshu.io/upload_images/1835430-24721d8aad9561dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来的三句有了上面的介绍就应该很清楚了，分别是完成时不移除，完成时保持末尾状态，播放时长2秒。\n\n再往下看，我`给animation的toValue赋值`。\n\n这是在做什么呢？不知道，我们就点进去看看。\n\n这个看到有`toValue，fromValue，byValue`。\n注释还挺多，分开看。老司机之前说过，`CABasicAnimation是要指定动画的初始状态和终止状态的`。那这三个属性就是用来指定状态的。\n\n- from就是指定初始状态\n- toValue就是终止状态\n- by就是状态的增量\n\n这三个值呢，`不能全为空`，以为这样你就一个状态也没有指定。\n\n`也不能全不为空`，因为这样你就指定了三个状态，系统也不知道选哪两个。\n\n若果你`指定了一个状态`，那系统将自动`以当前状态作为另一个状态`。\n\n若你`指定了两个状态`，则系统`已这两个状态作为始末状态`。\n\n还有一点要说的是，看属性也看的出来，这个value你是要`传入一个对象`的，所以老司机将CGPoint装在了一个NSValue中。\n\n最后一句就是将动画填入layer中了，注意这里老司机图省事就没有给key。实际开发中`建议开发者填写key且key不可重复`，因为如果涉及到检测动画播放进度或者是移除动画之类的都要填写正确的key才可以。\n\n好的，我们的动画已经初具规模了，我们一点一点完善。\n\n\tCABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@\"position\"];\n    animaiton.removedOnCompletion = NO;\n    animaiton.fillMode = kCAFillModeForwards;\n    animaiton.duration = 2;\n    animaiton.beginTime = CACurrentMediaTime() + 1;\n    animaiton.repeatCount = MAXFLOAT;\n    animaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n    [redView.layer addAnimation:animaiton forKey:nil];\n\n\n代码改成了这个样子，跑一下看看是什么样子。\n\n\n![延时](http://upload-images.jianshu.io/upload_images/1835430-bab04c38cdbb7b08.gif?imageMogr2/auto-orient/strip)\n\n我们看到我添加这延时语句，同时改变了repeatCount让他无限循环。（这里你要注意我延时语句的写法）\n\n我们再稍微改一下\n\n\tCABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@\"position\"];\n    animaiton.removedOnCompletion = NO;\n    animaiton.fillMode = kCAFillModeForwards;\n    animaiton.duration = 2;\n    animaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n    [redView.layer addAnimation:animaiton forKey:nil];\n    animaiton.beginTime = CACurrentMediaTime() + 1;\n    animaiton.repeatCount = MAXFLOAT;\n    \n发现变化了么？老司机把重复和延时放在了添加动画之后，这个时候动画是什么样子的呢？\n\n\n![调整语句顺序](http://upload-images.jianshu.io/upload_images/1835430-a86ec17b9a2c3a31.gif?imageMogr2/auto-orient/strip)\n\n延时没有了，也不重复了，怎么回事？？？\n\n因为当你调用addAnimation：forKey：这句时，其实系统是对你传入的`animation进行了一次copy`，然后`把copy的这份添加在图层上`。这时你再改animation当然是不能更改动画效果的了。\n\n**这里同时也引出了一点，当你将animation加入layer层以后，你就无法再更改动画效果了。**\n\n其他的属性都是字面意思，老司机就不一句一句讲了。\n\n- - -\n## CAKeyframeAnimation\n\n刚才也忘了说了，其实CABasicAnimation和CAKeyframeAnimation都是继承自CAPropertyAnimation。看名字就知道是根据属性来展示动画的。\n\n所以CAKeyframeAnimation也是根据属性展示动画的，他与CABasicAnimation的不同点在于他可以`指定多个状态`，不局限于始末状态，这样`你的动画将更加灵活。`\n\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n\n\n\n![keyframe](http://upload-images.jianshu.io/upload_images/1835430-bf5c0269b3108fe8.gif?imageMogr2/auto-orient/strip)\n\n还是逐句讲一下。\n\n我先生成一个CAKeyframeAnimation对象，指定要做动画的属性。\n然后`给values属性给了一个数组`。这什么意思呢？`CABasicAnimation是指定两个状态，而我们的CAKeyframeAnimation则是指定多个状态`，动画也的确按照我的规划移动了。\n\n其实这里你应该注意到一点，有没有发现我的红色方形最开始是看不到全部的？因为还记得`锚点`那个概念么？他的初始值是CGPointMake(0.5,0.5),`所有动画都是以锚点为参考点`，所以说你指定的状态都是相对于锚点来说的状态。当然如果有需要，你可以修改锚点来实现一些特殊的动画效果。\n\n改一下代码\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.calculationMode = kCAAnimationCubicPaced;\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n\t\n\n![calculationMode](http://upload-images.jianshu.io/upload_images/1835430-0b3020d9906c97d5.gif?imageMogr2/auto-orient/strip)\n\n我改变了`calculationMode`这个属性，有没有发现转折点出动作平滑了许多？恩，这个属性是用来改变补间动画的计算模式的。这个属性`是CAKeyframeAnimation独有的属性`。\n\n继续修改\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.keyTimes = @[@0,@0.8,@1];\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n\n我去掉了calculationMode属性，添加了keyTimes属性，效果是这样的。\n\n\n![keyTimes](http://upload-images.jianshu.io/upload_images/1835430-d64671e9c70a19f9.gif?imageMogr2/auto-orient/strip)\n\n是不是发现第一段路径速度明显比第二段慢？是因为`keyTimes属性指定的是当前状态节点到初始状态节点的时间占动画总时长的比例`。若果`不设置keyTimes则匀速播放`。\n\nGo on\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.keyTimes = @[@0,@0.8,@1];\n    animation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n\n\n\n![path](http://upload-images.jianshu.io/upload_images/1835430-1fbc0c1de0032f9e.gif?imageMogr2/auto-orient/strip)\n\n\n这回机智如你应该发现几个问题，第一路径变了。\n\n因为我们`指定了path属性`，所以这时`values属性将被忽略`，按照指定的path运动。（此处注意我给的是CGPathRef类型数据，为什么？还记得之前说的UIKit的事么？）\n\n第二，即使以path为运动给你好像也不太对？\n\n这是因为以path为运动轨迹后只是相当于用另一种方式填写了values属性。这是一个圆形的路径，他被分成了四个`子路径`。然而你在keyTimes中指定的时间状态只有第二个 状态到初始状态的时间比例为1，自然后面的动画就没有了。\n\n改成下面的样子就好了。\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1];\n    animation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n    \n\n\n\n![修改keyTimes](http://upload-images.jianshu.io/upload_images/1835430-6511471e8429dfda.gif?imageMogr2/auto-orient/strip)\n\n这里呢，老司机想多嘴一句。当`使用path`这个属性时需要`注意这么一点`。就是当你使用的path是`两个Path拼接`到一起，比如一个波浪线你可以以两个半圆去模拟（当然你也可以使用二次贝塞尔曲线）。这时候其实你的动画是有`两个子路径的`。如果你`不设置calculationMode`属性的话，两个子路径之间`会有短暂的停顿`。所以这里`建议修改calculationMode为kCAAnimationPaced或者kCAAnimationCubicPaced`。这样动画将更加圆润。\n\n\n事实上，CAKeyframeAnimation还有一个独有的属性，`rotationMode`。这个属性的`默认是一个空值nil`。有两种可选值，*kCAAnimationRotateAuto*或者* kCAAnimationRotateAutoReverse*。如果这个属性设置成以上两个值中的任意一个，当前layer都会`始终保持朝向运动方向`，也就是跟随运动方向`自动旋转`。\n\n为什么特殊说一下这个属性呢？因为大家知道我们时常相对一个物体做旋转动画，然而我们又`不单纯的想以layer的中心坐旋转`，很多时候可能是layer的某个端点。这个时候你有三种选择：\n\n- 更改锚点\n- 更改你的layer层\n- 结合移动和转动\n\n`更改锚点`就是将锚点移至你想旋转的旋转中心。但是其实老司机`不建议你修改锚点`。因为锚点是一个layer层的参考点。当你修改锚点以后`将会影响layer的所有相关属性`以至于造成一些你所不希望的后果。\n\n`更改layer层`就是`扩展当前layer区域`，以透明区域填补空白区域，强行让你所期望的端点成为旋转中心。这个方法实在`笨拙`，`不优雅`。\n\n`结合移动和转动`就是其实`将以端点的转动拆分成锚点的转动及锚点的弧线运动`去模拟端点的转动。这个方法是三者中最优雅的了，最起码不是那些取巧的方法。\n\n但是有了`rotationMode`这个属性，哈哈，这三个方法都不用了。你只需要一个`锚点的弧线动画`以及`rotationMode = kCAAnimationAutoRotate`就可以了，简单了很多吧。\n\n- - -\n\n以上就是基于CAPropertyAnimation的属性动画的基本使用方法，当然这里老司机一直使用移动动画做的示例，你可以`更改属性，去做其他的动画都是可以的`。另外温馨提示，`二级属性也可以哦`。\n\n那你可能要说了，我使用过程中一般不可能只改变一个属性啊，我想两个一起改变怎么办啊？\n\n我们的衣食父母苹果怎么会没想到呢？所以他为我们提供了一个类，CAAnimationGroup。\n\n## CAAnimationGroup\n\n看名字就看得出来是动画组了，他支持多个动画并发执行。\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1];\n    animation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n    \n    CABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@\"cornerRadius\"];\n    animation2.toValue = @50;\n    animation2.duration = 2;\n    animation2.fillMode = kCAFillModeForwards;\n    animation2.removedOnCompletion = NO;\n    \n    CAAnimationGroup * group = [CAAnimationGroup animation];\n    group.duration = 2;\n    group.fillMode = kCAFillModeForwards;\n    group.removedOnCompletion = NO;\n    group.animations = @[animation,animation2];\n    \n    [redView.layer addAnimation:group forKey:@\"group\"];\n\n\n![CAAnimationGroup](http://upload-images.jianshu.io/upload_images/1835430-88b254bdbaa34902.gif?imageMogr2/auto-orient/strip)\n\n其实用法差不多，不同是的首先我`不需要指定属性`了，因为CAAnimationGroup可以播放多个属性同时变化，所以不需要指定属性。\n\n其次`不需要指定状态了`。因为CAAnimationGroup相当于多个CAAnimation动画并发执行的管理者，本身状态取决于其子动画的状态。\n\n还有一个animations属性，这个属性用于指定他的子动画。这个属性有些两点，可以说一下。我们点进去可以看到，animations是`装有CAAnimation对象一个的数组`。这句话的重点就是CAAnimationGroup也继承与CAAnimation，所以`CAAnimationGroup是可以嵌套`的。\n\n\n![animations](http://upload-images.jianshu.io/upload_images/1835430-f7569b4c0c423c81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n记得之前我说过beginTime很重要么？记得那个属性要加上矫正值么？想在你完全不用考虑那个问题了。遇到要改变beginTime的动画，`直接把他丢到CAAnimationGroup里面`去，然后时间你就直接加吧，也不用矫正了，哈哈哈哈。不过呢，你也不要高兴太早，这里`有一个坑`，就是`animations数组中你的所有CAAnimaiton对象请安beginTime进行升序排列`哦，否则也是会有问题的哟。\n\nCAAnimationGroup是个好东西，简化了很多操作，同时还可以嵌套，属性还很少。\n支持并发动画演示，屌屌的。\n- - -\n\n## CATransition\n\n最后一个啦，转场动画。\n\n\t- (void)viewDidLoad {\n\t    [super viewDidLoad];\n\t    UIButton * bu = [UIButton buttonWithType:(UIButtonTypeSystem)];\n\t    [bu setBackgroundColor:[UIColor yellowColor]];\n\t    [bu setFrame:CGRectMake(200, 200, 100, 100)];\n\t    [self.view addSubview:bu];\n\t    [bu addTarget:self action:@selector(a:) forControlEvents:(UIControlEventTouchUpInside)];\n\t    self.view.backgroundColor = [UIColor grayColor];\n\t    UIImageView * redView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];\n\t    redView.backgroundColor = [UIColor redColor];\n\t    redView.image = [UIImage imageNamed:@\"2.jpeg\"];\n\t    [self.view addSubview:redView];\n\t    self.imgV = redView;    \n\t}\n\t-(void)a:(UIButton *)btn\n\t{\n\t    CATransition *animation = [CATransition animation];\n\t    animation.duration = 5;\n\t    animation.fillMode = kCAFillModeForwards;\n\t    animation.type = @\"rippleEffect\";\n\t    animation.subtype = kCATransitionFromTop;\n\t    [self.imgV.layer addAnimation:animation forKey:@\"ripple\"];\n\t    self.imgV.image = [UIImage imageNamed:@\"3.jpg\"];\n    }\n\n\n![transition](http://upload-images.jianshu.io/upload_images/1835430-34c04cf9d77613f7.gif?imageMogr2/auto-orient/strip)\n\n看到了没有这个水波效果还是挺炫的。\n这个动画有两点不同，一个是`type`,这个属性指定的是动画的主类型，有以下几种可选择的动画：\n\n- kCATransitionFade\n- kCATransitionMoveIn\n- kCATransitionPush\n- kCATransitionReveal\n\n还有一些系统私有的动画但是可以安全使用,但是你只能用字符串\n\n//@\"cube\" @\"moveIn\" @\"reveal\" @\"fade\"(default) @\"pageCurl\" @\"pageUnCurl\" @\"suckEffect\" @\"rippleEffect\" @\"oglFlip\"\n\n还有一些绝对不能使用的动画我就不放出来了\n\n另外一个属性是subType。\n有四种选项：\n\n- kCATransitionFromRight\n- kCATransitionFromLeft\n- kCATransitionFromTop\n- kCATransitionFromBottom\n\n见名知意，就是指动画的方向啦。\n\n\n不过呢，这个转场动画不好的一点是需要跟转场代码写在一起，然而官方又没有给出转场到底是什么概念。\n\n所以我目前测出来的能用的情况有，`imageView切换图片`，`控制器的push或modal`，`UIView对象调用exchangeSubviewAtIndex：WithIndex：方法`的时候可以出发转场动画，其他我真是没有测出来，有大神知道还望告知=。=十分感谢。\n\n- - -\n\n最后呢，鉴于有同学问到为什么做动画后，layer的frame还是没有发生改变，老司机翻了一下，之前真的忘了说，所以在这里补充一下。\n\n除了图层树之外，系统在内部为我们的layer维持着三分copy。渲染树、呈现树、模型树。\n图层树就是想UIView中的subview、superview一样的图层的树状逻辑。\n他在CAAnimation中的各属性值是不随着动画而实时变化的。\n\n渲染树是系统内部用来处理动画效果的一份copy。并且对我们是不公开的，我们无法调用。\n\n呈现树是动画中每一个瞬时状态的各个属性值得那份copy，他是随着动画实时改变的。可以通过layer的presentationLayer进行访问。\n\n模型树是系统内部用来表示动画目标状态的各属性值的copy，可以通过modelLayer进行访问。\n\n- - -\n\n以上呢，就是CAAnimation的基本使用方法，基于这个你还可以自己组合出很多绚丽的动画，老司机就不在在这卖弄了。\n\n- - -\n哦，老司机刚才说了，老司机写CoreAnimation的教程是有阴谋的，阴谋是什么呢？嘿嘿嘿~\n\n\n![好多动画在一起](http://upload-images.jianshu.io/upload_images/1835430-e7d2fc246edd25c7.gif?imageMogr2/auto-orient/strip)\n\n呐，这是一个老司机封装的DWAnimation，他可以轻松、优雅地帮助你生成上面的动画。(有些动画播放两次是因为demo中要展示某些属性的用处，不要在意)\n\n比如这样：\n\n\n![优雅么？](http://upload-images.jianshu.io/upload_images/1835430-04a7fd69f578b586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下面是gitHub地址：[DWAnimation](https://github.com/CodeWicky/DWAnimation)\n\n这次老司机希望如果你喜欢，给我个star吧，哈哈哈。\n\n- - -\n\n## 参考资料\n\n- [崔神写的关于CoreAnimation相关，个人认为全网最全！](http://www.cnblogs.com/kenshincui/p/3972100.html)\n\n- [CAMediaTiming的详解](http://www.cocoachina.com/programmer/20131218/7569.html)\n\n- [隐式动画和显式动画](http://www.cocoachina.com/ios/20150105/10812.html)\n\n- - -\n写在最后，有的朋友说过不喜欢我写博客的风格，呐这里我想解释一下。\n\n首先呢，不是老司机做作，老司机平时就这样，`没事就好扯咸蛋`。。\n\n再者呢，老司机写博客呢，也是纯粹`为了记录自己学习过的知识`，因为老司机自己也记不住。\n\n三呢，老司机写博客呢，是`给一些刚入门的同学写的`，因为老司机一直都是在科普一些比较寻常的东西。既然是给入门的同学讲，老司机自然是能讲多细讲多细，知无不言言无不尽。但我要一直一板一眼的说，你看不到半小时保证就难以集中精力了。所以么，老司机是需要扯淡的。\n\n四呢，由于老司机写博客都是想起来啥说啥，可能你们真要是做项目找资料的看到我的博客都嫌烦，没事的，`移步简书首页善用搜索功能`，我是给坐地铁无聊的小伙伴们打发时间写的。\n\n最后，老司机就这样，\n**你咬我啊。**\n\n\n![你咬我啊](http://upload-images.jianshu.io/upload_images/1835430-6d94ce1bd36d5f61.gif?imageMogr2/auto-orient/strip)\n\n- - -\n","source":"_posts/老司机带你走进Core-Animation-之CAAnimation.md","raw":"---\n\ntitle: 老司机带你走进Core Animation 之CAAnimation\nlayout: post\ndate: 2016-09-06 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CAAnimation \n- 核心动画\ncategories: 核心动画\n\n---\n\n![老司机带你走进Core Animation 之CAAnimation](http://upload-images.jianshu.io/upload_images/1835430-77eacb0858d3a263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n为什么时隔这么久我又回来了呢？\n###回来圈粉。\n开玩笑的，前段时间ipv6被拒啊，超级悲剧的，前后弄了好久，然后需求啊什么的又超多，所以写好的东西也没有时间整理。不过既然我现在回来了，那么这将是一个井喷的时节。（感觉给自己立下了什么死亡flag，啧啧啧）\n\n先说什么呢？说一下CAAnimation相关的吧，因为最近也刚好在研究这些东西。不过看到末尾之前，请你相信我今天讲CAAnimation绝对是有阴谋的。\n- - -\n#老司机带你走进Core Animation\n\n事实上，老司机今天讲的只是核心动画（Core Animation）中的一小部分，`动画那部分`=。=\n\n开发中，有的时候我们可爱的UI妹子或者产品妹子会说（表示一下纯属个人YY）：技术哥哥，这里能不能duang的一下弹出来呢？这里能不能转个圈出现啊？这里能不能加一些炫酷的效果啊？\n\n\n![Duang](http://upload-images.jianshu.io/upload_images/1835430-07cc02042b300306.gif?imageMogr2/auto-orient/strip)\n\n作为`高冷而又无所不能`的技术，能说不么？\n###不能！\n然后你就硬着头皮去写动画吧。\n\n好在呢，苹果已经想到**`程序员也是要撩妹`**的这个需求，所以为我们提供了CAAnimation这个好东西，当然还贴心的帮我们又进行了一层`封装`，那就是`UIView得animate相关`的方法了。\n\n然而封装好的东西，灵活度当然会降低了。所以既然是基于`CAAnimation`的，那我们就去自己调用好了！\n\n所以呢，今天我打算说说CAAnimaiton。\n\n这篇博客中可能会涉及到什么呢？\n\n- CALayer与UIView\n- CAAnimation与UIView animate\n\n<!-- more -->\n\n- - -\n\n## CALayer\n\n为什么会先说CALayer呢？以为`CAAimation实际上操作的都是Layer层`。\n\n所以不知道CALayer会很头疼的，知道的偷学去冲杯咖啡吧。\n\n>The CALayer class manages image-based content and allows you to perform animations on that content. Layers are often used to provide the backing store for views but can also be used without a view to display content. A layer’s main job is to manage the visual content that you provide but the layer itself has visual attributes that can be set, such as a background color, border, and shadow. In addition to managing visual content, the layer also maintains information about the geometry of its content (such as its position, size, and transform) that is used to present that content onscreen. Modifying the properties of the layer is how you initiate animations on the layer’s content or geometry. A layer object encapsulates the duration and pacing of a layer and its animations by adopting the CAMediaTiming protocol, which defines the layer’s timing information.\n\n>If the layer object was created by a view, the view typically assigns itself as the layer’s delegate automatically, and you should not change that relationship. For layers you create yourself, you can assign a delegate object and use that object to provide the contents of the layer dynamically and perform other tasks. A layer may also have a layout manager object (assigned to the layoutManager property) to manage the layout of subviews separately.\n\n这是官方文档对CALayer的解释，以老司机的英语水平翻译成人话就是：\n\nCALayer是用来`绘制、渲染`图形的。\n\n### 那他与UIView又有什么区别和联系呢？\n\n事实上所有的UIView及其子类图形的绘制。UIView下有一个layer属性，这个layer层就是真正绘制UIView所要展示的东西的人。然而之所以要将CALayer封装成UIView则是为了给其`添加事件响应`。\n\n因为`CALayer`是继承与NSObject的，所以他是`不具备响应`的。而`UIView是继承与UIResponder`的，UIResponder本身`可以提供事件响应`，再用CALayer给他绘制一个图像，那一个具有响应事件的对象就诞生了，他就是我们的UIView。\n\n\n当我们创建一个UIView对象时，系统自动为我们创建一个CALayer对象,这个对象就是UIView的layer属性。\n\n### CALayer有具体有什么属性呢？\n\n前面有说过，layer层负责绘制和渲染，那么图像的基本属性他是一定要有的。\n\n这里呢，老司机还是着重介绍一个常用和重要的属性吧。\n\nCALayer有`bounds，position，frame`的属性，他呢，其实就是UIView中bounds，center，frame的映射。事实上，我们在layer中一般只操作bounds和position两个属性。由于有着对应关系，所以这个理解起来就相对容易，我就不展开讲解了。\n\nCALayer还有一个非常重要的属性`anchorPoint`，即锚点。说起来这个概念还是真难解释，锚点就好像是体心，一个物体抽象成一个点的对象。还记得物理中的质点么？我们操作属性，比如移动，旋转，缩放等等都是以锚点作为`参考点`的。他是一个`CGPoint类型`的对象，他的`x、y取值范围都是0~1`。数值就是从锚点到layer的左上角（类比UIView的origin）的 横向/纵向 距离占layer得 width/height 的`比例`。\n\n\n![锚点](http://upload-images.jianshu.io/upload_images/1835430-b882c8aef33998c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`contents`，寄宿图。事实上这个属性我们操作的也很少，不过还是可以解释一下的。他可以看做是`当前图层的背景图片`。就是在当前图层的背景展示一张图片。也就是说你甚至可以用一个UIView展示一张图片了，就是这样。不过你别看他的类型是id，可不代表你给他传什么对象都可以。事实上你只能传`CGImageRef`类型的数据进去。他的id类型是为了配合OS X系统的。哦，你说为什么不能传UIIamge？是这样的，`CALayer是在QuartzCore框架下`的，他是可以跨平台的，也就是在iOS和OS X上都可以，所以他当然不能让你传入UIKit下的对象了。`CALayer的所有属性都不能传入UIKit的对象`。\n\n`transform`，仿射变换啦，这个东西其实挺多能讲的，那套图像变换的原理挺有意思的，不过我矩阵真的不会算了=。=延展的东西数学好的同学们自己看吧，其实想用还是挺简单的。\n\n`cornerRadius、masksToBounds`。这两个属性比较常用啦，切圆角时候我们用的属性。\n\n`opacity`，类比UIView的alpha。\n\n`shadowOpacity、shadowColor、shadowPath、shadowOffset、shadowRadius`，这几个阴影相关的属性。这里需要注意的是`shadowOpacity的默认值现在是0`。也就是说默认效果下你是看不到任何阴影效果的，想要实现阴影想过请先`更改shadowOpacity为一个非0得小于等于1的值`。还有一点就是由于shadow是图层外的延展效果，要想看到shadow效果请`设置masksToBounds属性为No`。\n\n`borderColor、borderWidth`，这是边框相关的属性。borderWidth默认值是0。\n\n`mask`，这也是个有趣又有用的属性，`遮罩属性`。可以以一个layerA作为另一个layerB的遮罩，即layerB.mask = layerA。那么作为遮罩的layerA中的透明区域将被过滤掉，`layerB只显示layerA的非透明区域`。借助这个属性可以实现很多神奇的效果，比如歌词、图像展开等等。\n\n\n![mask](http://upload-images.jianshu.io/upload_images/1835430-d7eec1186a9a4349.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nCALayer还有一个其他的属性，不过平时使用的也不多，老司机就不逐一介绍了，有兴趣的同学可以自行了解哈。\n\n基于CALayer的种种属性，以及CALayer还有很多子类，有了他们，我们能看到各种各样的UI控件，那我们又如何创建动画呢？\n- - -\n\n\n## CAAnimation\n\n### CAAnimation是什么呢？\n\n>CAAnimation is an abstract animation class. It provides the basic support for the CAMediaTiming and CAAction protocols. To animate Core Animation layers or Scene Kit objects, create instances of the concrete subclasses CABasicAnimation, CAKeyframeAnimation, CAAnimationGroup, or CATransition.\n\n官方对CAAnimation的描述也并不多，其实不过说的的确都很到位。\nCAAniamtion是一个`抽象类`，遵循着CAMediaTiming和CAAciotn两个协议。通过他的`4个子类`，我们可以`实现很多绚丽的动画效果`。\n\n- - -\n\nCAAnimation下有几个属性，下面逐一介绍\n\n`timingFunction`，这个呢，指定的是动画的节奏。所谓节奏是什么什么意思呢？就是动画执行的快慢交替。有如下几个可选项\n\n- kCAMediaTimingFunctionLinear//线性节奏，就是匀速\n- kCAMediaTimingFunctionEaseIn//淡入，缓慢加速进入，然后匀速\n- kCAMediaTimingFunctionEaseOut//淡出，匀速，然后缓慢减速移除\n- kCAMediaTimingFunctionEaseInEaseOut//淡入淡出，结合以上两者\n- kCAMediaTimingFunctionDefault//默认效果\n\n`delegate`，代理。设置代理以后就会执行代理方法啦。\n\n- -(void)animationDidStart:(CAAnimation *)anim;\n\n- -(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;\n\n一个是动画开始的代理，一个是动画结束的代理。\n\n值得注意的是，结束代理中，有一个flag。他的意思是如果动画正常播放完成的话，flag为YES。如果没有播放完成或者被移除则返回NO。\n\n`removedOnCompletion`，是否在播放完成后移除。这是一个非常重要的属性，有的时候我们希望动画播放完成，但是保留最终的播放效果是，这个属性一定要改为NO，否则无效。\n\n- - - \n遵循着CAMediaTiming协议，所以他自然也有duration、beginTime等一些属性。\n\n`beginTime`,动画的开始时间，准确的说应该叫滞后时间。就是当你将动画加载layer中后滞后多长时间开始播放。\n\n>/* The begin time of the object, in relation to its parent object, if\n * applicable. Defaults to 0. */\n \n这个属性很重要，我想要着重讲一下。上面是beginTime属性的注释。从中我们能够看出，这个`beginTime是与父对象有关`的。\n\n由于CALayer和CAAnimation都遵循CAMediaTiming协议，所以那他都可以作为我们animation对象的父对象。\n\n如果你将animation添加在一个动画组（CAAnimationGroup）中，那么ok，你直接按照下面的写法就好了。\n\n\n\tanimation.beginTime = beginTime;\n\n但是，如果你直接添加在一个layer上，他的父对象是layer。这个layer的时间线很可能是一个过去的时间。即使你添加上beginTime得到的仍旧是一个过去的时间。那么这个时候我们的动画就会显示在动画结束时的状态。为了避免这种状况，我们要修正我们的时间。代码如下：\n\n```\nCFTimeInterval time = [layer convertTime:CACurrentMediaTime() fromLayer:nil];\nanimation.beginTime = time + beginTime;\n```\n\nCACurrentMediaTime()是马赫时间，是全局时间，也就是设备距离上次开机的时间。\n\nconvertTime是获取本地时间。该方法有两个参数，第一个是时间，第二个是时间所对应的图层。当第二个参数为nil时，则返回的就是第一个参数的值。\n\n这样我们就能得到一个绝对时间。\n\n这里很重要，不过引申下去就远了，想了解的同学点[这里](http://blog.csdn.net/yaozhuoyu/article/details/9566511)。\n\n`duration`，是动画的持续时间。简单的概念我就一笔带过了吧，同样的还有`repeatCount，autoreverses`。这些都是一些基本属性，基本看单词就知道用途了。\n\n![duration](http://upload-images.jianshu.io/upload_images/1835430-62f9e4502e71bbfd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`speed`，这个我也要说一下，他表示的是`当前对象的时间流速`。简单来说，如果speed是2，duration是3，那么经过1.5秒，我的动画已经播放完成了。s = v * t，s就相当于已经播放的动画，也就是长度为3个单位的动画，v相当于每秒播放多少动画，即每秒播放两个单位的动画，所以1.5秒后动画其实就播放完成了。\n\n\n![speed](http://upload-images.jianshu.io/upload_images/1835430-bc4299e260ddf310.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`timeOffset`,是表示我将从动画的`第几秒开始播放`。比如一个duration = 3的动画，timeOffset = 2，那么此时我的动画从第二秒开始播放，播放到第三秒动画结束的状态后，立即变为动画的初始状态，也就是第0秒的播放状态，继续播放之第二秒的状态，然后动画结束。形象的说就好像你绕操场跑圈，以前你都是`从起点开始跑跑一圈`；这回你`从一半开始跑`，但是`同样跑一圈`，过了起点就还要再跑半圈，就是这样。\n\n\n![timeOffset](http://upload-images.jianshu.io/upload_images/1835430-d73090e071359ba4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nfillMode，是播放结束后的状态。他有四个枚举值\n\n- kCAFillModeForwards//保持结束时状态\n- kCAFillModeBackwards//保持开始时状态\n- kCAFillModeBoth//保持两者，我没懂两者是什么概念，实际使用中`与kCAFillModeBackwards相同\n`\n- kCAFillModeRemoved//移除\n\n哦，这个属性使用的时候要设置`removedOnCompletion = NO`，否则你是看不到效果的。其实除了保持结束状态有效果，其他跟没效果也没什么区别。。可能也是我没看出来。。\n\n- - -\n其实说实话，我也不想讲这么些属性，不过这些铺垫也不好讲。\n\n下面又到了我们最喜欢的淘宝推荐环节。不对，是代码环节。\n\n## CABasicAnimation\n\n前文说过，CAAnimation是一个抽象类，想要实现动画效果呢，是要使用其四个子类的。\n\n首先我们就介绍一下CABasicAnimation。\n\n看名字就知道，这是一个多么基础的动画啊=。=\n\nCABasicAnimation用来`创建基于两个状态的动画`，你只需要给出两个状态，一个初始状态一个终止状态，系统自动为你将中间的动画补全。\n\n\n\tUIView * redView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];\n    redView.backgroundColor = [UIColor redColor];\n    [self.view addSubview:redView];\n    CABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@\"position\"];\n    animaiton.removedOnCompletion = NO;\n    animaiton.fillMode = kCAFillModeForwards;\n    animaiton.duration = 2;\n    animaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n    [redView.layer addAnimation:animaiton forKey:nil];\n    \n\n\n![移动](http://upload-images.jianshu.io/upload_images/1835430-7312aedda0c07f65.gif?imageMogr2/auto-orient/strip)\n\n这已经是最简单的一个动画效果了。（无视起点位置不对=。=视频录制时机总是晚）\n\n\n下面老司机逐句讲解一下。\n\n首先呢，我创建了一个animation对象。那个`keyPath`是什么呢？是我们要修改的属性名。那，我们要给谁做动画？老司机说过，CAAnimation都是对CALayer进行展示动画的。所以这属性当然是`CALayer的属性`了。至于那些属性改变支持动画效果呢？command + 左键点进CALayer，我们能看到CALayer的每个属性。看他的注释，是不是最后一句有一个`animatable`。对了，有这个的，`就是支持动画`的。\n\n\n![支持动画的属性](http://upload-images.jianshu.io/upload_images/1835430-24721d8aad9561dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来的三句有了上面的介绍就应该很清楚了，分别是完成时不移除，完成时保持末尾状态，播放时长2秒。\n\n再往下看，我`给animation的toValue赋值`。\n\n这是在做什么呢？不知道，我们就点进去看看。\n\n这个看到有`toValue，fromValue，byValue`。\n注释还挺多，分开看。老司机之前说过，`CABasicAnimation是要指定动画的初始状态和终止状态的`。那这三个属性就是用来指定状态的。\n\n- from就是指定初始状态\n- toValue就是终止状态\n- by就是状态的增量\n\n这三个值呢，`不能全为空`，以为这样你就一个状态也没有指定。\n\n`也不能全不为空`，因为这样你就指定了三个状态，系统也不知道选哪两个。\n\n若果你`指定了一个状态`，那系统将自动`以当前状态作为另一个状态`。\n\n若你`指定了两个状态`，则系统`已这两个状态作为始末状态`。\n\n还有一点要说的是，看属性也看的出来，这个value你是要`传入一个对象`的，所以老司机将CGPoint装在了一个NSValue中。\n\n最后一句就是将动画填入layer中了，注意这里老司机图省事就没有给key。实际开发中`建议开发者填写key且key不可重复`，因为如果涉及到检测动画播放进度或者是移除动画之类的都要填写正确的key才可以。\n\n好的，我们的动画已经初具规模了，我们一点一点完善。\n\n\tCABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@\"position\"];\n    animaiton.removedOnCompletion = NO;\n    animaiton.fillMode = kCAFillModeForwards;\n    animaiton.duration = 2;\n    animaiton.beginTime = CACurrentMediaTime() + 1;\n    animaiton.repeatCount = MAXFLOAT;\n    animaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n    [redView.layer addAnimation:animaiton forKey:nil];\n\n\n代码改成了这个样子，跑一下看看是什么样子。\n\n\n![延时](http://upload-images.jianshu.io/upload_images/1835430-bab04c38cdbb7b08.gif?imageMogr2/auto-orient/strip)\n\n我们看到我添加这延时语句，同时改变了repeatCount让他无限循环。（这里你要注意我延时语句的写法）\n\n我们再稍微改一下\n\n\tCABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@\"position\"];\n    animaiton.removedOnCompletion = NO;\n    animaiton.fillMode = kCAFillModeForwards;\n    animaiton.duration = 2;\n    animaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n    [redView.layer addAnimation:animaiton forKey:nil];\n    animaiton.beginTime = CACurrentMediaTime() + 1;\n    animaiton.repeatCount = MAXFLOAT;\n    \n发现变化了么？老司机把重复和延时放在了添加动画之后，这个时候动画是什么样子的呢？\n\n\n![调整语句顺序](http://upload-images.jianshu.io/upload_images/1835430-a86ec17b9a2c3a31.gif?imageMogr2/auto-orient/strip)\n\n延时没有了，也不重复了，怎么回事？？？\n\n因为当你调用addAnimation：forKey：这句时，其实系统是对你传入的`animation进行了一次copy`，然后`把copy的这份添加在图层上`。这时你再改animation当然是不能更改动画效果的了。\n\n**这里同时也引出了一点，当你将animation加入layer层以后，你就无法再更改动画效果了。**\n\n其他的属性都是字面意思，老司机就不一句一句讲了。\n\n- - -\n## CAKeyframeAnimation\n\n刚才也忘了说了，其实CABasicAnimation和CAKeyframeAnimation都是继承自CAPropertyAnimation。看名字就知道是根据属性来展示动画的。\n\n所以CAKeyframeAnimation也是根据属性展示动画的，他与CABasicAnimation的不同点在于他可以`指定多个状态`，不局限于始末状态，这样`你的动画将更加灵活。`\n\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n\n\n\n![keyframe](http://upload-images.jianshu.io/upload_images/1835430-bf5c0269b3108fe8.gif?imageMogr2/auto-orient/strip)\n\n还是逐句讲一下。\n\n我先生成一个CAKeyframeAnimation对象，指定要做动画的属性。\n然后`给values属性给了一个数组`。这什么意思呢？`CABasicAnimation是指定两个状态，而我们的CAKeyframeAnimation则是指定多个状态`，动画也的确按照我的规划移动了。\n\n其实这里你应该注意到一点，有没有发现我的红色方形最开始是看不到全部的？因为还记得`锚点`那个概念么？他的初始值是CGPointMake(0.5,0.5),`所有动画都是以锚点为参考点`，所以说你指定的状态都是相对于锚点来说的状态。当然如果有需要，你可以修改锚点来实现一些特殊的动画效果。\n\n改一下代码\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.calculationMode = kCAAnimationCubicPaced;\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n\t\n\n![calculationMode](http://upload-images.jianshu.io/upload_images/1835430-0b3020d9906c97d5.gif?imageMogr2/auto-orient/strip)\n\n我改变了`calculationMode`这个属性，有没有发现转折点出动作平滑了许多？恩，这个属性是用来改变补间动画的计算模式的。这个属性`是CAKeyframeAnimation独有的属性`。\n\n继续修改\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.keyTimes = @[@0,@0.8,@1];\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n\n我去掉了calculationMode属性，添加了keyTimes属性，效果是这样的。\n\n\n![keyTimes](http://upload-images.jianshu.io/upload_images/1835430-d64671e9c70a19f9.gif?imageMogr2/auto-orient/strip)\n\n是不是发现第一段路径速度明显比第二段慢？是因为`keyTimes属性指定的是当前状态节点到初始状态节点的时间占动画总时长的比例`。若果`不设置keyTimes则匀速播放`。\n\nGo on\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.keyTimes = @[@0,@0.8,@1];\n    animation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n\n\n\n![path](http://upload-images.jianshu.io/upload_images/1835430-1fbc0c1de0032f9e.gif?imageMogr2/auto-orient/strip)\n\n\n这回机智如你应该发现几个问题，第一路径变了。\n\n因为我们`指定了path属性`，所以这时`values属性将被忽略`，按照指定的path运动。（此处注意我给的是CGPathRef类型数据，为什么？还记得之前说的UIKit的事么？）\n\n第二，即使以path为运动给你好像也不太对？\n\n这是因为以path为运动轨迹后只是相当于用另一种方式填写了values属性。这是一个圆形的路径，他被分成了四个`子路径`。然而你在keyTimes中指定的时间状态只有第二个 状态到初始状态的时间比例为1，自然后面的动画就没有了。\n\n改成下面的样子就好了。\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1];\n    animation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n    [redView.layer addAnimation:animation forKey:@\"keyframe\"];\n    \n\n\n\n![修改keyTimes](http://upload-images.jianshu.io/upload_images/1835430-6511471e8429dfda.gif?imageMogr2/auto-orient/strip)\n\n这里呢，老司机想多嘴一句。当`使用path`这个属性时需要`注意这么一点`。就是当你使用的path是`两个Path拼接`到一起，比如一个波浪线你可以以两个半圆去模拟（当然你也可以使用二次贝塞尔曲线）。这时候其实你的动画是有`两个子路径的`。如果你`不设置calculationMode`属性的话，两个子路径之间`会有短暂的停顿`。所以这里`建议修改calculationMode为kCAAnimationPaced或者kCAAnimationCubicPaced`。这样动画将更加圆润。\n\n\n事实上，CAKeyframeAnimation还有一个独有的属性，`rotationMode`。这个属性的`默认是一个空值nil`。有两种可选值，*kCAAnimationRotateAuto*或者* kCAAnimationRotateAutoReverse*。如果这个属性设置成以上两个值中的任意一个，当前layer都会`始终保持朝向运动方向`，也就是跟随运动方向`自动旋转`。\n\n为什么特殊说一下这个属性呢？因为大家知道我们时常相对一个物体做旋转动画，然而我们又`不单纯的想以layer的中心坐旋转`，很多时候可能是layer的某个端点。这个时候你有三种选择：\n\n- 更改锚点\n- 更改你的layer层\n- 结合移动和转动\n\n`更改锚点`就是将锚点移至你想旋转的旋转中心。但是其实老司机`不建议你修改锚点`。因为锚点是一个layer层的参考点。当你修改锚点以后`将会影响layer的所有相关属性`以至于造成一些你所不希望的后果。\n\n`更改layer层`就是`扩展当前layer区域`，以透明区域填补空白区域，强行让你所期望的端点成为旋转中心。这个方法实在`笨拙`，`不优雅`。\n\n`结合移动和转动`就是其实`将以端点的转动拆分成锚点的转动及锚点的弧线运动`去模拟端点的转动。这个方法是三者中最优雅的了，最起码不是那些取巧的方法。\n\n但是有了`rotationMode`这个属性，哈哈，这三个方法都不用了。你只需要一个`锚点的弧线动画`以及`rotationMode = kCAAnimationAutoRotate`就可以了，简单了很多吧。\n\n- - -\n\n以上就是基于CAPropertyAnimation的属性动画的基本使用方法，当然这里老司机一直使用移动动画做的示例，你可以`更改属性，去做其他的动画都是可以的`。另外温馨提示，`二级属性也可以哦`。\n\n那你可能要说了，我使用过程中一般不可能只改变一个属性啊，我想两个一起改变怎么办啊？\n\n我们的衣食父母苹果怎么会没想到呢？所以他为我们提供了一个类，CAAnimationGroup。\n\n## CAAnimationGroup\n\n看名字就看得出来是动画组了，他支持多个动画并发执行。\n\n\tCAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\n    animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\n    animation.duration = 2;\n    animation.removedOnCompletion = NO;\n    animation.fillMode = kCAFillModeForwards;\n    animation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1];\n    animation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n    \n    CABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@\"cornerRadius\"];\n    animation2.toValue = @50;\n    animation2.duration = 2;\n    animation2.fillMode = kCAFillModeForwards;\n    animation2.removedOnCompletion = NO;\n    \n    CAAnimationGroup * group = [CAAnimationGroup animation];\n    group.duration = 2;\n    group.fillMode = kCAFillModeForwards;\n    group.removedOnCompletion = NO;\n    group.animations = @[animation,animation2];\n    \n    [redView.layer addAnimation:group forKey:@\"group\"];\n\n\n![CAAnimationGroup](http://upload-images.jianshu.io/upload_images/1835430-88b254bdbaa34902.gif?imageMogr2/auto-orient/strip)\n\n其实用法差不多，不同是的首先我`不需要指定属性`了，因为CAAnimationGroup可以播放多个属性同时变化，所以不需要指定属性。\n\n其次`不需要指定状态了`。因为CAAnimationGroup相当于多个CAAnimation动画并发执行的管理者，本身状态取决于其子动画的状态。\n\n还有一个animations属性，这个属性用于指定他的子动画。这个属性有些两点，可以说一下。我们点进去可以看到，animations是`装有CAAnimation对象一个的数组`。这句话的重点就是CAAnimationGroup也继承与CAAnimation，所以`CAAnimationGroup是可以嵌套`的。\n\n\n![animations](http://upload-images.jianshu.io/upload_images/1835430-f7569b4c0c423c81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n记得之前我说过beginTime很重要么？记得那个属性要加上矫正值么？想在你完全不用考虑那个问题了。遇到要改变beginTime的动画，`直接把他丢到CAAnimationGroup里面`去，然后时间你就直接加吧，也不用矫正了，哈哈哈哈。不过呢，你也不要高兴太早，这里`有一个坑`，就是`animations数组中你的所有CAAnimaiton对象请安beginTime进行升序排列`哦，否则也是会有问题的哟。\n\nCAAnimationGroup是个好东西，简化了很多操作，同时还可以嵌套，属性还很少。\n支持并发动画演示，屌屌的。\n- - -\n\n## CATransition\n\n最后一个啦，转场动画。\n\n\t- (void)viewDidLoad {\n\t    [super viewDidLoad];\n\t    UIButton * bu = [UIButton buttonWithType:(UIButtonTypeSystem)];\n\t    [bu setBackgroundColor:[UIColor yellowColor]];\n\t    [bu setFrame:CGRectMake(200, 200, 100, 100)];\n\t    [self.view addSubview:bu];\n\t    [bu addTarget:self action:@selector(a:) forControlEvents:(UIControlEventTouchUpInside)];\n\t    self.view.backgroundColor = [UIColor grayColor];\n\t    UIImageView * redView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];\n\t    redView.backgroundColor = [UIColor redColor];\n\t    redView.image = [UIImage imageNamed:@\"2.jpeg\"];\n\t    [self.view addSubview:redView];\n\t    self.imgV = redView;    \n\t}\n\t-(void)a:(UIButton *)btn\n\t{\n\t    CATransition *animation = [CATransition animation];\n\t    animation.duration = 5;\n\t    animation.fillMode = kCAFillModeForwards;\n\t    animation.type = @\"rippleEffect\";\n\t    animation.subtype = kCATransitionFromTop;\n\t    [self.imgV.layer addAnimation:animation forKey:@\"ripple\"];\n\t    self.imgV.image = [UIImage imageNamed:@\"3.jpg\"];\n    }\n\n\n![transition](http://upload-images.jianshu.io/upload_images/1835430-34c04cf9d77613f7.gif?imageMogr2/auto-orient/strip)\n\n看到了没有这个水波效果还是挺炫的。\n这个动画有两点不同，一个是`type`,这个属性指定的是动画的主类型，有以下几种可选择的动画：\n\n- kCATransitionFade\n- kCATransitionMoveIn\n- kCATransitionPush\n- kCATransitionReveal\n\n还有一些系统私有的动画但是可以安全使用,但是你只能用字符串\n\n//@\"cube\" @\"moveIn\" @\"reveal\" @\"fade\"(default) @\"pageCurl\" @\"pageUnCurl\" @\"suckEffect\" @\"rippleEffect\" @\"oglFlip\"\n\n还有一些绝对不能使用的动画我就不放出来了\n\n另外一个属性是subType。\n有四种选项：\n\n- kCATransitionFromRight\n- kCATransitionFromLeft\n- kCATransitionFromTop\n- kCATransitionFromBottom\n\n见名知意，就是指动画的方向啦。\n\n\n不过呢，这个转场动画不好的一点是需要跟转场代码写在一起，然而官方又没有给出转场到底是什么概念。\n\n所以我目前测出来的能用的情况有，`imageView切换图片`，`控制器的push或modal`，`UIView对象调用exchangeSubviewAtIndex：WithIndex：方法`的时候可以出发转场动画，其他我真是没有测出来，有大神知道还望告知=。=十分感谢。\n\n- - -\n\n最后呢，鉴于有同学问到为什么做动画后，layer的frame还是没有发生改变，老司机翻了一下，之前真的忘了说，所以在这里补充一下。\n\n除了图层树之外，系统在内部为我们的layer维持着三分copy。渲染树、呈现树、模型树。\n图层树就是想UIView中的subview、superview一样的图层的树状逻辑。\n他在CAAnimation中的各属性值是不随着动画而实时变化的。\n\n渲染树是系统内部用来处理动画效果的一份copy。并且对我们是不公开的，我们无法调用。\n\n呈现树是动画中每一个瞬时状态的各个属性值得那份copy，他是随着动画实时改变的。可以通过layer的presentationLayer进行访问。\n\n模型树是系统内部用来表示动画目标状态的各属性值的copy，可以通过modelLayer进行访问。\n\n- - -\n\n以上呢，就是CAAnimation的基本使用方法，基于这个你还可以自己组合出很多绚丽的动画，老司机就不在在这卖弄了。\n\n- - -\n哦，老司机刚才说了，老司机写CoreAnimation的教程是有阴谋的，阴谋是什么呢？嘿嘿嘿~\n\n\n![好多动画在一起](http://upload-images.jianshu.io/upload_images/1835430-e7d2fc246edd25c7.gif?imageMogr2/auto-orient/strip)\n\n呐，这是一个老司机封装的DWAnimation，他可以轻松、优雅地帮助你生成上面的动画。(有些动画播放两次是因为demo中要展示某些属性的用处，不要在意)\n\n比如这样：\n\n\n![优雅么？](http://upload-images.jianshu.io/upload_images/1835430-04a7fd69f578b586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下面是gitHub地址：[DWAnimation](https://github.com/CodeWicky/DWAnimation)\n\n这次老司机希望如果你喜欢，给我个star吧，哈哈哈。\n\n- - -\n\n## 参考资料\n\n- [崔神写的关于CoreAnimation相关，个人认为全网最全！](http://www.cnblogs.com/kenshincui/p/3972100.html)\n\n- [CAMediaTiming的详解](http://www.cocoachina.com/programmer/20131218/7569.html)\n\n- [隐式动画和显式动画](http://www.cocoachina.com/ios/20150105/10812.html)\n\n- - -\n写在最后，有的朋友说过不喜欢我写博客的风格，呐这里我想解释一下。\n\n首先呢，不是老司机做作，老司机平时就这样，`没事就好扯咸蛋`。。\n\n再者呢，老司机写博客呢，也是纯粹`为了记录自己学习过的知识`，因为老司机自己也记不住。\n\n三呢，老司机写博客呢，是`给一些刚入门的同学写的`，因为老司机一直都是在科普一些比较寻常的东西。既然是给入门的同学讲，老司机自然是能讲多细讲多细，知无不言言无不尽。但我要一直一板一眼的说，你看不到半小时保证就难以集中精力了。所以么，老司机是需要扯淡的。\n\n四呢，由于老司机写博客都是想起来啥说啥，可能你们真要是做项目找资料的看到我的博客都嫌烦，没事的，`移步简书首页善用搜索功能`，我是给坐地铁无聊的小伙伴们打发时间写的。\n\n最后，老司机就这样，\n**你咬我啊。**\n\n\n![你咬我啊](http://upload-images.jianshu.io/upload_images/1835430-6d94ce1bd36d5f61.gif?imageMogr2/auto-orient/strip)\n\n- - -\n","slug":"老司机带你走进Core-Animation-之CAAnimation","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htpq000vjigbf1yqccu0","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-77eacb0858d3a263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之CAAnimation\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>为什么时隔这么久我又回来了呢？</p>\n<p>###回来圈粉。<br>开玩笑的，前段时间ipv6被拒啊，超级悲剧的，前后弄了好久，然后需求啊什么的又超多，所以写好的东西也没有时间整理。不过既然我现在回来了，那么这将是一个井喷的时节。（感觉给自己立下了什么死亡flag，啧啧啧）</p>\n<p>先说什么呢？说一下CAAnimation相关的吧，因为最近也刚好在研究这些东西。不过看到末尾之前，请你相信我今天讲CAAnimation绝对是有阴谋的。</p>\n<hr>\n<p>#老司机带你走进Core Animation</p>\n<p>事实上，老司机今天讲的只是核心动画（Core Animation）中的一小部分，<code>动画那部分</code>=。=</p>\n<p>开发中，有的时候我们可爱的UI妹子或者产品妹子会说（表示一下纯属个人YY）：技术哥哥，这里能不能duang的一下弹出来呢？这里能不能转个圈出现啊？这里能不能加一些炫酷的效果啊？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-07cc02042b300306.gif?imageMogr2/auto-orient/strip\" alt=\"Duang\"></p>\n<p>作为<code>高冷而又无所不能</code>的技术，能说不么？</p>\n<p>###不能！<br>然后你就硬着头皮去写动画吧。</p>\n<p>好在呢，苹果已经想到<strong><code>程序员也是要撩妹</code></strong>的这个需求，所以为我们提供了CAAnimation这个好东西，当然还贴心的帮我们又进行了一层<code>封装</code>，那就是<code>UIView得animate相关</code>的方法了。</p>\n<p>然而封装好的东西，灵活度当然会降低了。所以既然是基于<code>CAAnimation</code>的，那我们就去自己调用好了！</p>\n<p>所以呢，今天我打算说说CAAnimaiton。</p>\n<p>这篇博客中可能会涉及到什么呢？</p>\n<ul>\n<li>CALayer与UIView</li>\n<li>CAAnimation与UIView animate</li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"CALayer\"><a href=\"#CALayer\" class=\"headerlink\" title=\"CALayer\"></a>CALayer</h2><p>为什么会先说CALayer呢？以为<code>CAAimation实际上操作的都是Layer层</code>。</p>\n<p>所以不知道CALayer会很头疼的，知道的偷学去冲杯咖啡吧。</p>\n<blockquote>\n<p>The CALayer class manages image-based content and allows you to perform animations on that content. Layers are often used to provide the backing store for views but can also be used without a view to display content. A layer’s main job is to manage the visual content that you provide but the layer itself has visual attributes that can be set, such as a background color, border, and shadow. In addition to managing visual content, the layer also maintains information about the geometry of its content (such as its position, size, and transform) that is used to present that content onscreen. Modifying the properties of the layer is how you initiate animations on the layer’s content or geometry. A layer object encapsulates the duration and pacing of a layer and its animations by adopting the CAMediaTiming protocol, which defines the layer’s timing information.</p>\n<p>If the layer object was created by a view, the view typically assigns itself as the layer’s delegate automatically, and you should not change that relationship. For layers you create yourself, you can assign a delegate object and use that object to provide the contents of the layer dynamically and perform other tasks. A layer may also have a layout manager object (assigned to the layoutManager property) to manage the layout of subviews separately.</p>\n</blockquote>\n<p>这是官方文档对CALayer的解释，以老司机的英语水平翻译成人话就是：</p>\n<p>CALayer是用来<code>绘制、渲染</code>图形的。</p>\n<h3 id=\"那他与UIView又有什么区别和联系呢？\"><a href=\"#那他与UIView又有什么区别和联系呢？\" class=\"headerlink\" title=\"那他与UIView又有什么区别和联系呢？\"></a>那他与UIView又有什么区别和联系呢？</h3><p>事实上所有的UIView及其子类图形的绘制。UIView下有一个layer属性，这个layer层就是真正绘制UIView所要展示的东西的人。然而之所以要将CALayer封装成UIView则是为了给其<code>添加事件响应</code>。</p>\n<p>因为<code>CALayer</code>是继承与NSObject的，所以他是<code>不具备响应</code>的。而<code>UIView是继承与UIResponder</code>的，UIResponder本身<code>可以提供事件响应</code>，再用CALayer给他绘制一个图像，那一个具有响应事件的对象就诞生了，他就是我们的UIView。</p>\n<p>当我们创建一个UIView对象时，系统自动为我们创建一个CALayer对象,这个对象就是UIView的layer属性。</p>\n<h3 id=\"CALayer有具体有什么属性呢？\"><a href=\"#CALayer有具体有什么属性呢？\" class=\"headerlink\" title=\"CALayer有具体有什么属性呢？\"></a>CALayer有具体有什么属性呢？</h3><p>前面有说过，layer层负责绘制和渲染，那么图像的基本属性他是一定要有的。</p>\n<p>这里呢，老司机还是着重介绍一个常用和重要的属性吧。</p>\n<p>CALayer有<code>bounds，position，frame</code>的属性，他呢，其实就是UIView中bounds，center，frame的映射。事实上，我们在layer中一般只操作bounds和position两个属性。由于有着对应关系，所以这个理解起来就相对容易，我就不展开讲解了。</p>\n<p>CALayer还有一个非常重要的属性<code>anchorPoint</code>，即锚点。说起来这个概念还是真难解释，锚点就好像是体心，一个物体抽象成一个点的对象。还记得物理中的质点么？我们操作属性，比如移动，旋转，缩放等等都是以锚点作为<code>参考点</code>的。他是一个<code>CGPoint类型</code>的对象，他的<code>x、y取值范围都是0~1</code>。数值就是从锚点到layer的左上角（类比UIView的origin）的 横向/纵向 距离占layer得 width/height 的<code>比例</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b882c8aef33998c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"锚点\"></p>\n<p><code>contents</code>，寄宿图。事实上这个属性我们操作的也很少，不过还是可以解释一下的。他可以看做是<code>当前图层的背景图片</code>。就是在当前图层的背景展示一张图片。也就是说你甚至可以用一个UIView展示一张图片了，就是这样。不过你别看他的类型是id，可不代表你给他传什么对象都可以。事实上你只能传<code>CGImageRef</code>类型的数据进去。他的id类型是为了配合OS X系统的。哦，你说为什么不能传UIIamge？是这样的，<code>CALayer是在QuartzCore框架下</code>的，他是可以跨平台的，也就是在iOS和OS X上都可以，所以他当然不能让你传入UIKit下的对象了。<code>CALayer的所有属性都不能传入UIKit的对象</code>。</p>\n<p><code>transform</code>，仿射变换啦，这个东西其实挺多能讲的，那套图像变换的原理挺有意思的，不过我矩阵真的不会算了=。=延展的东西数学好的同学们自己看吧，其实想用还是挺简单的。</p>\n<p><code>cornerRadius、masksToBounds</code>。这两个属性比较常用啦，切圆角时候我们用的属性。</p>\n<p><code>opacity</code>，类比UIView的alpha。</p>\n<p><code>shadowOpacity、shadowColor、shadowPath、shadowOffset、shadowRadius</code>，这几个阴影相关的属性。这里需要注意的是<code>shadowOpacity的默认值现在是0</code>。也就是说默认效果下你是看不到任何阴影效果的，想要实现阴影想过请先<code>更改shadowOpacity为一个非0得小于等于1的值</code>。还有一点就是由于shadow是图层外的延展效果，要想看到shadow效果请<code>设置masksToBounds属性为No</code>。</p>\n<p><code>borderColor、borderWidth</code>，这是边框相关的属性。borderWidth默认值是0。</p>\n<p><code>mask</code>，这也是个有趣又有用的属性，<code>遮罩属性</code>。可以以一个layerA作为另一个layerB的遮罩，即layerB.mask = layerA。那么作为遮罩的layerA中的透明区域将被过滤掉，<code>layerB只显示layerA的非透明区域</code>。借助这个属性可以实现很多神奇的效果，比如歌词、图像展开等等。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d7eec1186a9a4349.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mask\"></p>\n<p>CALayer还有一个其他的属性，不过平时使用的也不多，老司机就不逐一介绍了，有兴趣的同学可以自行了解哈。</p>\n<p>基于CALayer的种种属性，以及CALayer还有很多子类，有了他们，我们能看到各种各样的UI控件，那我们又如何创建动画呢？</p>\n<hr>\n<h2 id=\"CAAnimation\"><a href=\"#CAAnimation\" class=\"headerlink\" title=\"CAAnimation\"></a>CAAnimation</h2><h3 id=\"CAAnimation是什么呢？\"><a href=\"#CAAnimation是什么呢？\" class=\"headerlink\" title=\"CAAnimation是什么呢？\"></a>CAAnimation是什么呢？</h3><blockquote>\n<p>CAAnimation is an abstract animation class. It provides the basic support for the CAMediaTiming and CAAction protocols. To animate Core Animation layers or Scene Kit objects, create instances of the concrete subclasses CABasicAnimation, CAKeyframeAnimation, CAAnimationGroup, or CATransition.</p>\n</blockquote>\n<p>官方对CAAnimation的描述也并不多，其实不过说的的确都很到位。<br>CAAniamtion是一个<code>抽象类</code>，遵循着CAMediaTiming和CAAciotn两个协议。通过他的<code>4个子类</code>，我们可以<code>实现很多绚丽的动画效果</code>。</p>\n<hr>\n<p>CAAnimation下有几个属性，下面逐一介绍</p>\n<p><code>timingFunction</code>，这个呢，指定的是动画的节奏。所谓节奏是什么什么意思呢？就是动画执行的快慢交替。有如下几个可选项</p>\n<ul>\n<li>kCAMediaTimingFunctionLinear//线性节奏，就是匀速</li>\n<li>kCAMediaTimingFunctionEaseIn//淡入，缓慢加速进入，然后匀速</li>\n<li>kCAMediaTimingFunctionEaseOut//淡出，匀速，然后缓慢减速移除</li>\n<li>kCAMediaTimingFunctionEaseInEaseOut//淡入淡出，结合以上两者</li>\n<li>kCAMediaTimingFunctionDefault//默认效果</li>\n</ul>\n<p><code>delegate</code>，代理。设置代理以后就会执行代理方法啦。</p>\n<ul>\n<li><p>-(void)animationDidStart:(CAAnimation *)anim;</p>\n</li>\n<li><p>-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;</p>\n</li>\n</ul>\n<p>一个是动画开始的代理，一个是动画结束的代理。</p>\n<p>值得注意的是，结束代理中，有一个flag。他的意思是如果动画正常播放完成的话，flag为YES。如果没有播放完成或者被移除则返回NO。</p>\n<p><code>removedOnCompletion</code>，是否在播放完成后移除。这是一个非常重要的属性，有的时候我们希望动画播放完成，但是保留最终的播放效果是，这个属性一定要改为NO，否则无效。</p>\n<hr>\n<p>遵循着CAMediaTiming协议，所以他自然也有duration、beginTime等一些属性。</p>\n<p><code>beginTime</code>,动画的开始时间，准确的说应该叫滞后时间。就是当你将动画加载layer中后滞后多长时间开始播放。</p>\n<blockquote>\n<p>/* The begin time of the object, in relation to its parent object, if</p>\n<ul>\n<li>applicable. Defaults to 0. */</li>\n</ul>\n</blockquote>\n<p>这个属性很重要，我想要着重讲一下。上面是beginTime属性的注释。从中我们能够看出，这个<code>beginTime是与父对象有关</code>的。</p>\n<p>由于CALayer和CAAnimation都遵循CAMediaTiming协议，所以那他都可以作为我们animation对象的父对象。</p>\n<p>如果你将animation添加在一个动画组（CAAnimationGroup）中，那么ok，你直接按照下面的写法就好了。</p>\n<pre><code>animation.beginTime = beginTime;\n</code></pre><p>但是，如果你直接添加在一个layer上，他的父对象是layer。这个layer的时间线很可能是一个过去的时间。即使你添加上beginTime得到的仍旧是一个过去的时间。那么这个时候我们的动画就会显示在动画结束时的状态。为了避免这种状况，我们要修正我们的时间。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFTimeInterval time = [layer convertTime:CACurrentMediaTime() fromLayer:nil];</div><div class=\"line\">animation.beginTime = time + beginTime;</div></pre></td></tr></table></figure>\n<p>CACurrentMediaTime()是马赫时间，是全局时间，也就是设备距离上次开机的时间。</p>\n<p>convertTime是获取本地时间。该方法有两个参数，第一个是时间，第二个是时间所对应的图层。当第二个参数为nil时，则返回的就是第一个参数的值。</p>\n<p>这样我们就能得到一个绝对时间。</p>\n<p>这里很重要，不过引申下去就远了，想了解的同学点<a href=\"http://blog.csdn.net/yaozhuoyu/article/details/9566511\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p><code>duration</code>，是动画的持续时间。简单的概念我就一笔带过了吧，同样的还有<code>repeatCount，autoreverses</code>。这些都是一些基本属性，基本看单词就知道用途了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-62f9e4502e71bbfd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"duration\"></p>\n<p><code>speed</code>，这个我也要说一下，他表示的是<code>当前对象的时间流速</code>。简单来说，如果speed是2，duration是3，那么经过1.5秒，我的动画已经播放完成了。s = v * t，s就相当于已经播放的动画，也就是长度为3个单位的动画，v相当于每秒播放多少动画，即每秒播放两个单位的动画，所以1.5秒后动画其实就播放完成了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc4299e260ddf310.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"speed\"></p>\n<p><code>timeOffset</code>,是表示我将从动画的<code>第几秒开始播放</code>。比如一个duration = 3的动画，timeOffset = 2，那么此时我的动画从第二秒开始播放，播放到第三秒动画结束的状态后，立即变为动画的初始状态，也就是第0秒的播放状态，继续播放之第二秒的状态，然后动画结束。形象的说就好像你绕操场跑圈，以前你都是<code>从起点开始跑跑一圈</code>；这回你<code>从一半开始跑</code>，但是<code>同样跑一圈</code>，过了起点就还要再跑半圈，就是这样。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d73090e071359ba4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timeOffset\"></p>\n<p>fillMode，是播放结束后的状态。他有四个枚举值</p>\n<ul>\n<li>kCAFillModeForwards//保持结束时状态</li>\n<li>kCAFillModeBackwards//保持开始时状态</li>\n<li>kCAFillModeBoth//保持两者，我没懂两者是什么概念，实际使用中<code>与kCAFillModeBackwards相同</code></li>\n<li>kCAFillModeRemoved//移除</li>\n</ul>\n<p>哦，这个属性使用的时候要设置<code>removedOnCompletion = NO</code>，否则你是看不到效果的。其实除了保持结束状态有效果，其他跟没效果也没什么区别。。可能也是我没看出来。。</p>\n<hr>\n<p>其实说实话，我也不想讲这么些属性，不过这些铺垫也不好讲。</p>\n<p>下面又到了我们最喜欢的淘宝推荐环节。不对，是代码环节。</p>\n<h2 id=\"CABasicAnimation\"><a href=\"#CABasicAnimation\" class=\"headerlink\" title=\"CABasicAnimation\"></a>CABasicAnimation</h2><p>前文说过，CAAnimation是一个抽象类，想要实现动画效果呢，是要使用其四个子类的。</p>\n<p>首先我们就介绍一下CABasicAnimation。</p>\n<p>看名字就知道，这是一个多么基础的动画啊=。=</p>\n<p>CABasicAnimation用来<code>创建基于两个状态的动画</code>，你只需要给出两个状态，一个初始状态一个终止状态，系统自动为你将中间的动画补全。</p>\n<pre><code>UIView * redView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];\nredView.backgroundColor = [UIColor redColor];\n[self.view addSubview:redView];\nCABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];\nanimaiton.removedOnCompletion = NO;\nanimaiton.fillMode = kCAFillModeForwards;\nanimaiton.duration = 2;\nanimaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n[redView.layer addAnimation:animaiton forKey:nil];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-7312aedda0c07f65.gif?imageMogr2/auto-orient/strip\" alt=\"移动\"></p>\n<p>这已经是最简单的一个动画效果了。（无视起点位置不对=。=视频录制时机总是晚）</p>\n<p>下面老司机逐句讲解一下。</p>\n<p>首先呢，我创建了一个animation对象。那个<code>keyPath</code>是什么呢？是我们要修改的属性名。那，我们要给谁做动画？老司机说过，CAAnimation都是对CALayer进行展示动画的。所以这属性当然是<code>CALayer的属性</code>了。至于那些属性改变支持动画效果呢？command + 左键点进CALayer，我们能看到CALayer的每个属性。看他的注释，是不是最后一句有一个<code>animatable</code>。对了，有这个的，<code>就是支持动画</code>的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-24721d8aad9561dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"支持动画的属性\"></p>\n<p>接下来的三句有了上面的介绍就应该很清楚了，分别是完成时不移除，完成时保持末尾状态，播放时长2秒。</p>\n<p>再往下看，我<code>给animation的toValue赋值</code>。</p>\n<p>这是在做什么呢？不知道，我们就点进去看看。</p>\n<p>这个看到有<code>toValue，fromValue，byValue</code>。<br>注释还挺多，分开看。老司机之前说过，<code>CABasicAnimation是要指定动画的初始状态和终止状态的</code>。那这三个属性就是用来指定状态的。</p>\n<ul>\n<li>from就是指定初始状态</li>\n<li>toValue就是终止状态</li>\n<li>by就是状态的增量</li>\n</ul>\n<p>这三个值呢，<code>不能全为空</code>，以为这样你就一个状态也没有指定。</p>\n<p><code>也不能全不为空</code>，因为这样你就指定了三个状态，系统也不知道选哪两个。</p>\n<p>若果你<code>指定了一个状态</code>，那系统将自动<code>以当前状态作为另一个状态</code>。</p>\n<p>若你<code>指定了两个状态</code>，则系统<code>已这两个状态作为始末状态</code>。</p>\n<p>还有一点要说的是，看属性也看的出来，这个value你是要<code>传入一个对象</code>的，所以老司机将CGPoint装在了一个NSValue中。</p>\n<p>最后一句就是将动画填入layer中了，注意这里老司机图省事就没有给key。实际开发中<code>建议开发者填写key且key不可重复</code>，因为如果涉及到检测动画播放进度或者是移除动画之类的都要填写正确的key才可以。</p>\n<p>好的，我们的动画已经初具规模了，我们一点一点完善。</p>\n<pre><code>CABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];\nanimaiton.removedOnCompletion = NO;\nanimaiton.fillMode = kCAFillModeForwards;\nanimaiton.duration = 2;\nanimaiton.beginTime = CACurrentMediaTime() + 1;\nanimaiton.repeatCount = MAXFLOAT;\nanimaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n[redView.layer addAnimation:animaiton forKey:nil];\n</code></pre><p>代码改成了这个样子，跑一下看看是什么样子。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bab04c38cdbb7b08.gif?imageMogr2/auto-orient/strip\" alt=\"延时\"></p>\n<p>我们看到我添加这延时语句，同时改变了repeatCount让他无限循环。（这里你要注意我延时语句的写法）</p>\n<p>我们再稍微改一下</p>\n<pre><code>CABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];\nanimaiton.removedOnCompletion = NO;\nanimaiton.fillMode = kCAFillModeForwards;\nanimaiton.duration = 2;\nanimaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n[redView.layer addAnimation:animaiton forKey:nil];\nanimaiton.beginTime = CACurrentMediaTime() + 1;\nanimaiton.repeatCount = MAXFLOAT;\n</code></pre><p>发现变化了么？老司机把重复和延时放在了添加动画之后，这个时候动画是什么样子的呢？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a86ec17b9a2c3a31.gif?imageMogr2/auto-orient/strip\" alt=\"调整语句顺序\"></p>\n<p>延时没有了，也不重复了，怎么回事？？？</p>\n<p>因为当你调用addAnimation：forKey：这句时，其实系统是对你传入的<code>animation进行了一次copy</code>，然后<code>把copy的这份添加在图层上</code>。这时你再改animation当然是不能更改动画效果的了。</p>\n<p><strong>这里同时也引出了一点，当你将animation加入layer层以后，你就无法再更改动画效果了。</strong></p>\n<p>其他的属性都是字面意思，老司机就不一句一句讲了。</p>\n<hr>\n<h2 id=\"CAKeyframeAnimation\"><a href=\"#CAKeyframeAnimation\" class=\"headerlink\" title=\"CAKeyframeAnimation\"></a>CAKeyframeAnimation</h2><p>刚才也忘了说了，其实CABasicAnimation和CAKeyframeAnimation都是继承自CAPropertyAnimation。看名字就知道是根据属性来展示动画的。</p>\n<p>所以CAKeyframeAnimation也是根据属性展示动画的，他与CABasicAnimation的不同点在于他可以<code>指定多个状态</code>，不局限于始末状态，这样<code>你的动画将更加灵活。</code></p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bf5c0269b3108fe8.gif?imageMogr2/auto-orient/strip\" alt=\"keyframe\"></p>\n<p>还是逐句讲一下。</p>\n<p>我先生成一个CAKeyframeAnimation对象，指定要做动画的属性。<br>然后<code>给values属性给了一个数组</code>。这什么意思呢？<code>CABasicAnimation是指定两个状态，而我们的CAKeyframeAnimation则是指定多个状态</code>，动画也的确按照我的规划移动了。</p>\n<p>其实这里你应该注意到一点，有没有发现我的红色方形最开始是看不到全部的？因为还记得<code>锚点</code>那个概念么？他的初始值是CGPointMake(0.5,0.5),<code>所有动画都是以锚点为参考点</code>，所以说你指定的状态都是相对于锚点来说的状态。当然如果有需要，你可以修改锚点来实现一些特殊的动画效果。</p>\n<p>改一下代码</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.calculationMode = kCAAnimationCubicPaced;\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0b3020d9906c97d5.gif?imageMogr2/auto-orient/strip\" alt=\"calculationMode\"></p>\n<p>我改变了<code>calculationMode</code>这个属性，有没有发现转折点出动作平滑了许多？恩，这个属性是用来改变补间动画的计算模式的。这个属性<code>是CAKeyframeAnimation独有的属性</code>。</p>\n<p>继续修改</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.keyTimes = @[@0,@0.8,@1];\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p>我去掉了calculationMode属性，添加了keyTimes属性，效果是这样的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d64671e9c70a19f9.gif?imageMogr2/auto-orient/strip\" alt=\"keyTimes\"></p>\n<p>是不是发现第一段路径速度明显比第二段慢？是因为<code>keyTimes属性指定的是当前状态节点到初始状态节点的时间占动画总时长的比例</code>。若果<code>不设置keyTimes则匀速播放</code>。</p>\n<p>Go on</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.keyTimes = @[@0,@0.8,@1];\nanimation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1fbc0c1de0032f9e.gif?imageMogr2/auto-orient/strip\" alt=\"path\"></p>\n<p>这回机智如你应该发现几个问题，第一路径变了。</p>\n<p>因为我们<code>指定了path属性</code>，所以这时<code>values属性将被忽略</code>，按照指定的path运动。（此处注意我给的是CGPathRef类型数据，为什么？还记得之前说的UIKit的事么？）</p>\n<p>第二，即使以path为运动给你好像也不太对？</p>\n<p>这是因为以path为运动轨迹后只是相当于用另一种方式填写了values属性。这是一个圆形的路径，他被分成了四个<code>子路径</code>。然而你在keyTimes中指定的时间状态只有第二个 状态到初始状态的时间比例为1，自然后面的动画就没有了。</p>\n<p>改成下面的样子就好了。</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1];\nanimation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6511471e8429dfda.gif?imageMogr2/auto-orient/strip\" alt=\"修改keyTimes\"></p>\n<p>这里呢，老司机想多嘴一句。当<code>使用path</code>这个属性时需要<code>注意这么一点</code>。就是当你使用的path是<code>两个Path拼接</code>到一起，比如一个波浪线你可以以两个半圆去模拟（当然你也可以使用二次贝塞尔曲线）。这时候其实你的动画是有<code>两个子路径的</code>。如果你<code>不设置calculationMode</code>属性的话，两个子路径之间<code>会有短暂的停顿</code>。所以这里<code>建议修改calculationMode为kCAAnimationPaced或者kCAAnimationCubicPaced</code>。这样动画将更加圆润。</p>\n<p>事实上，CAKeyframeAnimation还有一个独有的属性，<code>rotationMode</code>。这个属性的<code>默认是一个空值nil</code>。有两种可选值，<em>kCAAnimationRotateAuto</em>或者<em> kCAAnimationRotateAutoReverse</em>。如果这个属性设置成以上两个值中的任意一个，当前layer都会<code>始终保持朝向运动方向</code>，也就是跟随运动方向<code>自动旋转</code>。</p>\n<p>为什么特殊说一下这个属性呢？因为大家知道我们时常相对一个物体做旋转动画，然而我们又<code>不单纯的想以layer的中心坐旋转</code>，很多时候可能是layer的某个端点。这个时候你有三种选择：</p>\n<ul>\n<li>更改锚点</li>\n<li>更改你的layer层</li>\n<li>结合移动和转动</li>\n</ul>\n<p><code>更改锚点</code>就是将锚点移至你想旋转的旋转中心。但是其实老司机<code>不建议你修改锚点</code>。因为锚点是一个layer层的参考点。当你修改锚点以后<code>将会影响layer的所有相关属性</code>以至于造成一些你所不希望的后果。</p>\n<p><code>更改layer层</code>就是<code>扩展当前layer区域</code>，以透明区域填补空白区域，强行让你所期望的端点成为旋转中心。这个方法实在<code>笨拙</code>，<code>不优雅</code>。</p>\n<p><code>结合移动和转动</code>就是其实<code>将以端点的转动拆分成锚点的转动及锚点的弧线运动</code>去模拟端点的转动。这个方法是三者中最优雅的了，最起码不是那些取巧的方法。</p>\n<p>但是有了<code>rotationMode</code>这个属性，哈哈，这三个方法都不用了。你只需要一个<code>锚点的弧线动画</code>以及<code>rotationMode = kCAAnimationAutoRotate</code>就可以了，简单了很多吧。</p>\n<hr>\n<p>以上就是基于CAPropertyAnimation的属性动画的基本使用方法，当然这里老司机一直使用移动动画做的示例，你可以<code>更改属性，去做其他的动画都是可以的</code>。另外温馨提示，<code>二级属性也可以哦</code>。</p>\n<p>那你可能要说了，我使用过程中一般不可能只改变一个属性啊，我想两个一起改变怎么办啊？</p>\n<p>我们的衣食父母苹果怎么会没想到呢？所以他为我们提供了一个类，CAAnimationGroup。</p>\n<h2 id=\"CAAnimationGroup\"><a href=\"#CAAnimationGroup\" class=\"headerlink\" title=\"CAAnimationGroup\"></a>CAAnimationGroup</h2><p>看名字就看得出来是动画组了，他支持多个动画并发执行。</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1];\nanimation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n\nCABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@&quot;cornerRadius&quot;];\nanimation2.toValue = @50;\nanimation2.duration = 2;\nanimation2.fillMode = kCAFillModeForwards;\nanimation2.removedOnCompletion = NO;\n\nCAAnimationGroup * group = [CAAnimationGroup animation];\ngroup.duration = 2;\ngroup.fillMode = kCAFillModeForwards;\ngroup.removedOnCompletion = NO;\ngroup.animations = @[animation,animation2];\n\n[redView.layer addAnimation:group forKey:@&quot;group&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-88b254bdbaa34902.gif?imageMogr2/auto-orient/strip\" alt=\"CAAnimationGroup\"></p>\n<p>其实用法差不多，不同是的首先我<code>不需要指定属性</code>了，因为CAAnimationGroup可以播放多个属性同时变化，所以不需要指定属性。</p>\n<p>其次<code>不需要指定状态了</code>。因为CAAnimationGroup相当于多个CAAnimation动画并发执行的管理者，本身状态取决于其子动画的状态。</p>\n<p>还有一个animations属性，这个属性用于指定他的子动画。这个属性有些两点，可以说一下。我们点进去可以看到，animations是<code>装有CAAnimation对象一个的数组</code>。这句话的重点就是CAAnimationGroup也继承与CAAnimation，所以<code>CAAnimationGroup是可以嵌套</code>的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-f7569b4c0c423c81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"animations\"></p>\n<p>记得之前我说过beginTime很重要么？记得那个属性要加上矫正值么？想在你完全不用考虑那个问题了。遇到要改变beginTime的动画，<code>直接把他丢到CAAnimationGroup里面</code>去，然后时间你就直接加吧，也不用矫正了，哈哈哈哈。不过呢，你也不要高兴太早，这里<code>有一个坑</code>，就是<code>animations数组中你的所有CAAnimaiton对象请安beginTime进行升序排列</code>哦，否则也是会有问题的哟。</p>\n<p>CAAnimationGroup是个好东西，简化了很多操作，同时还可以嵌套，属性还很少。<br>支持并发动画演示，屌屌的。</p>\n<hr>\n<h2 id=\"CATransition\"><a href=\"#CATransition\" class=\"headerlink\" title=\"CATransition\"></a>CATransition</h2><p>最后一个啦，转场动画。</p>\n<pre><code>- (void)viewDidLoad {\n    [super viewDidLoad];\n    UIButton * bu = [UIButton buttonWithType:(UIButtonTypeSystem)];\n    [bu setBackgroundColor:[UIColor yellowColor]];\n    [bu setFrame:CGRectMake(200, 200, 100, 100)];\n    [self.view addSubview:bu];\n    [bu addTarget:self action:@selector(a:) forControlEvents:(UIControlEventTouchUpInside)];\n    self.view.backgroundColor = [UIColor grayColor];\n    UIImageView * redView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];\n    redView.backgroundColor = [UIColor redColor];\n    redView.image = [UIImage imageNamed:@&quot;2.jpeg&quot;];\n    [self.view addSubview:redView];\n    self.imgV = redView;    \n}\n-(void)a:(UIButton *)btn\n{\n    CATransition *animation = [CATransition animation];\n    animation.duration = 5;\n    animation.fillMode = kCAFillModeForwards;\n    animation.type = @&quot;rippleEffect&quot;;\n    animation.subtype = kCATransitionFromTop;\n    [self.imgV.layer addAnimation:animation forKey:@&quot;ripple&quot;];\n    self.imgV.image = [UIImage imageNamed:@&quot;3.jpg&quot;];\n}\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-34c04cf9d77613f7.gif?imageMogr2/auto-orient/strip\" alt=\"transition\"></p>\n<p>看到了没有这个水波效果还是挺炫的。<br>这个动画有两点不同，一个是<code>type</code>,这个属性指定的是动画的主类型，有以下几种可选择的动画：</p>\n<ul>\n<li>kCATransitionFade</li>\n<li>kCATransitionMoveIn</li>\n<li>kCATransitionPush</li>\n<li>kCATransitionReveal</li>\n</ul>\n<p>还有一些系统私有的动画但是可以安全使用,但是你只能用字符串</p>\n<p>//@”cube” @”moveIn” @”reveal” @”fade”(default) @”pageCurl” @”pageUnCurl” @”suckEffect” @”rippleEffect” @”oglFlip”</p>\n<p>还有一些绝对不能使用的动画我就不放出来了</p>\n<p>另外一个属性是subType。<br>有四种选项：</p>\n<ul>\n<li>kCATransitionFromRight</li>\n<li>kCATransitionFromLeft</li>\n<li>kCATransitionFromTop</li>\n<li>kCATransitionFromBottom</li>\n</ul>\n<p>见名知意，就是指动画的方向啦。</p>\n<p>不过呢，这个转场动画不好的一点是需要跟转场代码写在一起，然而官方又没有给出转场到底是什么概念。</p>\n<p>所以我目前测出来的能用的情况有，<code>imageView切换图片</code>，<code>控制器的push或modal</code>，<code>UIView对象调用exchangeSubviewAtIndex：WithIndex：方法</code>的时候可以出发转场动画，其他我真是没有测出来，有大神知道还望告知=。=十分感谢。</p>\n<hr>\n<p>最后呢，鉴于有同学问到为什么做动画后，layer的frame还是没有发生改变，老司机翻了一下，之前真的忘了说，所以在这里补充一下。</p>\n<p>除了图层树之外，系统在内部为我们的layer维持着三分copy。渲染树、呈现树、模型树。<br>图层树就是想UIView中的subview、superview一样的图层的树状逻辑。<br>他在CAAnimation中的各属性值是不随着动画而实时变化的。</p>\n<p>渲染树是系统内部用来处理动画效果的一份copy。并且对我们是不公开的，我们无法调用。</p>\n<p>呈现树是动画中每一个瞬时状态的各个属性值得那份copy，他是随着动画实时改变的。可以通过layer的presentationLayer进行访问。</p>\n<p>模型树是系统内部用来表示动画目标状态的各属性值的copy，可以通过modelLayer进行访问。</p>\n<hr>\n<p>以上呢，就是CAAnimation的基本使用方法，基于这个你还可以自己组合出很多绚丽的动画，老司机就不在在这卖弄了。</p>\n<hr>\n<p>哦，老司机刚才说了，老司机写CoreAnimation的教程是有阴谋的，阴谋是什么呢？嘿嘿嘿~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7d2fc246edd25c7.gif?imageMogr2/auto-orient/strip\" alt=\"好多动画在一起\"></p>\n<p>呐，这是一个老司机封装的DWAnimation，他可以轻松、优雅地帮助你生成上面的动画。(有些动画播放两次是因为demo中要展示某些属性的用处，不要在意)</p>\n<p>比如这样：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-04a7fd69f578b586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"优雅么？\"></p>\n<p>下面是gitHub地址：<a href=\"https://github.com/CodeWicky/DWAnimation\" target=\"_blank\" rel=\"external\">DWAnimation</a></p>\n<p>这次老司机希望如果你喜欢，给我个star吧，哈哈哈。</p>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><p><a href=\"http://www.cnblogs.com/kenshincui/p/3972100.html\" target=\"_blank\" rel=\"external\">崔神写的关于CoreAnimation相关，个人认为全网最全！</a></p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/programmer/20131218/7569.html\" target=\"_blank\" rel=\"external\">CAMediaTiming的详解</a></p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/ios/20150105/10812.html\" target=\"_blank\" rel=\"external\">隐式动画和显式动画</a></p>\n</li>\n</ul>\n<hr>\n<p>写在最后，有的朋友说过不喜欢我写博客的风格，呐这里我想解释一下。</p>\n<p>首先呢，不是老司机做作，老司机平时就这样，<code>没事就好扯咸蛋</code>。。</p>\n<p>再者呢，老司机写博客呢，也是纯粹<code>为了记录自己学习过的知识</code>，因为老司机自己也记不住。</p>\n<p>三呢，老司机写博客呢，是<code>给一些刚入门的同学写的</code>，因为老司机一直都是在科普一些比较寻常的东西。既然是给入门的同学讲，老司机自然是能讲多细讲多细，知无不言言无不尽。但我要一直一板一眼的说，你看不到半小时保证就难以集中精力了。所以么，老司机是需要扯淡的。</p>\n<p>四呢，由于老司机写博客都是想起来啥说啥，可能你们真要是做项目找资料的看到我的博客都嫌烦，没事的，<code>移步简书首页善用搜索功能</code>，我是给坐地铁无聊的小伙伴们打发时间写的。</p>\n<p>最后，老司机就这样，<br><strong>你咬我啊。</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6d94ce1bd36d5f61.gif?imageMogr2/auto-orient/strip\" alt=\"你咬我啊\"></p>\n<hr>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-77eacb0858d3a263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之CAAnimation\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>为什么时隔这么久我又回来了呢？</p>\n<p>###回来圈粉。<br>开玩笑的，前段时间ipv6被拒啊，超级悲剧的，前后弄了好久，然后需求啊什么的又超多，所以写好的东西也没有时间整理。不过既然我现在回来了，那么这将是一个井喷的时节。（感觉给自己立下了什么死亡flag，啧啧啧）</p>\n<p>先说什么呢？说一下CAAnimation相关的吧，因为最近也刚好在研究这些东西。不过看到末尾之前，请你相信我今天讲CAAnimation绝对是有阴谋的。</p>\n<hr>\n<p>#老司机带你走进Core Animation</p>\n<p>事实上，老司机今天讲的只是核心动画（Core Animation）中的一小部分，<code>动画那部分</code>=。=</p>\n<p>开发中，有的时候我们可爱的UI妹子或者产品妹子会说（表示一下纯属个人YY）：技术哥哥，这里能不能duang的一下弹出来呢？这里能不能转个圈出现啊？这里能不能加一些炫酷的效果啊？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-07cc02042b300306.gif?imageMogr2/auto-orient/strip\" alt=\"Duang\"></p>\n<p>作为<code>高冷而又无所不能</code>的技术，能说不么？</p>\n<p>###不能！<br>然后你就硬着头皮去写动画吧。</p>\n<p>好在呢，苹果已经想到<strong><code>程序员也是要撩妹</code></strong>的这个需求，所以为我们提供了CAAnimation这个好东西，当然还贴心的帮我们又进行了一层<code>封装</code>，那就是<code>UIView得animate相关</code>的方法了。</p>\n<p>然而封装好的东西，灵活度当然会降低了。所以既然是基于<code>CAAnimation</code>的，那我们就去自己调用好了！</p>\n<p>所以呢，今天我打算说说CAAnimaiton。</p>\n<p>这篇博客中可能会涉及到什么呢？</p>\n<ul>\n<li>CALayer与UIView</li>\n<li>CAAnimation与UIView animate</li>\n</ul>","more":"<hr>\n<h2 id=\"CALayer\"><a href=\"#CALayer\" class=\"headerlink\" title=\"CALayer\"></a>CALayer</h2><p>为什么会先说CALayer呢？以为<code>CAAimation实际上操作的都是Layer层</code>。</p>\n<p>所以不知道CALayer会很头疼的，知道的偷学去冲杯咖啡吧。</p>\n<blockquote>\n<p>The CALayer class manages image-based content and allows you to perform animations on that content. Layers are often used to provide the backing store for views but can also be used without a view to display content. A layer’s main job is to manage the visual content that you provide but the layer itself has visual attributes that can be set, such as a background color, border, and shadow. In addition to managing visual content, the layer also maintains information about the geometry of its content (such as its position, size, and transform) that is used to present that content onscreen. Modifying the properties of the layer is how you initiate animations on the layer’s content or geometry. A layer object encapsulates the duration and pacing of a layer and its animations by adopting the CAMediaTiming protocol, which defines the layer’s timing information.</p>\n<p>If the layer object was created by a view, the view typically assigns itself as the layer’s delegate automatically, and you should not change that relationship. For layers you create yourself, you can assign a delegate object and use that object to provide the contents of the layer dynamically and perform other tasks. A layer may also have a layout manager object (assigned to the layoutManager property) to manage the layout of subviews separately.</p>\n</blockquote>\n<p>这是官方文档对CALayer的解释，以老司机的英语水平翻译成人话就是：</p>\n<p>CALayer是用来<code>绘制、渲染</code>图形的。</p>\n<h3 id=\"那他与UIView又有什么区别和联系呢？\"><a href=\"#那他与UIView又有什么区别和联系呢？\" class=\"headerlink\" title=\"那他与UIView又有什么区别和联系呢？\"></a>那他与UIView又有什么区别和联系呢？</h3><p>事实上所有的UIView及其子类图形的绘制。UIView下有一个layer属性，这个layer层就是真正绘制UIView所要展示的东西的人。然而之所以要将CALayer封装成UIView则是为了给其<code>添加事件响应</code>。</p>\n<p>因为<code>CALayer</code>是继承与NSObject的，所以他是<code>不具备响应</code>的。而<code>UIView是继承与UIResponder</code>的，UIResponder本身<code>可以提供事件响应</code>，再用CALayer给他绘制一个图像，那一个具有响应事件的对象就诞生了，他就是我们的UIView。</p>\n<p>当我们创建一个UIView对象时，系统自动为我们创建一个CALayer对象,这个对象就是UIView的layer属性。</p>\n<h3 id=\"CALayer有具体有什么属性呢？\"><a href=\"#CALayer有具体有什么属性呢？\" class=\"headerlink\" title=\"CALayer有具体有什么属性呢？\"></a>CALayer有具体有什么属性呢？</h3><p>前面有说过，layer层负责绘制和渲染，那么图像的基本属性他是一定要有的。</p>\n<p>这里呢，老司机还是着重介绍一个常用和重要的属性吧。</p>\n<p>CALayer有<code>bounds，position，frame</code>的属性，他呢，其实就是UIView中bounds，center，frame的映射。事实上，我们在layer中一般只操作bounds和position两个属性。由于有着对应关系，所以这个理解起来就相对容易，我就不展开讲解了。</p>\n<p>CALayer还有一个非常重要的属性<code>anchorPoint</code>，即锚点。说起来这个概念还是真难解释，锚点就好像是体心，一个物体抽象成一个点的对象。还记得物理中的质点么？我们操作属性，比如移动，旋转，缩放等等都是以锚点作为<code>参考点</code>的。他是一个<code>CGPoint类型</code>的对象，他的<code>x、y取值范围都是0~1</code>。数值就是从锚点到layer的左上角（类比UIView的origin）的 横向/纵向 距离占layer得 width/height 的<code>比例</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b882c8aef33998c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"锚点\"></p>\n<p><code>contents</code>，寄宿图。事实上这个属性我们操作的也很少，不过还是可以解释一下的。他可以看做是<code>当前图层的背景图片</code>。就是在当前图层的背景展示一张图片。也就是说你甚至可以用一个UIView展示一张图片了，就是这样。不过你别看他的类型是id，可不代表你给他传什么对象都可以。事实上你只能传<code>CGImageRef</code>类型的数据进去。他的id类型是为了配合OS X系统的。哦，你说为什么不能传UIIamge？是这样的，<code>CALayer是在QuartzCore框架下</code>的，他是可以跨平台的，也就是在iOS和OS X上都可以，所以他当然不能让你传入UIKit下的对象了。<code>CALayer的所有属性都不能传入UIKit的对象</code>。</p>\n<p><code>transform</code>，仿射变换啦，这个东西其实挺多能讲的，那套图像变换的原理挺有意思的，不过我矩阵真的不会算了=。=延展的东西数学好的同学们自己看吧，其实想用还是挺简单的。</p>\n<p><code>cornerRadius、masksToBounds</code>。这两个属性比较常用啦，切圆角时候我们用的属性。</p>\n<p><code>opacity</code>，类比UIView的alpha。</p>\n<p><code>shadowOpacity、shadowColor、shadowPath、shadowOffset、shadowRadius</code>，这几个阴影相关的属性。这里需要注意的是<code>shadowOpacity的默认值现在是0</code>。也就是说默认效果下你是看不到任何阴影效果的，想要实现阴影想过请先<code>更改shadowOpacity为一个非0得小于等于1的值</code>。还有一点就是由于shadow是图层外的延展效果，要想看到shadow效果请<code>设置masksToBounds属性为No</code>。</p>\n<p><code>borderColor、borderWidth</code>，这是边框相关的属性。borderWidth默认值是0。</p>\n<p><code>mask</code>，这也是个有趣又有用的属性，<code>遮罩属性</code>。可以以一个layerA作为另一个layerB的遮罩，即layerB.mask = layerA。那么作为遮罩的layerA中的透明区域将被过滤掉，<code>layerB只显示layerA的非透明区域</code>。借助这个属性可以实现很多神奇的效果，比如歌词、图像展开等等。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d7eec1186a9a4349.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mask\"></p>\n<p>CALayer还有一个其他的属性，不过平时使用的也不多，老司机就不逐一介绍了，有兴趣的同学可以自行了解哈。</p>\n<p>基于CALayer的种种属性，以及CALayer还有很多子类，有了他们，我们能看到各种各样的UI控件，那我们又如何创建动画呢？</p>\n<hr>\n<h2 id=\"CAAnimation\"><a href=\"#CAAnimation\" class=\"headerlink\" title=\"CAAnimation\"></a>CAAnimation</h2><h3 id=\"CAAnimation是什么呢？\"><a href=\"#CAAnimation是什么呢？\" class=\"headerlink\" title=\"CAAnimation是什么呢？\"></a>CAAnimation是什么呢？</h3><blockquote>\n<p>CAAnimation is an abstract animation class. It provides the basic support for the CAMediaTiming and CAAction protocols. To animate Core Animation layers or Scene Kit objects, create instances of the concrete subclasses CABasicAnimation, CAKeyframeAnimation, CAAnimationGroup, or CATransition.</p>\n</blockquote>\n<p>官方对CAAnimation的描述也并不多，其实不过说的的确都很到位。<br>CAAniamtion是一个<code>抽象类</code>，遵循着CAMediaTiming和CAAciotn两个协议。通过他的<code>4个子类</code>，我们可以<code>实现很多绚丽的动画效果</code>。</p>\n<hr>\n<p>CAAnimation下有几个属性，下面逐一介绍</p>\n<p><code>timingFunction</code>，这个呢，指定的是动画的节奏。所谓节奏是什么什么意思呢？就是动画执行的快慢交替。有如下几个可选项</p>\n<ul>\n<li>kCAMediaTimingFunctionLinear//线性节奏，就是匀速</li>\n<li>kCAMediaTimingFunctionEaseIn//淡入，缓慢加速进入，然后匀速</li>\n<li>kCAMediaTimingFunctionEaseOut//淡出，匀速，然后缓慢减速移除</li>\n<li>kCAMediaTimingFunctionEaseInEaseOut//淡入淡出，结合以上两者</li>\n<li>kCAMediaTimingFunctionDefault//默认效果</li>\n</ul>\n<p><code>delegate</code>，代理。设置代理以后就会执行代理方法啦。</p>\n<ul>\n<li><p>-(void)animationDidStart:(CAAnimation *)anim;</p>\n</li>\n<li><p>-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;</p>\n</li>\n</ul>\n<p>一个是动画开始的代理，一个是动画结束的代理。</p>\n<p>值得注意的是，结束代理中，有一个flag。他的意思是如果动画正常播放完成的话，flag为YES。如果没有播放完成或者被移除则返回NO。</p>\n<p><code>removedOnCompletion</code>，是否在播放完成后移除。这是一个非常重要的属性，有的时候我们希望动画播放完成，但是保留最终的播放效果是，这个属性一定要改为NO，否则无效。</p>\n<hr>\n<p>遵循着CAMediaTiming协议，所以他自然也有duration、beginTime等一些属性。</p>\n<p><code>beginTime</code>,动画的开始时间，准确的说应该叫滞后时间。就是当你将动画加载layer中后滞后多长时间开始播放。</p>\n<blockquote>\n<p>/* The begin time of the object, in relation to its parent object, if</p>\n<ul>\n<li>applicable. Defaults to 0. */</li>\n</ul>\n</blockquote>\n<p>这个属性很重要，我想要着重讲一下。上面是beginTime属性的注释。从中我们能够看出，这个<code>beginTime是与父对象有关</code>的。</p>\n<p>由于CALayer和CAAnimation都遵循CAMediaTiming协议，所以那他都可以作为我们animation对象的父对象。</p>\n<p>如果你将animation添加在一个动画组（CAAnimationGroup）中，那么ok，你直接按照下面的写法就好了。</p>\n<pre><code>animation.beginTime = beginTime;\n</code></pre><p>但是，如果你直接添加在一个layer上，他的父对象是layer。这个layer的时间线很可能是一个过去的时间。即使你添加上beginTime得到的仍旧是一个过去的时间。那么这个时候我们的动画就会显示在动画结束时的状态。为了避免这种状况，我们要修正我们的时间。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFTimeInterval time = [layer convertTime:CACurrentMediaTime() fromLayer:nil];</div><div class=\"line\">animation.beginTime = time + beginTime;</div></pre></td></tr></table></figure>\n<p>CACurrentMediaTime()是马赫时间，是全局时间，也就是设备距离上次开机的时间。</p>\n<p>convertTime是获取本地时间。该方法有两个参数，第一个是时间，第二个是时间所对应的图层。当第二个参数为nil时，则返回的就是第一个参数的值。</p>\n<p>这样我们就能得到一个绝对时间。</p>\n<p>这里很重要，不过引申下去就远了，想了解的同学点<a href=\"http://blog.csdn.net/yaozhuoyu/article/details/9566511\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p><code>duration</code>，是动画的持续时间。简单的概念我就一笔带过了吧，同样的还有<code>repeatCount，autoreverses</code>。这些都是一些基本属性，基本看单词就知道用途了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-62f9e4502e71bbfd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"duration\"></p>\n<p><code>speed</code>，这个我也要说一下，他表示的是<code>当前对象的时间流速</code>。简单来说，如果speed是2，duration是3，那么经过1.5秒，我的动画已经播放完成了。s = v * t，s就相当于已经播放的动画，也就是长度为3个单位的动画，v相当于每秒播放多少动画，即每秒播放两个单位的动画，所以1.5秒后动画其实就播放完成了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc4299e260ddf310.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"speed\"></p>\n<p><code>timeOffset</code>,是表示我将从动画的<code>第几秒开始播放</code>。比如一个duration = 3的动画，timeOffset = 2，那么此时我的动画从第二秒开始播放，播放到第三秒动画结束的状态后，立即变为动画的初始状态，也就是第0秒的播放状态，继续播放之第二秒的状态，然后动画结束。形象的说就好像你绕操场跑圈，以前你都是<code>从起点开始跑跑一圈</code>；这回你<code>从一半开始跑</code>，但是<code>同样跑一圈</code>，过了起点就还要再跑半圈，就是这样。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d73090e071359ba4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timeOffset\"></p>\n<p>fillMode，是播放结束后的状态。他有四个枚举值</p>\n<ul>\n<li>kCAFillModeForwards//保持结束时状态</li>\n<li>kCAFillModeBackwards//保持开始时状态</li>\n<li>kCAFillModeBoth//保持两者，我没懂两者是什么概念，实际使用中<code>与kCAFillModeBackwards相同</code></li>\n<li>kCAFillModeRemoved//移除</li>\n</ul>\n<p>哦，这个属性使用的时候要设置<code>removedOnCompletion = NO</code>，否则你是看不到效果的。其实除了保持结束状态有效果，其他跟没效果也没什么区别。。可能也是我没看出来。。</p>\n<hr>\n<p>其实说实话，我也不想讲这么些属性，不过这些铺垫也不好讲。</p>\n<p>下面又到了我们最喜欢的淘宝推荐环节。不对，是代码环节。</p>\n<h2 id=\"CABasicAnimation\"><a href=\"#CABasicAnimation\" class=\"headerlink\" title=\"CABasicAnimation\"></a>CABasicAnimation</h2><p>前文说过，CAAnimation是一个抽象类，想要实现动画效果呢，是要使用其四个子类的。</p>\n<p>首先我们就介绍一下CABasicAnimation。</p>\n<p>看名字就知道，这是一个多么基础的动画啊=。=</p>\n<p>CABasicAnimation用来<code>创建基于两个状态的动画</code>，你只需要给出两个状态，一个初始状态一个终止状态，系统自动为你将中间的动画补全。</p>\n<pre><code>UIView * redView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];\nredView.backgroundColor = [UIColor redColor];\n[self.view addSubview:redView];\nCABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];\nanimaiton.removedOnCompletion = NO;\nanimaiton.fillMode = kCAFillModeForwards;\nanimaiton.duration = 2;\nanimaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n[redView.layer addAnimation:animaiton forKey:nil];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-7312aedda0c07f65.gif?imageMogr2/auto-orient/strip\" alt=\"移动\"></p>\n<p>这已经是最简单的一个动画效果了。（无视起点位置不对=。=视频录制时机总是晚）</p>\n<p>下面老司机逐句讲解一下。</p>\n<p>首先呢，我创建了一个animation对象。那个<code>keyPath</code>是什么呢？是我们要修改的属性名。那，我们要给谁做动画？老司机说过，CAAnimation都是对CALayer进行展示动画的。所以这属性当然是<code>CALayer的属性</code>了。至于那些属性改变支持动画效果呢？command + 左键点进CALayer，我们能看到CALayer的每个属性。看他的注释，是不是最后一句有一个<code>animatable</code>。对了，有这个的，<code>就是支持动画</code>的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-24721d8aad9561dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"支持动画的属性\"></p>\n<p>接下来的三句有了上面的介绍就应该很清楚了，分别是完成时不移除，完成时保持末尾状态，播放时长2秒。</p>\n<p>再往下看，我<code>给animation的toValue赋值</code>。</p>\n<p>这是在做什么呢？不知道，我们就点进去看看。</p>\n<p>这个看到有<code>toValue，fromValue，byValue</code>。<br>注释还挺多，分开看。老司机之前说过，<code>CABasicAnimation是要指定动画的初始状态和终止状态的</code>。那这三个属性就是用来指定状态的。</p>\n<ul>\n<li>from就是指定初始状态</li>\n<li>toValue就是终止状态</li>\n<li>by就是状态的增量</li>\n</ul>\n<p>这三个值呢，<code>不能全为空</code>，以为这样你就一个状态也没有指定。</p>\n<p><code>也不能全不为空</code>，因为这样你就指定了三个状态，系统也不知道选哪两个。</p>\n<p>若果你<code>指定了一个状态</code>，那系统将自动<code>以当前状态作为另一个状态</code>。</p>\n<p>若你<code>指定了两个状态</code>，则系统<code>已这两个状态作为始末状态</code>。</p>\n<p>还有一点要说的是，看属性也看的出来，这个value你是要<code>传入一个对象</code>的，所以老司机将CGPoint装在了一个NSValue中。</p>\n<p>最后一句就是将动画填入layer中了，注意这里老司机图省事就没有给key。实际开发中<code>建议开发者填写key且key不可重复</code>，因为如果涉及到检测动画播放进度或者是移除动画之类的都要填写正确的key才可以。</p>\n<p>好的，我们的动画已经初具规模了，我们一点一点完善。</p>\n<pre><code>CABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];\nanimaiton.removedOnCompletion = NO;\nanimaiton.fillMode = kCAFillModeForwards;\nanimaiton.duration = 2;\nanimaiton.beginTime = CACurrentMediaTime() + 1;\nanimaiton.repeatCount = MAXFLOAT;\nanimaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n[redView.layer addAnimation:animaiton forKey:nil];\n</code></pre><p>代码改成了这个样子，跑一下看看是什么样子。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bab04c38cdbb7b08.gif?imageMogr2/auto-orient/strip\" alt=\"延时\"></p>\n<p>我们看到我添加这延时语句，同时改变了repeatCount让他无限循环。（这里你要注意我延时语句的写法）</p>\n<p>我们再稍微改一下</p>\n<pre><code>CABasicAnimation * animaiton = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];\nanimaiton.removedOnCompletion = NO;\nanimaiton.fillMode = kCAFillModeForwards;\nanimaiton.duration = 2;\nanimaiton.toValue = [NSValue valueWithCGPoint:CGPointMake(400, 400)];\n[redView.layer addAnimation:animaiton forKey:nil];\nanimaiton.beginTime = CACurrentMediaTime() + 1;\nanimaiton.repeatCount = MAXFLOAT;\n</code></pre><p>发现变化了么？老司机把重复和延时放在了添加动画之后，这个时候动画是什么样子的呢？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a86ec17b9a2c3a31.gif?imageMogr2/auto-orient/strip\" alt=\"调整语句顺序\"></p>\n<p>延时没有了，也不重复了，怎么回事？？？</p>\n<p>因为当你调用addAnimation：forKey：这句时，其实系统是对你传入的<code>animation进行了一次copy</code>，然后<code>把copy的这份添加在图层上</code>。这时你再改animation当然是不能更改动画效果的了。</p>\n<p><strong>这里同时也引出了一点，当你将animation加入layer层以后，你就无法再更改动画效果了。</strong></p>\n<p>其他的属性都是字面意思，老司机就不一句一句讲了。</p>\n<hr>\n<h2 id=\"CAKeyframeAnimation\"><a href=\"#CAKeyframeAnimation\" class=\"headerlink\" title=\"CAKeyframeAnimation\"></a>CAKeyframeAnimation</h2><p>刚才也忘了说了，其实CABasicAnimation和CAKeyframeAnimation都是继承自CAPropertyAnimation。看名字就知道是根据属性来展示动画的。</p>\n<p>所以CAKeyframeAnimation也是根据属性展示动画的，他与CABasicAnimation的不同点在于他可以<code>指定多个状态</code>，不局限于始末状态，这样<code>你的动画将更加灵活。</code></p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bf5c0269b3108fe8.gif?imageMogr2/auto-orient/strip\" alt=\"keyframe\"></p>\n<p>还是逐句讲一下。</p>\n<p>我先生成一个CAKeyframeAnimation对象，指定要做动画的属性。<br>然后<code>给values属性给了一个数组</code>。这什么意思呢？<code>CABasicAnimation是指定两个状态，而我们的CAKeyframeAnimation则是指定多个状态</code>，动画也的确按照我的规划移动了。</p>\n<p>其实这里你应该注意到一点，有没有发现我的红色方形最开始是看不到全部的？因为还记得<code>锚点</code>那个概念么？他的初始值是CGPointMake(0.5,0.5),<code>所有动画都是以锚点为参考点</code>，所以说你指定的状态都是相对于锚点来说的状态。当然如果有需要，你可以修改锚点来实现一些特殊的动画效果。</p>\n<p>改一下代码</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.calculationMode = kCAAnimationCubicPaced;\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0b3020d9906c97d5.gif?imageMogr2/auto-orient/strip\" alt=\"calculationMode\"></p>\n<p>我改变了<code>calculationMode</code>这个属性，有没有发现转折点出动作平滑了许多？恩，这个属性是用来改变补间动画的计算模式的。这个属性<code>是CAKeyframeAnimation独有的属性</code>。</p>\n<p>继续修改</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.keyTimes = @[@0,@0.8,@1];\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p>我去掉了calculationMode属性，添加了keyTimes属性，效果是这样的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d64671e9c70a19f9.gif?imageMogr2/auto-orient/strip\" alt=\"keyTimes\"></p>\n<p>是不是发现第一段路径速度明显比第二段慢？是因为<code>keyTimes属性指定的是当前状态节点到初始状态节点的时间占动画总时长的比例</code>。若果<code>不设置keyTimes则匀速播放</code>。</p>\n<p>Go on</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.keyTimes = @[@0,@0.8,@1];\nanimation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1fbc0c1de0032f9e.gif?imageMogr2/auto-orient/strip\" alt=\"path\"></p>\n<p>这回机智如你应该发现几个问题，第一路径变了。</p>\n<p>因为我们<code>指定了path属性</code>，所以这时<code>values属性将被忽略</code>，按照指定的path运动。（此处注意我给的是CGPathRef类型数据，为什么？还记得之前说的UIKit的事么？）</p>\n<p>第二，即使以path为运动给你好像也不太对？</p>\n<p>这是因为以path为运动轨迹后只是相当于用另一种方式填写了values属性。这是一个圆形的路径，他被分成了四个<code>子路径</code>。然而你在keyTimes中指定的时间状态只有第二个 状态到初始状态的时间比例为1，自然后面的动画就没有了。</p>\n<p>改成下面的样子就好了。</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1];\nanimation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n[redView.layer addAnimation:animation forKey:@&quot;keyframe&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6511471e8429dfda.gif?imageMogr2/auto-orient/strip\" alt=\"修改keyTimes\"></p>\n<p>这里呢，老司机想多嘴一句。当<code>使用path</code>这个属性时需要<code>注意这么一点</code>。就是当你使用的path是<code>两个Path拼接</code>到一起，比如一个波浪线你可以以两个半圆去模拟（当然你也可以使用二次贝塞尔曲线）。这时候其实你的动画是有<code>两个子路径的</code>。如果你<code>不设置calculationMode</code>属性的话，两个子路径之间<code>会有短暂的停顿</code>。所以这里<code>建议修改calculationMode为kCAAnimationPaced或者kCAAnimationCubicPaced</code>。这样动画将更加圆润。</p>\n<p>事实上，CAKeyframeAnimation还有一个独有的属性，<code>rotationMode</code>。这个属性的<code>默认是一个空值nil</code>。有两种可选值，<em>kCAAnimationRotateAuto</em>或者<em> kCAAnimationRotateAutoReverse</em>。如果这个属性设置成以上两个值中的任意一个，当前layer都会<code>始终保持朝向运动方向</code>，也就是跟随运动方向<code>自动旋转</code>。</p>\n<p>为什么特殊说一下这个属性呢？因为大家知道我们时常相对一个物体做旋转动画，然而我们又<code>不单纯的想以layer的中心坐旋转</code>，很多时候可能是layer的某个端点。这个时候你有三种选择：</p>\n<ul>\n<li>更改锚点</li>\n<li>更改你的layer层</li>\n<li>结合移动和转动</li>\n</ul>\n<p><code>更改锚点</code>就是将锚点移至你想旋转的旋转中心。但是其实老司机<code>不建议你修改锚点</code>。因为锚点是一个layer层的参考点。当你修改锚点以后<code>将会影响layer的所有相关属性</code>以至于造成一些你所不希望的后果。</p>\n<p><code>更改layer层</code>就是<code>扩展当前layer区域</code>，以透明区域填补空白区域，强行让你所期望的端点成为旋转中心。这个方法实在<code>笨拙</code>，<code>不优雅</code>。</p>\n<p><code>结合移动和转动</code>就是其实<code>将以端点的转动拆分成锚点的转动及锚点的弧线运动</code>去模拟端点的转动。这个方法是三者中最优雅的了，最起码不是那些取巧的方法。</p>\n<p>但是有了<code>rotationMode</code>这个属性，哈哈，这三个方法都不用了。你只需要一个<code>锚点的弧线动画</code>以及<code>rotationMode = kCAAnimationAutoRotate</code>就可以了，简单了很多吧。</p>\n<hr>\n<p>以上就是基于CAPropertyAnimation的属性动画的基本使用方法，当然这里老司机一直使用移动动画做的示例，你可以<code>更改属性，去做其他的动画都是可以的</code>。另外温馨提示，<code>二级属性也可以哦</code>。</p>\n<p>那你可能要说了，我使用过程中一般不可能只改变一个属性啊，我想两个一起改变怎么办啊？</p>\n<p>我们的衣食父母苹果怎么会没想到呢？所以他为我们提供了一个类，CAAnimationGroup。</p>\n<h2 id=\"CAAnimationGroup\"><a href=\"#CAAnimationGroup\" class=\"headerlink\" title=\"CAAnimationGroup\"></a>CAAnimationGroup</h2><p>看名字就看得出来是动画组了，他支持多个动画并发执行。</p>\n<pre><code>CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];\nanimation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]];\nanimation.duration = 2;\nanimation.removedOnCompletion = NO;\nanimation.fillMode = kCAFillModeForwards;\nanimation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1];\nanimation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath;\n\nCABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@&quot;cornerRadius&quot;];\nanimation2.toValue = @50;\nanimation2.duration = 2;\nanimation2.fillMode = kCAFillModeForwards;\nanimation2.removedOnCompletion = NO;\n\nCAAnimationGroup * group = [CAAnimationGroup animation];\ngroup.duration = 2;\ngroup.fillMode = kCAFillModeForwards;\ngroup.removedOnCompletion = NO;\ngroup.animations = @[animation,animation2];\n\n[redView.layer addAnimation:group forKey:@&quot;group&quot;];\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-88b254bdbaa34902.gif?imageMogr2/auto-orient/strip\" alt=\"CAAnimationGroup\"></p>\n<p>其实用法差不多，不同是的首先我<code>不需要指定属性</code>了，因为CAAnimationGroup可以播放多个属性同时变化，所以不需要指定属性。</p>\n<p>其次<code>不需要指定状态了</code>。因为CAAnimationGroup相当于多个CAAnimation动画并发执行的管理者，本身状态取决于其子动画的状态。</p>\n<p>还有一个animations属性，这个属性用于指定他的子动画。这个属性有些两点，可以说一下。我们点进去可以看到，animations是<code>装有CAAnimation对象一个的数组</code>。这句话的重点就是CAAnimationGroup也继承与CAAnimation，所以<code>CAAnimationGroup是可以嵌套</code>的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-f7569b4c0c423c81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"animations\"></p>\n<p>记得之前我说过beginTime很重要么？记得那个属性要加上矫正值么？想在你完全不用考虑那个问题了。遇到要改变beginTime的动画，<code>直接把他丢到CAAnimationGroup里面</code>去，然后时间你就直接加吧，也不用矫正了，哈哈哈哈。不过呢，你也不要高兴太早，这里<code>有一个坑</code>，就是<code>animations数组中你的所有CAAnimaiton对象请安beginTime进行升序排列</code>哦，否则也是会有问题的哟。</p>\n<p>CAAnimationGroup是个好东西，简化了很多操作，同时还可以嵌套，属性还很少。<br>支持并发动画演示，屌屌的。</p>\n<hr>\n<h2 id=\"CATransition\"><a href=\"#CATransition\" class=\"headerlink\" title=\"CATransition\"></a>CATransition</h2><p>最后一个啦，转场动画。</p>\n<pre><code>- (void)viewDidLoad {\n    [super viewDidLoad];\n    UIButton * bu = [UIButton buttonWithType:(UIButtonTypeSystem)];\n    [bu setBackgroundColor:[UIColor yellowColor]];\n    [bu setFrame:CGRectMake(200, 200, 100, 100)];\n    [self.view addSubview:bu];\n    [bu addTarget:self action:@selector(a:) forControlEvents:(UIControlEventTouchUpInside)];\n    self.view.backgroundColor = [UIColor grayColor];\n    UIImageView * redView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];\n    redView.backgroundColor = [UIColor redColor];\n    redView.image = [UIImage imageNamed:@&quot;2.jpeg&quot;];\n    [self.view addSubview:redView];\n    self.imgV = redView;    \n}\n-(void)a:(UIButton *)btn\n{\n    CATransition *animation = [CATransition animation];\n    animation.duration = 5;\n    animation.fillMode = kCAFillModeForwards;\n    animation.type = @&quot;rippleEffect&quot;;\n    animation.subtype = kCATransitionFromTop;\n    [self.imgV.layer addAnimation:animation forKey:@&quot;ripple&quot;];\n    self.imgV.image = [UIImage imageNamed:@&quot;3.jpg&quot;];\n}\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-34c04cf9d77613f7.gif?imageMogr2/auto-orient/strip\" alt=\"transition\"></p>\n<p>看到了没有这个水波效果还是挺炫的。<br>这个动画有两点不同，一个是<code>type</code>,这个属性指定的是动画的主类型，有以下几种可选择的动画：</p>\n<ul>\n<li>kCATransitionFade</li>\n<li>kCATransitionMoveIn</li>\n<li>kCATransitionPush</li>\n<li>kCATransitionReveal</li>\n</ul>\n<p>还有一些系统私有的动画但是可以安全使用,但是你只能用字符串</p>\n<p>//@”cube” @”moveIn” @”reveal” @”fade”(default) @”pageCurl” @”pageUnCurl” @”suckEffect” @”rippleEffect” @”oglFlip”</p>\n<p>还有一些绝对不能使用的动画我就不放出来了</p>\n<p>另外一个属性是subType。<br>有四种选项：</p>\n<ul>\n<li>kCATransitionFromRight</li>\n<li>kCATransitionFromLeft</li>\n<li>kCATransitionFromTop</li>\n<li>kCATransitionFromBottom</li>\n</ul>\n<p>见名知意，就是指动画的方向啦。</p>\n<p>不过呢，这个转场动画不好的一点是需要跟转场代码写在一起，然而官方又没有给出转场到底是什么概念。</p>\n<p>所以我目前测出来的能用的情况有，<code>imageView切换图片</code>，<code>控制器的push或modal</code>，<code>UIView对象调用exchangeSubviewAtIndex：WithIndex：方法</code>的时候可以出发转场动画，其他我真是没有测出来，有大神知道还望告知=。=十分感谢。</p>\n<hr>\n<p>最后呢，鉴于有同学问到为什么做动画后，layer的frame还是没有发生改变，老司机翻了一下，之前真的忘了说，所以在这里补充一下。</p>\n<p>除了图层树之外，系统在内部为我们的layer维持着三分copy。渲染树、呈现树、模型树。<br>图层树就是想UIView中的subview、superview一样的图层的树状逻辑。<br>他在CAAnimation中的各属性值是不随着动画而实时变化的。</p>\n<p>渲染树是系统内部用来处理动画效果的一份copy。并且对我们是不公开的，我们无法调用。</p>\n<p>呈现树是动画中每一个瞬时状态的各个属性值得那份copy，他是随着动画实时改变的。可以通过layer的presentationLayer进行访问。</p>\n<p>模型树是系统内部用来表示动画目标状态的各属性值的copy，可以通过modelLayer进行访问。</p>\n<hr>\n<p>以上呢，就是CAAnimation的基本使用方法，基于这个你还可以自己组合出很多绚丽的动画，老司机就不在在这卖弄了。</p>\n<hr>\n<p>哦，老司机刚才说了，老司机写CoreAnimation的教程是有阴谋的，阴谋是什么呢？嘿嘿嘿~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7d2fc246edd25c7.gif?imageMogr2/auto-orient/strip\" alt=\"好多动画在一起\"></p>\n<p>呐，这是一个老司机封装的DWAnimation，他可以轻松、优雅地帮助你生成上面的动画。(有些动画播放两次是因为demo中要展示某些属性的用处，不要在意)</p>\n<p>比如这样：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-04a7fd69f578b586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"优雅么？\"></p>\n<p>下面是gitHub地址：<a href=\"https://github.com/CodeWicky/DWAnimation\" target=\"_blank\" rel=\"external\">DWAnimation</a></p>\n<p>这次老司机希望如果你喜欢，给我个star吧，哈哈哈。</p>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><p><a href=\"http://www.cnblogs.com/kenshincui/p/3972100.html\" target=\"_blank\" rel=\"external\">崔神写的关于CoreAnimation相关，个人认为全网最全！</a></p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/programmer/20131218/7569.html\" target=\"_blank\" rel=\"external\">CAMediaTiming的详解</a></p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/ios/20150105/10812.html\" target=\"_blank\" rel=\"external\">隐式动画和显式动画</a></p>\n</li>\n</ul>\n<hr>\n<p>写在最后，有的朋友说过不喜欢我写博客的风格，呐这里我想解释一下。</p>\n<p>首先呢，不是老司机做作，老司机平时就这样，<code>没事就好扯咸蛋</code>。。</p>\n<p>再者呢，老司机写博客呢，也是纯粹<code>为了记录自己学习过的知识</code>，因为老司机自己也记不住。</p>\n<p>三呢，老司机写博客呢，是<code>给一些刚入门的同学写的</code>，因为老司机一直都是在科普一些比较寻常的东西。既然是给入门的同学讲，老司机自然是能讲多细讲多细，知无不言言无不尽。但我要一直一板一眼的说，你看不到半小时保证就难以集中精力了。所以么，老司机是需要扯淡的。</p>\n<p>四呢，由于老司机写博客都是想起来啥说啥，可能你们真要是做项目找资料的看到我的博客都嫌烦，没事的，<code>移步简书首页善用搜索功能</code>，我是给坐地铁无聊的小伙伴们打发时间写的。</p>\n<p>最后，老司机就这样，<br><strong>你咬我啊。</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6d94ce1bd36d5f61.gif?imageMogr2/auto-orient/strip\" alt=\"你咬我啊\"></p>\n<hr>"},{"title":"老司机带你走进Core Animation 之CADisplayLink","layout":"post","date":"2016-09-20T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n\n\n![老司机带你走进Core Animation 之CADisplayLink](http://upload-images.jianshu.io/upload_images/1835430-107159f2337784d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n\n今天说点啥呢？上次老司机说过，带你走进CoreAnimation，那今天就趁热打铁，继续讲讲核心动画相关的东西吧。那今天要讲的就是CADisplayLink。\n\n这篇文章会涉及到什么呢？\n\n- CADisplayLink的基本使用方法\n- OC中的三种定时器：CADisplayLink、NSTimer、GCD\n- runloop浅析\n\n<!-- more -->\n\n- - -\n### CADisplayLink\n\n点进CADisplayLink的头文件我们能看到，其实他的方法并不多，而且他的功能很单一，就是作为一个`定时器`的存在。\n\n不过既然苹果专门提供了这么一个类，就一定是有他的存在意义的。他的优势就在于他的执行频率是`根据设备屏幕的刷新频率来计算`的。换句话讲，他也是`时间间隔最准确`的定时器。\n\n还是在使用中介绍吧。\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];        \n    self.view.backgroundColor = [UIColor grayColor];\n    ///target selector 模式初始化一个实例\n    self.timerInC = [CADisplayLink displayLinkWithTarget:self selector:@selector(changeImg)];\n    ///暂停\n    self.timerInC.paused = YES;\n    ///selector触发间隔\n    self.timerInC.frameInterval = 2;\n    \n    self.imgV = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];\n    self.imgV.contentMode = UIViewContentModeScaleAspectFill;\n    self.imgV.center = self.view.center;\n    [self.view addSubview:self.imgV];\n    \n    ///加入一个runLoop\n    [self.timerInC addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];\n    \n    UIButton * button = [UIButton buttonWithType:(UIButtonTypeSystem)];\n    [button setFrame:CGRectMake(0, 0, 100, 30)];\n    button.center = CGPointMake(self.view.center.x, self.view.center.y + 200);\n    [self.view addSubview:button];\n    [button setTitle:@\"开始播放\" forState:(UIControlStateNormal)];\n    [button setBackgroundColor:[UIColor whiteColor]];\n    [button addTarget:self action:@selector(gifAction) forControlEvents:(UIControlEventTouchUpInside)];\n}\n-(void)changeImg\n{\n    self.currentIndex ++;\n    if (self.currentIndex > 75) {\n        self.currentIndex = 1;\n    }\n    self.imgV.image = [UIImage imageNamed:[NSString stringWithFormat:@\"%ld.jpg\",self.currentIndex]];\n}\n\n-(void)gifAction\n{\n    self.timerInC.paused = !self.timerInC.paused;\n}\n\n```\n\n\n![CADisplayTimer](http://upload-images.jianshu.io/upload_images/1835430-8a5d35d64ec667cf.gif?imageMogr2/auto-orient/strip)\n\n我们可以从头文件中看到，苹果只提供了一个生成实例的接口。\n\n>+(CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;\n\n通过这个方法，可以以target/selector模式`生成一个绑定了触发事件的实例`。参数target、selector可以类比button，我就不做具体讲解了。\n\n然而你只生成一个实例你的事件是`不会被触发`的，这是因为你没有`把他加入到runloop`当中。\n\n>-(void)addToRunLoop:(NSRunLoop \\*)runloop forMode:(NSString \\*)mode;\n\n你可以调用这个方法将实例加入到一个选定的runloop中，这时我们的事件就能被触发了。\n\n>-(void)removeFromRunLoop:(NSRunLoop \\*)runloop forMode:(NSString \\*)mode;\n\n有添加当然会有移除，当你要从某个runloop中移除当前实例的时候你可以调用上面的方法。\n\n类比NSTimer，CADisplayLink也有一个计时器销毁的方法：\n\n>-(void)invalidate;\n\n调用这个方法，会`从所有runLoop中移除当前实例`，这个方法可以用于不需要计时器后对他进行释放前的操作。\n\n好吧，CADisplayLink就这四个方法。以及四个属性：\n\n- `timestamp`，获取上一次selector被执行的时间戳。这个属性是一个`只读属性`，而且你要记住的是只有`当selector被执行过一次之后`这个值才会被取到有效值。这个属性同上是用来比较当前图层时间与上一次selector执行时间只差，从而来计`算本次UI应该发生的改变的进度`（例如视图做移动效果）。\n\n- `duration`，获取当前设备的屏幕刷新时间间隔。同timestamp一样，他也是个只读属性，并且也需要selector触发一次才可以取值。值的一提的是，当前iOS设备的刷新频率都是60HZ。也就是说`每16.7ms刷新一次`。作用也与timestamp相同，都可以用于辅助计算。不过需要说明的一点是，如果`CPU过于繁忙`，duration的值是会`浮动的`。\n\n- `paused`，看名字就能看出来，是控制计时器暂停与恢复的属性。设置为YES的时候会暂停事件的触发。\n\n- `frameInterval`，事件触发间隔。是指两次selector触发之间间隔几次屏幕刷新，`默认值为1`，也就是说屏幕`每刷新一次，执行一次`selector，这个也可以间接用来`控制动画速度`。\n\n两次selector触发的时间间隔是time = frameInterVal * duration。必须注意的是，`selector执行所需要的时间一定要小于其触发间隔，否则会造成掉帧情况`。\n\n总体来说，CADisplayLink的使用还是比较简单的。\n\n- - -\n### 三种定时器的优势与劣势\n#### CADisplayLink\n基本用法上文刚刚介绍过。\n\n优势：依托于设备屏幕刷新频率触发事件，所以其触发时间上是最准确的。也是`最适合做UI不断刷新的事件`，过渡相对流畅，无卡顿感。\n\n缺点：\n\n- 由于依托于屏幕刷新频率，若果CPU不堪重负而影响了屏幕刷新，那么我们的触发事件也会受到相应影响。\n- selector触发的时间间隔只能是duration的整倍数。\n- selector事件如果大于其触发间隔就会造成掉帧现象。\n- CADisplayLink不能被继承。\n\n- - -\n#### NSTimer\n基本用法：\n\n```\nself.timerInN = [NSTimer timerWithTimeInterval:0.032 target:self selector:@selector(changeImg) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:self.timerInN forMode:NSRunLoopCommonModes];\n```\n\nNSTimer的使用方法也相对简单。\n\n首先，有5个方法可以为我们提供NSTimer实例。\n分三类，以timer开头的两个类方法，以schedule开头的两个类方法以及以init开头的一个实例方法。\n\n以timer开头的两个类方法是`灵活度最高`的两个方法。这两个方法的不同点在于绑定事件的方式。一个使用NSInvocation进行转发消息，一个使用target/selector模式绑定事件。总之就是绑定timer的触发事件，这里不做展开讲解。\n\n后面两个参数分别是用户参数以及重复模式。\n\n但是`单单生成了实例还是不会触发我们的事件`，像CADisplayLink一样我们也需要将他`加入到runloop中`,之后就可以触发我们的事件了。\n\n只要是`使用NSTimer就一定要加入到runloop`中才可以触发我们的事件，你可能会说schedule开头那两个类方法就不用添加runloop，这其实是个错觉，是`系统为你将timer添加到了currentRunLoop中，defaultModel`。\n\n最后一个init开头的实例方法就是给timer添加了一个定时启动，这里就不赘述了。\n\nNSTimer还有两个实例方法，`fire和invalid`。分别是立即执行事件和销毁timer。这两个方法比较重要，稍后我会着重讲解一下。\n\n接着说一下他的五个属性。\n\n- `fireDate`，设置当前timer的事件的触发时间。通常我们使用这个属性来做`计时器的暂停与恢复`。\n\n```\n///暂停计时器\nself.timer.fireDate = [NSDate distantFuture];\n///恢复计时器\nself.timer.fireDate = [NSDate distantPast];\n```\n\n- timeInterval,只读属性，获取`当前timer的事件的触发间隔`。\n\n- tolerance，`允许误差时间`。我们知道`NSTimer事件的触发事件是不准确的`，完全`取决于当前runloop`处理的时间。如果当前runloop在`处理复杂运算`，则timer执行时间`将会被推迟`，直到复杂`运算结束后立即执行触发事件`，之后`再按照初始设置的节奏去执行`。当设置tolerance之后在允许范围内的延迟可以触发事件，超过的则不触发。关于tolerance的设置，苹果有这么一段介绍：\n\n>  As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.\n\n翻译成人话就是苹果给了你一个设置`tolerance的参考值`，就是`timeInterval的十分之一`。\n\n- valid，只读属性，获取当前timer是否有效。\n- userInfo，用户参数，在初始化的时候传入的用户参数。\n\n\n说到这里其实NSTimer也就基本介绍完成了，不过老司机还是想着重讲一下NSTimer。\n\n- 关于fire方法\n> You can use this method to fire a repeating timer without interrupting its regular firing schedule. If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.\n\n网上很多人对fire方法的解释其实并不正确。`fire并不是立即激活定时器，而是立即执行一次定时器方法`。当加入到`runloop中timer不需要激活`即可按照设定的时间触发事件。fire只是相当于`手动让timer触发一次事件`。如果timer设置的`repeat为NO，则fire之后timer立即销毁`。如果timer的`repeat为YES`，则到了之前设置的时间他依旧会`按部就班的触发事件`。`fire只是单独触发了一次事件，并不影响原timer的节奏`。\n\n\n![fire](http://upload-images.jianshu.io/upload_images/1835430-fbd2dbc274695136.gif?imageMogr2/auto-orient/strip)\n\n如上图，默认情况且，根据我写的代码，timerB是不会执行的，应为当前mode并不正确（后面会说）。但是当我点击button也就是执行fire方法时，我们看到timerB响应了事件。\n\n- 关于invalid方法\n\n我们知道NSTimer使用的时候如果不注意的话，是`会造成内存泄漏的`。原因是我们生成实例的时候，会对控制器retain一下。如果不对其进行管理则VC的永远不会引用计数为零，进而造成内存泄漏。\n\n所以，当我们不需要的timer的时候，请如下操作：\n\n```\n[self.timer invalid];\nself.timer = nil;\n```\n\n这样Timer会对VC进行一次release。`所以一定不要忘记调用invalid方法`。\n\n顺便提一句，如果生成timer实例的时候`repeat为NO`，那当触发事件结束后，`系统也会自动调用invalid一次`。\n\n- 关于runloop\n\n有时我们将timer添加到runloop中，而依旧不触发事件。这时候我们应该考虑我们添加到的runloop是否是活跃的runloop。`只有成为活跃的runloop，才会执行runloop中的资源`。\n\n\n![非活跃runloop](http://upload-images.jianshu.io/upload_images/1835430-4411f0d4977e0e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 关于mode\n\n即使是目标runloop为活跃runloop依然可能不执行，这时候就要考虑目标runloop是否处于我们指定的mode。`如果不是我们指定的mode，依然不会执行我们的方法`。\n\n\n![非指定runloopMode](http://upload-images.jianshu.io/upload_images/1835430-664464b0b1457459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们看到，我将timerB加入到UITrackingRunLoopMode模式中，默认我们的timerB是不会执行的。因为默认情况下runloop是处于NSDefaultRunLoopMode中的。当scrollView及其子类滚动的时候，runloop会自动切换为追踪模式（UITrackingRunLoopMode）。这是我们的计时器就会工作了。\n\n\n![切换为正确的Mode](http://upload-images.jianshu.io/upload_images/1835430-dcc29ab0c73b71b6.gif?imageMogr2/auto-orient/strip)\n\n那我们来说一下runloop的几种mode：\n\n- Default模式\n \n定义：`NSDefaultRunLoopMode` (Cocoa) kCFRunLoopDefaultMode (Core Foundation)\n\n描述：默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式。\n\n- Connection模式\n\n定义：NSConnectionReplyMode(Cocoa)\n\n描述：处理NSConnection对象相关事件，系统内部使用，用户基本不会使用。\n\n- Modal模式\n\n定义：NSModalPanelRunLoopMode(Cocoa)\n\n描述：处理modal panels事件。\n\n- Event tracking模式\n\n定义：`UITrackingRunLoopMode`(iOS) \nNSEventTrackingRunLoopMode(cocoa)\n\n描述：在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。\n\n- Common模式\n\n定义：`NSRunLoopCommonModes` (Cocoa) kCFRunLoopCommonModes (Core Foundation)\n\n描述：这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.可使用CFRunLoopAddCommonMode方法想Common Modes中添加自定义modes。\n\n**注：iOS中仅NSDefaultRunLoopMode，UITrackingRunLoopMode，NSRunLoopCommonModes三种可用mode。**\n\n你们知道苹果手机为什么崛起的这么快么？第一是因为他是诺基亚年代唯一能与塞班并肩的`智能系统`（毕竟当时用黑莓的很少），当时还没有安卓。第二就是他的`流畅的UI`。\n\n为什么他可以做到UI如德芙一样纵享丝滑呢？因为它赋予了UI极高的地位。全局仅有一条主线程，用来刷新UI。需要不断重绘的scrollView及其子类，享有一个专用的runloopMode，UITrackingRunLoopMode。`当scrollView发生滚动时`，`当前runloop会切换为UITrackingRunLoopMode`。所以正如上面提到过的，如果你的定时器加到NSDefaultRunLoopMode中那么滚动的时候，计时器动作就停止了。这时，你需要`将timer加载NSRunLoopCommonModes`中，才能保证滚动与停止时你的timer都会触发事件。这个对于你的轮播图可是很有用的哦。\n\n这里由于篇幅限制，我并不能展开讲解runloop及mode，建议大家去[这里看看](http://www.cnblogs.com/smileEvday/archive/2012/12/21/NSTimer.html)。\n\nNSTimer的优势：使用相对灵活，应用广泛\n\n劣势：受runloop影响严重，同时易造成内存泄漏（调用invalid方法解决）\n\n- - -\n#### dispatch_source_t\n\n其实说dispatch_source_t是timer这样是狭隘的。dispatch_source_t是GCD为我们预留的`源`类型对象。\n\nGCD方法众多，而且各种牛逼的应用，老司机也并不能玩转GCD，所以这里还是主要讲解一下GCD中Timer的用法吧。\n\n```\nself.timerInG = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n            dispatch_source_set_timer(self.timerInG,  dispatch_walltime(NULL,0 * NSEC_PER_SEC), 0.032 * NSEC_PER_SEC, 0);\n            dispatch_source_set_event_handler(self.timerInG, ^{\n                [self changeImg];\n            });\n```\n- dispatch_source_create（,,,） \n\n这个方法用于返回一个dispatch_source_t对象。第一个参数为源类型，最后一个参数为资源要加入的队列。\n\n- dispatch_source_set_timer(,,,)\n\n这个方法用来设置我们timer的相关信息。第一个参数是我们的timer对象，第二个是timer事件首次触发的延迟时间，第三个参数是timer时间触发的时间间隔，最后一个参数是timer触发的允许延迟值。类比NSTimer的tolerance。建议值也是十分之一。\n\n- dispatch_source_set_event_handler（,）\n\n这个方法用来设置timer的触发事件。第一个参数为Timer对象，第二个为回调block。\n\n- dispatch_resume()\n\n用来激活源对象\n\n- dispatch_suspend()\n\n用来暂停源对象\n\n- dispatch_source_cancel()\n\n用来销毁定时器。\n\n另外需要注意的是，dispatch_source_t  一定要被设置为成员变量，否则将会立即被释放。\n\n关于GCD的timer使用起来相对简单，不过，其实操作不当的话也会造成`内存泄漏`！\n\n`处于挂起`（也就是掉用过 dispatch_suspend()）`的源是不能释放的`。这样就会造成内存泄漏。\n所以建议控制器添加一个标识符，记录源是否处于挂起状态，`在dealloc事件中判断当前源是否被挂起，如果被挂起，则resume，即可解决内存泄漏问题`。`同时如果某个源挂起后不需要恢复则直接调用dispatch_source_cancel销毁就好`。\n\nGCDTimer的优势：不`受当前runloopMode的`影响。\n劣势：虽然说不受runloopMode的影响，但是其计时效应仍`不是百分之百准确的。另外，他的触发事件也有可能被阻塞，当GCD内部管理的所有线程都被占用时，其触发事件将被延迟`。\n\n- - -\n\n最后，老司机给个demo吧，[点这里](https://pan.baidu.com/s/1jIlp6sA)。\n- - -\n好了，到这里是不是CADisplayLink说完了=。=其实我是来还债的。\n\n老规矩，求赞，求关注。\n","source":"_posts/老司机带你走进Core-Animation-之CADisplayLink.md","raw":"---\n\ntitle: 老司机带你走进Core Animation 之CADisplayLink\nlayout: post\ndate: 2016-09-21 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CAAnimation \n- 核心动画\n- 计时器\ncategories: 核心动画\n\n---\n\n\n\n![老司机带你走进Core Animation 之CADisplayLink](http://upload-images.jianshu.io/upload_images/1835430-107159f2337784d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n\n今天说点啥呢？上次老司机说过，带你走进CoreAnimation，那今天就趁热打铁，继续讲讲核心动画相关的东西吧。那今天要讲的就是CADisplayLink。\n\n这篇文章会涉及到什么呢？\n\n- CADisplayLink的基本使用方法\n- OC中的三种定时器：CADisplayLink、NSTimer、GCD\n- runloop浅析\n\n<!-- more -->\n\n- - -\n### CADisplayLink\n\n点进CADisplayLink的头文件我们能看到，其实他的方法并不多，而且他的功能很单一，就是作为一个`定时器`的存在。\n\n不过既然苹果专门提供了这么一个类，就一定是有他的存在意义的。他的优势就在于他的执行频率是`根据设备屏幕的刷新频率来计算`的。换句话讲，他也是`时间间隔最准确`的定时器。\n\n还是在使用中介绍吧。\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];        \n    self.view.backgroundColor = [UIColor grayColor];\n    ///target selector 模式初始化一个实例\n    self.timerInC = [CADisplayLink displayLinkWithTarget:self selector:@selector(changeImg)];\n    ///暂停\n    self.timerInC.paused = YES;\n    ///selector触发间隔\n    self.timerInC.frameInterval = 2;\n    \n    self.imgV = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];\n    self.imgV.contentMode = UIViewContentModeScaleAspectFill;\n    self.imgV.center = self.view.center;\n    [self.view addSubview:self.imgV];\n    \n    ///加入一个runLoop\n    [self.timerInC addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];\n    \n    UIButton * button = [UIButton buttonWithType:(UIButtonTypeSystem)];\n    [button setFrame:CGRectMake(0, 0, 100, 30)];\n    button.center = CGPointMake(self.view.center.x, self.view.center.y + 200);\n    [self.view addSubview:button];\n    [button setTitle:@\"开始播放\" forState:(UIControlStateNormal)];\n    [button setBackgroundColor:[UIColor whiteColor]];\n    [button addTarget:self action:@selector(gifAction) forControlEvents:(UIControlEventTouchUpInside)];\n}\n-(void)changeImg\n{\n    self.currentIndex ++;\n    if (self.currentIndex > 75) {\n        self.currentIndex = 1;\n    }\n    self.imgV.image = [UIImage imageNamed:[NSString stringWithFormat:@\"%ld.jpg\",self.currentIndex]];\n}\n\n-(void)gifAction\n{\n    self.timerInC.paused = !self.timerInC.paused;\n}\n\n```\n\n\n![CADisplayTimer](http://upload-images.jianshu.io/upload_images/1835430-8a5d35d64ec667cf.gif?imageMogr2/auto-orient/strip)\n\n我们可以从头文件中看到，苹果只提供了一个生成实例的接口。\n\n>+(CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;\n\n通过这个方法，可以以target/selector模式`生成一个绑定了触发事件的实例`。参数target、selector可以类比button，我就不做具体讲解了。\n\n然而你只生成一个实例你的事件是`不会被触发`的，这是因为你没有`把他加入到runloop`当中。\n\n>-(void)addToRunLoop:(NSRunLoop \\*)runloop forMode:(NSString \\*)mode;\n\n你可以调用这个方法将实例加入到一个选定的runloop中，这时我们的事件就能被触发了。\n\n>-(void)removeFromRunLoop:(NSRunLoop \\*)runloop forMode:(NSString \\*)mode;\n\n有添加当然会有移除，当你要从某个runloop中移除当前实例的时候你可以调用上面的方法。\n\n类比NSTimer，CADisplayLink也有一个计时器销毁的方法：\n\n>-(void)invalidate;\n\n调用这个方法，会`从所有runLoop中移除当前实例`，这个方法可以用于不需要计时器后对他进行释放前的操作。\n\n好吧，CADisplayLink就这四个方法。以及四个属性：\n\n- `timestamp`，获取上一次selector被执行的时间戳。这个属性是一个`只读属性`，而且你要记住的是只有`当selector被执行过一次之后`这个值才会被取到有效值。这个属性同上是用来比较当前图层时间与上一次selector执行时间只差，从而来计`算本次UI应该发生的改变的进度`（例如视图做移动效果）。\n\n- `duration`，获取当前设备的屏幕刷新时间间隔。同timestamp一样，他也是个只读属性，并且也需要selector触发一次才可以取值。值的一提的是，当前iOS设备的刷新频率都是60HZ。也就是说`每16.7ms刷新一次`。作用也与timestamp相同，都可以用于辅助计算。不过需要说明的一点是，如果`CPU过于繁忙`，duration的值是会`浮动的`。\n\n- `paused`，看名字就能看出来，是控制计时器暂停与恢复的属性。设置为YES的时候会暂停事件的触发。\n\n- `frameInterval`，事件触发间隔。是指两次selector触发之间间隔几次屏幕刷新，`默认值为1`，也就是说屏幕`每刷新一次，执行一次`selector，这个也可以间接用来`控制动画速度`。\n\n两次selector触发的时间间隔是time = frameInterVal * duration。必须注意的是，`selector执行所需要的时间一定要小于其触发间隔，否则会造成掉帧情况`。\n\n总体来说，CADisplayLink的使用还是比较简单的。\n\n- - -\n### 三种定时器的优势与劣势\n#### CADisplayLink\n基本用法上文刚刚介绍过。\n\n优势：依托于设备屏幕刷新频率触发事件，所以其触发时间上是最准确的。也是`最适合做UI不断刷新的事件`，过渡相对流畅，无卡顿感。\n\n缺点：\n\n- 由于依托于屏幕刷新频率，若果CPU不堪重负而影响了屏幕刷新，那么我们的触发事件也会受到相应影响。\n- selector触发的时间间隔只能是duration的整倍数。\n- selector事件如果大于其触发间隔就会造成掉帧现象。\n- CADisplayLink不能被继承。\n\n- - -\n#### NSTimer\n基本用法：\n\n```\nself.timerInN = [NSTimer timerWithTimeInterval:0.032 target:self selector:@selector(changeImg) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:self.timerInN forMode:NSRunLoopCommonModes];\n```\n\nNSTimer的使用方法也相对简单。\n\n首先，有5个方法可以为我们提供NSTimer实例。\n分三类，以timer开头的两个类方法，以schedule开头的两个类方法以及以init开头的一个实例方法。\n\n以timer开头的两个类方法是`灵活度最高`的两个方法。这两个方法的不同点在于绑定事件的方式。一个使用NSInvocation进行转发消息，一个使用target/selector模式绑定事件。总之就是绑定timer的触发事件，这里不做展开讲解。\n\n后面两个参数分别是用户参数以及重复模式。\n\n但是`单单生成了实例还是不会触发我们的事件`，像CADisplayLink一样我们也需要将他`加入到runloop中`,之后就可以触发我们的事件了。\n\n只要是`使用NSTimer就一定要加入到runloop`中才可以触发我们的事件，你可能会说schedule开头那两个类方法就不用添加runloop，这其实是个错觉，是`系统为你将timer添加到了currentRunLoop中，defaultModel`。\n\n最后一个init开头的实例方法就是给timer添加了一个定时启动，这里就不赘述了。\n\nNSTimer还有两个实例方法，`fire和invalid`。分别是立即执行事件和销毁timer。这两个方法比较重要，稍后我会着重讲解一下。\n\n接着说一下他的五个属性。\n\n- `fireDate`，设置当前timer的事件的触发时间。通常我们使用这个属性来做`计时器的暂停与恢复`。\n\n```\n///暂停计时器\nself.timer.fireDate = [NSDate distantFuture];\n///恢复计时器\nself.timer.fireDate = [NSDate distantPast];\n```\n\n- timeInterval,只读属性，获取`当前timer的事件的触发间隔`。\n\n- tolerance，`允许误差时间`。我们知道`NSTimer事件的触发事件是不准确的`，完全`取决于当前runloop`处理的时间。如果当前runloop在`处理复杂运算`，则timer执行时间`将会被推迟`，直到复杂`运算结束后立即执行触发事件`，之后`再按照初始设置的节奏去执行`。当设置tolerance之后在允许范围内的延迟可以触发事件，超过的则不触发。关于tolerance的设置，苹果有这么一段介绍：\n\n>  As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.\n\n翻译成人话就是苹果给了你一个设置`tolerance的参考值`，就是`timeInterval的十分之一`。\n\n- valid，只读属性，获取当前timer是否有效。\n- userInfo，用户参数，在初始化的时候传入的用户参数。\n\n\n说到这里其实NSTimer也就基本介绍完成了，不过老司机还是想着重讲一下NSTimer。\n\n- 关于fire方法\n> You can use this method to fire a repeating timer without interrupting its regular firing schedule. If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.\n\n网上很多人对fire方法的解释其实并不正确。`fire并不是立即激活定时器，而是立即执行一次定时器方法`。当加入到`runloop中timer不需要激活`即可按照设定的时间触发事件。fire只是相当于`手动让timer触发一次事件`。如果timer设置的`repeat为NO，则fire之后timer立即销毁`。如果timer的`repeat为YES`，则到了之前设置的时间他依旧会`按部就班的触发事件`。`fire只是单独触发了一次事件，并不影响原timer的节奏`。\n\n\n![fire](http://upload-images.jianshu.io/upload_images/1835430-fbd2dbc274695136.gif?imageMogr2/auto-orient/strip)\n\n如上图，默认情况且，根据我写的代码，timerB是不会执行的，应为当前mode并不正确（后面会说）。但是当我点击button也就是执行fire方法时，我们看到timerB响应了事件。\n\n- 关于invalid方法\n\n我们知道NSTimer使用的时候如果不注意的话，是`会造成内存泄漏的`。原因是我们生成实例的时候，会对控制器retain一下。如果不对其进行管理则VC的永远不会引用计数为零，进而造成内存泄漏。\n\n所以，当我们不需要的timer的时候，请如下操作：\n\n```\n[self.timer invalid];\nself.timer = nil;\n```\n\n这样Timer会对VC进行一次release。`所以一定不要忘记调用invalid方法`。\n\n顺便提一句，如果生成timer实例的时候`repeat为NO`，那当触发事件结束后，`系统也会自动调用invalid一次`。\n\n- 关于runloop\n\n有时我们将timer添加到runloop中，而依旧不触发事件。这时候我们应该考虑我们添加到的runloop是否是活跃的runloop。`只有成为活跃的runloop，才会执行runloop中的资源`。\n\n\n![非活跃runloop](http://upload-images.jianshu.io/upload_images/1835430-4411f0d4977e0e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 关于mode\n\n即使是目标runloop为活跃runloop依然可能不执行，这时候就要考虑目标runloop是否处于我们指定的mode。`如果不是我们指定的mode，依然不会执行我们的方法`。\n\n\n![非指定runloopMode](http://upload-images.jianshu.io/upload_images/1835430-664464b0b1457459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们看到，我将timerB加入到UITrackingRunLoopMode模式中，默认我们的timerB是不会执行的。因为默认情况下runloop是处于NSDefaultRunLoopMode中的。当scrollView及其子类滚动的时候，runloop会自动切换为追踪模式（UITrackingRunLoopMode）。这是我们的计时器就会工作了。\n\n\n![切换为正确的Mode](http://upload-images.jianshu.io/upload_images/1835430-dcc29ab0c73b71b6.gif?imageMogr2/auto-orient/strip)\n\n那我们来说一下runloop的几种mode：\n\n- Default模式\n \n定义：`NSDefaultRunLoopMode` (Cocoa) kCFRunLoopDefaultMode (Core Foundation)\n\n描述：默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式。\n\n- Connection模式\n\n定义：NSConnectionReplyMode(Cocoa)\n\n描述：处理NSConnection对象相关事件，系统内部使用，用户基本不会使用。\n\n- Modal模式\n\n定义：NSModalPanelRunLoopMode(Cocoa)\n\n描述：处理modal panels事件。\n\n- Event tracking模式\n\n定义：`UITrackingRunLoopMode`(iOS) \nNSEventTrackingRunLoopMode(cocoa)\n\n描述：在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。\n\n- Common模式\n\n定义：`NSRunLoopCommonModes` (Cocoa) kCFRunLoopCommonModes (Core Foundation)\n\n描述：这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.可使用CFRunLoopAddCommonMode方法想Common Modes中添加自定义modes。\n\n**注：iOS中仅NSDefaultRunLoopMode，UITrackingRunLoopMode，NSRunLoopCommonModes三种可用mode。**\n\n你们知道苹果手机为什么崛起的这么快么？第一是因为他是诺基亚年代唯一能与塞班并肩的`智能系统`（毕竟当时用黑莓的很少），当时还没有安卓。第二就是他的`流畅的UI`。\n\n为什么他可以做到UI如德芙一样纵享丝滑呢？因为它赋予了UI极高的地位。全局仅有一条主线程，用来刷新UI。需要不断重绘的scrollView及其子类，享有一个专用的runloopMode，UITrackingRunLoopMode。`当scrollView发生滚动时`，`当前runloop会切换为UITrackingRunLoopMode`。所以正如上面提到过的，如果你的定时器加到NSDefaultRunLoopMode中那么滚动的时候，计时器动作就停止了。这时，你需要`将timer加载NSRunLoopCommonModes`中，才能保证滚动与停止时你的timer都会触发事件。这个对于你的轮播图可是很有用的哦。\n\n这里由于篇幅限制，我并不能展开讲解runloop及mode，建议大家去[这里看看](http://www.cnblogs.com/smileEvday/archive/2012/12/21/NSTimer.html)。\n\nNSTimer的优势：使用相对灵活，应用广泛\n\n劣势：受runloop影响严重，同时易造成内存泄漏（调用invalid方法解决）\n\n- - -\n#### dispatch_source_t\n\n其实说dispatch_source_t是timer这样是狭隘的。dispatch_source_t是GCD为我们预留的`源`类型对象。\n\nGCD方法众多，而且各种牛逼的应用，老司机也并不能玩转GCD，所以这里还是主要讲解一下GCD中Timer的用法吧。\n\n```\nself.timerInG = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n            dispatch_source_set_timer(self.timerInG,  dispatch_walltime(NULL,0 * NSEC_PER_SEC), 0.032 * NSEC_PER_SEC, 0);\n            dispatch_source_set_event_handler(self.timerInG, ^{\n                [self changeImg];\n            });\n```\n- dispatch_source_create（,,,） \n\n这个方法用于返回一个dispatch_source_t对象。第一个参数为源类型，最后一个参数为资源要加入的队列。\n\n- dispatch_source_set_timer(,,,)\n\n这个方法用来设置我们timer的相关信息。第一个参数是我们的timer对象，第二个是timer事件首次触发的延迟时间，第三个参数是timer时间触发的时间间隔，最后一个参数是timer触发的允许延迟值。类比NSTimer的tolerance。建议值也是十分之一。\n\n- dispatch_source_set_event_handler（,）\n\n这个方法用来设置timer的触发事件。第一个参数为Timer对象，第二个为回调block。\n\n- dispatch_resume()\n\n用来激活源对象\n\n- dispatch_suspend()\n\n用来暂停源对象\n\n- dispatch_source_cancel()\n\n用来销毁定时器。\n\n另外需要注意的是，dispatch_source_t  一定要被设置为成员变量，否则将会立即被释放。\n\n关于GCD的timer使用起来相对简单，不过，其实操作不当的话也会造成`内存泄漏`！\n\n`处于挂起`（也就是掉用过 dispatch_suspend()）`的源是不能释放的`。这样就会造成内存泄漏。\n所以建议控制器添加一个标识符，记录源是否处于挂起状态，`在dealloc事件中判断当前源是否被挂起，如果被挂起，则resume，即可解决内存泄漏问题`。`同时如果某个源挂起后不需要恢复则直接调用dispatch_source_cancel销毁就好`。\n\nGCDTimer的优势：不`受当前runloopMode的`影响。\n劣势：虽然说不受runloopMode的影响，但是其计时效应仍`不是百分之百准确的。另外，他的触发事件也有可能被阻塞，当GCD内部管理的所有线程都被占用时，其触发事件将被延迟`。\n\n- - -\n\n最后，老司机给个demo吧，[点这里](https://pan.baidu.com/s/1jIlp6sA)。\n- - -\n好了，到这里是不是CADisplayLink说完了=。=其实我是来还债的。\n\n老规矩，求赞，求关注。\n","slug":"老司机带你走进Core-Animation-之CADisplayLink","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htps000xjigb3zm8ifk6","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-107159f2337784d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之CADisplayLink\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>今天说点啥呢？上次老司机说过，带你走进CoreAnimation，那今天就趁热打铁，继续讲讲核心动画相关的东西吧。那今天要讲的就是CADisplayLink。</p>\n<p>这篇文章会涉及到什么呢？</p>\n<ul>\n<li>CADisplayLink的基本使用方法</li>\n<li>OC中的三种定时器：CADisplayLink、NSTimer、GCD</li>\n<li>runloop浅析</li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"CADisplayLink\"><a href=\"#CADisplayLink\" class=\"headerlink\" title=\"CADisplayLink\"></a>CADisplayLink</h3><p>点进CADisplayLink的头文件我们能看到，其实他的方法并不多，而且他的功能很单一，就是作为一个<code>定时器</code>的存在。</p>\n<p>不过既然苹果专门提供了这么一个类，就一定是有他的存在意义的。他的优势就在于他的执行频率是<code>根据设备屏幕的刷新频率来计算</code>的。换句话讲，他也是<code>时间间隔最准确</code>的定时器。</p>\n<p>还是在使用中介绍吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];        </div><div class=\"line\">    self.view.backgroundColor = [UIColor grayColor];</div><div class=\"line\">    ///target selector 模式初始化一个实例</div><div class=\"line\">    self.timerInC = [CADisplayLink displayLinkWithTarget:self selector:@selector(changeImg)];</div><div class=\"line\">    ///暂停</div><div class=\"line\">    self.timerInC.paused = YES;</div><div class=\"line\">    ///selector触发间隔</div><div class=\"line\">    self.timerInC.frameInterval = 2;</div><div class=\"line\">    </div><div class=\"line\">    self.imgV = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];</div><div class=\"line\">    self.imgV.contentMode = UIViewContentModeScaleAspectFill;</div><div class=\"line\">    self.imgV.center = self.view.center;</div><div class=\"line\">    [self.view addSubview:self.imgV];</div><div class=\"line\">    </div><div class=\"line\">    ///加入一个runLoop</div><div class=\"line\">    [self.timerInC addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class=\"line\">    </div><div class=\"line\">    UIButton * button = [UIButton buttonWithType:(UIButtonTypeSystem)];</div><div class=\"line\">    [button setFrame:CGRectMake(0, 0, 100, 30)];</div><div class=\"line\">    button.center = CGPointMake(self.view.center.x, self.view.center.y + 200);</div><div class=\"line\">    [self.view addSubview:button];</div><div class=\"line\">    [button setTitle:@&quot;开始播放&quot; forState:(UIControlStateNormal)];</div><div class=\"line\">    [button setBackgroundColor:[UIColor whiteColor]];</div><div class=\"line\">    [button addTarget:self action:@selector(gifAction) forControlEvents:(UIControlEventTouchUpInside)];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)changeImg</div><div class=\"line\">&#123;</div><div class=\"line\">    self.currentIndex ++;</div><div class=\"line\">    if (self.currentIndex &gt; 75) &#123;</div><div class=\"line\">        self.currentIndex = 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.imgV.image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%ld.jpg&quot;,self.currentIndex]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)gifAction</div><div class=\"line\">&#123;</div><div class=\"line\">    self.timerInC.paused = !self.timerInC.paused;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-8a5d35d64ec667cf.gif?imageMogr2/auto-orient/strip\" alt=\"CADisplayTimer\"></p>\n<p>我们可以从头文件中看到，苹果只提供了一个生成实例的接口。</p>\n<blockquote>\n<p>+(CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</p>\n</blockquote>\n<p>通过这个方法，可以以target/selector模式<code>生成一个绑定了触发事件的实例</code>。参数target、selector可以类比button，我就不做具体讲解了。</p>\n<p>然而你只生成一个实例你的事件是<code>不会被触发</code>的，这是因为你没有<code>把他加入到runloop</code>当中。</p>\n<blockquote>\n<p>-(void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;</p>\n</blockquote>\n<p>你可以调用这个方法将实例加入到一个选定的runloop中，这时我们的事件就能被触发了。</p>\n<blockquote>\n<p>-(void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;</p>\n</blockquote>\n<p>有添加当然会有移除，当你要从某个runloop中移除当前实例的时候你可以调用上面的方法。</p>\n<p>类比NSTimer，CADisplayLink也有一个计时器销毁的方法：</p>\n<blockquote>\n<p>-(void)invalidate;</p>\n</blockquote>\n<p>调用这个方法，会<code>从所有runLoop中移除当前实例</code>，这个方法可以用于不需要计时器后对他进行释放前的操作。</p>\n<p>好吧，CADisplayLink就这四个方法。以及四个属性：</p>\n<ul>\n<li><p><code>timestamp</code>，获取上一次selector被执行的时间戳。这个属性是一个<code>只读属性</code>，而且你要记住的是只有<code>当selector被执行过一次之后</code>这个值才会被取到有效值。这个属性同上是用来比较当前图层时间与上一次selector执行时间只差，从而来计<code>算本次UI应该发生的改变的进度</code>（例如视图做移动效果）。</p>\n</li>\n<li><p><code>duration</code>，获取当前设备的屏幕刷新时间间隔。同timestamp一样，他也是个只读属性，并且也需要selector触发一次才可以取值。值的一提的是，当前iOS设备的刷新频率都是60HZ。也就是说<code>每16.7ms刷新一次</code>。作用也与timestamp相同，都可以用于辅助计算。不过需要说明的一点是，如果<code>CPU过于繁忙</code>，duration的值是会<code>浮动的</code>。</p>\n</li>\n<li><p><code>paused</code>，看名字就能看出来，是控制计时器暂停与恢复的属性。设置为YES的时候会暂停事件的触发。</p>\n</li>\n<li><p><code>frameInterval</code>，事件触发间隔。是指两次selector触发之间间隔几次屏幕刷新，<code>默认值为1</code>，也就是说屏幕<code>每刷新一次，执行一次</code>selector，这个也可以间接用来<code>控制动画速度</code>。</p>\n</li>\n</ul>\n<p>两次selector触发的时间间隔是time = frameInterVal * duration。必须注意的是，<code>selector执行所需要的时间一定要小于其触发间隔，否则会造成掉帧情况</code>。</p>\n<p>总体来说，CADisplayLink的使用还是比较简单的。</p>\n<hr>\n<h3 id=\"三种定时器的优势与劣势\"><a href=\"#三种定时器的优势与劣势\" class=\"headerlink\" title=\"三种定时器的优势与劣势\"></a>三种定时器的优势与劣势</h3><h4 id=\"CADisplayLink-1\"><a href=\"#CADisplayLink-1\" class=\"headerlink\" title=\"CADisplayLink\"></a>CADisplayLink</h4><p>基本用法上文刚刚介绍过。</p>\n<p>优势：依托于设备屏幕刷新频率触发事件，所以其触发时间上是最准确的。也是<code>最适合做UI不断刷新的事件</code>，过渡相对流畅，无卡顿感。</p>\n<p>缺点：</p>\n<ul>\n<li>由于依托于屏幕刷新频率，若果CPU不堪重负而影响了屏幕刷新，那么我们的触发事件也会受到相应影响。</li>\n<li>selector触发的时间间隔只能是duration的整倍数。</li>\n<li>selector事件如果大于其触发间隔就会造成掉帧现象。</li>\n<li>CADisplayLink不能被继承。</li>\n</ul>\n<hr>\n<h4 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h4><p>基本用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.timerInN = [NSTimer timerWithTimeInterval:0.032 target:self selector:@selector(changeImg) userInfo:nil repeats:YES];</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:self.timerInN forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>\n<p>NSTimer的使用方法也相对简单。</p>\n<p>首先，有5个方法可以为我们提供NSTimer实例。<br>分三类，以timer开头的两个类方法，以schedule开头的两个类方法以及以init开头的一个实例方法。</p>\n<p>以timer开头的两个类方法是<code>灵活度最高</code>的两个方法。这两个方法的不同点在于绑定事件的方式。一个使用NSInvocation进行转发消息，一个使用target/selector模式绑定事件。总之就是绑定timer的触发事件，这里不做展开讲解。</p>\n<p>后面两个参数分别是用户参数以及重复模式。</p>\n<p>但是<code>单单生成了实例还是不会触发我们的事件</code>，像CADisplayLink一样我们也需要将他<code>加入到runloop中</code>,之后就可以触发我们的事件了。</p>\n<p>只要是<code>使用NSTimer就一定要加入到runloop</code>中才可以触发我们的事件，你可能会说schedule开头那两个类方法就不用添加runloop，这其实是个错觉，是<code>系统为你将timer添加到了currentRunLoop中，defaultModel</code>。</p>\n<p>最后一个init开头的实例方法就是给timer添加了一个定时启动，这里就不赘述了。</p>\n<p>NSTimer还有两个实例方法，<code>fire和invalid</code>。分别是立即执行事件和销毁timer。这两个方法比较重要，稍后我会着重讲解一下。</p>\n<p>接着说一下他的五个属性。</p>\n<ul>\n<li><code>fireDate</code>，设置当前timer的事件的触发时间。通常我们使用这个属性来做<code>计时器的暂停与恢复</code>。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">///暂停计时器</div><div class=\"line\">self.timer.fireDate = [NSDate distantFuture];</div><div class=\"line\">///恢复计时器</div><div class=\"line\">self.timer.fireDate = [NSDate distantPast];</div></pre></td></tr></table></figure>\n<ul>\n<li><p>timeInterval,只读属性，获取<code>当前timer的事件的触发间隔</code>。</p>\n</li>\n<li><p>tolerance，<code>允许误差时间</code>。我们知道<code>NSTimer事件的触发事件是不准确的</code>，完全<code>取决于当前runloop</code>处理的时间。如果当前runloop在<code>处理复杂运算</code>，则timer执行时间<code>将会被推迟</code>，直到复杂<code>运算结束后立即执行触发事件</code>，之后<code>再按照初始设置的节奏去执行</code>。当设置tolerance之后在允许范围内的延迟可以触发事件，超过的则不触发。关于tolerance的设置，苹果有这么一段介绍：</p>\n</li>\n</ul>\n<blockquote>\n<p> As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.</p>\n</blockquote>\n<p>翻译成人话就是苹果给了你一个设置<code>tolerance的参考值</code>，就是<code>timeInterval的十分之一</code>。</p>\n<ul>\n<li>valid，只读属性，获取当前timer是否有效。</li>\n<li>userInfo，用户参数，在初始化的时候传入的用户参数。</li>\n</ul>\n<p>说到这里其实NSTimer也就基本介绍完成了，不过老司机还是想着重讲一下NSTimer。</p>\n<ul>\n<li>关于fire方法<blockquote>\n<p>You can use this method to fire a repeating timer without interrupting its regular firing schedule. If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.</p>\n</blockquote>\n</li>\n</ul>\n<p>网上很多人对fire方法的解释其实并不正确。<code>fire并不是立即激活定时器，而是立即执行一次定时器方法</code>。当加入到<code>runloop中timer不需要激活</code>即可按照设定的时间触发事件。fire只是相当于<code>手动让timer触发一次事件</code>。如果timer设置的<code>repeat为NO，则fire之后timer立即销毁</code>。如果timer的<code>repeat为YES</code>，则到了之前设置的时间他依旧会<code>按部就班的触发事件</code>。<code>fire只是单独触发了一次事件，并不影响原timer的节奏</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-fbd2dbc274695136.gif?imageMogr2/auto-orient/strip\" alt=\"fire\"></p>\n<p>如上图，默认情况且，根据我写的代码，timerB是不会执行的，应为当前mode并不正确（后面会说）。但是当我点击button也就是执行fire方法时，我们看到timerB响应了事件。</p>\n<ul>\n<li>关于invalid方法</li>\n</ul>\n<p>我们知道NSTimer使用的时候如果不注意的话，是<code>会造成内存泄漏的</code>。原因是我们生成实例的时候，会对控制器retain一下。如果不对其进行管理则VC的永远不会引用计数为零，进而造成内存泄漏。</p>\n<p>所以，当我们不需要的timer的时候，请如下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.timer invalid];</div><div class=\"line\">self.timer = nil;</div></pre></td></tr></table></figure>\n<p>这样Timer会对VC进行一次release。<code>所以一定不要忘记调用invalid方法</code>。</p>\n<p>顺便提一句，如果生成timer实例的时候<code>repeat为NO</code>，那当触发事件结束后，<code>系统也会自动调用invalid一次</code>。</p>\n<ul>\n<li>关于runloop</li>\n</ul>\n<p>有时我们将timer添加到runloop中，而依旧不触发事件。这时候我们应该考虑我们添加到的runloop是否是活跃的runloop。<code>只有成为活跃的runloop，才会执行runloop中的资源</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-4411f0d4977e0e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"非活跃runloop\"></p>\n<ul>\n<li>关于mode</li>\n</ul>\n<p>即使是目标runloop为活跃runloop依然可能不执行，这时候就要考虑目标runloop是否处于我们指定的mode。<code>如果不是我们指定的mode，依然不会执行我们的方法</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-664464b0b1457459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"非指定runloopMode\"></p>\n<p>我们看到，我将timerB加入到UITrackingRunLoopMode模式中，默认我们的timerB是不会执行的。因为默认情况下runloop是处于NSDefaultRunLoopMode中的。当scrollView及其子类滚动的时候，runloop会自动切换为追踪模式（UITrackingRunLoopMode）。这是我们的计时器就会工作了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-dcc29ab0c73b71b6.gif?imageMogr2/auto-orient/strip\" alt=\"切换为正确的Mode\"></p>\n<p>那我们来说一下runloop的几种mode：</p>\n<ul>\n<li>Default模式</li>\n</ul>\n<p>定义：<code>NSDefaultRunLoopMode</code> (Cocoa) kCFRunLoopDefaultMode (Core Foundation)</p>\n<p>描述：默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式。</p>\n<ul>\n<li>Connection模式</li>\n</ul>\n<p>定义：NSConnectionReplyMode(Cocoa)</p>\n<p>描述：处理NSConnection对象相关事件，系统内部使用，用户基本不会使用。</p>\n<ul>\n<li>Modal模式</li>\n</ul>\n<p>定义：NSModalPanelRunLoopMode(Cocoa)</p>\n<p>描述：处理modal panels事件。</p>\n<ul>\n<li>Event tracking模式</li>\n</ul>\n<p>定义：<code>UITrackingRunLoopMode</code>(iOS)<br>NSEventTrackingRunLoopMode(cocoa)</p>\n<p>描述：在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。</p>\n<ul>\n<li>Common模式</li>\n</ul>\n<p>定义：<code>NSRunLoopCommonModes</code> (Cocoa) kCFRunLoopCommonModes (Core Foundation)</p>\n<p>描述：这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.可使用CFRunLoopAddCommonMode方法想Common Modes中添加自定义modes。</p>\n<p><strong>注：iOS中仅NSDefaultRunLoopMode，UITrackingRunLoopMode，NSRunLoopCommonModes三种可用mode。</strong></p>\n<p>你们知道苹果手机为什么崛起的这么快么？第一是因为他是诺基亚年代唯一能与塞班并肩的<code>智能系统</code>（毕竟当时用黑莓的很少），当时还没有安卓。第二就是他的<code>流畅的UI</code>。</p>\n<p>为什么他可以做到UI如德芙一样纵享丝滑呢？因为它赋予了UI极高的地位。全局仅有一条主线程，用来刷新UI。需要不断重绘的scrollView及其子类，享有一个专用的runloopMode，UITrackingRunLoopMode。<code>当scrollView发生滚动时</code>，<code>当前runloop会切换为UITrackingRunLoopMode</code>。所以正如上面提到过的，如果你的定时器加到NSDefaultRunLoopMode中那么滚动的时候，计时器动作就停止了。这时，你需要<code>将timer加载NSRunLoopCommonModes</code>中，才能保证滚动与停止时你的timer都会触发事件。这个对于你的轮播图可是很有用的哦。</p>\n<p>这里由于篇幅限制，我并不能展开讲解runloop及mode，建议大家去<a href=\"http://www.cnblogs.com/smileEvday/archive/2012/12/21/NSTimer.html\" target=\"_blank\" rel=\"external\">这里看看</a>。</p>\n<p>NSTimer的优势：使用相对灵活，应用广泛</p>\n<p>劣势：受runloop影响严重，同时易造成内存泄漏（调用invalid方法解决）</p>\n<hr>\n<h4 id=\"dispatch-source-t\"><a href=\"#dispatch-source-t\" class=\"headerlink\" title=\"dispatch_source_t\"></a>dispatch_source_t</h4><p>其实说dispatch_source_t是timer这样是狭隘的。dispatch_source_t是GCD为我们预留的<code>源</code>类型对象。</p>\n<p>GCD方法众多，而且各种牛逼的应用，老司机也并不能玩转GCD，所以这里还是主要讲解一下GCD中Timer的用法吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.timerInG = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">            dispatch_source_set_timer(self.timerInG,  dispatch_walltime(NULL,0 * NSEC_PER_SEC), 0.032 * NSEC_PER_SEC, 0);</div><div class=\"line\">            dispatch_source_set_event_handler(self.timerInG, ^&#123;</div><div class=\"line\">                [self changeImg];</div><div class=\"line\">            &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>dispatch_source_create（,,,） </li>\n</ul>\n<p>这个方法用于返回一个dispatch_source_t对象。第一个参数为源类型，最后一个参数为资源要加入的队列。</p>\n<ul>\n<li>dispatch_source_set_timer(,,,)</li>\n</ul>\n<p>这个方法用来设置我们timer的相关信息。第一个参数是我们的timer对象，第二个是timer事件首次触发的延迟时间，第三个参数是timer时间触发的时间间隔，最后一个参数是timer触发的允许延迟值。类比NSTimer的tolerance。建议值也是十分之一。</p>\n<ul>\n<li>dispatch_source_set_event_handler（,）</li>\n</ul>\n<p>这个方法用来设置timer的触发事件。第一个参数为Timer对象，第二个为回调block。</p>\n<ul>\n<li>dispatch_resume()</li>\n</ul>\n<p>用来激活源对象</p>\n<ul>\n<li>dispatch_suspend()</li>\n</ul>\n<p>用来暂停源对象</p>\n<ul>\n<li>dispatch_source_cancel()</li>\n</ul>\n<p>用来销毁定时器。</p>\n<p>另外需要注意的是，dispatch_source_t  一定要被设置为成员变量，否则将会立即被释放。</p>\n<p>关于GCD的timer使用起来相对简单，不过，其实操作不当的话也会造成<code>内存泄漏</code>！</p>\n<p><code>处于挂起</code>（也就是掉用过 dispatch_suspend()）<code>的源是不能释放的</code>。这样就会造成内存泄漏。<br>所以建议控制器添加一个标识符，记录源是否处于挂起状态，<code>在dealloc事件中判断当前源是否被挂起，如果被挂起，则resume，即可解决内存泄漏问题</code>。<code>同时如果某个源挂起后不需要恢复则直接调用dispatch_source_cancel销毁就好</code>。</p>\n<p>GCDTimer的优势：不<code>受当前runloopMode的</code>影响。<br>劣势：虽然说不受runloopMode的影响，但是其计时效应仍<code>不是百分之百准确的。另外，他的触发事件也有可能被阻塞，当GCD内部管理的所有线程都被占用时，其触发事件将被延迟</code>。</p>\n<hr>\n<p>最后，老司机给个demo吧，<a href=\"https://pan.baidu.com/s/1jIlp6sA\" target=\"_blank\" rel=\"external\">点这里</a>。</p>\n<hr>\n<p>好了，到这里是不是CADisplayLink说完了=。=其实我是来还债的。</p>\n<p>老规矩，求赞，求关注。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-107159f2337784d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之CADisplayLink\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>今天说点啥呢？上次老司机说过，带你走进CoreAnimation，那今天就趁热打铁，继续讲讲核心动画相关的东西吧。那今天要讲的就是CADisplayLink。</p>\n<p>这篇文章会涉及到什么呢？</p>\n<ul>\n<li>CADisplayLink的基本使用方法</li>\n<li>OC中的三种定时器：CADisplayLink、NSTimer、GCD</li>\n<li>runloop浅析</li>\n</ul>","more":"<hr>\n<h3 id=\"CADisplayLink\"><a href=\"#CADisplayLink\" class=\"headerlink\" title=\"CADisplayLink\"></a>CADisplayLink</h3><p>点进CADisplayLink的头文件我们能看到，其实他的方法并不多，而且他的功能很单一，就是作为一个<code>定时器</code>的存在。</p>\n<p>不过既然苹果专门提供了这么一个类，就一定是有他的存在意义的。他的优势就在于他的执行频率是<code>根据设备屏幕的刷新频率来计算</code>的。换句话讲，他也是<code>时间间隔最准确</code>的定时器。</p>\n<p>还是在使用中介绍吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];        </div><div class=\"line\">    self.view.backgroundColor = [UIColor grayColor];</div><div class=\"line\">    ///target selector 模式初始化一个实例</div><div class=\"line\">    self.timerInC = [CADisplayLink displayLinkWithTarget:self selector:@selector(changeImg)];</div><div class=\"line\">    ///暂停</div><div class=\"line\">    self.timerInC.paused = YES;</div><div class=\"line\">    ///selector触发间隔</div><div class=\"line\">    self.timerInC.frameInterval = 2;</div><div class=\"line\">    </div><div class=\"line\">    self.imgV = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];</div><div class=\"line\">    self.imgV.contentMode = UIViewContentModeScaleAspectFill;</div><div class=\"line\">    self.imgV.center = self.view.center;</div><div class=\"line\">    [self.view addSubview:self.imgV];</div><div class=\"line\">    </div><div class=\"line\">    ///加入一个runLoop</div><div class=\"line\">    [self.timerInC addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class=\"line\">    </div><div class=\"line\">    UIButton * button = [UIButton buttonWithType:(UIButtonTypeSystem)];</div><div class=\"line\">    [button setFrame:CGRectMake(0, 0, 100, 30)];</div><div class=\"line\">    button.center = CGPointMake(self.view.center.x, self.view.center.y + 200);</div><div class=\"line\">    [self.view addSubview:button];</div><div class=\"line\">    [button setTitle:@&quot;开始播放&quot; forState:(UIControlStateNormal)];</div><div class=\"line\">    [button setBackgroundColor:[UIColor whiteColor]];</div><div class=\"line\">    [button addTarget:self action:@selector(gifAction) forControlEvents:(UIControlEventTouchUpInside)];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)changeImg</div><div class=\"line\">&#123;</div><div class=\"line\">    self.currentIndex ++;</div><div class=\"line\">    if (self.currentIndex &gt; 75) &#123;</div><div class=\"line\">        self.currentIndex = 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.imgV.image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%ld.jpg&quot;,self.currentIndex]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)gifAction</div><div class=\"line\">&#123;</div><div class=\"line\">    self.timerInC.paused = !self.timerInC.paused;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-8a5d35d64ec667cf.gif?imageMogr2/auto-orient/strip\" alt=\"CADisplayTimer\"></p>\n<p>我们可以从头文件中看到，苹果只提供了一个生成实例的接口。</p>\n<blockquote>\n<p>+(CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</p>\n</blockquote>\n<p>通过这个方法，可以以target/selector模式<code>生成一个绑定了触发事件的实例</code>。参数target、selector可以类比button，我就不做具体讲解了。</p>\n<p>然而你只生成一个实例你的事件是<code>不会被触发</code>的，这是因为你没有<code>把他加入到runloop</code>当中。</p>\n<blockquote>\n<p>-(void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;</p>\n</blockquote>\n<p>你可以调用这个方法将实例加入到一个选定的runloop中，这时我们的事件就能被触发了。</p>\n<blockquote>\n<p>-(void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;</p>\n</blockquote>\n<p>有添加当然会有移除，当你要从某个runloop中移除当前实例的时候你可以调用上面的方法。</p>\n<p>类比NSTimer，CADisplayLink也有一个计时器销毁的方法：</p>\n<blockquote>\n<p>-(void)invalidate;</p>\n</blockquote>\n<p>调用这个方法，会<code>从所有runLoop中移除当前实例</code>，这个方法可以用于不需要计时器后对他进行释放前的操作。</p>\n<p>好吧，CADisplayLink就这四个方法。以及四个属性：</p>\n<ul>\n<li><p><code>timestamp</code>，获取上一次selector被执行的时间戳。这个属性是一个<code>只读属性</code>，而且你要记住的是只有<code>当selector被执行过一次之后</code>这个值才会被取到有效值。这个属性同上是用来比较当前图层时间与上一次selector执行时间只差，从而来计<code>算本次UI应该发生的改变的进度</code>（例如视图做移动效果）。</p>\n</li>\n<li><p><code>duration</code>，获取当前设备的屏幕刷新时间间隔。同timestamp一样，他也是个只读属性，并且也需要selector触发一次才可以取值。值的一提的是，当前iOS设备的刷新频率都是60HZ。也就是说<code>每16.7ms刷新一次</code>。作用也与timestamp相同，都可以用于辅助计算。不过需要说明的一点是，如果<code>CPU过于繁忙</code>，duration的值是会<code>浮动的</code>。</p>\n</li>\n<li><p><code>paused</code>，看名字就能看出来，是控制计时器暂停与恢复的属性。设置为YES的时候会暂停事件的触发。</p>\n</li>\n<li><p><code>frameInterval</code>，事件触发间隔。是指两次selector触发之间间隔几次屏幕刷新，<code>默认值为1</code>，也就是说屏幕<code>每刷新一次，执行一次</code>selector，这个也可以间接用来<code>控制动画速度</code>。</p>\n</li>\n</ul>\n<p>两次selector触发的时间间隔是time = frameInterVal * duration。必须注意的是，<code>selector执行所需要的时间一定要小于其触发间隔，否则会造成掉帧情况</code>。</p>\n<p>总体来说，CADisplayLink的使用还是比较简单的。</p>\n<hr>\n<h3 id=\"三种定时器的优势与劣势\"><a href=\"#三种定时器的优势与劣势\" class=\"headerlink\" title=\"三种定时器的优势与劣势\"></a>三种定时器的优势与劣势</h3><h4 id=\"CADisplayLink-1\"><a href=\"#CADisplayLink-1\" class=\"headerlink\" title=\"CADisplayLink\"></a>CADisplayLink</h4><p>基本用法上文刚刚介绍过。</p>\n<p>优势：依托于设备屏幕刷新频率触发事件，所以其触发时间上是最准确的。也是<code>最适合做UI不断刷新的事件</code>，过渡相对流畅，无卡顿感。</p>\n<p>缺点：</p>\n<ul>\n<li>由于依托于屏幕刷新频率，若果CPU不堪重负而影响了屏幕刷新，那么我们的触发事件也会受到相应影响。</li>\n<li>selector触发的时间间隔只能是duration的整倍数。</li>\n<li>selector事件如果大于其触发间隔就会造成掉帧现象。</li>\n<li>CADisplayLink不能被继承。</li>\n</ul>\n<hr>\n<h4 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h4><p>基本用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.timerInN = [NSTimer timerWithTimeInterval:0.032 target:self selector:@selector(changeImg) userInfo:nil repeats:YES];</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:self.timerInN forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>\n<p>NSTimer的使用方法也相对简单。</p>\n<p>首先，有5个方法可以为我们提供NSTimer实例。<br>分三类，以timer开头的两个类方法，以schedule开头的两个类方法以及以init开头的一个实例方法。</p>\n<p>以timer开头的两个类方法是<code>灵活度最高</code>的两个方法。这两个方法的不同点在于绑定事件的方式。一个使用NSInvocation进行转发消息，一个使用target/selector模式绑定事件。总之就是绑定timer的触发事件，这里不做展开讲解。</p>\n<p>后面两个参数分别是用户参数以及重复模式。</p>\n<p>但是<code>单单生成了实例还是不会触发我们的事件</code>，像CADisplayLink一样我们也需要将他<code>加入到runloop中</code>,之后就可以触发我们的事件了。</p>\n<p>只要是<code>使用NSTimer就一定要加入到runloop</code>中才可以触发我们的事件，你可能会说schedule开头那两个类方法就不用添加runloop，这其实是个错觉，是<code>系统为你将timer添加到了currentRunLoop中，defaultModel</code>。</p>\n<p>最后一个init开头的实例方法就是给timer添加了一个定时启动，这里就不赘述了。</p>\n<p>NSTimer还有两个实例方法，<code>fire和invalid</code>。分别是立即执行事件和销毁timer。这两个方法比较重要，稍后我会着重讲解一下。</p>\n<p>接着说一下他的五个属性。</p>\n<ul>\n<li><code>fireDate</code>，设置当前timer的事件的触发时间。通常我们使用这个属性来做<code>计时器的暂停与恢复</code>。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">///暂停计时器</div><div class=\"line\">self.timer.fireDate = [NSDate distantFuture];</div><div class=\"line\">///恢复计时器</div><div class=\"line\">self.timer.fireDate = [NSDate distantPast];</div></pre></td></tr></table></figure>\n<ul>\n<li><p>timeInterval,只读属性，获取<code>当前timer的事件的触发间隔</code>。</p>\n</li>\n<li><p>tolerance，<code>允许误差时间</code>。我们知道<code>NSTimer事件的触发事件是不准确的</code>，完全<code>取决于当前runloop</code>处理的时间。如果当前runloop在<code>处理复杂运算</code>，则timer执行时间<code>将会被推迟</code>，直到复杂<code>运算结束后立即执行触发事件</code>，之后<code>再按照初始设置的节奏去执行</code>。当设置tolerance之后在允许范围内的延迟可以触发事件，超过的则不触发。关于tolerance的设置，苹果有这么一段介绍：</p>\n</li>\n</ul>\n<blockquote>\n<p> As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.</p>\n</blockquote>\n<p>翻译成人话就是苹果给了你一个设置<code>tolerance的参考值</code>，就是<code>timeInterval的十分之一</code>。</p>\n<ul>\n<li>valid，只读属性，获取当前timer是否有效。</li>\n<li>userInfo，用户参数，在初始化的时候传入的用户参数。</li>\n</ul>\n<p>说到这里其实NSTimer也就基本介绍完成了，不过老司机还是想着重讲一下NSTimer。</p>\n<ul>\n<li>关于fire方法<blockquote>\n<p>You can use this method to fire a repeating timer without interrupting its regular firing schedule. If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.</p>\n</blockquote>\n</li>\n</ul>\n<p>网上很多人对fire方法的解释其实并不正确。<code>fire并不是立即激活定时器，而是立即执行一次定时器方法</code>。当加入到<code>runloop中timer不需要激活</code>即可按照设定的时间触发事件。fire只是相当于<code>手动让timer触发一次事件</code>。如果timer设置的<code>repeat为NO，则fire之后timer立即销毁</code>。如果timer的<code>repeat为YES</code>，则到了之前设置的时间他依旧会<code>按部就班的触发事件</code>。<code>fire只是单独触发了一次事件，并不影响原timer的节奏</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-fbd2dbc274695136.gif?imageMogr2/auto-orient/strip\" alt=\"fire\"></p>\n<p>如上图，默认情况且，根据我写的代码，timerB是不会执行的，应为当前mode并不正确（后面会说）。但是当我点击button也就是执行fire方法时，我们看到timerB响应了事件。</p>\n<ul>\n<li>关于invalid方法</li>\n</ul>\n<p>我们知道NSTimer使用的时候如果不注意的话，是<code>会造成内存泄漏的</code>。原因是我们生成实例的时候，会对控制器retain一下。如果不对其进行管理则VC的永远不会引用计数为零，进而造成内存泄漏。</p>\n<p>所以，当我们不需要的timer的时候，请如下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.timer invalid];</div><div class=\"line\">self.timer = nil;</div></pre></td></tr></table></figure>\n<p>这样Timer会对VC进行一次release。<code>所以一定不要忘记调用invalid方法</code>。</p>\n<p>顺便提一句，如果生成timer实例的时候<code>repeat为NO</code>，那当触发事件结束后，<code>系统也会自动调用invalid一次</code>。</p>\n<ul>\n<li>关于runloop</li>\n</ul>\n<p>有时我们将timer添加到runloop中，而依旧不触发事件。这时候我们应该考虑我们添加到的runloop是否是活跃的runloop。<code>只有成为活跃的runloop，才会执行runloop中的资源</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-4411f0d4977e0e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"非活跃runloop\"></p>\n<ul>\n<li>关于mode</li>\n</ul>\n<p>即使是目标runloop为活跃runloop依然可能不执行，这时候就要考虑目标runloop是否处于我们指定的mode。<code>如果不是我们指定的mode，依然不会执行我们的方法</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-664464b0b1457459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"非指定runloopMode\"></p>\n<p>我们看到，我将timerB加入到UITrackingRunLoopMode模式中，默认我们的timerB是不会执行的。因为默认情况下runloop是处于NSDefaultRunLoopMode中的。当scrollView及其子类滚动的时候，runloop会自动切换为追踪模式（UITrackingRunLoopMode）。这是我们的计时器就会工作了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-dcc29ab0c73b71b6.gif?imageMogr2/auto-orient/strip\" alt=\"切换为正确的Mode\"></p>\n<p>那我们来说一下runloop的几种mode：</p>\n<ul>\n<li>Default模式</li>\n</ul>\n<p>定义：<code>NSDefaultRunLoopMode</code> (Cocoa) kCFRunLoopDefaultMode (Core Foundation)</p>\n<p>描述：默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式。</p>\n<ul>\n<li>Connection模式</li>\n</ul>\n<p>定义：NSConnectionReplyMode(Cocoa)</p>\n<p>描述：处理NSConnection对象相关事件，系统内部使用，用户基本不会使用。</p>\n<ul>\n<li>Modal模式</li>\n</ul>\n<p>定义：NSModalPanelRunLoopMode(Cocoa)</p>\n<p>描述：处理modal panels事件。</p>\n<ul>\n<li>Event tracking模式</li>\n</ul>\n<p>定义：<code>UITrackingRunLoopMode</code>(iOS)<br>NSEventTrackingRunLoopMode(cocoa)</p>\n<p>描述：在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。</p>\n<ul>\n<li>Common模式</li>\n</ul>\n<p>定义：<code>NSRunLoopCommonModes</code> (Cocoa) kCFRunLoopCommonModes (Core Foundation)</p>\n<p>描述：这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.可使用CFRunLoopAddCommonMode方法想Common Modes中添加自定义modes。</p>\n<p><strong>注：iOS中仅NSDefaultRunLoopMode，UITrackingRunLoopMode，NSRunLoopCommonModes三种可用mode。</strong></p>\n<p>你们知道苹果手机为什么崛起的这么快么？第一是因为他是诺基亚年代唯一能与塞班并肩的<code>智能系统</code>（毕竟当时用黑莓的很少），当时还没有安卓。第二就是他的<code>流畅的UI</code>。</p>\n<p>为什么他可以做到UI如德芙一样纵享丝滑呢？因为它赋予了UI极高的地位。全局仅有一条主线程，用来刷新UI。需要不断重绘的scrollView及其子类，享有一个专用的runloopMode，UITrackingRunLoopMode。<code>当scrollView发生滚动时</code>，<code>当前runloop会切换为UITrackingRunLoopMode</code>。所以正如上面提到过的，如果你的定时器加到NSDefaultRunLoopMode中那么滚动的时候，计时器动作就停止了。这时，你需要<code>将timer加载NSRunLoopCommonModes</code>中，才能保证滚动与停止时你的timer都会触发事件。这个对于你的轮播图可是很有用的哦。</p>\n<p>这里由于篇幅限制，我并不能展开讲解runloop及mode，建议大家去<a href=\"http://www.cnblogs.com/smileEvday/archive/2012/12/21/NSTimer.html\" target=\"_blank\" rel=\"external\">这里看看</a>。</p>\n<p>NSTimer的优势：使用相对灵活，应用广泛</p>\n<p>劣势：受runloop影响严重，同时易造成内存泄漏（调用invalid方法解决）</p>\n<hr>\n<h4 id=\"dispatch-source-t\"><a href=\"#dispatch-source-t\" class=\"headerlink\" title=\"dispatch_source_t\"></a>dispatch_source_t</h4><p>其实说dispatch_source_t是timer这样是狭隘的。dispatch_source_t是GCD为我们预留的<code>源</code>类型对象。</p>\n<p>GCD方法众多，而且各种牛逼的应用，老司机也并不能玩转GCD，所以这里还是主要讲解一下GCD中Timer的用法吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.timerInG = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">            dispatch_source_set_timer(self.timerInG,  dispatch_walltime(NULL,0 * NSEC_PER_SEC), 0.032 * NSEC_PER_SEC, 0);</div><div class=\"line\">            dispatch_source_set_event_handler(self.timerInG, ^&#123;</div><div class=\"line\">                [self changeImg];</div><div class=\"line\">            &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>dispatch_source_create（,,,） </li>\n</ul>\n<p>这个方法用于返回一个dispatch_source_t对象。第一个参数为源类型，最后一个参数为资源要加入的队列。</p>\n<ul>\n<li>dispatch_source_set_timer(,,,)</li>\n</ul>\n<p>这个方法用来设置我们timer的相关信息。第一个参数是我们的timer对象，第二个是timer事件首次触发的延迟时间，第三个参数是timer时间触发的时间间隔，最后一个参数是timer触发的允许延迟值。类比NSTimer的tolerance。建议值也是十分之一。</p>\n<ul>\n<li>dispatch_source_set_event_handler（,）</li>\n</ul>\n<p>这个方法用来设置timer的触发事件。第一个参数为Timer对象，第二个为回调block。</p>\n<ul>\n<li>dispatch_resume()</li>\n</ul>\n<p>用来激活源对象</p>\n<ul>\n<li>dispatch_suspend()</li>\n</ul>\n<p>用来暂停源对象</p>\n<ul>\n<li>dispatch_source_cancel()</li>\n</ul>\n<p>用来销毁定时器。</p>\n<p>另外需要注意的是，dispatch_source_t  一定要被设置为成员变量，否则将会立即被释放。</p>\n<p>关于GCD的timer使用起来相对简单，不过，其实操作不当的话也会造成<code>内存泄漏</code>！</p>\n<p><code>处于挂起</code>（也就是掉用过 dispatch_suspend()）<code>的源是不能释放的</code>。这样就会造成内存泄漏。<br>所以建议控制器添加一个标识符，记录源是否处于挂起状态，<code>在dealloc事件中判断当前源是否被挂起，如果被挂起，则resume，即可解决内存泄漏问题</code>。<code>同时如果某个源挂起后不需要恢复则直接调用dispatch_source_cancel销毁就好</code>。</p>\n<p>GCDTimer的优势：不<code>受当前runloopMode的</code>影响。<br>劣势：虽然说不受runloopMode的影响，但是其计时效应仍<code>不是百分之百准确的。另外，他的触发事件也有可能被阻塞，当GCD内部管理的所有线程都被占用时，其触发事件将被延迟</code>。</p>\n<hr>\n<p>最后，老司机给个demo吧，<a href=\"https://pan.baidu.com/s/1jIlp6sA\" target=\"_blank\" rel=\"external\">点这里</a>。</p>\n<hr>\n<p>好了，到这里是不是CADisplayLink说完了=。=其实我是来还债的。</p>\n<p>老规矩，求赞，求关注。</p>"},{"title":"老司机带你走进Core Animation 之CAShapeLayer和CATextLayer","layout":"post","date":"2016-11-18T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://upload-images.jianshu.io/upload_images/1835430-7a62b93ba150bff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n\n呐，老司机之前说过会来讲CALayer的，当然不会食言啦，今天就讲一些CALayer相关的吧。\n\n由于老司机这个想起来啥说啥的特点，CALayer与UIView的一些关系以及CALayer的一些重要属性，早在老司机CoreAnimation系列第一章里面就已经做了很系统的介绍。本着从来不凑字的原则（啧啧啧，违心），没看到的同学去[这里](http://www.jianshu.com/p/92a0661a21c6)补票吧。\n\n不要怪老司机做事没有条理哦，毕竟当时也没想做成系列的，真的是有这么多读者才支持我一步一步写到这里。\n\n\n![爱你们哟](http://upload-images.jianshu.io/upload_images/1835430-29aa5a4d1032747c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n废话有点多，那今天要讲什么呢？就讲讲CALayer的两个子类，`CAShapeLayer`和`CATextLayer`吧。\n\n<!-- more -->\n\n- - -\n### CAShapeLayer\n\n其实在日常使用中，CALayer能满足需求的情况还是比较少的，（当然你用它来划线还是很好用的），原因就在于`CALayer并不能很方便`的生成除了矩形的`其他形状`。（其实老司机更愿意认为他是作为基类存在的，为所有子类提供公有属性及方法）由于作为基类的CALayer老司机已经介绍过了，所以接下来的两个子类老司机都会`只讲述其差异性`。然而`CAShapeLayer则`是作为一个强大无比的子类出现的，通过名字我们大概就可以猜到，`他可以画出各样的形状`。\n\n- CAShapeLayer的优势\n\n老生常谈了，肯定是性能啊（不提性能要如何装作一副很厉害的样子），他的`渲染都在GPU里面`，`不！占！内！存！`\n\n- CAShapeLayer如何绘制出各种图形？\n\n我们可以从头文件中观察到，CAShapeLayer有一个独有的属性，是`Path`。他是一个CGPathRef对象。我们知道，这就是个路径，没错，`CAShapeLayer就是根据这个路径绘制出各种形状的图形的`。\n\n```\nCAShapeLayer * circle = [CAShapeLayer layer];\n    circle.bounds = CGRectMake(0, 0, 100, 100);\n    circle.position = self.view.center;\n    [self.view.layer addSublayer:circle];\n    circle.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 100, 100)].CGPath;\n    circle.strokeColor = [UIColor redColor].CGColor;\n    circle.fillColor = [UIColor yellowColor].CGColor;\n    circle.lineWidth = 10;\n    circle.lineCap = @\"round\";\n    circle.strokeEnd = 0.75;\n\n```\n\n![CAShapeLayer](http://upload-images.jianshu.io/upload_images/1835430-0eb13e22ef4f77d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n代码很简单，结合这张图片你就应该大概知道每个属性是做什么的。\n挑几个讲一下吧：\n\n 1.path\n \n 可以看到，老司机这里用的是UIBezierPath生成一个path，然后取他的CGPath来获取路径的。他是什么呢？是`一层对CGPath的封装`，他更符合OC面向对象的语法风格。这都不是重点，老司机并不想讲怎么使用UIBezierPath。`重点是`这里有一个`初学者经常会犯的错误`，`同学们在绘制曲线的时候经常会以layer在父图层中的相对位置去绘制曲线，这是错的！！！应该以layer自身的坐标系划线。`别不当回事，你错的时候就知道咋回事了😈\n \n 另外，如下图所示，`整个圆形`UIBezierPath其实是`分为多个子路径`绘制的，这个特性在CAKeyframeAnimation中会有特殊的应用（可以回顾一下[第一篇](http://www.jianshu.com/p/92a0661a21c6)）。\n \n\n![子路径](http://upload-images.jianshu.io/upload_images/1835430-a6e13a035133e6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n 2.strokeEnd\n \n 是轮廓终点的属性，`取值范围[0,1]`。代表轮廓终点在整条路径的百分比处，相应的还有strokeStart属性。\n \n 不过你应该思考的是：\n \n 首先，`哪个是所谓的终点`？老司机可以告诉你答案，`靠上的那个点`是终点。那为什么0.75是在那个位置呢？请记住，`在iOS中，以x轴正方向（即水平向右）为0度，顺时针旋转一周为360度。`\n\n其实说到这里CAShapeLayer的基本用法就结束了。\n\n\n- 你这么说，意思是还有特殊用法咯？\n\n说不上特殊用法，是两个`比较实用`但又偏门`的点`。\n\n1.绘制空心图层\n\n\n![绿油油的好护眼](http://upload-images.jianshu.io/upload_images/1835430-417f6bc522ded01e.gif?imageMogr2/auto-orient/strip)\n\n大家看看上面这个简单的效果，看上去还可以是吧。\n\n这个跟[第三篇](http://www.jianshu.com/p/8e14616679ea)里面那个系统更新样式采用的是两种画法，这个没有使用CADisplayLink做重绘。因为写这个demo时没有考虑到做暂停。\n\n那这个怎么做呢？\n\n把它分成两部分吧，一部分外面不变那部分，一部分中间变那部分。\n\n这时候我们就要考虑`如何画出一个空心的图层`。\n\n老司机先放一下空心图层的代码\n\n```\nCGRect rect = CGRectMake(0, 0, 100, 100);\n    UIBezierPath * rectP = [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:5];\n    UIBezierPath * circleP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 10, 80, 80)];\n    [rectP appendPath:circleP];\n    CAShapeLayer * layer = [CAShapeLayer layer];\n    layer.bounds = CGRectMake(0, 0, 100, 100);\n    layer.position = self.view.center;\n    layer.path = rectP.CGPath;\n    layer.fillColor = [UIColor colorWithWhite:0 alpha:0.5].CGColor;\n    layer.fillRule = kCAFillRuleEvenOdd;\n    [self.view.layer addSublayer:layer];\n\n```\n\n可以看到，事实上老司机`叠加了两条路径`，一个圆角矩形一个圆形，然而这还并不够，因为`layer`还要知道`自己的填充判断规则`，就是重要的`fillRule`属性。\n\n`这个属性是用来判断某一点是否在填充区域内的判断规则。`\n\n他有两个枚举值，`kCAFillRuleNonZero`和`kCAFillRuleEvenOdd`。\n\n这里介绍一下分别是如何判断的\n     \n-  kCAFillRuleNonZero\n\t从该点向任意方向画一条射线，若顺时针穿过该射线的条数与逆时针穿过该射线的条数不相等，则表示该点在区域内部，否则在外部。\n\t\n- kCAFillRuleEvenOdd\n\t从该点向任意方向画一条射线，如果该射线穿过奇数条路径则该点在区域内部，否则在外部。\n\t\n\t\n2.strokeEnd\n\n为什么又说strokeEnd？你还说你不是凑字！\n\n真不是，这次说他主要是想表达`这个属性是默认支持隐式动画的`。\n\n隐式动画就是不用显示声明，系统默认为我们实现的动画。\n\n网上99%的CAShapeLayer教程都是用这个属性做一个环形指示器，诶，`老司机就是不讲这个例子`，你们自己去想吧，无辜脸。\n\n像下面这个图一样，不过他们都留了一个坑没说。我敢保证如果你只用strokeEnd和strokeStart两个属性交替配合，绝对实现不了这个效果。如果`不信邪你可以现在去试试`，啧啧啧。我会在文章的最后放出如何才能解决你们遇到的问题，别着急往下拉哦。（你要是没遇到问题，老司机再教你一个快捷键，`command + A`，`然后按delete键`可以快速整理代码）。\n\n\n\n![这张图是我盗的](http://upload-images.jianshu.io/upload_images/1835430-efdce1871fc493f7.gif?imageMogr2/auto-orient/strip)\n\n恩，这个strokeEnd的隐式动画讲完，上面老司机放的那个绿色背景进度图那个你也能做了，当给你们留的作业了自己去实现吧😊。\n\n\n3.虚线\n\n这个属性真的是`一直被忽略`，从未被使用。\n\n![画了一条虚线](http://upload-images.jianshu.io/upload_images/1835430-48382570f6bb461b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n代码还是上面circle那段代码，在末尾添了三句话\n\n\t\n\tcircle.lineWidth = 2;\n    circle.lineDashPhase = 3;\n    circle.lineDashPattern = @[@5,@5,@15,@5];\n    \n因为间距很小，原来的线宽显示不出来所以这里更改了线宽。\n\n先看lineDashPattern这个属性。这个属性指的是实线与虚线长度交替的数组。注意`奇数位为实线`，`偶数位为虚线`，`单位像素`。系统会按照给定数组自动重复设置虚线。\n\nlineDashPhase这个属性是告诉系统从多少开始计算这个距离。比如上图中第一段实现的距离明显小于5，其实他是2，因为我们从3开始计算，5 - 3就剩2了。\n\n说到这里，CAShapeLayer的一些用法就真的介绍完毕了。\n- - -\n\n### CATextLayer\n\n相比CAShapeLayer，可能CATextLayer的用途更加单一一些，他可以用来`展示文字`。\n\n那个，等会再关浏览器，你先听我说完😭\n\n我知道，有UILabel，你完全不需要使用这个。\n但是存在必定是有他的意义的。正如UILabel是已经封装完成的，有一些我们想用的功能UILabel不一定有，比如下面这个：\n\n![歌词Label](http://upload-images.jianshu.io/upload_images/1835430-4a92c932f13a83d1.gif?imageMogr2/auto-orient/strip)\n\n当然这个效果用两个label叠加再用一个mask也可以实现，不过`两个label实在是不优雅`。所以`老司机决定用CATextLayer来实现这个效果`。\n\n先来讲一下CATextLayer的基本使用方法吧。\n\n他的几个属性都是见名知意，就是跟label相差无几的属性。最简单的你想让他显示文字的话直接给string属性赋值就好了。\n\n不要太简单，哈哈哈😆\n\nCATextLayer我们就讲到这里。\n怎么可能，我当然会把这个的实现方式告诉大家啊~\n\n先给大家看一个效果：\n\n\n![这个效果你一定会](http://upload-images.jianshu.io/upload_images/1835430-bdb264c3fde947b7.gif?imageMogr2/auto-orient/strip)\n\n这个效果你一定会吧，一个绿色的CALayer，，上面盖了一个红色的CAShapeLayer，strokeEnd从0到1，对吧。\n\n那怎么让他`只显示字的区域呢`？记得老司机曾经讲个CALayer的一个属性叫做`mask属性`么？对咯，就是`以一个CATextLayer做红色的CALayer的mask，CATextLayer的字体设置有颜色，背景设置透明色，这样就只能显示出红色的CALayer的文字部分了`~把他封装在一个UIView里面我们的展示歌词的Label就完成了。大家可以去[这里下载这个Demo](https://github.com/CodeWicky/DWLyricLabel.git)哦~\n\n恩，其实只要是显示文字，CATextLayer都可以完成，想要定制一些UILabel没有的功能，都可以考虑使用CATextLayer。\n\nCATextLayer也算是讲完了~\n\n- - -\n\n回过头来说之前留的那个坑。问题就是当你`第一循环结束`后你想把你的`strokeEnd恢复成0`你却发现他是`以动画形式恢复`回去的不是你要的效果对吧？这就是因为他的隐式动画了。因为这时候我们不需要他的动画是吧？知道原因就好办了，我们可以通过\nCATransaction显式的关闭他的动画，恢复成0，再打开动画，是不是就行了？哈哈哈，就是这么简单。\n\n```\n[CATransaction begin];\n[CATransaction setDisableActions:YES];\nself.layer.strokeEnd = 0;\n[CATransaction setDisableActions:NO];\n[CATransaction commit];\n\n```\n\n- - -\n\n坑填完了，看截图你们也知道老司机是熬夜给你们码字的吧，是时候点波赞👍加波关注💗了~\n","source":"_posts/老司机带你走进Core-Animation-之CAShapeLayer和CATextLayer.md","raw":"---\n\ntitle: 老司机带你走进Core Animation 之CAShapeLayer和CATextLayer\nlayout: post\ndate: 2016-11-19 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CAAnimation \n- 核心动画\n- CAShapeLayer\n- CATextLayer\ncategories: 核心动画\n\n---\n\n![老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://upload-images.jianshu.io/upload_images/1835430-7a62b93ba150bff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n\n呐，老司机之前说过会来讲CALayer的，当然不会食言啦，今天就讲一些CALayer相关的吧。\n\n由于老司机这个想起来啥说啥的特点，CALayer与UIView的一些关系以及CALayer的一些重要属性，早在老司机CoreAnimation系列第一章里面就已经做了很系统的介绍。本着从来不凑字的原则（啧啧啧，违心），没看到的同学去[这里](http://www.jianshu.com/p/92a0661a21c6)补票吧。\n\n不要怪老司机做事没有条理哦，毕竟当时也没想做成系列的，真的是有这么多读者才支持我一步一步写到这里。\n\n\n![爱你们哟](http://upload-images.jianshu.io/upload_images/1835430-29aa5a4d1032747c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n废话有点多，那今天要讲什么呢？就讲讲CALayer的两个子类，`CAShapeLayer`和`CATextLayer`吧。\n\n<!-- more -->\n\n- - -\n### CAShapeLayer\n\n其实在日常使用中，CALayer能满足需求的情况还是比较少的，（当然你用它来划线还是很好用的），原因就在于`CALayer并不能很方便`的生成除了矩形的`其他形状`。（其实老司机更愿意认为他是作为基类存在的，为所有子类提供公有属性及方法）由于作为基类的CALayer老司机已经介绍过了，所以接下来的两个子类老司机都会`只讲述其差异性`。然而`CAShapeLayer则`是作为一个强大无比的子类出现的，通过名字我们大概就可以猜到，`他可以画出各样的形状`。\n\n- CAShapeLayer的优势\n\n老生常谈了，肯定是性能啊（不提性能要如何装作一副很厉害的样子），他的`渲染都在GPU里面`，`不！占！内！存！`\n\n- CAShapeLayer如何绘制出各种图形？\n\n我们可以从头文件中观察到，CAShapeLayer有一个独有的属性，是`Path`。他是一个CGPathRef对象。我们知道，这就是个路径，没错，`CAShapeLayer就是根据这个路径绘制出各种形状的图形的`。\n\n```\nCAShapeLayer * circle = [CAShapeLayer layer];\n    circle.bounds = CGRectMake(0, 0, 100, 100);\n    circle.position = self.view.center;\n    [self.view.layer addSublayer:circle];\n    circle.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 100, 100)].CGPath;\n    circle.strokeColor = [UIColor redColor].CGColor;\n    circle.fillColor = [UIColor yellowColor].CGColor;\n    circle.lineWidth = 10;\n    circle.lineCap = @\"round\";\n    circle.strokeEnd = 0.75;\n\n```\n\n![CAShapeLayer](http://upload-images.jianshu.io/upload_images/1835430-0eb13e22ef4f77d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n代码很简单，结合这张图片你就应该大概知道每个属性是做什么的。\n挑几个讲一下吧：\n\n 1.path\n \n 可以看到，老司机这里用的是UIBezierPath生成一个path，然后取他的CGPath来获取路径的。他是什么呢？是`一层对CGPath的封装`，他更符合OC面向对象的语法风格。这都不是重点，老司机并不想讲怎么使用UIBezierPath。`重点是`这里有一个`初学者经常会犯的错误`，`同学们在绘制曲线的时候经常会以layer在父图层中的相对位置去绘制曲线，这是错的！！！应该以layer自身的坐标系划线。`别不当回事，你错的时候就知道咋回事了😈\n \n 另外，如下图所示，`整个圆形`UIBezierPath其实是`分为多个子路径`绘制的，这个特性在CAKeyframeAnimation中会有特殊的应用（可以回顾一下[第一篇](http://www.jianshu.com/p/92a0661a21c6)）。\n \n\n![子路径](http://upload-images.jianshu.io/upload_images/1835430-a6e13a035133e6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n 2.strokeEnd\n \n 是轮廓终点的属性，`取值范围[0,1]`。代表轮廓终点在整条路径的百分比处，相应的还有strokeStart属性。\n \n 不过你应该思考的是：\n \n 首先，`哪个是所谓的终点`？老司机可以告诉你答案，`靠上的那个点`是终点。那为什么0.75是在那个位置呢？请记住，`在iOS中，以x轴正方向（即水平向右）为0度，顺时针旋转一周为360度。`\n\n其实说到这里CAShapeLayer的基本用法就结束了。\n\n\n- 你这么说，意思是还有特殊用法咯？\n\n说不上特殊用法，是两个`比较实用`但又偏门`的点`。\n\n1.绘制空心图层\n\n\n![绿油油的好护眼](http://upload-images.jianshu.io/upload_images/1835430-417f6bc522ded01e.gif?imageMogr2/auto-orient/strip)\n\n大家看看上面这个简单的效果，看上去还可以是吧。\n\n这个跟[第三篇](http://www.jianshu.com/p/8e14616679ea)里面那个系统更新样式采用的是两种画法，这个没有使用CADisplayLink做重绘。因为写这个demo时没有考虑到做暂停。\n\n那这个怎么做呢？\n\n把它分成两部分吧，一部分外面不变那部分，一部分中间变那部分。\n\n这时候我们就要考虑`如何画出一个空心的图层`。\n\n老司机先放一下空心图层的代码\n\n```\nCGRect rect = CGRectMake(0, 0, 100, 100);\n    UIBezierPath * rectP = [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:5];\n    UIBezierPath * circleP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 10, 80, 80)];\n    [rectP appendPath:circleP];\n    CAShapeLayer * layer = [CAShapeLayer layer];\n    layer.bounds = CGRectMake(0, 0, 100, 100);\n    layer.position = self.view.center;\n    layer.path = rectP.CGPath;\n    layer.fillColor = [UIColor colorWithWhite:0 alpha:0.5].CGColor;\n    layer.fillRule = kCAFillRuleEvenOdd;\n    [self.view.layer addSublayer:layer];\n\n```\n\n可以看到，事实上老司机`叠加了两条路径`，一个圆角矩形一个圆形，然而这还并不够，因为`layer`还要知道`自己的填充判断规则`，就是重要的`fillRule`属性。\n\n`这个属性是用来判断某一点是否在填充区域内的判断规则。`\n\n他有两个枚举值，`kCAFillRuleNonZero`和`kCAFillRuleEvenOdd`。\n\n这里介绍一下分别是如何判断的\n     \n-  kCAFillRuleNonZero\n\t从该点向任意方向画一条射线，若顺时针穿过该射线的条数与逆时针穿过该射线的条数不相等，则表示该点在区域内部，否则在外部。\n\t\n- kCAFillRuleEvenOdd\n\t从该点向任意方向画一条射线，如果该射线穿过奇数条路径则该点在区域内部，否则在外部。\n\t\n\t\n2.strokeEnd\n\n为什么又说strokeEnd？你还说你不是凑字！\n\n真不是，这次说他主要是想表达`这个属性是默认支持隐式动画的`。\n\n隐式动画就是不用显示声明，系统默认为我们实现的动画。\n\n网上99%的CAShapeLayer教程都是用这个属性做一个环形指示器，诶，`老司机就是不讲这个例子`，你们自己去想吧，无辜脸。\n\n像下面这个图一样，不过他们都留了一个坑没说。我敢保证如果你只用strokeEnd和strokeStart两个属性交替配合，绝对实现不了这个效果。如果`不信邪你可以现在去试试`，啧啧啧。我会在文章的最后放出如何才能解决你们遇到的问题，别着急往下拉哦。（你要是没遇到问题，老司机再教你一个快捷键，`command + A`，`然后按delete键`可以快速整理代码）。\n\n\n\n![这张图是我盗的](http://upload-images.jianshu.io/upload_images/1835430-efdce1871fc493f7.gif?imageMogr2/auto-orient/strip)\n\n恩，这个strokeEnd的隐式动画讲完，上面老司机放的那个绿色背景进度图那个你也能做了，当给你们留的作业了自己去实现吧😊。\n\n\n3.虚线\n\n这个属性真的是`一直被忽略`，从未被使用。\n\n![画了一条虚线](http://upload-images.jianshu.io/upload_images/1835430-48382570f6bb461b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n代码还是上面circle那段代码，在末尾添了三句话\n\n\t\n\tcircle.lineWidth = 2;\n    circle.lineDashPhase = 3;\n    circle.lineDashPattern = @[@5,@5,@15,@5];\n    \n因为间距很小，原来的线宽显示不出来所以这里更改了线宽。\n\n先看lineDashPattern这个属性。这个属性指的是实线与虚线长度交替的数组。注意`奇数位为实线`，`偶数位为虚线`，`单位像素`。系统会按照给定数组自动重复设置虚线。\n\nlineDashPhase这个属性是告诉系统从多少开始计算这个距离。比如上图中第一段实现的距离明显小于5，其实他是2，因为我们从3开始计算，5 - 3就剩2了。\n\n说到这里，CAShapeLayer的一些用法就真的介绍完毕了。\n- - -\n\n### CATextLayer\n\n相比CAShapeLayer，可能CATextLayer的用途更加单一一些，他可以用来`展示文字`。\n\n那个，等会再关浏览器，你先听我说完😭\n\n我知道，有UILabel，你完全不需要使用这个。\n但是存在必定是有他的意义的。正如UILabel是已经封装完成的，有一些我们想用的功能UILabel不一定有，比如下面这个：\n\n![歌词Label](http://upload-images.jianshu.io/upload_images/1835430-4a92c932f13a83d1.gif?imageMogr2/auto-orient/strip)\n\n当然这个效果用两个label叠加再用一个mask也可以实现，不过`两个label实在是不优雅`。所以`老司机决定用CATextLayer来实现这个效果`。\n\n先来讲一下CATextLayer的基本使用方法吧。\n\n他的几个属性都是见名知意，就是跟label相差无几的属性。最简单的你想让他显示文字的话直接给string属性赋值就好了。\n\n不要太简单，哈哈哈😆\n\nCATextLayer我们就讲到这里。\n怎么可能，我当然会把这个的实现方式告诉大家啊~\n\n先给大家看一个效果：\n\n\n![这个效果你一定会](http://upload-images.jianshu.io/upload_images/1835430-bdb264c3fde947b7.gif?imageMogr2/auto-orient/strip)\n\n这个效果你一定会吧，一个绿色的CALayer，，上面盖了一个红色的CAShapeLayer，strokeEnd从0到1，对吧。\n\n那怎么让他`只显示字的区域呢`？记得老司机曾经讲个CALayer的一个属性叫做`mask属性`么？对咯，就是`以一个CATextLayer做红色的CALayer的mask，CATextLayer的字体设置有颜色，背景设置透明色，这样就只能显示出红色的CALayer的文字部分了`~把他封装在一个UIView里面我们的展示歌词的Label就完成了。大家可以去[这里下载这个Demo](https://github.com/CodeWicky/DWLyricLabel.git)哦~\n\n恩，其实只要是显示文字，CATextLayer都可以完成，想要定制一些UILabel没有的功能，都可以考虑使用CATextLayer。\n\nCATextLayer也算是讲完了~\n\n- - -\n\n回过头来说之前留的那个坑。问题就是当你`第一循环结束`后你想把你的`strokeEnd恢复成0`你却发现他是`以动画形式恢复`回去的不是你要的效果对吧？这就是因为他的隐式动画了。因为这时候我们不需要他的动画是吧？知道原因就好办了，我们可以通过\nCATransaction显式的关闭他的动画，恢复成0，再打开动画，是不是就行了？哈哈哈，就是这么简单。\n\n```\n[CATransaction begin];\n[CATransaction setDisableActions:YES];\nself.layer.strokeEnd = 0;\n[CATransaction setDisableActions:NO];\n[CATransaction commit];\n\n```\n\n- - -\n\n坑填完了，看截图你们也知道老司机是熬夜给你们码字的吧，是时候点波赞👍加波关注💗了~\n","slug":"老司机带你走进Core-Animation-之CAShapeLayer和CATextLayer","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htpt0012jigbgcli384k","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-7a62b93ba150bff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之CAShapeLayer和CATextLayer\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>呐，老司机之前说过会来讲CALayer的，当然不会食言啦，今天就讲一些CALayer相关的吧。</p>\n<p>由于老司机这个想起来啥说啥的特点，CALayer与UIView的一些关系以及CALayer的一些重要属性，早在老司机CoreAnimation系列第一章里面就已经做了很系统的介绍。本着从来不凑字的原则（啧啧啧，违心），没看到的同学去<a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">这里</a>补票吧。</p>\n<p>不要怪老司机做事没有条理哦，毕竟当时也没想做成系列的，真的是有这么多读者才支持我一步一步写到这里。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-29aa5a4d1032747c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你们哟\"></p>\n<p>废话有点多，那今天要讲什么呢？就讲讲CALayer的两个子类，<code>CAShapeLayer</code>和<code>CATextLayer</code>吧。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"CAShapeLayer\"><a href=\"#CAShapeLayer\" class=\"headerlink\" title=\"CAShapeLayer\"></a>CAShapeLayer</h3><p>其实在日常使用中，CALayer能满足需求的情况还是比较少的，（当然你用它来划线还是很好用的），原因就在于<code>CALayer并不能很方便</code>的生成除了矩形的<code>其他形状</code>。（其实老司机更愿意认为他是作为基类存在的，为所有子类提供公有属性及方法）由于作为基类的CALayer老司机已经介绍过了，所以接下来的两个子类老司机都会<code>只讲述其差异性</code>。然而<code>CAShapeLayer则</code>是作为一个强大无比的子类出现的，通过名字我们大概就可以猜到，<code>他可以画出各样的形状</code>。</p>\n<ul>\n<li>CAShapeLayer的优势</li>\n</ul>\n<p>老生常谈了，肯定是性能啊（不提性能要如何装作一副很厉害的样子），他的<code>渲染都在GPU里面</code>，<code>不！占！内！存！</code></p>\n<ul>\n<li>CAShapeLayer如何绘制出各种图形？</li>\n</ul>\n<p>我们可以从头文件中观察到，CAShapeLayer有一个独有的属性，是<code>Path</code>。他是一个CGPathRef对象。我们知道，这就是个路径，没错，<code>CAShapeLayer就是根据这个路径绘制出各种形状的图形的</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">CAShapeLayer * circle = [CAShapeLayer layer];</div><div class=\"line\">    circle.bounds = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">    circle.position = self.view.center;</div><div class=\"line\">    [self.view.layer addSublayer:circle];</div><div class=\"line\">    circle.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 100, 100)].CGPath;</div><div class=\"line\">    circle.strokeColor = [UIColor redColor].CGColor;</div><div class=\"line\">    circle.fillColor = [UIColor yellowColor].CGColor;</div><div class=\"line\">    circle.lineWidth = 10;</div><div class=\"line\">    circle.lineCap = @&quot;round&quot;;</div><div class=\"line\">    circle.strokeEnd = 0.75;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0eb13e22ef4f77d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CAShapeLayer\"><br>代码很简单，结合这张图片你就应该大概知道每个属性是做什么的。<br>挑几个讲一下吧：</p>\n<p> 1.path</p>\n<p> 可以看到，老司机这里用的是UIBezierPath生成一个path，然后取他的CGPath来获取路径的。他是什么呢？是<code>一层对CGPath的封装</code>，他更符合OC面向对象的语法风格。这都不是重点，老司机并不想讲怎么使用UIBezierPath。<code>重点是</code>这里有一个<code>初学者经常会犯的错误</code>，<code>同学们在绘制曲线的时候经常会以layer在父图层中的相对位置去绘制曲线，这是错的！！！应该以layer自身的坐标系划线。</code>别不当回事，你错的时候就知道咋回事了😈</p>\n<p> 另外，如下图所示，<code>整个圆形</code>UIBezierPath其实是<code>分为多个子路径</code>绘制的，这个特性在CAKeyframeAnimation中会有特殊的应用（可以回顾一下<a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">第一篇</a>）。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a6e13a035133e6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"子路径\"></p>\n<p> 2.strokeEnd</p>\n<p> 是轮廓终点的属性，<code>取值范围[0,1]</code>。代表轮廓终点在整条路径的百分比处，相应的还有strokeStart属性。</p>\n<p> 不过你应该思考的是：</p>\n<p> 首先，<code>哪个是所谓的终点</code>？老司机可以告诉你答案，<code>靠上的那个点</code>是终点。那为什么0.75是在那个位置呢？请记住，<code>在iOS中，以x轴正方向（即水平向右）为0度，顺时针旋转一周为360度。</code></p>\n<p>其实说到这里CAShapeLayer的基本用法就结束了。</p>\n<ul>\n<li>你这么说，意思是还有特殊用法咯？</li>\n</ul>\n<p>说不上特殊用法，是两个<code>比较实用</code>但又偏门<code>的点</code>。</p>\n<p>1.绘制空心图层</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-417f6bc522ded01e.gif?imageMogr2/auto-orient/strip\" alt=\"绿油油的好护眼\"></p>\n<p>大家看看上面这个简单的效果，看上去还可以是吧。</p>\n<p>这个跟<a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">第三篇</a>里面那个系统更新样式采用的是两种画法，这个没有使用CADisplayLink做重绘。因为写这个demo时没有考虑到做暂停。</p>\n<p>那这个怎么做呢？</p>\n<p>把它分成两部分吧，一部分外面不变那部分，一部分中间变那部分。</p>\n<p>这时候我们就要考虑<code>如何画出一个空心的图层</code>。</p>\n<p>老司机先放一下空心图层的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGRect rect = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">    UIBezierPath * rectP = [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:5];</div><div class=\"line\">    UIBezierPath * circleP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 10, 80, 80)];</div><div class=\"line\">    [rectP appendPath:circleP];</div><div class=\"line\">    CAShapeLayer * layer = [CAShapeLayer layer];</div><div class=\"line\">    layer.bounds = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">    layer.position = self.view.center;</div><div class=\"line\">    layer.path = rectP.CGPath;</div><div class=\"line\">    layer.fillColor = [UIColor colorWithWhite:0 alpha:0.5].CGColor;</div><div class=\"line\">    layer.fillRule = kCAFillRuleEvenOdd;</div><div class=\"line\">    [self.view.layer addSublayer:layer];</div></pre></td></tr></table></figure>\n<p>可以看到，事实上老司机<code>叠加了两条路径</code>，一个圆角矩形一个圆形，然而这还并不够，因为<code>layer</code>还要知道<code>自己的填充判断规则</code>，就是重要的<code>fillRule</code>属性。</p>\n<p><code>这个属性是用来判断某一点是否在填充区域内的判断规则。</code></p>\n<p>他有两个枚举值，<code>kCAFillRuleNonZero</code>和<code>kCAFillRuleEvenOdd</code>。</p>\n<p>这里介绍一下分别是如何判断的</p>\n<ul>\n<li><p>kCAFillRuleNonZero<br> 从该点向任意方向画一条射线，若顺时针穿过该射线的条数与逆时针穿过该射线的条数不相等，则表示该点在区域内部，否则在外部。</p>\n</li>\n<li><p>kCAFillRuleEvenOdd<br>  从该点向任意方向画一条射线，如果该射线穿过奇数条路径则该点在区域内部，否则在外部。</p>\n</li>\n</ul>\n<p>2.strokeEnd</p>\n<p>为什么又说strokeEnd？你还说你不是凑字！</p>\n<p>真不是，这次说他主要是想表达<code>这个属性是默认支持隐式动画的</code>。</p>\n<p>隐式动画就是不用显示声明，系统默认为我们实现的动画。</p>\n<p>网上99%的CAShapeLayer教程都是用这个属性做一个环形指示器，诶，<code>老司机就是不讲这个例子</code>，你们自己去想吧，无辜脸。</p>\n<p>像下面这个图一样，不过他们都留了一个坑没说。我敢保证如果你只用strokeEnd和strokeStart两个属性交替配合，绝对实现不了这个效果。如果<code>不信邪你可以现在去试试</code>，啧啧啧。我会在文章的最后放出如何才能解决你们遇到的问题，别着急往下拉哦。（你要是没遇到问题，老司机再教你一个快捷键，<code>command + A</code>，<code>然后按delete键</code>可以快速整理代码）。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-efdce1871fc493f7.gif?imageMogr2/auto-orient/strip\" alt=\"这张图是我盗的\"></p>\n<p>恩，这个strokeEnd的隐式动画讲完，上面老司机放的那个绿色背景进度图那个你也能做了，当给你们留的作业了自己去实现吧😊。</p>\n<p>3.虚线</p>\n<p>这个属性真的是<code>一直被忽略</code>，从未被使用。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-48382570f6bb461b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"画了一条虚线\"></p>\n<p>代码还是上面circle那段代码，在末尾添了三句话</p>\n<pre><code>circle.lineWidth = 2;\ncircle.lineDashPhase = 3;\ncircle.lineDashPattern = @[@5,@5,@15,@5];\n</code></pre><p>因为间距很小，原来的线宽显示不出来所以这里更改了线宽。</p>\n<p>先看lineDashPattern这个属性。这个属性指的是实线与虚线长度交替的数组。注意<code>奇数位为实线</code>，<code>偶数位为虚线</code>，<code>单位像素</code>。系统会按照给定数组自动重复设置虚线。</p>\n<p>lineDashPhase这个属性是告诉系统从多少开始计算这个距离。比如上图中第一段实现的距离明显小于5，其实他是2，因为我们从3开始计算，5 - 3就剩2了。</p>\n<p>说到这里，CAShapeLayer的一些用法就真的介绍完毕了。</p>\n<hr>\n<h3 id=\"CATextLayer\"><a href=\"#CATextLayer\" class=\"headerlink\" title=\"CATextLayer\"></a>CATextLayer</h3><p>相比CAShapeLayer，可能CATextLayer的用途更加单一一些，他可以用来<code>展示文字</code>。</p>\n<p>那个，等会再关浏览器，你先听我说完😭</p>\n<p>我知道，有UILabel，你完全不需要使用这个。<br>但是存在必定是有他的意义的。正如UILabel是已经封装完成的，有一些我们想用的功能UILabel不一定有，比如下面这个：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-4a92c932f13a83d1.gif?imageMogr2/auto-orient/strip\" alt=\"歌词Label\"></p>\n<p>当然这个效果用两个label叠加再用一个mask也可以实现，不过<code>两个label实在是不优雅</code>。所以<code>老司机决定用CATextLayer来实现这个效果</code>。</p>\n<p>先来讲一下CATextLayer的基本使用方法吧。</p>\n<p>他的几个属性都是见名知意，就是跟label相差无几的属性。最简单的你想让他显示文字的话直接给string属性赋值就好了。</p>\n<p>不要太简单，哈哈哈😆</p>\n<p>CATextLayer我们就讲到这里。<br>怎么可能，我当然会把这个的实现方式告诉大家啊~</p>\n<p>先给大家看一个效果：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bdb264c3fde947b7.gif?imageMogr2/auto-orient/strip\" alt=\"这个效果你一定会\"></p>\n<p>这个效果你一定会吧，一个绿色的CALayer，，上面盖了一个红色的CAShapeLayer，strokeEnd从0到1，对吧。</p>\n<p>那怎么让他<code>只显示字的区域呢</code>？记得老司机曾经讲个CALayer的一个属性叫做<code>mask属性</code>么？对咯，就是<code>以一个CATextLayer做红色的CALayer的mask，CATextLayer的字体设置有颜色，背景设置透明色，这样就只能显示出红色的CALayer的文字部分了</code>~把他封装在一个UIView里面我们的展示歌词的Label就完成了。大家可以去<a href=\"https://github.com/CodeWicky/DWLyricLabel.git\" target=\"_blank\" rel=\"external\">这里下载这个Demo</a>哦~</p>\n<p>恩，其实只要是显示文字，CATextLayer都可以完成，想要定制一些UILabel没有的功能，都可以考虑使用CATextLayer。</p>\n<p>CATextLayer也算是讲完了~</p>\n<hr>\n<p>回过头来说之前留的那个坑。问题就是当你<code>第一循环结束</code>后你想把你的<code>strokeEnd恢复成0</code>你却发现他是<code>以动画形式恢复</code>回去的不是你要的效果对吧？这就是因为他的隐式动画了。因为这时候我们不需要他的动画是吧？知道原因就好办了，我们可以通过<br>CATransaction显式的关闭他的动画，恢复成0，再打开动画，是不是就行了？哈哈哈，就是这么简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[CATransaction begin];</div><div class=\"line\">[CATransaction setDisableActions:YES];</div><div class=\"line\">self.layer.strokeEnd = 0;</div><div class=\"line\">[CATransaction setDisableActions:NO];</div><div class=\"line\">[CATransaction commit];</div></pre></td></tr></table></figure>\n<hr>\n<p>坑填完了，看截图你们也知道老司机是熬夜给你们码字的吧，是时候点波赞👍加波关注💗了~</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-7a62b93ba150bff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之CAShapeLayer和CATextLayer\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>呐，老司机之前说过会来讲CALayer的，当然不会食言啦，今天就讲一些CALayer相关的吧。</p>\n<p>由于老司机这个想起来啥说啥的特点，CALayer与UIView的一些关系以及CALayer的一些重要属性，早在老司机CoreAnimation系列第一章里面就已经做了很系统的介绍。本着从来不凑字的原则（啧啧啧，违心），没看到的同学去<a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">这里</a>补票吧。</p>\n<p>不要怪老司机做事没有条理哦，毕竟当时也没想做成系列的，真的是有这么多读者才支持我一步一步写到这里。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-29aa5a4d1032747c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你们哟\"></p>\n<p>废话有点多，那今天要讲什么呢？就讲讲CALayer的两个子类，<code>CAShapeLayer</code>和<code>CATextLayer</code>吧。</p>","more":"<hr>\n<h3 id=\"CAShapeLayer\"><a href=\"#CAShapeLayer\" class=\"headerlink\" title=\"CAShapeLayer\"></a>CAShapeLayer</h3><p>其实在日常使用中，CALayer能满足需求的情况还是比较少的，（当然你用它来划线还是很好用的），原因就在于<code>CALayer并不能很方便</code>的生成除了矩形的<code>其他形状</code>。（其实老司机更愿意认为他是作为基类存在的，为所有子类提供公有属性及方法）由于作为基类的CALayer老司机已经介绍过了，所以接下来的两个子类老司机都会<code>只讲述其差异性</code>。然而<code>CAShapeLayer则</code>是作为一个强大无比的子类出现的，通过名字我们大概就可以猜到，<code>他可以画出各样的形状</code>。</p>\n<ul>\n<li>CAShapeLayer的优势</li>\n</ul>\n<p>老生常谈了，肯定是性能啊（不提性能要如何装作一副很厉害的样子），他的<code>渲染都在GPU里面</code>，<code>不！占！内！存！</code></p>\n<ul>\n<li>CAShapeLayer如何绘制出各种图形？</li>\n</ul>\n<p>我们可以从头文件中观察到，CAShapeLayer有一个独有的属性，是<code>Path</code>。他是一个CGPathRef对象。我们知道，这就是个路径，没错，<code>CAShapeLayer就是根据这个路径绘制出各种形状的图形的</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">CAShapeLayer * circle = [CAShapeLayer layer];</div><div class=\"line\">    circle.bounds = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">    circle.position = self.view.center;</div><div class=\"line\">    [self.view.layer addSublayer:circle];</div><div class=\"line\">    circle.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 100, 100)].CGPath;</div><div class=\"line\">    circle.strokeColor = [UIColor redColor].CGColor;</div><div class=\"line\">    circle.fillColor = [UIColor yellowColor].CGColor;</div><div class=\"line\">    circle.lineWidth = 10;</div><div class=\"line\">    circle.lineCap = @&quot;round&quot;;</div><div class=\"line\">    circle.strokeEnd = 0.75;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-0eb13e22ef4f77d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CAShapeLayer\"><br>代码很简单，结合这张图片你就应该大概知道每个属性是做什么的。<br>挑几个讲一下吧：</p>\n<p> 1.path</p>\n<p> 可以看到，老司机这里用的是UIBezierPath生成一个path，然后取他的CGPath来获取路径的。他是什么呢？是<code>一层对CGPath的封装</code>，他更符合OC面向对象的语法风格。这都不是重点，老司机并不想讲怎么使用UIBezierPath。<code>重点是</code>这里有一个<code>初学者经常会犯的错误</code>，<code>同学们在绘制曲线的时候经常会以layer在父图层中的相对位置去绘制曲线，这是错的！！！应该以layer自身的坐标系划线。</code>别不当回事，你错的时候就知道咋回事了😈</p>\n<p> 另外，如下图所示，<code>整个圆形</code>UIBezierPath其实是<code>分为多个子路径</code>绘制的，这个特性在CAKeyframeAnimation中会有特殊的应用（可以回顾一下<a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">第一篇</a>）。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a6e13a035133e6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"子路径\"></p>\n<p> 2.strokeEnd</p>\n<p> 是轮廓终点的属性，<code>取值范围[0,1]</code>。代表轮廓终点在整条路径的百分比处，相应的还有strokeStart属性。</p>\n<p> 不过你应该思考的是：</p>\n<p> 首先，<code>哪个是所谓的终点</code>？老司机可以告诉你答案，<code>靠上的那个点</code>是终点。那为什么0.75是在那个位置呢？请记住，<code>在iOS中，以x轴正方向（即水平向右）为0度，顺时针旋转一周为360度。</code></p>\n<p>其实说到这里CAShapeLayer的基本用法就结束了。</p>\n<ul>\n<li>你这么说，意思是还有特殊用法咯？</li>\n</ul>\n<p>说不上特殊用法，是两个<code>比较实用</code>但又偏门<code>的点</code>。</p>\n<p>1.绘制空心图层</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-417f6bc522ded01e.gif?imageMogr2/auto-orient/strip\" alt=\"绿油油的好护眼\"></p>\n<p>大家看看上面这个简单的效果，看上去还可以是吧。</p>\n<p>这个跟<a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">第三篇</a>里面那个系统更新样式采用的是两种画法，这个没有使用CADisplayLink做重绘。因为写这个demo时没有考虑到做暂停。</p>\n<p>那这个怎么做呢？</p>\n<p>把它分成两部分吧，一部分外面不变那部分，一部分中间变那部分。</p>\n<p>这时候我们就要考虑<code>如何画出一个空心的图层</code>。</p>\n<p>老司机先放一下空心图层的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGRect rect = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">    UIBezierPath * rectP = [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:5];</div><div class=\"line\">    UIBezierPath * circleP = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 10, 80, 80)];</div><div class=\"line\">    [rectP appendPath:circleP];</div><div class=\"line\">    CAShapeLayer * layer = [CAShapeLayer layer];</div><div class=\"line\">    layer.bounds = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">    layer.position = self.view.center;</div><div class=\"line\">    layer.path = rectP.CGPath;</div><div class=\"line\">    layer.fillColor = [UIColor colorWithWhite:0 alpha:0.5].CGColor;</div><div class=\"line\">    layer.fillRule = kCAFillRuleEvenOdd;</div><div class=\"line\">    [self.view.layer addSublayer:layer];</div></pre></td></tr></table></figure>\n<p>可以看到，事实上老司机<code>叠加了两条路径</code>，一个圆角矩形一个圆形，然而这还并不够，因为<code>layer</code>还要知道<code>自己的填充判断规则</code>，就是重要的<code>fillRule</code>属性。</p>\n<p><code>这个属性是用来判断某一点是否在填充区域内的判断规则。</code></p>\n<p>他有两个枚举值，<code>kCAFillRuleNonZero</code>和<code>kCAFillRuleEvenOdd</code>。</p>\n<p>这里介绍一下分别是如何判断的</p>\n<ul>\n<li><p>kCAFillRuleNonZero<br> 从该点向任意方向画一条射线，若顺时针穿过该射线的条数与逆时针穿过该射线的条数不相等，则表示该点在区域内部，否则在外部。</p>\n</li>\n<li><p>kCAFillRuleEvenOdd<br>  从该点向任意方向画一条射线，如果该射线穿过奇数条路径则该点在区域内部，否则在外部。</p>\n</li>\n</ul>\n<p>2.strokeEnd</p>\n<p>为什么又说strokeEnd？你还说你不是凑字！</p>\n<p>真不是，这次说他主要是想表达<code>这个属性是默认支持隐式动画的</code>。</p>\n<p>隐式动画就是不用显示声明，系统默认为我们实现的动画。</p>\n<p>网上99%的CAShapeLayer教程都是用这个属性做一个环形指示器，诶，<code>老司机就是不讲这个例子</code>，你们自己去想吧，无辜脸。</p>\n<p>像下面这个图一样，不过他们都留了一个坑没说。我敢保证如果你只用strokeEnd和strokeStart两个属性交替配合，绝对实现不了这个效果。如果<code>不信邪你可以现在去试试</code>，啧啧啧。我会在文章的最后放出如何才能解决你们遇到的问题，别着急往下拉哦。（你要是没遇到问题，老司机再教你一个快捷键，<code>command + A</code>，<code>然后按delete键</code>可以快速整理代码）。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-efdce1871fc493f7.gif?imageMogr2/auto-orient/strip\" alt=\"这张图是我盗的\"></p>\n<p>恩，这个strokeEnd的隐式动画讲完，上面老司机放的那个绿色背景进度图那个你也能做了，当给你们留的作业了自己去实现吧😊。</p>\n<p>3.虚线</p>\n<p>这个属性真的是<code>一直被忽略</code>，从未被使用。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-48382570f6bb461b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"画了一条虚线\"></p>\n<p>代码还是上面circle那段代码，在末尾添了三句话</p>\n<pre><code>circle.lineWidth = 2;\ncircle.lineDashPhase = 3;\ncircle.lineDashPattern = @[@5,@5,@15,@5];\n</code></pre><p>因为间距很小，原来的线宽显示不出来所以这里更改了线宽。</p>\n<p>先看lineDashPattern这个属性。这个属性指的是实线与虚线长度交替的数组。注意<code>奇数位为实线</code>，<code>偶数位为虚线</code>，<code>单位像素</code>。系统会按照给定数组自动重复设置虚线。</p>\n<p>lineDashPhase这个属性是告诉系统从多少开始计算这个距离。比如上图中第一段实现的距离明显小于5，其实他是2，因为我们从3开始计算，5 - 3就剩2了。</p>\n<p>说到这里，CAShapeLayer的一些用法就真的介绍完毕了。</p>\n<hr>\n<h3 id=\"CATextLayer\"><a href=\"#CATextLayer\" class=\"headerlink\" title=\"CATextLayer\"></a>CATextLayer</h3><p>相比CAShapeLayer，可能CATextLayer的用途更加单一一些，他可以用来<code>展示文字</code>。</p>\n<p>那个，等会再关浏览器，你先听我说完😭</p>\n<p>我知道，有UILabel，你完全不需要使用这个。<br>但是存在必定是有他的意义的。正如UILabel是已经封装完成的，有一些我们想用的功能UILabel不一定有，比如下面这个：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-4a92c932f13a83d1.gif?imageMogr2/auto-orient/strip\" alt=\"歌词Label\"></p>\n<p>当然这个效果用两个label叠加再用一个mask也可以实现，不过<code>两个label实在是不优雅</code>。所以<code>老司机决定用CATextLayer来实现这个效果</code>。</p>\n<p>先来讲一下CATextLayer的基本使用方法吧。</p>\n<p>他的几个属性都是见名知意，就是跟label相差无几的属性。最简单的你想让他显示文字的话直接给string属性赋值就好了。</p>\n<p>不要太简单，哈哈哈😆</p>\n<p>CATextLayer我们就讲到这里。<br>怎么可能，我当然会把这个的实现方式告诉大家啊~</p>\n<p>先给大家看一个效果：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bdb264c3fde947b7.gif?imageMogr2/auto-orient/strip\" alt=\"这个效果你一定会\"></p>\n<p>这个效果你一定会吧，一个绿色的CALayer，，上面盖了一个红色的CAShapeLayer，strokeEnd从0到1，对吧。</p>\n<p>那怎么让他<code>只显示字的区域呢</code>？记得老司机曾经讲个CALayer的一个属性叫做<code>mask属性</code>么？对咯，就是<code>以一个CATextLayer做红色的CALayer的mask，CATextLayer的字体设置有颜色，背景设置透明色，这样就只能显示出红色的CALayer的文字部分了</code>~把他封装在一个UIView里面我们的展示歌词的Label就完成了。大家可以去<a href=\"https://github.com/CodeWicky/DWLyricLabel.git\" target=\"_blank\" rel=\"external\">这里下载这个Demo</a>哦~</p>\n<p>恩，其实只要是显示文字，CATextLayer都可以完成，想要定制一些UILabel没有的功能，都可以考虑使用CATextLayer。</p>\n<p>CATextLayer也算是讲完了~</p>\n<hr>\n<p>回过头来说之前留的那个坑。问题就是当你<code>第一循环结束</code>后你想把你的<code>strokeEnd恢复成0</code>你却发现他是<code>以动画形式恢复</code>回去的不是你要的效果对吧？这就是因为他的隐式动画了。因为这时候我们不需要他的动画是吧？知道原因就好办了，我们可以通过<br>CATransaction显式的关闭他的动画，恢复成0，再打开动画，是不是就行了？哈哈哈，就是这么简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[CATransaction begin];</div><div class=\"line\">[CATransaction setDisableActions:YES];</div><div class=\"line\">self.layer.strokeEnd = 0;</div><div class=\"line\">[CATransaction setDisableActions:NO];</div><div class=\"line\">[CATransaction commit];</div></pre></td></tr></table></figure>\n<hr>\n<p>坑填完了，看截图你们也知道老司机是熬夜给你们码字的吧，是时候点波赞👍加波关注💗了~</p>"},{"title":"老司机带你走进Core Animation 之几种动画的简单应用","layout":"post","date":"2016-10-16T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![老司机带你走进Core Animation 之几种动画的简单应用](http://upload-images.jianshu.io/upload_images/1835430-1737a066b7319b0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n\n之所以要写这几种简单应用呢，是为了帮大家扩展一下思维，基于`CAAnimation`和`CADisplayLink`其实我们可以做到很多事情，不过我们都还是需要一个思路。有的时候可能，拿到一个效果，我们一眼就可以看出来，哦，使用核心动画就可以搞定，然而真正上手的时候就会发现，哦，没有想象的那么简单，为什么我达到的效果不对呢？一般情况下有两种可能，要么是思路不完整，要么是思路根本就不对。CAAnimation固然灵活，但要是使用方法不当的话，也会事倍功半。所以呢，今天老司机就针对以下几种情况来介绍截个动画的实现方式。（说这么多其实就是因为这段时间一直研究这个，的确也没研究别的，哈哈哈）\n\n在这篇文章中你会看到以下一些内容：\n\n- iOS中GIF动图的播放的实现方式\n\n- iOS系统更新图标样式的实现方式\n\n- 自定义水波样式的HUD的实现方式\n\n接下来我们就对这三个内容逐一进行一下讲解。\n\n<!-- more -->\n\n- - -\n\n### iOS中GIF动图的播放的实现方式\n\n我们知道，在OC中展示静态图片我们是使用UIIamgeView的，然而UIImageView对GIF动画的展示却并不友好。我知道你们一定会说UIImageView不是有组动画么，老司机当然知道有这个api，老司机最开始也是用这个api，但是有的时候就会发现播放出的gif的节奏有可能会跟原图不太一样。这是为什么呢？原来这是因为GIF文件的原因。我们知道，GIF其实就是由很多帧静态图片组成后连续播放组成的。重点就在于其实`每一帧的时间是可以不一样`的。(虽然这样的情况的确占少数)其实这种情况还好一些，我们知道系统的组动画api是`不支持动画的暂停与恢复的`，而且当`图片很多的时候也有很大的崩溃几率`，这是我们所不希望看见的，那么我们就开始想自己写一个api让他完美解决以上问题？怎么做呢？\n\n其实无非是UIImageView的图片不断切换，我自己加个定时器都可以。不过重要的还是一个思路。要想做到每一帧的时间可以不一样长，我相信用定时器很难实现吧。这个时候，我们是否可以换个思路，记得CAAnimation中可以指定每种状态时间的那个动画叫什么么还？对了，`CAKeyframeAnimation`。不记得了回头看看[这里的内容](http://www.jianshu.com/p/92a0661a21c6)。\n\n既然我们使用CAKeyframeAnimation的话，动画的暂停与恢复我们自然可以控制，只要控制好内存也就可以解决崩溃问题，那么这就是我们的思路了。\n\n有了思路就方便很多了，接下来我们只要去实现就好了。我记得以为伟大的程序猿曾经说过：\n> 程序员最不怕的就是如何实现，不会就去网上找，最怕的就是没网和没思路。\t\t\t\t\t\t\t\t------老司机\n\n\n大体思路：\n\n- 解析GIF文件，获取每一帧图片及对应时长\n\n- 构建CAKeyframeAnimation动画，以layer的contents属性去展示图片\n\n就这么简单的两步。\n\n老司机这里就不上全部代码了，上一些核心的代码简单的展示一下如何实现：\n\n\n![展示GIF](http://upload-images.jianshu.io/upload_images/1835430-d74c1c9bdeba5f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n以上就是核心代码，其实每一句的目的都很简单，可能有些函数没用过大家自己简单查一下也就都明白了。然后老司机放一下自己写的UIImageView的GIF分类，大家可以直接拿去用，在这里：\n\n[点我去下载](https://pan.baidu.com/s/1miApoko)\n\n![效果图，中间是我点暂停了=。=](http://upload-images.jianshu.io/upload_images/1835430-871a34118f5e1d41.gif?imageMogr2/auto-orient/strip)\n\n- - -\n\n### iOS系统更新图标样式的实现方式\n\n这个只得是什么呢？就是iOS中APP更新的时候在ICON上不是有一个更新的动画么？像下面这个样子：\n\n\n![仿系统更新样式](http://upload-images.jianshu.io/upload_images/1835430-e4e8b0e5407ca525.gif?imageMogr2/auto-orient/strip)\n\n这里我们就针对这个动画的实现方式进行一下探讨。\n\n说实话拿到这个需求老司机第一反应是`CABasicAnimation`。因为我们知道这个`不规则的形状我们完全可以使用CAShapeLayer去绘制`（关于CoreAnimation中CALayer的个个子类老司机会在接下来的博客中逐一跟新，敬请期待）。`不同的path可以绘制出不同的形状，而且path属性又是animutable的`。貌似轻松地很。然而真正写了一下老司机发现自己还是太天真了，CABasicAnimation是基于始末状态的补间动画，然而老司机又根本拿不准他自动补充的计算方式，所以写出来的动画跟预期的总是有一定的差距，老司机的思路层一度陷入僵局。后来老司机`换了一个思路`，既然用不了补间动画，我就`一帧一帧画`吧。这里就用到了`CADisplayLink`（不熟悉的小伙伴来[这里补票](http://www.jianshu.com/p/434ec6911148)）。\n\n大体思路：\n\n- 找出能代表动画中每一种状态的path\n\n- 使用CADisplayLink反复绘制\n\n首先我们找一下这个路径要如何表示：\n\n这里没有什么诀窍啊，高中数学啊，就是硬画啊，直接上代码\n\n\n![路径计算](http://upload-images.jianshu.io/upload_images/1835430-2b42571913401c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里属性和参数老司机解释一下`self.sRadius是中间非暂停状态下的扇形半径`。参数`percent是将要绘制的路径的角度百分比`，suspendR是大家能看到暂停状态下是从中心不断扩大一个圆的，`suspendR就是当前正要绘制的那个圆的半径`（注意并不是那个圆最终要变成的半径，而是当前的）。通过这三个变量老司机就能画出这个指示器各个状态的路径。（是不是很腻害，毕竟数学课代表，啧啧啧）\n\n这里重点讲的是动画的绘制，calayer的绘制老司机会在接下来的博客里面慢慢介绍，本例中用到的`中空的layer使用`了两种绘制方式，`usesEvenOddFillRule`和`mask`两种，稍后放的demo里面会有具体代码，大家看一下就好。\n\n接下来就是`使用CADisplayLink去一帧一帧绘制`了，这也是上一期讲过的内容了，老司机也不废话了，一切尽在demo吧：\n\n[点我去下载](https://pan.baidu.com/s/1miApoko)\n\n- - -\n\n### 自定义水波样式的HUD的实现方式\n\n闲的无聊写的一个效果，先看图：\n\n\n![波浪指示器](http://upload-images.jianshu.io/upload_images/1835430-b41b9f8b7edb5e62.gif?imageMogr2/auto-orient/strip)\n\n其实这个效果还挺有意思的，那么如何实现呢？\n\n其实有了上面的铺垫你应该会马上反映出两种思路：CAAnimation动画或者一帧一帧绘制。\n\n这里老司机说一句，本质上，`如果补间动画能完成效果的话，尽量使用CAAnimation`，不用一帧帧绘制，`代码量少了，cpu压力也小点`。但是一般情况写复杂的补间动画都画不出来，比如说这个。\n\n我们还是分析一下需求，首先我们需要`一条浪线`，其次这条浪线`还要能涨高`。我们可以`通过改变正弦曲线的相位`来使波浪左右摆动起来，改变正弦曲线k值改变波浪的高度。（事实上老司机使用的是`三次贝塞尔曲线`模拟的正弦曲线，效果相似，只不过OC中没有正弦曲线的封装，想绘制正弦曲线的话会增加很多计算量）。\n\n思路都在那，这个路径的绘制代码比较多，我就不截图了，也是在demo中大家看一下就好，一步一步思路都很清晰，还有老司机一向是注释详细的，你懂我~\n\n[点我去下载](https://pan.baidu.com/s/1miApoko)\n\n- - -\n\n恩，这次主要是想给大家`提供一下思路的扩展`，毕竟学会了动画要会用才是正道。\n\n另外，我还要推荐老司机出品的DWAnimation，帮你清爽的生成CALayer的属性动画，并且任意拼接，组合~\n\n![优雅么](http://upload-images.jianshu.io/upload_images/1835430-1d727fcd1edc50a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\ngitHub下载地址：[DWAnimation](https://github.com/CodeWicky/DWAnimation)\n欢迎给我star哦~\n\n恩，转载记得注明出处哦~\n\n**如果你觉得本篇文章对你有帮助，麻烦你给我点个赞!**\n\n**如果你就喜欢老司机这墨迹劲你再加个关注!**\n\n**如果你爱上老司机了你也可以给我打赏!**\n\n**但是就算你给我打赏我也只卖艺，不卖身。**\n\n\n![不卖身](http://upload-images.jianshu.io/upload_images/1835430-b49f2dacb7fdccb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/老司机带你走进Core-Animation-之几种动画的简单应用.md","raw":"---\n\ntitle: 老司机带你走进Core Animation 之几种动画的简单应用\nlayout: post\ndate: 2016-10-17 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CAAnimation \n- 核心动画\n- 动画\ncategories: 核心动画\n\n---\n\n![老司机带你走进Core Animation 之几种动画的简单应用](http://upload-images.jianshu.io/upload_images/1835430-1737a066b7319b0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n\n之所以要写这几种简单应用呢，是为了帮大家扩展一下思维，基于`CAAnimation`和`CADisplayLink`其实我们可以做到很多事情，不过我们都还是需要一个思路。有的时候可能，拿到一个效果，我们一眼就可以看出来，哦，使用核心动画就可以搞定，然而真正上手的时候就会发现，哦，没有想象的那么简单，为什么我达到的效果不对呢？一般情况下有两种可能，要么是思路不完整，要么是思路根本就不对。CAAnimation固然灵活，但要是使用方法不当的话，也会事倍功半。所以呢，今天老司机就针对以下几种情况来介绍截个动画的实现方式。（说这么多其实就是因为这段时间一直研究这个，的确也没研究别的，哈哈哈）\n\n在这篇文章中你会看到以下一些内容：\n\n- iOS中GIF动图的播放的实现方式\n\n- iOS系统更新图标样式的实现方式\n\n- 自定义水波样式的HUD的实现方式\n\n接下来我们就对这三个内容逐一进行一下讲解。\n\n<!-- more -->\n\n- - -\n\n### iOS中GIF动图的播放的实现方式\n\n我们知道，在OC中展示静态图片我们是使用UIIamgeView的，然而UIImageView对GIF动画的展示却并不友好。我知道你们一定会说UIImageView不是有组动画么，老司机当然知道有这个api，老司机最开始也是用这个api，但是有的时候就会发现播放出的gif的节奏有可能会跟原图不太一样。这是为什么呢？原来这是因为GIF文件的原因。我们知道，GIF其实就是由很多帧静态图片组成后连续播放组成的。重点就在于其实`每一帧的时间是可以不一样`的。(虽然这样的情况的确占少数)其实这种情况还好一些，我们知道系统的组动画api是`不支持动画的暂停与恢复的`，而且当`图片很多的时候也有很大的崩溃几率`，这是我们所不希望看见的，那么我们就开始想自己写一个api让他完美解决以上问题？怎么做呢？\n\n其实无非是UIImageView的图片不断切换，我自己加个定时器都可以。不过重要的还是一个思路。要想做到每一帧的时间可以不一样长，我相信用定时器很难实现吧。这个时候，我们是否可以换个思路，记得CAAnimation中可以指定每种状态时间的那个动画叫什么么还？对了，`CAKeyframeAnimation`。不记得了回头看看[这里的内容](http://www.jianshu.com/p/92a0661a21c6)。\n\n既然我们使用CAKeyframeAnimation的话，动画的暂停与恢复我们自然可以控制，只要控制好内存也就可以解决崩溃问题，那么这就是我们的思路了。\n\n有了思路就方便很多了，接下来我们只要去实现就好了。我记得以为伟大的程序猿曾经说过：\n> 程序员最不怕的就是如何实现，不会就去网上找，最怕的就是没网和没思路。\t\t\t\t\t\t\t\t------老司机\n\n\n大体思路：\n\n- 解析GIF文件，获取每一帧图片及对应时长\n\n- 构建CAKeyframeAnimation动画，以layer的contents属性去展示图片\n\n就这么简单的两步。\n\n老司机这里就不上全部代码了，上一些核心的代码简单的展示一下如何实现：\n\n\n![展示GIF](http://upload-images.jianshu.io/upload_images/1835430-d74c1c9bdeba5f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n以上就是核心代码，其实每一句的目的都很简单，可能有些函数没用过大家自己简单查一下也就都明白了。然后老司机放一下自己写的UIImageView的GIF分类，大家可以直接拿去用，在这里：\n\n[点我去下载](https://pan.baidu.com/s/1miApoko)\n\n![效果图，中间是我点暂停了=。=](http://upload-images.jianshu.io/upload_images/1835430-871a34118f5e1d41.gif?imageMogr2/auto-orient/strip)\n\n- - -\n\n### iOS系统更新图标样式的实现方式\n\n这个只得是什么呢？就是iOS中APP更新的时候在ICON上不是有一个更新的动画么？像下面这个样子：\n\n\n![仿系统更新样式](http://upload-images.jianshu.io/upload_images/1835430-e4e8b0e5407ca525.gif?imageMogr2/auto-orient/strip)\n\n这里我们就针对这个动画的实现方式进行一下探讨。\n\n说实话拿到这个需求老司机第一反应是`CABasicAnimation`。因为我们知道这个`不规则的形状我们完全可以使用CAShapeLayer去绘制`（关于CoreAnimation中CALayer的个个子类老司机会在接下来的博客中逐一跟新，敬请期待）。`不同的path可以绘制出不同的形状，而且path属性又是animutable的`。貌似轻松地很。然而真正写了一下老司机发现自己还是太天真了，CABasicAnimation是基于始末状态的补间动画，然而老司机又根本拿不准他自动补充的计算方式，所以写出来的动画跟预期的总是有一定的差距，老司机的思路层一度陷入僵局。后来老司机`换了一个思路`，既然用不了补间动画，我就`一帧一帧画`吧。这里就用到了`CADisplayLink`（不熟悉的小伙伴来[这里补票](http://www.jianshu.com/p/434ec6911148)）。\n\n大体思路：\n\n- 找出能代表动画中每一种状态的path\n\n- 使用CADisplayLink反复绘制\n\n首先我们找一下这个路径要如何表示：\n\n这里没有什么诀窍啊，高中数学啊，就是硬画啊，直接上代码\n\n\n![路径计算](http://upload-images.jianshu.io/upload_images/1835430-2b42571913401c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里属性和参数老司机解释一下`self.sRadius是中间非暂停状态下的扇形半径`。参数`percent是将要绘制的路径的角度百分比`，suspendR是大家能看到暂停状态下是从中心不断扩大一个圆的，`suspendR就是当前正要绘制的那个圆的半径`（注意并不是那个圆最终要变成的半径，而是当前的）。通过这三个变量老司机就能画出这个指示器各个状态的路径。（是不是很腻害，毕竟数学课代表，啧啧啧）\n\n这里重点讲的是动画的绘制，calayer的绘制老司机会在接下来的博客里面慢慢介绍，本例中用到的`中空的layer使用`了两种绘制方式，`usesEvenOddFillRule`和`mask`两种，稍后放的demo里面会有具体代码，大家看一下就好。\n\n接下来就是`使用CADisplayLink去一帧一帧绘制`了，这也是上一期讲过的内容了，老司机也不废话了，一切尽在demo吧：\n\n[点我去下载](https://pan.baidu.com/s/1miApoko)\n\n- - -\n\n### 自定义水波样式的HUD的实现方式\n\n闲的无聊写的一个效果，先看图：\n\n\n![波浪指示器](http://upload-images.jianshu.io/upload_images/1835430-b41b9f8b7edb5e62.gif?imageMogr2/auto-orient/strip)\n\n其实这个效果还挺有意思的，那么如何实现呢？\n\n其实有了上面的铺垫你应该会马上反映出两种思路：CAAnimation动画或者一帧一帧绘制。\n\n这里老司机说一句，本质上，`如果补间动画能完成效果的话，尽量使用CAAnimation`，不用一帧帧绘制，`代码量少了，cpu压力也小点`。但是一般情况写复杂的补间动画都画不出来，比如说这个。\n\n我们还是分析一下需求，首先我们需要`一条浪线`，其次这条浪线`还要能涨高`。我们可以`通过改变正弦曲线的相位`来使波浪左右摆动起来，改变正弦曲线k值改变波浪的高度。（事实上老司机使用的是`三次贝塞尔曲线`模拟的正弦曲线，效果相似，只不过OC中没有正弦曲线的封装，想绘制正弦曲线的话会增加很多计算量）。\n\n思路都在那，这个路径的绘制代码比较多，我就不截图了，也是在demo中大家看一下就好，一步一步思路都很清晰，还有老司机一向是注释详细的，你懂我~\n\n[点我去下载](https://pan.baidu.com/s/1miApoko)\n\n- - -\n\n恩，这次主要是想给大家`提供一下思路的扩展`，毕竟学会了动画要会用才是正道。\n\n另外，我还要推荐老司机出品的DWAnimation，帮你清爽的生成CALayer的属性动画，并且任意拼接，组合~\n\n![优雅么](http://upload-images.jianshu.io/upload_images/1835430-1d727fcd1edc50a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\ngitHub下载地址：[DWAnimation](https://github.com/CodeWicky/DWAnimation)\n欢迎给我star哦~\n\n恩，转载记得注明出处哦~\n\n**如果你觉得本篇文章对你有帮助，麻烦你给我点个赞!**\n\n**如果你就喜欢老司机这墨迹劲你再加个关注!**\n\n**如果你爱上老司机了你也可以给我打赏!**\n\n**但是就算你给我打赏我也只卖艺，不卖身。**\n\n\n![不卖身](http://upload-images.jianshu.io/upload_images/1835430-b49f2dacb7fdccb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"老司机带你走进Core-Animation-之几种动画的简单应用","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htpu0013jigbi23glves","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1737a066b7319b0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之几种动画的简单应用\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>之所以要写这几种简单应用呢，是为了帮大家扩展一下思维，基于<code>CAAnimation</code>和<code>CADisplayLink</code>其实我们可以做到很多事情，不过我们都还是需要一个思路。有的时候可能，拿到一个效果，我们一眼就可以看出来，哦，使用核心动画就可以搞定，然而真正上手的时候就会发现，哦，没有想象的那么简单，为什么我达到的效果不对呢？一般情况下有两种可能，要么是思路不完整，要么是思路根本就不对。CAAnimation固然灵活，但要是使用方法不当的话，也会事倍功半。所以呢，今天老司机就针对以下几种情况来介绍截个动画的实现方式。（说这么多其实就是因为这段时间一直研究这个，的确也没研究别的，哈哈哈）</p>\n<p>在这篇文章中你会看到以下一些内容：</p>\n<ul>\n<li><p>iOS中GIF动图的播放的实现方式</p>\n</li>\n<li><p>iOS系统更新图标样式的实现方式</p>\n</li>\n<li><p>自定义水波样式的HUD的实现方式</p>\n</li>\n</ul>\n<p>接下来我们就对这三个内容逐一进行一下讲解。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"iOS中GIF动图的播放的实现方式\"><a href=\"#iOS中GIF动图的播放的实现方式\" class=\"headerlink\" title=\"iOS中GIF动图的播放的实现方式\"></a>iOS中GIF动图的播放的实现方式</h3><p>我们知道，在OC中展示静态图片我们是使用UIIamgeView的，然而UIImageView对GIF动画的展示却并不友好。我知道你们一定会说UIImageView不是有组动画么，老司机当然知道有这个api，老司机最开始也是用这个api，但是有的时候就会发现播放出的gif的节奏有可能会跟原图不太一样。这是为什么呢？原来这是因为GIF文件的原因。我们知道，GIF其实就是由很多帧静态图片组成后连续播放组成的。重点就在于其实<code>每一帧的时间是可以不一样</code>的。(虽然这样的情况的确占少数)其实这种情况还好一些，我们知道系统的组动画api是<code>不支持动画的暂停与恢复的</code>，而且当<code>图片很多的时候也有很大的崩溃几率</code>，这是我们所不希望看见的，那么我们就开始想自己写一个api让他完美解决以上问题？怎么做呢？</p>\n<p>其实无非是UIImageView的图片不断切换，我自己加个定时器都可以。不过重要的还是一个思路。要想做到每一帧的时间可以不一样长，我相信用定时器很难实现吧。这个时候，我们是否可以换个思路，记得CAAnimation中可以指定每种状态时间的那个动画叫什么么还？对了，<code>CAKeyframeAnimation</code>。不记得了回头看看<a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">这里的内容</a>。</p>\n<p>既然我们使用CAKeyframeAnimation的话，动画的暂停与恢复我们自然可以控制，只要控制好内存也就可以解决崩溃问题，那么这就是我们的思路了。</p>\n<p>有了思路就方便很多了，接下来我们只要去实现就好了。我记得以为伟大的程序猿曾经说过：</p>\n<blockquote>\n<p>程序员最不怕的就是如何实现，不会就去网上找，最怕的就是没网和没思路。                                ——老司机</p>\n</blockquote>\n<p>大体思路：</p>\n<ul>\n<li><p>解析GIF文件，获取每一帧图片及对应时长</p>\n</li>\n<li><p>构建CAKeyframeAnimation动画，以layer的contents属性去展示图片</p>\n</li>\n</ul>\n<p>就这么简单的两步。</p>\n<p>老司机这里就不上全部代码了，上一些核心的代码简单的展示一下如何实现：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d74c1c9bdeba5f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"展示GIF\"></p>\n<p>以上就是核心代码，其实每一句的目的都很简单，可能有些函数没用过大家自己简单查一下也就都明白了。然后老司机放一下自己写的UIImageView的GIF分类，大家可以直接拿去用，在这里：</p>\n<p><a href=\"https://pan.baidu.com/s/1miApoko\" target=\"_blank\" rel=\"external\">点我去下载</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-871a34118f5e1d41.gif?imageMogr2/auto-orient/strip\" alt=\"效果图，中间是我点暂停了=。=\"></p>\n<hr>\n<h3 id=\"iOS系统更新图标样式的实现方式\"><a href=\"#iOS系统更新图标样式的实现方式\" class=\"headerlink\" title=\"iOS系统更新图标样式的实现方式\"></a>iOS系统更新图标样式的实现方式</h3><p>这个只得是什么呢？就是iOS中APP更新的时候在ICON上不是有一个更新的动画么？像下面这个样子：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e4e8b0e5407ca525.gif?imageMogr2/auto-orient/strip\" alt=\"仿系统更新样式\"></p>\n<p>这里我们就针对这个动画的实现方式进行一下探讨。</p>\n<p>说实话拿到这个需求老司机第一反应是<code>CABasicAnimation</code>。因为我们知道这个<code>不规则的形状我们完全可以使用CAShapeLayer去绘制</code>（关于CoreAnimation中CALayer的个个子类老司机会在接下来的博客中逐一跟新，敬请期待）。<code>不同的path可以绘制出不同的形状，而且path属性又是animutable的</code>。貌似轻松地很。然而真正写了一下老司机发现自己还是太天真了，CABasicAnimation是基于始末状态的补间动画，然而老司机又根本拿不准他自动补充的计算方式，所以写出来的动画跟预期的总是有一定的差距，老司机的思路层一度陷入僵局。后来老司机<code>换了一个思路</code>，既然用不了补间动画，我就<code>一帧一帧画</code>吧。这里就用到了<code>CADisplayLink</code>（不熟悉的小伙伴来<a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">这里补票</a>）。</p>\n<p>大体思路：</p>\n<ul>\n<li><p>找出能代表动画中每一种状态的path</p>\n</li>\n<li><p>使用CADisplayLink反复绘制</p>\n</li>\n</ul>\n<p>首先我们找一下这个路径要如何表示：</p>\n<p>这里没有什么诀窍啊，高中数学啊，就是硬画啊，直接上代码</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-2b42571913401c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"路径计算\"></p>\n<p>这里属性和参数老司机解释一下<code>self.sRadius是中间非暂停状态下的扇形半径</code>。参数<code>percent是将要绘制的路径的角度百分比</code>，suspendR是大家能看到暂停状态下是从中心不断扩大一个圆的，<code>suspendR就是当前正要绘制的那个圆的半径</code>（注意并不是那个圆最终要变成的半径，而是当前的）。通过这三个变量老司机就能画出这个指示器各个状态的路径。（是不是很腻害，毕竟数学课代表，啧啧啧）</p>\n<p>这里重点讲的是动画的绘制，calayer的绘制老司机会在接下来的博客里面慢慢介绍，本例中用到的<code>中空的layer使用</code>了两种绘制方式，<code>usesEvenOddFillRule</code>和<code>mask</code>两种，稍后放的demo里面会有具体代码，大家看一下就好。</p>\n<p>接下来就是<code>使用CADisplayLink去一帧一帧绘制</code>了，这也是上一期讲过的内容了，老司机也不废话了，一切尽在demo吧：</p>\n<p><a href=\"https://pan.baidu.com/s/1miApoko\" target=\"_blank\" rel=\"external\">点我去下载</a></p>\n<hr>\n<h3 id=\"自定义水波样式的HUD的实现方式\"><a href=\"#自定义水波样式的HUD的实现方式\" class=\"headerlink\" title=\"自定义水波样式的HUD的实现方式\"></a>自定义水波样式的HUD的实现方式</h3><p>闲的无聊写的一个效果，先看图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b41b9f8b7edb5e62.gif?imageMogr2/auto-orient/strip\" alt=\"波浪指示器\"></p>\n<p>其实这个效果还挺有意思的，那么如何实现呢？</p>\n<p>其实有了上面的铺垫你应该会马上反映出两种思路：CAAnimation动画或者一帧一帧绘制。</p>\n<p>这里老司机说一句，本质上，<code>如果补间动画能完成效果的话，尽量使用CAAnimation</code>，不用一帧帧绘制，<code>代码量少了，cpu压力也小点</code>。但是一般情况写复杂的补间动画都画不出来，比如说这个。</p>\n<p>我们还是分析一下需求，首先我们需要<code>一条浪线</code>，其次这条浪线<code>还要能涨高</code>。我们可以<code>通过改变正弦曲线的相位</code>来使波浪左右摆动起来，改变正弦曲线k值改变波浪的高度。（事实上老司机使用的是<code>三次贝塞尔曲线</code>模拟的正弦曲线，效果相似，只不过OC中没有正弦曲线的封装，想绘制正弦曲线的话会增加很多计算量）。</p>\n<p>思路都在那，这个路径的绘制代码比较多，我就不截图了，也是在demo中大家看一下就好，一步一步思路都很清晰，还有老司机一向是注释详细的，你懂我~</p>\n<p><a href=\"https://pan.baidu.com/s/1miApoko\" target=\"_blank\" rel=\"external\">点我去下载</a></p>\n<hr>\n<p>恩，这次主要是想给大家<code>提供一下思路的扩展</code>，毕竟学会了动画要会用才是正道。</p>\n<p>另外，我还要推荐老司机出品的DWAnimation，帮你清爽的生成CALayer的属性动画，并且任意拼接，组合~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1d727fcd1edc50a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"优雅么\"></p>\n<p>gitHub下载地址：<a href=\"https://github.com/CodeWicky/DWAnimation\" target=\"_blank\" rel=\"external\">DWAnimation</a><br>欢迎给我star哦~</p>\n<p>恩，转载记得注明出处哦~</p>\n<p><strong>如果你觉得本篇文章对你有帮助，麻烦你给我点个赞!</strong></p>\n<p><strong>如果你就喜欢老司机这墨迹劲你再加个关注!</strong></p>\n<p><strong>如果你爱上老司机了你也可以给我打赏!</strong></p>\n<p><strong>但是就算你给我打赏我也只卖艺，不卖身。</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b49f2dacb7fdccb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"不卖身\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1737a066b7319b0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之几种动画的简单应用\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>之所以要写这几种简单应用呢，是为了帮大家扩展一下思维，基于<code>CAAnimation</code>和<code>CADisplayLink</code>其实我们可以做到很多事情，不过我们都还是需要一个思路。有的时候可能，拿到一个效果，我们一眼就可以看出来，哦，使用核心动画就可以搞定，然而真正上手的时候就会发现，哦，没有想象的那么简单，为什么我达到的效果不对呢？一般情况下有两种可能，要么是思路不完整，要么是思路根本就不对。CAAnimation固然灵活，但要是使用方法不当的话，也会事倍功半。所以呢，今天老司机就针对以下几种情况来介绍截个动画的实现方式。（说这么多其实就是因为这段时间一直研究这个，的确也没研究别的，哈哈哈）</p>\n<p>在这篇文章中你会看到以下一些内容：</p>\n<ul>\n<li><p>iOS中GIF动图的播放的实现方式</p>\n</li>\n<li><p>iOS系统更新图标样式的实现方式</p>\n</li>\n<li><p>自定义水波样式的HUD的实现方式</p>\n</li>\n</ul>\n<p>接下来我们就对这三个内容逐一进行一下讲解。</p>","more":"<hr>\n<h3 id=\"iOS中GIF动图的播放的实现方式\"><a href=\"#iOS中GIF动图的播放的实现方式\" class=\"headerlink\" title=\"iOS中GIF动图的播放的实现方式\"></a>iOS中GIF动图的播放的实现方式</h3><p>我们知道，在OC中展示静态图片我们是使用UIIamgeView的，然而UIImageView对GIF动画的展示却并不友好。我知道你们一定会说UIImageView不是有组动画么，老司机当然知道有这个api，老司机最开始也是用这个api，但是有的时候就会发现播放出的gif的节奏有可能会跟原图不太一样。这是为什么呢？原来这是因为GIF文件的原因。我们知道，GIF其实就是由很多帧静态图片组成后连续播放组成的。重点就在于其实<code>每一帧的时间是可以不一样</code>的。(虽然这样的情况的确占少数)其实这种情况还好一些，我们知道系统的组动画api是<code>不支持动画的暂停与恢复的</code>，而且当<code>图片很多的时候也有很大的崩溃几率</code>，这是我们所不希望看见的，那么我们就开始想自己写一个api让他完美解决以上问题？怎么做呢？</p>\n<p>其实无非是UIImageView的图片不断切换，我自己加个定时器都可以。不过重要的还是一个思路。要想做到每一帧的时间可以不一样长，我相信用定时器很难实现吧。这个时候，我们是否可以换个思路，记得CAAnimation中可以指定每种状态时间的那个动画叫什么么还？对了，<code>CAKeyframeAnimation</code>。不记得了回头看看<a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">这里的内容</a>。</p>\n<p>既然我们使用CAKeyframeAnimation的话，动画的暂停与恢复我们自然可以控制，只要控制好内存也就可以解决崩溃问题，那么这就是我们的思路了。</p>\n<p>有了思路就方便很多了，接下来我们只要去实现就好了。我记得以为伟大的程序猿曾经说过：</p>\n<blockquote>\n<p>程序员最不怕的就是如何实现，不会就去网上找，最怕的就是没网和没思路。                                ——老司机</p>\n</blockquote>\n<p>大体思路：</p>\n<ul>\n<li><p>解析GIF文件，获取每一帧图片及对应时长</p>\n</li>\n<li><p>构建CAKeyframeAnimation动画，以layer的contents属性去展示图片</p>\n</li>\n</ul>\n<p>就这么简单的两步。</p>\n<p>老司机这里就不上全部代码了，上一些核心的代码简单的展示一下如何实现：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d74c1c9bdeba5f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"展示GIF\"></p>\n<p>以上就是核心代码，其实每一句的目的都很简单，可能有些函数没用过大家自己简单查一下也就都明白了。然后老司机放一下自己写的UIImageView的GIF分类，大家可以直接拿去用，在这里：</p>\n<p><a href=\"https://pan.baidu.com/s/1miApoko\" target=\"_blank\" rel=\"external\">点我去下载</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-871a34118f5e1d41.gif?imageMogr2/auto-orient/strip\" alt=\"效果图，中间是我点暂停了=。=\"></p>\n<hr>\n<h3 id=\"iOS系统更新图标样式的实现方式\"><a href=\"#iOS系统更新图标样式的实现方式\" class=\"headerlink\" title=\"iOS系统更新图标样式的实现方式\"></a>iOS系统更新图标样式的实现方式</h3><p>这个只得是什么呢？就是iOS中APP更新的时候在ICON上不是有一个更新的动画么？像下面这个样子：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e4e8b0e5407ca525.gif?imageMogr2/auto-orient/strip\" alt=\"仿系统更新样式\"></p>\n<p>这里我们就针对这个动画的实现方式进行一下探讨。</p>\n<p>说实话拿到这个需求老司机第一反应是<code>CABasicAnimation</code>。因为我们知道这个<code>不规则的形状我们完全可以使用CAShapeLayer去绘制</code>（关于CoreAnimation中CALayer的个个子类老司机会在接下来的博客中逐一跟新，敬请期待）。<code>不同的path可以绘制出不同的形状，而且path属性又是animutable的</code>。貌似轻松地很。然而真正写了一下老司机发现自己还是太天真了，CABasicAnimation是基于始末状态的补间动画，然而老司机又根本拿不准他自动补充的计算方式，所以写出来的动画跟预期的总是有一定的差距，老司机的思路层一度陷入僵局。后来老司机<code>换了一个思路</code>，既然用不了补间动画，我就<code>一帧一帧画</code>吧。这里就用到了<code>CADisplayLink</code>（不熟悉的小伙伴来<a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">这里补票</a>）。</p>\n<p>大体思路：</p>\n<ul>\n<li><p>找出能代表动画中每一种状态的path</p>\n</li>\n<li><p>使用CADisplayLink反复绘制</p>\n</li>\n</ul>\n<p>首先我们找一下这个路径要如何表示：</p>\n<p>这里没有什么诀窍啊，高中数学啊，就是硬画啊，直接上代码</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-2b42571913401c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"路径计算\"></p>\n<p>这里属性和参数老司机解释一下<code>self.sRadius是中间非暂停状态下的扇形半径</code>。参数<code>percent是将要绘制的路径的角度百分比</code>，suspendR是大家能看到暂停状态下是从中心不断扩大一个圆的，<code>suspendR就是当前正要绘制的那个圆的半径</code>（注意并不是那个圆最终要变成的半径，而是当前的）。通过这三个变量老司机就能画出这个指示器各个状态的路径。（是不是很腻害，毕竟数学课代表，啧啧啧）</p>\n<p>这里重点讲的是动画的绘制，calayer的绘制老司机会在接下来的博客里面慢慢介绍，本例中用到的<code>中空的layer使用</code>了两种绘制方式，<code>usesEvenOddFillRule</code>和<code>mask</code>两种，稍后放的demo里面会有具体代码，大家看一下就好。</p>\n<p>接下来就是<code>使用CADisplayLink去一帧一帧绘制</code>了，这也是上一期讲过的内容了，老司机也不废话了，一切尽在demo吧：</p>\n<p><a href=\"https://pan.baidu.com/s/1miApoko\" target=\"_blank\" rel=\"external\">点我去下载</a></p>\n<hr>\n<h3 id=\"自定义水波样式的HUD的实现方式\"><a href=\"#自定义水波样式的HUD的实现方式\" class=\"headerlink\" title=\"自定义水波样式的HUD的实现方式\"></a>自定义水波样式的HUD的实现方式</h3><p>闲的无聊写的一个效果，先看图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b41b9f8b7edb5e62.gif?imageMogr2/auto-orient/strip\" alt=\"波浪指示器\"></p>\n<p>其实这个效果还挺有意思的，那么如何实现呢？</p>\n<p>其实有了上面的铺垫你应该会马上反映出两种思路：CAAnimation动画或者一帧一帧绘制。</p>\n<p>这里老司机说一句，本质上，<code>如果补间动画能完成效果的话，尽量使用CAAnimation</code>，不用一帧帧绘制，<code>代码量少了，cpu压力也小点</code>。但是一般情况写复杂的补间动画都画不出来，比如说这个。</p>\n<p>我们还是分析一下需求，首先我们需要<code>一条浪线</code>，其次这条浪线<code>还要能涨高</code>。我们可以<code>通过改变正弦曲线的相位</code>来使波浪左右摆动起来，改变正弦曲线k值改变波浪的高度。（事实上老司机使用的是<code>三次贝塞尔曲线</code>模拟的正弦曲线，效果相似，只不过OC中没有正弦曲线的封装，想绘制正弦曲线的话会增加很多计算量）。</p>\n<p>思路都在那，这个路径的绘制代码比较多，我就不截图了，也是在demo中大家看一下就好，一步一步思路都很清晰，还有老司机一向是注释详细的，你懂我~</p>\n<p><a href=\"https://pan.baidu.com/s/1miApoko\" target=\"_blank\" rel=\"external\">点我去下载</a></p>\n<hr>\n<p>恩，这次主要是想给大家<code>提供一下思路的扩展</code>，毕竟学会了动画要会用才是正道。</p>\n<p>另外，我还要推荐老司机出品的DWAnimation，帮你清爽的生成CALayer的属性动画，并且任意拼接，组合~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1d727fcd1edc50a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"优雅么\"></p>\n<p>gitHub下载地址：<a href=\"https://github.com/CodeWicky/DWAnimation\" target=\"_blank\" rel=\"external\">DWAnimation</a><br>欢迎给我star哦~</p>\n<p>恩，转载记得注明出处哦~</p>\n<p><strong>如果你觉得本篇文章对你有帮助，麻烦你给我点个赞!</strong></p>\n<p><strong>如果你就喜欢老司机这墨迹劲你再加个关注!</strong></p>\n<p><strong>如果你爱上老司机了你也可以给我打赏!</strong></p>\n<p><strong>但是就算你给我打赏我也只卖艺，不卖身。</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b49f2dacb7fdccb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"不卖身\"></p>"},{"title":"老司机带你走进Core Animation 之图层的透视、渐变及复制","layout":"post","date":"2016-12-20T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![老司机带你走进Core Animation 之图层的透视、渐变及复制](http://upload-images.jianshu.io/upload_images/1835430-deee60e266a22d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n这回呢，当然还是顺着头文件里面的几个类，老司机一个一个捋吧。\n\n老司机的想法就是要把CoreAnimation头文件中的类大概都说一遍，毕竟一开始把系列名定成了《老司机带你走进CoreAnimation》（深切的觉得自己给自己坑了。。。）。\n![我给自己挖的坑](http://upload-images.jianshu.io/upload_images/1835430-ff640963309ad310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以呢，在今天的博客里你将会看到以下截个内容\n\n- CATransform3D\n- CATransformLayer\n- CAGradientLayer\n- CAReplicatorLayer\n- DWMirrorView\n\n废话不多说，直接进入主题。\n\n<!-- more -->\n\n- - -\n\n### CATransform3D\n\n先介绍一下CATransform3D吧。\n\n![CATransform3D](http://upload-images.jianshu.io/upload_images/1835430-84870af23882317f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n正如上图所示，我们可以清晰的看到，CATransform3D是一个结构体。而且苹果很友好的调整了一下书写格式，正如你看到的，它像是一个4 X 4的矩阵。\n\n事实上他的原理就是一个`4 X 4矩阵`。\n\n其实他还有一个弟弟，CGAffineTransform。这是一个3 X 3的矩阵。\n他们的作用都一样，进行坐标变换。\n不同点在于，CATransform3D作用与3维坐标系的坐标变换，CGAffineTransform作用于2维坐标系的坐标变换。\n\n所以CGAffineTransform用于对UIView进行变换，而CATransform3D用于对CALayer进行变换。\n\n虽然老司机从小到大都是数学课代表，不过我要很郑重的告诉你，数学是一门靠悟性的学问，不是我讲给你听，你就能消化的，所以关于矩阵计算什么的，请各位同学自己消化理解（咳咳，我会告诉你我高数、线代、概率没有一科过70的么=。=）\n![一脸无辜](\nhttp://upload-images.jianshu.io/upload_images/1835430-60aec696da69627f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n)\n\n所以呢，老司机直接来介绍CATransform3D的相关api吧。（CGAffineTransform的api与CATransform3D相似，可类比使用）。\n\n> - CATransform3DIdentity\n> \n>生成一个无任何变换的默认矩阵，可用于使变换后的Layer恢复初始状态\n>\n>- - -\n> - CATransform3DMakeTranslation\n> - CATransform3DMakeScale \n> - CATransform3DMakeRotation\n> \n> 分别是平移、缩放、旋转，这三个api最大的相同点就在于函数名中都有Make。意思就是生成指定变换的矩阵。与之相对的就是下面的api👇\n> \n> - CATransform3DTranslate\n> - CATransform3DScale\n> - CATransform3DRotate\n> \n> 与之前三个api的不同点在于，这三个api都多了一个参数，同样是一个CATransform3D结构体。我想你一定猜到了，就是对给定的矩阵在其现有基础上进行指定的变换。\n> \n> 值得注意的是，以上两个旋转api中x/y/z三个参数均为指定旋转轴，可选值0和1，`0代表此轴不做旋转`，`1代表作旋转`。例如想对x、y轴做45度旋转，则angle = M____PI____4,x = 1,y = 1,z = 0。另外，此处旋转角度为`弧度制`哦，不是角度制。\n> \n> - - -\n> - CATransform3DConcat\n> \n> 返回两个矩阵的乘积。\n> \n> - - -\n> \n> - CATransform3DInvert\n> \n> 反转矩阵\n> \n> - - -\n> \n> - CATransform3DMakeAffineTransform\n> - CATransform3DGetAffineTransform\n> \n> CGAffineTransform与CATransform3D相互转化的api\n> \n> - - -\n> \n> - CATransform3DIsIdentity\n> - CATransform3DEqualToTransform\n> - CATransform3DIsAffine\n> \n> 这三个api见名知意了，不多说。\n> \n\n哦，重要的一点你一定要知道，所有的矩阵变换都是相对于图层的`锚点`进行的。还记得锚点的概念么？不记得可以去这个系列的[第一篇文章](http://www.jianshu.com/p/92a0661a21c6)补课哦。\n\n其实呢，关于CATransform3D你只要会使用以上api对图层做3维坐标转换就够了。不过上述这些变换默认情况下都是`不具备透视效果`的，因为你所看到的都是图层`在x轴y轴上的投影`，那想要透视效果怎么办呢？两个办法，CATranformLayer，以及M34。\n\n#### M34\n\n老司机说过，CATransform3D不过是一个4 X 4的矩阵。那么其实这16个数字中，每一个数字都有自己可以控制的转换，这是纯数学知识啊，自己领悟=。=不过老司机可以单独说说`M34`这个数。这个数是用来控制图层变换后的`景深效果`的，也就是`透视效果`。\n\n![M34](http://upload-images.jianshu.io/upload_images/1835430-5f03c502308df4c2.gif?imageMogr2/auto-orient/strip)\n\n上面的图片分别展示了具有透视效果的旋转及动画。\n\n代码上的体现就是\n\n```\n\tCALayer * staticLayerA = [CALayer layer];\n    staticLayerA.bounds = CGRectMake(0, 0, 100, 100);\n    staticLayerA.position = CGPointMake(self.view.center.x - 75, self.view.center.y - 100);\n    staticLayerA.backgroundColor = [UIColor redColor].CGColor;\n    [self.view.layer addSublayer:staticLayerA];\n    \n    CATransform3D transA = CATransform3DIdentity;\n    transA.m34 = - 1.0 / 500;\n    transA = CATransform3DRotate(transA, M_PI / 3, 1, 0, 0);\n    staticLayerA.transform = transA;\n\n```\n\n使用上很简单，代码里M34 = - 1.0 / 500 的意思就是`图层距离屏幕向里500的单位`。如果向外则是M34 = 1.0 / 500。这个距离至一般掌握至500~1000这个范围会取得不错的效果。\n\n这里需要注意的是`M34的赋值一定要写在矩阵变换前面`，具体为什么说实话老司机也不知道。\n\n- - -\n\n### CATransformLayer\n\n老司机上面提到过，CALayer做矩阵变换你能看到的只是他在XY轴上的投影，这时你若想看到透视效果，就需要使用到M34或CATransformLayer。其实他两个又有一些区别，CATransformLayer是让你看到的不只是其在XY轴上的投影。\n\n说起来不好懂，看下面的图吧。\n\n![TransformLayer](http://upload-images.jianshu.io/upload_images/1835430-6a1cec404c39345f.gif?imageMogr2/auto-orient/strip)\n\nCATransformLayer可以让其的`子视图各自现实自身的真实形状，而不是其在父视图的投影`。\n\n你可能还不懂，其实你看的正方体是六个CALayer经过矩阵变换拼成的实实在在的正方体。\n\n```\n\t//create cube layer\n    CATransformLayer *cube = [CATransformLayer layer];\n    \n    //add cube face 1\n    CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 2\n    ct = CATransform3DMakeTranslation(50, 0, 0);\n    ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 3\n    ct = CATransform3DMakeTranslation(0, -50, 0);\n    ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 4\n    ct = CATransform3DMakeTranslation(0, 50, 0);\n    ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 5\n    ct = CATransform3DMakeTranslation(-50, 0, 0);\n    ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 6\n    ct = CATransform3DMakeTranslation(0, 0, -50);\n    ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //center the cube layer within the container\n    CGSize containerSize = self.containerView.bounds.size;\n    cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);\n```\n```\n- (CALayer *)faceWithTransform:(CATransform3D)transform\n{\n    //create cube face layer\n    CALayer *face = [CALayer layer];\n    face.bounds = CGRectMake(0, 0, 100, 100);\n    //apply a random color\n    CGFloat red = (rand() / (double)INT_MAX);\n    CGFloat green = (rand() / (double)INT_MAX);\n    CGFloat blue = (rand() / (double)INT_MAX);\n    face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;\n    face.transform = transform;\n    return face;\n}\n\n```\n使用起来就是这么简单，把各个变换后的layer加入到CATransformLayer中就可以了。\n\n本身CATransformLayer不具有任何其他属性，其实他更像是`一个容器`。它本身至渲染其子图层，自身没有任何layer的属性。\n\n最重要的一点是，当图层加入到CATransformLayer中以后，`hitTest和convertPoint两个方法就失效了`，请注意这点。\n\n- - -\n\n### CAGradientLayer\n\nCAGradientLayer本身的属性也比较少，而且完全是针对于过渡颜色来的。\n\n> - colors\n> \n> 图层显示的所有颜色的数组\n> \n> - - -\n> - locations\n> \n> 每个颜色对应的位置。注意，这个位置指的是颜色的位置，而不是过渡线的位置。\n> \n> - - - \n> - startPoint\n> - endPoint\n> \n> 是颜色过渡的方向，会沿着起点到终点的向量进行过渡。\n> - - -\n> \n> - type\n> \n> 过渡模式，当前苹果给我们暴露的只有一种模式，kCAGradientLayerAxial。\n> \n\n需要说明的是，CAGradientLayer只能做`矩形的渐变图层`。\n\n![你要怎么做？](http://upload-images.jianshu.io/upload_images/1835430-ed19e2d814f232f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n所以说这个效果要如何实现呢？其实啊，这只是一个错觉，看这个。\n\n![矩形渐变层](http://upload-images.jianshu.io/upload_images/1835430-cd67967da4814962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以说看到这你就知道了吧，两个拼一起的CAGradientLayer，然后用一个shapeLayer做了一个mask就成了环形的过渡层了。这一招老司机早就做了过，还记得么，[歌词显示那一章](http://www.jianshu.com/p/8e14616679ea)。\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(50, 50) radius:45 startAngle:- 7.0 / 6 * M_PI endAngle:M_PI / 6 clockwise:YES];\n    \n    [self.view.layer addSublayer:[self createShapeLayerWithPath:path]];\n    \n    CAGradientLayer * leftL = [self createGradientLayerWithColors:@[(id)[UIColor redColor].CGColor,(id)[UIColor yellowColor].CGColor]];\n    leftL.position = CGPointMake(25, 40);\n    \n    CAGradientLayer * rightL = [self createGradientLayerWithColors:@[(id)[UIColor greenColor].CGColor,(id)[UIColor yellowColor].CGColor]];\n    rightL.position = CGPointMake(75, 40);\n    \n    CALayer * layer = [CALayer layer];\n    layer.bounds = CGRectMake(0, 0, 100, 80);\n    layer.position = self.view.center;\n    [layer addSublayer:leftL];\n    [layer addSublayer:rightL];\n    [self.view.layer addSublayer:layer];\n    \n    CAShapeLayer * mask = [self createShapeLayerWithPath:path];\n    mask.position = CGPointMake(50, 40);\n    layer.mask = mask;\n    mask.strokeEnd = 0;\n    self.mask = mask;\n}\n\n-(CAShapeLayer *)createShapeLayerWithPath:(UIBezierPath *)path\n{\n    CAShapeLayer * layer = [CAShapeLayer layer];\n    layer.path = path.CGPath;\n    layer.bounds = CGRectMake(0, 0, 100, 75);\n    layer.position = self.view.center;\n    layer.fillColor = [UIColor clearColor].CGColor;\n    layer.strokeColor = [UIColor colorWithRed:33 / 255.0 green:192 / 255.0 blue:250 / 255.0 alpha:1].CGColor;\n    layer.lineCap = @\"round\";\n    layer.lineWidth = 10;\n    return layer;\n}\n\n-(CAGradientLayer *)createGradientLayerWithColors:(NSArray *)colors\n{\n    CAGradientLayer * gradientLayer = [CAGradientLayer layer];\n    gradientLayer.colors = colors;\n    gradientLayer.locations = @[@0,@0.8];\n    gradientLayer.startPoint = CGPointMake(0, 1);\n    gradientLayer.endPoint = CGPointMake(0, 0);\n    gradientLayer.bounds = CGRectMake(0, 0, 50, 80);\n    return gradientLayer;\n}\n```\n\n- - -\n\n### CAReplicatorLayer\nCAReplicatorLayer官方的解释是一个`高效处理复制图层的中间层`。他能复制图层的`所有属性`，`包括动画`。\n\n使用起来很简单，从他的属性一一看：\n\n> - instanceCount\n> \n> 实例数，复制后的实例数。\n> \n> - preservesDepth\n> \n> 这是一个bool值，默认为No，如果设为Yes，将会具有3维透视效果。\n> \n> - instanceDelay\n> - instanceTransform\n> - instanceColor\n> - instanceRedOffset\n> - instanceGreenOffset\n> - instanceBlueOffset\n> - instanceAlphaOffset\n> \n> 这一排属性都是每一个实例与上一个实例对应属性的偏移量。\n> \n\n还是上代码吧，直观点。\n\n```\n//     Do any additional setup after loading the view.\n        CALayer * layer = [CALayer layer];\n        layer.bounds = CGRectMake(0, 0, 30, 30);\n        layer.position = CGPointMake(self.view.center.x - 50, self.view.center.y - 50);\n        layer.backgroundColor = [UIColor redColor].CGColor;\n        layer.cornerRadius = 15;\n        [self.view.layer addSublayer:layer];\n    \n        CABasicAnimation * animation1 = [CABasicAnimation animationWithKeyPath:@\"opacity\"];\n        animation1.fromValue = @(0);\n        animation1.toValue = @(1);\n        animation1.duration = 1.5;\n    //    animation1.autoreverses = YES;\n    \n        CABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];\n        animation2.toValue = @(1.5);\n        animation2.fromValue = @(0.5);\n        animation2.duration = 1.5;\n    //    animation2.autoreverses = YES;\n    \n        CAAnimationGroup * ani = [CAAnimationGroup animation];\n        ani.animations = @[animation1,animation2];\n        ani.duration = 1.5;\n        ani.repeatCount = MAXFLOAT;\n        ani.autoreverses = YES;\n    \n        [layer addAnimation:ani forKey:nil];\n    \n        CAReplicatorLayer * rec = [CAReplicatorLayer layer];\n        [rec addSublayer:layer];\n        rec.instanceCount = 3;\n        rec.instanceDelay = 0.5;\n        rec.instanceTransform = CATransform3DMakeTranslation(50, 0, 0);\n        [self.view.layer addSublayer:rec];\n    \n        CAReplicatorLayer * rec2 = [CAReplicatorLayer layer];\n        [rec2 addSublayer:rec];\n        rec2.instanceCount = 3;\n        rec2.instanceDelay = 0.5;\n        rec2.instanceTransform = CATransform3DMakeTranslation(0, 50, 0);\n        [self.view.layer addSublayer:rec2];\n```\n正如你所看到的，`CAReplicatorLayer支持嵌套使用`。它的效果是如下这个样子的。\n\n![ReplicatorLayer](http://upload-images.jianshu.io/upload_images/1835430-cdc45f4b556ba1b5.gif?imageMogr2/auto-orient/strip)\n\n- - -\n\n### DWMirrorView\n\n啧啧啧，没想到今天的内容就这么讲完了。\n\n额，内容比较少，的确是今天讲的这几个比较简单。我知道只是这样你们是不会放过我的。那我就放一个这几个属性联合起来的一个小应用吧。\n\n![Mirror.gif](http://upload-images.jianshu.io/upload_images/1835430-72af1c07bb22ff51.gif?imageMogr2/auto-orient/strip)\n\n忽略倒影的层次感吧，截图问题，正常是一个梯度渐变下去的。\n\n其实拿到一个需求，我们先分析一下想要实现他的步骤，这个过程对于开发其实是很重要的。\n\n>首先来说，我们看到的倒影，我们应该可以考虑CAReplicator做一个复制图层，配合instranceTransform属性做出倒影效果\n\n>然后来说，我们看到了倒影渐变效果，我们应该想到的是使用CAGradientLayer去实现过渡效果。\n\n>最后一些细节的参数我们可以根据需求去进行相关设置。\n\n分析过后其实思路还是挺清晰的，一步步实现就好。\n实现起来很简单，代码量也不多，我就直接放代码就好了。\n\n```\n#pragma mark ---tool method---\n\n-(void)handleMirrorDistant:(CGFloat)distant\n{\n    CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;\n    CATransform3D transform = CATransform3DIdentity;\n    transform = CATransform3DTranslate(transform, 0, distant + self.bounds.size.height, 0);\n    transform = CATransform3DScale(transform, 1, -1, 0);\n    layer.instanceTransform = transform;\n}\n\n-(NSArray *)getMaskLayerLocations\n{\n    CGFloat height = self.bounds.size.height * 2 + self.mirrorDistant;\n    CGFloat mirrowScale = self.bounds.size.height * (1 + self.mirrorScale) + self.mirrorDistant;\n    return @[@0,@((self.bounds.size.height + self.mirrorDistant) / height),@(mirrowScale / height)];\n}\n\n-(CGFloat)safeValueBetween0And1:(CGFloat)value\n{\n    if (value > 1) {\n        value = 1;\n    } else if (value < 0) {\n        value = 0;\n    }\n    return value;\n}\n\n-(void)valueInit\n{\n    self.mirrorDistant = 0;\n    self.mirrorScale = 0.5;\n    self.mirrored = YES;\n    self.dynamic = YES;\n    self.mirrorAlpha = 0.5;\n}\n\n#pragma mark ---override---\n\n-(instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        [self valueInit];\n    }\n    return self;\n}\n\n-(void)awakeFromNib\n{\n    [super awakeFromNib];\n    [self valueInit];\n}\n\n+(Class)layerClass\n{\n    return [CAReplicatorLayer class];\n}\n\n-(void)drawRect:(CGRect)rect\n{\n    [super drawRect:rect];\n    CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;\n    if (self.mirrored) {\n        if (self.dynamic) {\n            [self.mirrorImageView removeFromSuperview];\n            self.mirrorImageView = nil;\n            layer.instanceCount = 2;\n            if (CATransform3DEqualToTransform(layer.instanceTransform, CATransform3DIdentity)) {\n                [self handleMirrorDistant:self.mirrorDistant];\n            }\n        }\n        else\n        {\n            layer.instanceCount = 1;\n            CGSize size = CGSizeMake(self.bounds.size.width, self.bounds.size.height * self.mirrorScale);\n            if (size.height > 0.0f && size.width > 0.0f)\n            {\n                UIGraphicsBeginImageContextWithOptions(size, NO, 0.0f);\n                CGContextRef context = UIGraphicsGetCurrentContext();\n                CGContextScaleCTM(context, 1.0f, -1.0f);\n                CGContextTranslateCTM(context, 0.0f, -self.bounds.size.height);\n                [self.layer renderInContext:context];\n                self.mirrorImageView.image = UIGraphicsGetImageFromCurrentImageContext();\n                UIGraphicsEndImageContext();\n            }\n            self.mirrorImageView.alpha = self.mirrorAlpha;\n            self.mirrorImageView.frame = CGRectMake(0, self.bounds.size.height + self.mirrorDistant, size.width, size.height);\n        }\n        self.layer.mask = self.maskLayer;\n    }\n    else\n    {\n        layer.instanceCount = 1;\n        [self.mirrorImageView removeFromSuperview];\n        self.mirrorImageView = nil;\n        self.layer.mask = nil;\n    }\n    \n}\n\n#pragma mark ---setter/getter---\n\n-(void)setMirrored:(BOOL)mirrored\n{\n    _mirrored = mirrored;\n    [self setNeedsDisplay];\n}\n\n-(void)setDynamic:(BOOL)dynamic\n{\n    _dynamic = dynamic;\n    [self setNeedsDisplay];\n}\n\n-(void)setMirrorAlpha:(CGFloat)mirrorAlpha\n{\n    _mirrorAlpha = [self safeValueBetween0And1:mirrorAlpha];\n    if (self.mirrored) {\n        if (self.dynamic) {\n            CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;\n            layer.instanceAlphaOffset = self.mirrorAlpha - 1;\n        }\n        else\n        {\n            [self setNeedsDisplay];\n        }\n    }\n    \n}\n\n-(void)setMirrorScale:(CGFloat)mirrorScale\n{\n    _mirrorScale = [self safeValueBetween0And1:mirrorScale];\n    if (self.mirrored) {\n        self.maskLayer.locations = [self getMaskLayerLocations];\n        if (!self.dynamic) {\n            [self setNeedsDisplay];\n        }\n    }\n}\n\n-(void)setMirrorDistant:(CGFloat)mirrorDistant\n{\n    _mirrorDistant = mirrorDistant;\n    if (self.mirrored) {\n        self.maskLayer = nil;\n        [self handleMirrorDistant:mirrorDistant];\n        [self setNeedsDisplay];\n    }\n}\n\n-(CAGradientLayer *)maskLayer\n{\n    if (!_maskLayer) {\n        _maskLayer = [CAGradientLayer layer];\n        _maskLayer.frame = CGRectMake(0, 0, self.bounds.size.width, self.bounds.size.height * 2 + self.mirrorDistant);\n        _maskLayer.startPoint = CGPointMake(0, 0);\n        _maskLayer.endPoint = CGPointMake(0, 1);\n        _maskLayer.locations = [self getMaskLayerLocations];\n        _maskLayer.colors = @[(id)[UIColor blackColor].CGColor,(id)[UIColor blackColor].CGColor,(id)[UIColor clearColor].CGColor];\n    }\n    return _maskLayer;\n}\n\n-(UIImageView *)mirrorImageView\n{\n    if (!_mirrorImageView) {\n        _mirrorImageView = [[UIImageView alloc] initWithFrame:self.bounds];\n        _mirrorImageView.contentMode = UIViewContentModeScaleToFill;\n        _mirrorImageView.userInteractionEnabled = NO;\n        [self addSubview:_mirrorImageView];\n    }\n    return _mirrorImageView;\n}\n```\n\n因为本身只作为一个容器存在，不需要对外界留一些接口，所以总共才200行代码，不过实现的效果还是可以的。\n\n- - -\n\n今天的内容告一段落了=。=老司机更的速度呢的确是有点慢，忙是一方面，`懒`是另一方面。\n\n![懒](http://upload-images.jianshu.io/upload_images/1835430-eb4d9e47069d8be1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n不过老司机会把剩下的几个类在下一期说完的=。=\n\ndemo老司机放在了网盘里，你可以来[这里](https://pan.baidu.com/s/1mi9COfm)找。\n\n至于镜像控件，老司机封装好了单独放在了一个仓库，你可以来[这里](https://github.com/CodeWicky/Components.git)找。\n\n最后，如果你喜欢老司机的文章，点个关注点个喜欢吧~\n","source":"_posts/老司机带你走进Core-Animation-之图层的透视、渐变及复制.md","raw":"---\n\ntitle: 老司机带你走进Core Animation 之图层的透视、渐变及复制\nlayout: post\ndate: 2016-12-21 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CAAnimation \n- 核心动画\n- 图层效果\ncategories: 核心动画\n\n---\n\n![老司机带你走进Core Animation 之图层的透视、渐变及复制](http://upload-images.jianshu.io/upload_images/1835430-deee60e266a22d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n这回呢，当然还是顺着头文件里面的几个类，老司机一个一个捋吧。\n\n老司机的想法就是要把CoreAnimation头文件中的类大概都说一遍，毕竟一开始把系列名定成了《老司机带你走进CoreAnimation》（深切的觉得自己给自己坑了。。。）。\n![我给自己挖的坑](http://upload-images.jianshu.io/upload_images/1835430-ff640963309ad310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以呢，在今天的博客里你将会看到以下截个内容\n\n- CATransform3D\n- CATransformLayer\n- CAGradientLayer\n- CAReplicatorLayer\n- DWMirrorView\n\n废话不多说，直接进入主题。\n\n<!-- more -->\n\n- - -\n\n### CATransform3D\n\n先介绍一下CATransform3D吧。\n\n![CATransform3D](http://upload-images.jianshu.io/upload_images/1835430-84870af23882317f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n正如上图所示，我们可以清晰的看到，CATransform3D是一个结构体。而且苹果很友好的调整了一下书写格式，正如你看到的，它像是一个4 X 4的矩阵。\n\n事实上他的原理就是一个`4 X 4矩阵`。\n\n其实他还有一个弟弟，CGAffineTransform。这是一个3 X 3的矩阵。\n他们的作用都一样，进行坐标变换。\n不同点在于，CATransform3D作用与3维坐标系的坐标变换，CGAffineTransform作用于2维坐标系的坐标变换。\n\n所以CGAffineTransform用于对UIView进行变换，而CATransform3D用于对CALayer进行变换。\n\n虽然老司机从小到大都是数学课代表，不过我要很郑重的告诉你，数学是一门靠悟性的学问，不是我讲给你听，你就能消化的，所以关于矩阵计算什么的，请各位同学自己消化理解（咳咳，我会告诉你我高数、线代、概率没有一科过70的么=。=）\n![一脸无辜](\nhttp://upload-images.jianshu.io/upload_images/1835430-60aec696da69627f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n)\n\n所以呢，老司机直接来介绍CATransform3D的相关api吧。（CGAffineTransform的api与CATransform3D相似，可类比使用）。\n\n> - CATransform3DIdentity\n> \n>生成一个无任何变换的默认矩阵，可用于使变换后的Layer恢复初始状态\n>\n>- - -\n> - CATransform3DMakeTranslation\n> - CATransform3DMakeScale \n> - CATransform3DMakeRotation\n> \n> 分别是平移、缩放、旋转，这三个api最大的相同点就在于函数名中都有Make。意思就是生成指定变换的矩阵。与之相对的就是下面的api👇\n> \n> - CATransform3DTranslate\n> - CATransform3DScale\n> - CATransform3DRotate\n> \n> 与之前三个api的不同点在于，这三个api都多了一个参数，同样是一个CATransform3D结构体。我想你一定猜到了，就是对给定的矩阵在其现有基础上进行指定的变换。\n> \n> 值得注意的是，以上两个旋转api中x/y/z三个参数均为指定旋转轴，可选值0和1，`0代表此轴不做旋转`，`1代表作旋转`。例如想对x、y轴做45度旋转，则angle = M____PI____4,x = 1,y = 1,z = 0。另外，此处旋转角度为`弧度制`哦，不是角度制。\n> \n> - - -\n> - CATransform3DConcat\n> \n> 返回两个矩阵的乘积。\n> \n> - - -\n> \n> - CATransform3DInvert\n> \n> 反转矩阵\n> \n> - - -\n> \n> - CATransform3DMakeAffineTransform\n> - CATransform3DGetAffineTransform\n> \n> CGAffineTransform与CATransform3D相互转化的api\n> \n> - - -\n> \n> - CATransform3DIsIdentity\n> - CATransform3DEqualToTransform\n> - CATransform3DIsAffine\n> \n> 这三个api见名知意了，不多说。\n> \n\n哦，重要的一点你一定要知道，所有的矩阵变换都是相对于图层的`锚点`进行的。还记得锚点的概念么？不记得可以去这个系列的[第一篇文章](http://www.jianshu.com/p/92a0661a21c6)补课哦。\n\n其实呢，关于CATransform3D你只要会使用以上api对图层做3维坐标转换就够了。不过上述这些变换默认情况下都是`不具备透视效果`的，因为你所看到的都是图层`在x轴y轴上的投影`，那想要透视效果怎么办呢？两个办法，CATranformLayer，以及M34。\n\n#### M34\n\n老司机说过，CATransform3D不过是一个4 X 4的矩阵。那么其实这16个数字中，每一个数字都有自己可以控制的转换，这是纯数学知识啊，自己领悟=。=不过老司机可以单独说说`M34`这个数。这个数是用来控制图层变换后的`景深效果`的，也就是`透视效果`。\n\n![M34](http://upload-images.jianshu.io/upload_images/1835430-5f03c502308df4c2.gif?imageMogr2/auto-orient/strip)\n\n上面的图片分别展示了具有透视效果的旋转及动画。\n\n代码上的体现就是\n\n```\n\tCALayer * staticLayerA = [CALayer layer];\n    staticLayerA.bounds = CGRectMake(0, 0, 100, 100);\n    staticLayerA.position = CGPointMake(self.view.center.x - 75, self.view.center.y - 100);\n    staticLayerA.backgroundColor = [UIColor redColor].CGColor;\n    [self.view.layer addSublayer:staticLayerA];\n    \n    CATransform3D transA = CATransform3DIdentity;\n    transA.m34 = - 1.0 / 500;\n    transA = CATransform3DRotate(transA, M_PI / 3, 1, 0, 0);\n    staticLayerA.transform = transA;\n\n```\n\n使用上很简单，代码里M34 = - 1.0 / 500 的意思就是`图层距离屏幕向里500的单位`。如果向外则是M34 = 1.0 / 500。这个距离至一般掌握至500~1000这个范围会取得不错的效果。\n\n这里需要注意的是`M34的赋值一定要写在矩阵变换前面`，具体为什么说实话老司机也不知道。\n\n- - -\n\n### CATransformLayer\n\n老司机上面提到过，CALayer做矩阵变换你能看到的只是他在XY轴上的投影，这时你若想看到透视效果，就需要使用到M34或CATransformLayer。其实他两个又有一些区别，CATransformLayer是让你看到的不只是其在XY轴上的投影。\n\n说起来不好懂，看下面的图吧。\n\n![TransformLayer](http://upload-images.jianshu.io/upload_images/1835430-6a1cec404c39345f.gif?imageMogr2/auto-orient/strip)\n\nCATransformLayer可以让其的`子视图各自现实自身的真实形状，而不是其在父视图的投影`。\n\n你可能还不懂，其实你看的正方体是六个CALayer经过矩阵变换拼成的实实在在的正方体。\n\n```\n\t//create cube layer\n    CATransformLayer *cube = [CATransformLayer layer];\n    \n    //add cube face 1\n    CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 2\n    ct = CATransform3DMakeTranslation(50, 0, 0);\n    ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 3\n    ct = CATransform3DMakeTranslation(0, -50, 0);\n    ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 4\n    ct = CATransform3DMakeTranslation(0, 50, 0);\n    ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 5\n    ct = CATransform3DMakeTranslation(-50, 0, 0);\n    ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //add cube face 6\n    ct = CATransform3DMakeTranslation(0, 0, -50);\n    ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);\n    [cube addSublayer:[self faceWithTransform:ct]];\n    \n    //center the cube layer within the container\n    CGSize containerSize = self.containerView.bounds.size;\n    cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);\n```\n```\n- (CALayer *)faceWithTransform:(CATransform3D)transform\n{\n    //create cube face layer\n    CALayer *face = [CALayer layer];\n    face.bounds = CGRectMake(0, 0, 100, 100);\n    //apply a random color\n    CGFloat red = (rand() / (double)INT_MAX);\n    CGFloat green = (rand() / (double)INT_MAX);\n    CGFloat blue = (rand() / (double)INT_MAX);\n    face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;\n    face.transform = transform;\n    return face;\n}\n\n```\n使用起来就是这么简单，把各个变换后的layer加入到CATransformLayer中就可以了。\n\n本身CATransformLayer不具有任何其他属性，其实他更像是`一个容器`。它本身至渲染其子图层，自身没有任何layer的属性。\n\n最重要的一点是，当图层加入到CATransformLayer中以后，`hitTest和convertPoint两个方法就失效了`，请注意这点。\n\n- - -\n\n### CAGradientLayer\n\nCAGradientLayer本身的属性也比较少，而且完全是针对于过渡颜色来的。\n\n> - colors\n> \n> 图层显示的所有颜色的数组\n> \n> - - -\n> - locations\n> \n> 每个颜色对应的位置。注意，这个位置指的是颜色的位置，而不是过渡线的位置。\n> \n> - - - \n> - startPoint\n> - endPoint\n> \n> 是颜色过渡的方向，会沿着起点到终点的向量进行过渡。\n> - - -\n> \n> - type\n> \n> 过渡模式，当前苹果给我们暴露的只有一种模式，kCAGradientLayerAxial。\n> \n\n需要说明的是，CAGradientLayer只能做`矩形的渐变图层`。\n\n![你要怎么做？](http://upload-images.jianshu.io/upload_images/1835430-ed19e2d814f232f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n所以说这个效果要如何实现呢？其实啊，这只是一个错觉，看这个。\n\n![矩形渐变层](http://upload-images.jianshu.io/upload_images/1835430-cd67967da4814962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以说看到这你就知道了吧，两个拼一起的CAGradientLayer，然后用一个shapeLayer做了一个mask就成了环形的过渡层了。这一招老司机早就做了过，还记得么，[歌词显示那一章](http://www.jianshu.com/p/8e14616679ea)。\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(50, 50) radius:45 startAngle:- 7.0 / 6 * M_PI endAngle:M_PI / 6 clockwise:YES];\n    \n    [self.view.layer addSublayer:[self createShapeLayerWithPath:path]];\n    \n    CAGradientLayer * leftL = [self createGradientLayerWithColors:@[(id)[UIColor redColor].CGColor,(id)[UIColor yellowColor].CGColor]];\n    leftL.position = CGPointMake(25, 40);\n    \n    CAGradientLayer * rightL = [self createGradientLayerWithColors:@[(id)[UIColor greenColor].CGColor,(id)[UIColor yellowColor].CGColor]];\n    rightL.position = CGPointMake(75, 40);\n    \n    CALayer * layer = [CALayer layer];\n    layer.bounds = CGRectMake(0, 0, 100, 80);\n    layer.position = self.view.center;\n    [layer addSublayer:leftL];\n    [layer addSublayer:rightL];\n    [self.view.layer addSublayer:layer];\n    \n    CAShapeLayer * mask = [self createShapeLayerWithPath:path];\n    mask.position = CGPointMake(50, 40);\n    layer.mask = mask;\n    mask.strokeEnd = 0;\n    self.mask = mask;\n}\n\n-(CAShapeLayer *)createShapeLayerWithPath:(UIBezierPath *)path\n{\n    CAShapeLayer * layer = [CAShapeLayer layer];\n    layer.path = path.CGPath;\n    layer.bounds = CGRectMake(0, 0, 100, 75);\n    layer.position = self.view.center;\n    layer.fillColor = [UIColor clearColor].CGColor;\n    layer.strokeColor = [UIColor colorWithRed:33 / 255.0 green:192 / 255.0 blue:250 / 255.0 alpha:1].CGColor;\n    layer.lineCap = @\"round\";\n    layer.lineWidth = 10;\n    return layer;\n}\n\n-(CAGradientLayer *)createGradientLayerWithColors:(NSArray *)colors\n{\n    CAGradientLayer * gradientLayer = [CAGradientLayer layer];\n    gradientLayer.colors = colors;\n    gradientLayer.locations = @[@0,@0.8];\n    gradientLayer.startPoint = CGPointMake(0, 1);\n    gradientLayer.endPoint = CGPointMake(0, 0);\n    gradientLayer.bounds = CGRectMake(0, 0, 50, 80);\n    return gradientLayer;\n}\n```\n\n- - -\n\n### CAReplicatorLayer\nCAReplicatorLayer官方的解释是一个`高效处理复制图层的中间层`。他能复制图层的`所有属性`，`包括动画`。\n\n使用起来很简单，从他的属性一一看：\n\n> - instanceCount\n> \n> 实例数，复制后的实例数。\n> \n> - preservesDepth\n> \n> 这是一个bool值，默认为No，如果设为Yes，将会具有3维透视效果。\n> \n> - instanceDelay\n> - instanceTransform\n> - instanceColor\n> - instanceRedOffset\n> - instanceGreenOffset\n> - instanceBlueOffset\n> - instanceAlphaOffset\n> \n> 这一排属性都是每一个实例与上一个实例对应属性的偏移量。\n> \n\n还是上代码吧，直观点。\n\n```\n//     Do any additional setup after loading the view.\n        CALayer * layer = [CALayer layer];\n        layer.bounds = CGRectMake(0, 0, 30, 30);\n        layer.position = CGPointMake(self.view.center.x - 50, self.view.center.y - 50);\n        layer.backgroundColor = [UIColor redColor].CGColor;\n        layer.cornerRadius = 15;\n        [self.view.layer addSublayer:layer];\n    \n        CABasicAnimation * animation1 = [CABasicAnimation animationWithKeyPath:@\"opacity\"];\n        animation1.fromValue = @(0);\n        animation1.toValue = @(1);\n        animation1.duration = 1.5;\n    //    animation1.autoreverses = YES;\n    \n        CABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];\n        animation2.toValue = @(1.5);\n        animation2.fromValue = @(0.5);\n        animation2.duration = 1.5;\n    //    animation2.autoreverses = YES;\n    \n        CAAnimationGroup * ani = [CAAnimationGroup animation];\n        ani.animations = @[animation1,animation2];\n        ani.duration = 1.5;\n        ani.repeatCount = MAXFLOAT;\n        ani.autoreverses = YES;\n    \n        [layer addAnimation:ani forKey:nil];\n    \n        CAReplicatorLayer * rec = [CAReplicatorLayer layer];\n        [rec addSublayer:layer];\n        rec.instanceCount = 3;\n        rec.instanceDelay = 0.5;\n        rec.instanceTransform = CATransform3DMakeTranslation(50, 0, 0);\n        [self.view.layer addSublayer:rec];\n    \n        CAReplicatorLayer * rec2 = [CAReplicatorLayer layer];\n        [rec2 addSublayer:rec];\n        rec2.instanceCount = 3;\n        rec2.instanceDelay = 0.5;\n        rec2.instanceTransform = CATransform3DMakeTranslation(0, 50, 0);\n        [self.view.layer addSublayer:rec2];\n```\n正如你所看到的，`CAReplicatorLayer支持嵌套使用`。它的效果是如下这个样子的。\n\n![ReplicatorLayer](http://upload-images.jianshu.io/upload_images/1835430-cdc45f4b556ba1b5.gif?imageMogr2/auto-orient/strip)\n\n- - -\n\n### DWMirrorView\n\n啧啧啧，没想到今天的内容就这么讲完了。\n\n额，内容比较少，的确是今天讲的这几个比较简单。我知道只是这样你们是不会放过我的。那我就放一个这几个属性联合起来的一个小应用吧。\n\n![Mirror.gif](http://upload-images.jianshu.io/upload_images/1835430-72af1c07bb22ff51.gif?imageMogr2/auto-orient/strip)\n\n忽略倒影的层次感吧，截图问题，正常是一个梯度渐变下去的。\n\n其实拿到一个需求，我们先分析一下想要实现他的步骤，这个过程对于开发其实是很重要的。\n\n>首先来说，我们看到的倒影，我们应该可以考虑CAReplicator做一个复制图层，配合instranceTransform属性做出倒影效果\n\n>然后来说，我们看到了倒影渐变效果，我们应该想到的是使用CAGradientLayer去实现过渡效果。\n\n>最后一些细节的参数我们可以根据需求去进行相关设置。\n\n分析过后其实思路还是挺清晰的，一步步实现就好。\n实现起来很简单，代码量也不多，我就直接放代码就好了。\n\n```\n#pragma mark ---tool method---\n\n-(void)handleMirrorDistant:(CGFloat)distant\n{\n    CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;\n    CATransform3D transform = CATransform3DIdentity;\n    transform = CATransform3DTranslate(transform, 0, distant + self.bounds.size.height, 0);\n    transform = CATransform3DScale(transform, 1, -1, 0);\n    layer.instanceTransform = transform;\n}\n\n-(NSArray *)getMaskLayerLocations\n{\n    CGFloat height = self.bounds.size.height * 2 + self.mirrorDistant;\n    CGFloat mirrowScale = self.bounds.size.height * (1 + self.mirrorScale) + self.mirrorDistant;\n    return @[@0,@((self.bounds.size.height + self.mirrorDistant) / height),@(mirrowScale / height)];\n}\n\n-(CGFloat)safeValueBetween0And1:(CGFloat)value\n{\n    if (value > 1) {\n        value = 1;\n    } else if (value < 0) {\n        value = 0;\n    }\n    return value;\n}\n\n-(void)valueInit\n{\n    self.mirrorDistant = 0;\n    self.mirrorScale = 0.5;\n    self.mirrored = YES;\n    self.dynamic = YES;\n    self.mirrorAlpha = 0.5;\n}\n\n#pragma mark ---override---\n\n-(instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        [self valueInit];\n    }\n    return self;\n}\n\n-(void)awakeFromNib\n{\n    [super awakeFromNib];\n    [self valueInit];\n}\n\n+(Class)layerClass\n{\n    return [CAReplicatorLayer class];\n}\n\n-(void)drawRect:(CGRect)rect\n{\n    [super drawRect:rect];\n    CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;\n    if (self.mirrored) {\n        if (self.dynamic) {\n            [self.mirrorImageView removeFromSuperview];\n            self.mirrorImageView = nil;\n            layer.instanceCount = 2;\n            if (CATransform3DEqualToTransform(layer.instanceTransform, CATransform3DIdentity)) {\n                [self handleMirrorDistant:self.mirrorDistant];\n            }\n        }\n        else\n        {\n            layer.instanceCount = 1;\n            CGSize size = CGSizeMake(self.bounds.size.width, self.bounds.size.height * self.mirrorScale);\n            if (size.height > 0.0f && size.width > 0.0f)\n            {\n                UIGraphicsBeginImageContextWithOptions(size, NO, 0.0f);\n                CGContextRef context = UIGraphicsGetCurrentContext();\n                CGContextScaleCTM(context, 1.0f, -1.0f);\n                CGContextTranslateCTM(context, 0.0f, -self.bounds.size.height);\n                [self.layer renderInContext:context];\n                self.mirrorImageView.image = UIGraphicsGetImageFromCurrentImageContext();\n                UIGraphicsEndImageContext();\n            }\n            self.mirrorImageView.alpha = self.mirrorAlpha;\n            self.mirrorImageView.frame = CGRectMake(0, self.bounds.size.height + self.mirrorDistant, size.width, size.height);\n        }\n        self.layer.mask = self.maskLayer;\n    }\n    else\n    {\n        layer.instanceCount = 1;\n        [self.mirrorImageView removeFromSuperview];\n        self.mirrorImageView = nil;\n        self.layer.mask = nil;\n    }\n    \n}\n\n#pragma mark ---setter/getter---\n\n-(void)setMirrored:(BOOL)mirrored\n{\n    _mirrored = mirrored;\n    [self setNeedsDisplay];\n}\n\n-(void)setDynamic:(BOOL)dynamic\n{\n    _dynamic = dynamic;\n    [self setNeedsDisplay];\n}\n\n-(void)setMirrorAlpha:(CGFloat)mirrorAlpha\n{\n    _mirrorAlpha = [self safeValueBetween0And1:mirrorAlpha];\n    if (self.mirrored) {\n        if (self.dynamic) {\n            CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;\n            layer.instanceAlphaOffset = self.mirrorAlpha - 1;\n        }\n        else\n        {\n            [self setNeedsDisplay];\n        }\n    }\n    \n}\n\n-(void)setMirrorScale:(CGFloat)mirrorScale\n{\n    _mirrorScale = [self safeValueBetween0And1:mirrorScale];\n    if (self.mirrored) {\n        self.maskLayer.locations = [self getMaskLayerLocations];\n        if (!self.dynamic) {\n            [self setNeedsDisplay];\n        }\n    }\n}\n\n-(void)setMirrorDistant:(CGFloat)mirrorDistant\n{\n    _mirrorDistant = mirrorDistant;\n    if (self.mirrored) {\n        self.maskLayer = nil;\n        [self handleMirrorDistant:mirrorDistant];\n        [self setNeedsDisplay];\n    }\n}\n\n-(CAGradientLayer *)maskLayer\n{\n    if (!_maskLayer) {\n        _maskLayer = [CAGradientLayer layer];\n        _maskLayer.frame = CGRectMake(0, 0, self.bounds.size.width, self.bounds.size.height * 2 + self.mirrorDistant);\n        _maskLayer.startPoint = CGPointMake(0, 0);\n        _maskLayer.endPoint = CGPointMake(0, 1);\n        _maskLayer.locations = [self getMaskLayerLocations];\n        _maskLayer.colors = @[(id)[UIColor blackColor].CGColor,(id)[UIColor blackColor].CGColor,(id)[UIColor clearColor].CGColor];\n    }\n    return _maskLayer;\n}\n\n-(UIImageView *)mirrorImageView\n{\n    if (!_mirrorImageView) {\n        _mirrorImageView = [[UIImageView alloc] initWithFrame:self.bounds];\n        _mirrorImageView.contentMode = UIViewContentModeScaleToFill;\n        _mirrorImageView.userInteractionEnabled = NO;\n        [self addSubview:_mirrorImageView];\n    }\n    return _mirrorImageView;\n}\n```\n\n因为本身只作为一个容器存在，不需要对外界留一些接口，所以总共才200行代码，不过实现的效果还是可以的。\n\n- - -\n\n今天的内容告一段落了=。=老司机更的速度呢的确是有点慢，忙是一方面，`懒`是另一方面。\n\n![懒](http://upload-images.jianshu.io/upload_images/1835430-eb4d9e47069d8be1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n不过老司机会把剩下的几个类在下一期说完的=。=\n\ndemo老司机放在了网盘里，你可以来[这里](https://pan.baidu.com/s/1mi9COfm)找。\n\n至于镜像控件，老司机封装好了单独放在了一个仓库，你可以来[这里](https://github.com/CodeWicky/Components.git)找。\n\n最后，如果你喜欢老司机的文章，点个关注点个喜欢吧~\n","slug":"老司机带你走进Core-Animation-之图层的透视、渐变及复制","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htq20017jigbj3vjdba2","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-deee60e266a22d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之图层的透视、渐变及复制\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>这回呢，当然还是顺着头文件里面的几个类，老司机一个一个捋吧。</p>\n<p>老司机的想法就是要把CoreAnimation头文件中的类大概都说一遍，毕竟一开始把系列名定成了《老司机带你走进CoreAnimation》（深切的觉得自己给自己坑了。。。）。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ff640963309ad310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"我给自己挖的坑\"></p>\n<p>所以呢，在今天的博客里你将会看到以下截个内容</p>\n<ul>\n<li>CATransform3D</li>\n<li>CATransformLayer</li>\n<li>CAGradientLayer</li>\n<li>CAReplicatorLayer</li>\n<li>DWMirrorView</li>\n</ul>\n<p>废话不多说，直接进入主题。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"CATransform3D\"><a href=\"#CATransform3D\" class=\"headerlink\" title=\"CATransform3D\"></a>CATransform3D</h3><p>先介绍一下CATransform3D吧。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-84870af23882317f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CATransform3D\"></p>\n<p>正如上图所示，我们可以清晰的看到，CATransform3D是一个结构体。而且苹果很友好的调整了一下书写格式，正如你看到的，它像是一个4 X 4的矩阵。</p>\n<p>事实上他的原理就是一个<code>4 X 4矩阵</code>。</p>\n<p>其实他还有一个弟弟，CGAffineTransform。这是一个3 X 3的矩阵。<br>他们的作用都一样，进行坐标变换。<br>不同点在于，CATransform3D作用与3维坐标系的坐标变换，CGAffineTransform作用于2维坐标系的坐标变换。</p>\n<p>所以CGAffineTransform用于对UIView进行变换，而CATransform3D用于对CALayer进行变换。</p>\n<p>虽然老司机从小到大都是数学课代表，不过我要很郑重的告诉你，数学是一门靠悟性的学问，不是我讲给你听，你就能消化的，所以关于矩阵计算什么的，请各位同学自己消化理解（咳咳，我会告诉你我高数、线代、概率没有一科过70的么=。=）<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-60aec696da69627f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一脸无辜\"></p>\n<p>所以呢，老司机直接来介绍CATransform3D的相关api吧。（CGAffineTransform的api与CATransform3D相似，可类比使用）。</p>\n<blockquote>\n<ul>\n<li>CATransform3DIdentity</li>\n</ul>\n<p>生成一个无任何变换的默认矩阵，可用于使变换后的Layer恢复初始状态</p>\n<hr>\n<ul>\n<li>CATransform3DMakeTranslation</li>\n<li>CATransform3DMakeScale </li>\n<li>CATransform3DMakeRotation</li>\n</ul>\n<p>分别是平移、缩放、旋转，这三个api最大的相同点就在于函数名中都有Make。意思就是生成指定变换的矩阵。与之相对的就是下面的api👇</p>\n<ul>\n<li>CATransform3DTranslate</li>\n<li>CATransform3DScale</li>\n<li>CATransform3DRotate</li>\n</ul>\n<p>与之前三个api的不同点在于，这三个api都多了一个参数，同样是一个CATransform3D结构体。我想你一定猜到了，就是对给定的矩阵在其现有基础上进行指定的变换。</p>\n<p>值得注意的是，以上两个旋转api中x/y/z三个参数均为指定旋转轴，可选值0和1，<code>0代表此轴不做旋转</code>，<code>1代表作旋转</code>。例如想对x、y轴做45度旋转，则angle = M<strong><strong>PI</strong></strong>4,x = 1,y = 1,z = 0。另外，此处旋转角度为<code>弧度制</code>哦，不是角度制。</p>\n<hr>\n<ul>\n<li>CATransform3DConcat</li>\n</ul>\n<p>返回两个矩阵的乘积。</p>\n<hr>\n<ul>\n<li>CATransform3DInvert</li>\n</ul>\n<p>反转矩阵</p>\n<hr>\n<ul>\n<li>CATransform3DMakeAffineTransform</li>\n<li>CATransform3DGetAffineTransform</li>\n</ul>\n<p>CGAffineTransform与CATransform3D相互转化的api</p>\n<hr>\n<ul>\n<li>CATransform3DIsIdentity</li>\n<li>CATransform3DEqualToTransform</li>\n<li>CATransform3DIsAffine</li>\n</ul>\n<p>这三个api见名知意了，不多说。</p>\n</blockquote>\n<p>哦，重要的一点你一定要知道，所有的矩阵变换都是相对于图层的<code>锚点</code>进行的。还记得锚点的概念么？不记得可以去这个系列的<a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">第一篇文章</a>补课哦。</p>\n<p>其实呢，关于CATransform3D你只要会使用以上api对图层做3维坐标转换就够了。不过上述这些变换默认情况下都是<code>不具备透视效果</code>的，因为你所看到的都是图层<code>在x轴y轴上的投影</code>，那想要透视效果怎么办呢？两个办法，CATranformLayer，以及M34。</p>\n<h4 id=\"M34\"><a href=\"#M34\" class=\"headerlink\" title=\"M34\"></a>M34</h4><p>老司机说过，CATransform3D不过是一个4 X 4的矩阵。那么其实这16个数字中，每一个数字都有自己可以控制的转换，这是纯数学知识啊，自己领悟=。=不过老司机可以单独说说<code>M34</code>这个数。这个数是用来控制图层变换后的<code>景深效果</code>的，也就是<code>透视效果</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-5f03c502308df4c2.gif?imageMogr2/auto-orient/strip\" alt=\"M34\"></p>\n<p>上面的图片分别展示了具有透视效果的旋转及动画。</p>\n<p>代码上的体现就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">CALayer * staticLayerA = [CALayer layer];</div><div class=\"line\">   staticLayerA.bounds = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">   staticLayerA.position = CGPointMake(self.view.center.x - 75, self.view.center.y - 100);</div><div class=\"line\">   staticLayerA.backgroundColor = [UIColor redColor].CGColor;</div><div class=\"line\">   [self.view.layer addSublayer:staticLayerA];</div><div class=\"line\">   </div><div class=\"line\">   CATransform3D transA = CATransform3DIdentity;</div><div class=\"line\">   transA.m34 = - 1.0 / 500;</div><div class=\"line\">   transA = CATransform3DRotate(transA, M_PI / 3, 1, 0, 0);</div><div class=\"line\">   staticLayerA.transform = transA;</div></pre></td></tr></table></figure>\n<p>使用上很简单，代码里M34 = - 1.0 / 500 的意思就是<code>图层距离屏幕向里500的单位</code>。如果向外则是M34 = 1.0 / 500。这个距离至一般掌握至500~1000这个范围会取得不错的效果。</p>\n<p>这里需要注意的是<code>M34的赋值一定要写在矩阵变换前面</code>，具体为什么说实话老司机也不知道。</p>\n<hr>\n<h3 id=\"CATransformLayer\"><a href=\"#CATransformLayer\" class=\"headerlink\" title=\"CATransformLayer\"></a>CATransformLayer</h3><p>老司机上面提到过，CALayer做矩阵变换你能看到的只是他在XY轴上的投影，这时你若想看到透视效果，就需要使用到M34或CATransformLayer。其实他两个又有一些区别，CATransformLayer是让你看到的不只是其在XY轴上的投影。</p>\n<p>说起来不好懂，看下面的图吧。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6a1cec404c39345f.gif?imageMogr2/auto-orient/strip\" alt=\"TransformLayer\"></p>\n<p>CATransformLayer可以让其的<code>子视图各自现实自身的真实形状，而不是其在父视图的投影</code>。</p>\n<p>你可能还不懂，其实你看的正方体是六个CALayer经过矩阵变换拼成的实实在在的正方体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">//create cube layer</div><div class=\"line\">   CATransformLayer *cube = [CATransformLayer layer];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 1</div><div class=\"line\">   CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 2</div><div class=\"line\">   ct = CATransform3DMakeTranslation(50, 0, 0);</div><div class=\"line\">   ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 3</div><div class=\"line\">   ct = CATransform3DMakeTranslation(0, -50, 0);</div><div class=\"line\">   ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 4</div><div class=\"line\">   ct = CATransform3DMakeTranslation(0, 50, 0);</div><div class=\"line\">   ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 5</div><div class=\"line\">   ct = CATransform3DMakeTranslation(-50, 0, 0);</div><div class=\"line\">   ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 6</div><div class=\"line\">   ct = CATransform3DMakeTranslation(0, 0, -50);</div><div class=\"line\">   ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //center the cube layer within the container</div><div class=\"line\">   CGSize containerSize = self.containerView.bounds.size;</div><div class=\"line\">   cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (CALayer *)faceWithTransform:(CATransform3D)transform</div><div class=\"line\">&#123;</div><div class=\"line\">    //create cube face layer</div><div class=\"line\">    CALayer *face = [CALayer layer];</div><div class=\"line\">    face.bounds = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">    //apply a random color</div><div class=\"line\">    CGFloat red = (rand() / (double)INT_MAX);</div><div class=\"line\">    CGFloat green = (rand() / (double)INT_MAX);</div><div class=\"line\">    CGFloat blue = (rand() / (double)INT_MAX);</div><div class=\"line\">    face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class=\"line\">    face.transform = transform;</div><div class=\"line\">    return face;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用起来就是这么简单，把各个变换后的layer加入到CATransformLayer中就可以了。</p>\n<p>本身CATransformLayer不具有任何其他属性，其实他更像是<code>一个容器</code>。它本身至渲染其子图层，自身没有任何layer的属性。</p>\n<p>最重要的一点是，当图层加入到CATransformLayer中以后，<code>hitTest和convertPoint两个方法就失效了</code>，请注意这点。</p>\n<hr>\n<h3 id=\"CAGradientLayer\"><a href=\"#CAGradientLayer\" class=\"headerlink\" title=\"CAGradientLayer\"></a>CAGradientLayer</h3><p>CAGradientLayer本身的属性也比较少，而且完全是针对于过渡颜色来的。</p>\n<blockquote>\n<ul>\n<li>colors</li>\n</ul>\n<p>图层显示的所有颜色的数组</p>\n<hr>\n<ul>\n<li>locations</li>\n</ul>\n<p>每个颜色对应的位置。注意，这个位置指的是颜色的位置，而不是过渡线的位置。</p>\n<hr>\n<ul>\n<li>startPoint</li>\n<li>endPoint</li>\n</ul>\n<p>是颜色过渡的方向，会沿着起点到终点的向量进行过渡。</p>\n<hr>\n<ul>\n<li>type</li>\n</ul>\n<p>过渡模式，当前苹果给我们暴露的只有一种模式，kCAGradientLayerAxial。</p>\n</blockquote>\n<p>需要说明的是，CAGradientLayer只能做<code>矩形的渐变图层</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ed19e2d814f232f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"你要怎么做？\"></p>\n<p>所以说这个效果要如何实现呢？其实啊，这只是一个错觉，看这个。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-cd67967da4814962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"矩形渐变层\"></p>\n<p>所以说看到这你就知道了吧，两个拼一起的CAGradientLayer，然后用一个shapeLayer做了一个mask就成了环形的过渡层了。这一招老司机早就做了过，还记得么，<a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">歌词显示那一章</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(50, 50) radius:45 startAngle:- 7.0 / 6 * M_PI endAngle:M_PI / 6 clockwise:YES];</div><div class=\"line\">    </div><div class=\"line\">    [self.view.layer addSublayer:[self createShapeLayerWithPath:path]];</div><div class=\"line\">    </div><div class=\"line\">    CAGradientLayer * leftL = [self createGradientLayerWithColors:@[(id)[UIColor redColor].CGColor,(id)[UIColor yellowColor].CGColor]];</div><div class=\"line\">    leftL.position = CGPointMake(25, 40);</div><div class=\"line\">    </div><div class=\"line\">    CAGradientLayer * rightL = [self createGradientLayerWithColors:@[(id)[UIColor greenColor].CGColor,(id)[UIColor yellowColor].CGColor]];</div><div class=\"line\">    rightL.position = CGPointMake(75, 40);</div><div class=\"line\">    </div><div class=\"line\">    CALayer * layer = [CALayer layer];</div><div class=\"line\">    layer.bounds = CGRectMake(0, 0, 100, 80);</div><div class=\"line\">    layer.position = self.view.center;</div><div class=\"line\">    [layer addSublayer:leftL];</div><div class=\"line\">    [layer addSublayer:rightL];</div><div class=\"line\">    [self.view.layer addSublayer:layer];</div><div class=\"line\">    </div><div class=\"line\">    CAShapeLayer * mask = [self createShapeLayerWithPath:path];</div><div class=\"line\">    mask.position = CGPointMake(50, 40);</div><div class=\"line\">    layer.mask = mask;</div><div class=\"line\">    mask.strokeEnd = 0;</div><div class=\"line\">    self.mask = mask;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CAShapeLayer *)createShapeLayerWithPath:(UIBezierPath *)path</div><div class=\"line\">&#123;</div><div class=\"line\">    CAShapeLayer * layer = [CAShapeLayer layer];</div><div class=\"line\">    layer.path = path.CGPath;</div><div class=\"line\">    layer.bounds = CGRectMake(0, 0, 100, 75);</div><div class=\"line\">    layer.position = self.view.center;</div><div class=\"line\">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class=\"line\">    layer.strokeColor = [UIColor colorWithRed:33 / 255.0 green:192 / 255.0 blue:250 / 255.0 alpha:1].CGColor;</div><div class=\"line\">    layer.lineCap = @&quot;round&quot;;</div><div class=\"line\">    layer.lineWidth = 10;</div><div class=\"line\">    return layer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CAGradientLayer *)createGradientLayerWithColors:(NSArray *)colors</div><div class=\"line\">&#123;</div><div class=\"line\">    CAGradientLayer * gradientLayer = [CAGradientLayer layer];</div><div class=\"line\">    gradientLayer.colors = colors;</div><div class=\"line\">    gradientLayer.locations = @[@0,@0.8];</div><div class=\"line\">    gradientLayer.startPoint = CGPointMake(0, 1);</div><div class=\"line\">    gradientLayer.endPoint = CGPointMake(0, 0);</div><div class=\"line\">    gradientLayer.bounds = CGRectMake(0, 0, 50, 80);</div><div class=\"line\">    return gradientLayer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"CAReplicatorLayer\"><a href=\"#CAReplicatorLayer\" class=\"headerlink\" title=\"CAReplicatorLayer\"></a>CAReplicatorLayer</h3><p>CAReplicatorLayer官方的解释是一个<code>高效处理复制图层的中间层</code>。他能复制图层的<code>所有属性</code>，<code>包括动画</code>。</p>\n<p>使用起来很简单，从他的属性一一看：</p>\n<blockquote>\n<ul>\n<li>instanceCount</li>\n</ul>\n<p>实例数，复制后的实例数。</p>\n<ul>\n<li>preservesDepth</li>\n</ul>\n<p>这是一个bool值，默认为No，如果设为Yes，将会具有3维透视效果。</p>\n<ul>\n<li>instanceDelay</li>\n<li>instanceTransform</li>\n<li>instanceColor</li>\n<li>instanceRedOffset</li>\n<li>instanceGreenOffset</li>\n<li>instanceBlueOffset</li>\n<li>instanceAlphaOffset</li>\n</ul>\n<p>这一排属性都是每一个实例与上一个实例对应属性的偏移量。</p>\n</blockquote>\n<p>还是上代码吧，直观点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">//     Do any additional setup after loading the view.</div><div class=\"line\">        CALayer * layer = [CALayer layer];</div><div class=\"line\">        layer.bounds = CGRectMake(0, 0, 30, 30);</div><div class=\"line\">        layer.position = CGPointMake(self.view.center.x - 50, self.view.center.y - 50);</div><div class=\"line\">        layer.backgroundColor = [UIColor redColor].CGColor;</div><div class=\"line\">        layer.cornerRadius = 15;</div><div class=\"line\">        [self.view.layer addSublayer:layer];</div><div class=\"line\">    </div><div class=\"line\">        CABasicAnimation * animation1 = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];</div><div class=\"line\">        animation1.fromValue = @(0);</div><div class=\"line\">        animation1.toValue = @(1);</div><div class=\"line\">        animation1.duration = 1.5;</div><div class=\"line\">    //    animation1.autoreverses = YES;</div><div class=\"line\">    </div><div class=\"line\">        CABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</div><div class=\"line\">        animation2.toValue = @(1.5);</div><div class=\"line\">        animation2.fromValue = @(0.5);</div><div class=\"line\">        animation2.duration = 1.5;</div><div class=\"line\">    //    animation2.autoreverses = YES;</div><div class=\"line\">    </div><div class=\"line\">        CAAnimationGroup * ani = [CAAnimationGroup animation];</div><div class=\"line\">        ani.animations = @[animation1,animation2];</div><div class=\"line\">        ani.duration = 1.5;</div><div class=\"line\">        ani.repeatCount = MAXFLOAT;</div><div class=\"line\">        ani.autoreverses = YES;</div><div class=\"line\">    </div><div class=\"line\">        [layer addAnimation:ani forKey:nil];</div><div class=\"line\">    </div><div class=\"line\">        CAReplicatorLayer * rec = [CAReplicatorLayer layer];</div><div class=\"line\">        [rec addSublayer:layer];</div><div class=\"line\">        rec.instanceCount = 3;</div><div class=\"line\">        rec.instanceDelay = 0.5;</div><div class=\"line\">        rec.instanceTransform = CATransform3DMakeTranslation(50, 0, 0);</div><div class=\"line\">        [self.view.layer addSublayer:rec];</div><div class=\"line\">    </div><div class=\"line\">        CAReplicatorLayer * rec2 = [CAReplicatorLayer layer];</div><div class=\"line\">        [rec2 addSublayer:rec];</div><div class=\"line\">        rec2.instanceCount = 3;</div><div class=\"line\">        rec2.instanceDelay = 0.5;</div><div class=\"line\">        rec2.instanceTransform = CATransform3DMakeTranslation(0, 50, 0);</div><div class=\"line\">        [self.view.layer addSublayer:rec2];</div></pre></td></tr></table></figure>\n<p>正如你所看到的，<code>CAReplicatorLayer支持嵌套使用</code>。它的效果是如下这个样子的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-cdc45f4b556ba1b5.gif?imageMogr2/auto-orient/strip\" alt=\"ReplicatorLayer\"></p>\n<hr>\n<h3 id=\"DWMirrorView\"><a href=\"#DWMirrorView\" class=\"headerlink\" title=\"DWMirrorView\"></a>DWMirrorView</h3><p>啧啧啧，没想到今天的内容就这么讲完了。</p>\n<p>额，内容比较少，的确是今天讲的这几个比较简单。我知道只是这样你们是不会放过我的。那我就放一个这几个属性联合起来的一个小应用吧。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-72af1c07bb22ff51.gif?imageMogr2/auto-orient/strip\" alt=\"Mirror.gif\"></p>\n<p>忽略倒影的层次感吧，截图问题，正常是一个梯度渐变下去的。</p>\n<p>其实拿到一个需求，我们先分析一下想要实现他的步骤，这个过程对于开发其实是很重要的。</p>\n<blockquote>\n<p>首先来说，我们看到的倒影，我们应该可以考虑CAReplicator做一个复制图层，配合instranceTransform属性做出倒影效果</p>\n<p>然后来说，我们看到了倒影渐变效果，我们应该想到的是使用CAGradientLayer去实现过渡效果。</p>\n<p>最后一些细节的参数我们可以根据需求去进行相关设置。</p>\n</blockquote>\n<p>分析过后其实思路还是挺清晰的，一步步实现就好。<br>实现起来很简单，代码量也不多，我就直接放代码就好了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark ---tool method---</div><div class=\"line\"></div><div class=\"line\">-(void)handleMirrorDistant:(CGFloat)distant</div><div class=\"line\">&#123;</div><div class=\"line\">    CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;</div><div class=\"line\">    CATransform3D transform = CATransform3DIdentity;</div><div class=\"line\">    transform = CATransform3DTranslate(transform, 0, distant + self.bounds.size.height, 0);</div><div class=\"line\">    transform = CATransform3DScale(transform, 1, -1, 0);</div><div class=\"line\">    layer.instanceTransform = transform;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSArray *)getMaskLayerLocations</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat height = self.bounds.size.height * 2 + self.mirrorDistant;</div><div class=\"line\">    CGFloat mirrowScale = self.bounds.size.height * (1 + self.mirrorScale) + self.mirrorDistant;</div><div class=\"line\">    return @[@0,@((self.bounds.size.height + self.mirrorDistant) / height),@(mirrowScale / height)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGFloat)safeValueBetween0And1:(CGFloat)value</div><div class=\"line\">&#123;</div><div class=\"line\">    if (value &gt; 1) &#123;</div><div class=\"line\">        value = 1;</div><div class=\"line\">    &#125; else if (value &lt; 0) &#123;</div><div class=\"line\">        value = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)valueInit</div><div class=\"line\">&#123;</div><div class=\"line\">    self.mirrorDistant = 0;</div><div class=\"line\">    self.mirrorScale = 0.5;</div><div class=\"line\">    self.mirrored = YES;</div><div class=\"line\">    self.dynamic = YES;</div><div class=\"line\">    self.mirrorAlpha = 0.5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark ---override---</div><div class=\"line\"></div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super initWithFrame:frame];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        [self valueInit];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)awakeFromNib</div><div class=\"line\">&#123;</div><div class=\"line\">    [super awakeFromNib];</div><div class=\"line\">    [self valueInit];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(Class)layerClass</div><div class=\"line\">&#123;</div><div class=\"line\">    return [CAReplicatorLayer class];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)drawRect:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    [super drawRect:rect];</div><div class=\"line\">    CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;</div><div class=\"line\">    if (self.mirrored) &#123;</div><div class=\"line\">        if (self.dynamic) &#123;</div><div class=\"line\">            [self.mirrorImageView removeFromSuperview];</div><div class=\"line\">            self.mirrorImageView = nil;</div><div class=\"line\">            layer.instanceCount = 2;</div><div class=\"line\">            if (CATransform3DEqualToTransform(layer.instanceTransform, CATransform3DIdentity)) &#123;</div><div class=\"line\">                [self handleMirrorDistant:self.mirrorDistant];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            layer.instanceCount = 1;</div><div class=\"line\">            CGSize size = CGSizeMake(self.bounds.size.width, self.bounds.size.height * self.mirrorScale);</div><div class=\"line\">            if (size.height &gt; 0.0f &amp;&amp; size.width &gt; 0.0f)</div><div class=\"line\">            &#123;</div><div class=\"line\">                UIGraphicsBeginImageContextWithOptions(size, NO, 0.0f);</div><div class=\"line\">                CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">                CGContextScaleCTM(context, 1.0f, -1.0f);</div><div class=\"line\">                CGContextTranslateCTM(context, 0.0f, -self.bounds.size.height);</div><div class=\"line\">                [self.layer renderInContext:context];</div><div class=\"line\">                self.mirrorImageView.image = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">                UIGraphicsEndImageContext();</div><div class=\"line\">            &#125;</div><div class=\"line\">            self.mirrorImageView.alpha = self.mirrorAlpha;</div><div class=\"line\">            self.mirrorImageView.frame = CGRectMake(0, self.bounds.size.height + self.mirrorDistant, size.width, size.height);</div><div class=\"line\">        &#125;</div><div class=\"line\">        self.layer.mask = self.maskLayer;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        layer.instanceCount = 1;</div><div class=\"line\">        [self.mirrorImageView removeFromSuperview];</div><div class=\"line\">        self.mirrorImageView = nil;</div><div class=\"line\">        self.layer.mask = nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark ---setter/getter---</div><div class=\"line\"></div><div class=\"line\">-(void)setMirrored:(BOOL)mirrored</div><div class=\"line\">&#123;</div><div class=\"line\">    _mirrored = mirrored;</div><div class=\"line\">    [self setNeedsDisplay];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setDynamic:(BOOL)dynamic</div><div class=\"line\">&#123;</div><div class=\"line\">    _dynamic = dynamic;</div><div class=\"line\">    [self setNeedsDisplay];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setMirrorAlpha:(CGFloat)mirrorAlpha</div><div class=\"line\">&#123;</div><div class=\"line\">    _mirrorAlpha = [self safeValueBetween0And1:mirrorAlpha];</div><div class=\"line\">    if (self.mirrored) &#123;</div><div class=\"line\">        if (self.dynamic) &#123;</div><div class=\"line\">            CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;</div><div class=\"line\">            layer.instanceAlphaOffset = self.mirrorAlpha - 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            [self setNeedsDisplay];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setMirrorScale:(CGFloat)mirrorScale</div><div class=\"line\">&#123;</div><div class=\"line\">    _mirrorScale = [self safeValueBetween0And1:mirrorScale];</div><div class=\"line\">    if (self.mirrored) &#123;</div><div class=\"line\">        self.maskLayer.locations = [self getMaskLayerLocations];</div><div class=\"line\">        if (!self.dynamic) &#123;</div><div class=\"line\">            [self setNeedsDisplay];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setMirrorDistant:(CGFloat)mirrorDistant</div><div class=\"line\">&#123;</div><div class=\"line\">    _mirrorDistant = mirrorDistant;</div><div class=\"line\">    if (self.mirrored) &#123;</div><div class=\"line\">        self.maskLayer = nil;</div><div class=\"line\">        [self handleMirrorDistant:mirrorDistant];</div><div class=\"line\">        [self setNeedsDisplay];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CAGradientLayer *)maskLayer</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_maskLayer) &#123;</div><div class=\"line\">        _maskLayer = [CAGradientLayer layer];</div><div class=\"line\">        _maskLayer.frame = CGRectMake(0, 0, self.bounds.size.width, self.bounds.size.height * 2 + self.mirrorDistant);</div><div class=\"line\">        _maskLayer.startPoint = CGPointMake(0, 0);</div><div class=\"line\">        _maskLayer.endPoint = CGPointMake(0, 1);</div><div class=\"line\">        _maskLayer.locations = [self getMaskLayerLocations];</div><div class=\"line\">        _maskLayer.colors = @[(id)[UIColor blackColor].CGColor,(id)[UIColor blackColor].CGColor,(id)[UIColor clearColor].CGColor];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _maskLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(UIImageView *)mirrorImageView</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_mirrorImageView) &#123;</div><div class=\"line\">        _mirrorImageView = [[UIImageView alloc] initWithFrame:self.bounds];</div><div class=\"line\">        _mirrorImageView.contentMode = UIViewContentModeScaleToFill;</div><div class=\"line\">        _mirrorImageView.userInteractionEnabled = NO;</div><div class=\"line\">        [self addSubview:_mirrorImageView];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _mirrorImageView;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为本身只作为一个容器存在，不需要对外界留一些接口，所以总共才200行代码，不过实现的效果还是可以的。</p>\n<hr>\n<p>今天的内容告一段落了=。=老司机更的速度呢的确是有点慢，忙是一方面，<code>懒</code>是另一方面。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-eb4d9e47069d8be1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"懒\"></p>\n<p>不过老司机会把剩下的几个类在下一期说完的=。=</p>\n<p>demo老司机放在了网盘里，你可以来<a href=\"https://pan.baidu.com/s/1mi9COfm\" target=\"_blank\" rel=\"external\">这里</a>找。</p>\n<p>至于镜像控件，老司机封装好了单独放在了一个仓库，你可以来<a href=\"https://github.com/CodeWicky/Components.git\" target=\"_blank\" rel=\"external\">这里</a>找。</p>\n<p>最后，如果你喜欢老司机的文章，点个关注点个喜欢吧~</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-deee60e266a22d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之图层的透视、渐变及复制\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>这回呢，当然还是顺着头文件里面的几个类，老司机一个一个捋吧。</p>\n<p>老司机的想法就是要把CoreAnimation头文件中的类大概都说一遍，毕竟一开始把系列名定成了《老司机带你走进CoreAnimation》（深切的觉得自己给自己坑了。。。）。<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ff640963309ad310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"我给自己挖的坑\"></p>\n<p>所以呢，在今天的博客里你将会看到以下截个内容</p>\n<ul>\n<li>CATransform3D</li>\n<li>CATransformLayer</li>\n<li>CAGradientLayer</li>\n<li>CAReplicatorLayer</li>\n<li>DWMirrorView</li>\n</ul>\n<p>废话不多说，直接进入主题。</p>","more":"<hr>\n<h3 id=\"CATransform3D\"><a href=\"#CATransform3D\" class=\"headerlink\" title=\"CATransform3D\"></a>CATransform3D</h3><p>先介绍一下CATransform3D吧。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-84870af23882317f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"CATransform3D\"></p>\n<p>正如上图所示，我们可以清晰的看到，CATransform3D是一个结构体。而且苹果很友好的调整了一下书写格式，正如你看到的，它像是一个4 X 4的矩阵。</p>\n<p>事实上他的原理就是一个<code>4 X 4矩阵</code>。</p>\n<p>其实他还有一个弟弟，CGAffineTransform。这是一个3 X 3的矩阵。<br>他们的作用都一样，进行坐标变换。<br>不同点在于，CATransform3D作用与3维坐标系的坐标变换，CGAffineTransform作用于2维坐标系的坐标变换。</p>\n<p>所以CGAffineTransform用于对UIView进行变换，而CATransform3D用于对CALayer进行变换。</p>\n<p>虽然老司机从小到大都是数学课代表，不过我要很郑重的告诉你，数学是一门靠悟性的学问，不是我讲给你听，你就能消化的，所以关于矩阵计算什么的，请各位同学自己消化理解（咳咳，我会告诉你我高数、线代、概率没有一科过70的么=。=）<br><img src=\"http://upload-images.jianshu.io/upload_images/1835430-60aec696da69627f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一脸无辜\"></p>\n<p>所以呢，老司机直接来介绍CATransform3D的相关api吧。（CGAffineTransform的api与CATransform3D相似，可类比使用）。</p>\n<blockquote>\n<ul>\n<li>CATransform3DIdentity</li>\n</ul>\n<p>生成一个无任何变换的默认矩阵，可用于使变换后的Layer恢复初始状态</p>\n<hr>\n<ul>\n<li>CATransform3DMakeTranslation</li>\n<li>CATransform3DMakeScale </li>\n<li>CATransform3DMakeRotation</li>\n</ul>\n<p>分别是平移、缩放、旋转，这三个api最大的相同点就在于函数名中都有Make。意思就是生成指定变换的矩阵。与之相对的就是下面的api👇</p>\n<ul>\n<li>CATransform3DTranslate</li>\n<li>CATransform3DScale</li>\n<li>CATransform3DRotate</li>\n</ul>\n<p>与之前三个api的不同点在于，这三个api都多了一个参数，同样是一个CATransform3D结构体。我想你一定猜到了，就是对给定的矩阵在其现有基础上进行指定的变换。</p>\n<p>值得注意的是，以上两个旋转api中x/y/z三个参数均为指定旋转轴，可选值0和1，<code>0代表此轴不做旋转</code>，<code>1代表作旋转</code>。例如想对x、y轴做45度旋转，则angle = M<strong><strong>PI</strong></strong>4,x = 1,y = 1,z = 0。另外，此处旋转角度为<code>弧度制</code>哦，不是角度制。</p>\n<hr>\n<ul>\n<li>CATransform3DConcat</li>\n</ul>\n<p>返回两个矩阵的乘积。</p>\n<hr>\n<ul>\n<li>CATransform3DInvert</li>\n</ul>\n<p>反转矩阵</p>\n<hr>\n<ul>\n<li>CATransform3DMakeAffineTransform</li>\n<li>CATransform3DGetAffineTransform</li>\n</ul>\n<p>CGAffineTransform与CATransform3D相互转化的api</p>\n<hr>\n<ul>\n<li>CATransform3DIsIdentity</li>\n<li>CATransform3DEqualToTransform</li>\n<li>CATransform3DIsAffine</li>\n</ul>\n<p>这三个api见名知意了，不多说。</p>\n</blockquote>\n<p>哦，重要的一点你一定要知道，所有的矩阵变换都是相对于图层的<code>锚点</code>进行的。还记得锚点的概念么？不记得可以去这个系列的<a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">第一篇文章</a>补课哦。</p>\n<p>其实呢，关于CATransform3D你只要会使用以上api对图层做3维坐标转换就够了。不过上述这些变换默认情况下都是<code>不具备透视效果</code>的，因为你所看到的都是图层<code>在x轴y轴上的投影</code>，那想要透视效果怎么办呢？两个办法，CATranformLayer，以及M34。</p>\n<h4 id=\"M34\"><a href=\"#M34\" class=\"headerlink\" title=\"M34\"></a>M34</h4><p>老司机说过，CATransform3D不过是一个4 X 4的矩阵。那么其实这16个数字中，每一个数字都有自己可以控制的转换，这是纯数学知识啊，自己领悟=。=不过老司机可以单独说说<code>M34</code>这个数。这个数是用来控制图层变换后的<code>景深效果</code>的，也就是<code>透视效果</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-5f03c502308df4c2.gif?imageMogr2/auto-orient/strip\" alt=\"M34\"></p>\n<p>上面的图片分别展示了具有透视效果的旋转及动画。</p>\n<p>代码上的体现就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">CALayer * staticLayerA = [CALayer layer];</div><div class=\"line\">   staticLayerA.bounds = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">   staticLayerA.position = CGPointMake(self.view.center.x - 75, self.view.center.y - 100);</div><div class=\"line\">   staticLayerA.backgroundColor = [UIColor redColor].CGColor;</div><div class=\"line\">   [self.view.layer addSublayer:staticLayerA];</div><div class=\"line\">   </div><div class=\"line\">   CATransform3D transA = CATransform3DIdentity;</div><div class=\"line\">   transA.m34 = - 1.0 / 500;</div><div class=\"line\">   transA = CATransform3DRotate(transA, M_PI / 3, 1, 0, 0);</div><div class=\"line\">   staticLayerA.transform = transA;</div></pre></td></tr></table></figure>\n<p>使用上很简单，代码里M34 = - 1.0 / 500 的意思就是<code>图层距离屏幕向里500的单位</code>。如果向外则是M34 = 1.0 / 500。这个距离至一般掌握至500~1000这个范围会取得不错的效果。</p>\n<p>这里需要注意的是<code>M34的赋值一定要写在矩阵变换前面</code>，具体为什么说实话老司机也不知道。</p>\n<hr>\n<h3 id=\"CATransformLayer\"><a href=\"#CATransformLayer\" class=\"headerlink\" title=\"CATransformLayer\"></a>CATransformLayer</h3><p>老司机上面提到过，CALayer做矩阵变换你能看到的只是他在XY轴上的投影，这时你若想看到透视效果，就需要使用到M34或CATransformLayer。其实他两个又有一些区别，CATransformLayer是让你看到的不只是其在XY轴上的投影。</p>\n<p>说起来不好懂，看下面的图吧。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6a1cec404c39345f.gif?imageMogr2/auto-orient/strip\" alt=\"TransformLayer\"></p>\n<p>CATransformLayer可以让其的<code>子视图各自现实自身的真实形状，而不是其在父视图的投影</code>。</p>\n<p>你可能还不懂，其实你看的正方体是六个CALayer经过矩阵变换拼成的实实在在的正方体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">//create cube layer</div><div class=\"line\">   CATransformLayer *cube = [CATransformLayer layer];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 1</div><div class=\"line\">   CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 2</div><div class=\"line\">   ct = CATransform3DMakeTranslation(50, 0, 0);</div><div class=\"line\">   ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 3</div><div class=\"line\">   ct = CATransform3DMakeTranslation(0, -50, 0);</div><div class=\"line\">   ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 4</div><div class=\"line\">   ct = CATransform3DMakeTranslation(0, 50, 0);</div><div class=\"line\">   ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 5</div><div class=\"line\">   ct = CATransform3DMakeTranslation(-50, 0, 0);</div><div class=\"line\">   ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //add cube face 6</div><div class=\"line\">   ct = CATransform3DMakeTranslation(0, 0, -50);</div><div class=\"line\">   ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);</div><div class=\"line\">   [cube addSublayer:[self faceWithTransform:ct]];</div><div class=\"line\">   </div><div class=\"line\">   //center the cube layer within the container</div><div class=\"line\">   CGSize containerSize = self.containerView.bounds.size;</div><div class=\"line\">   cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (CALayer *)faceWithTransform:(CATransform3D)transform</div><div class=\"line\">&#123;</div><div class=\"line\">    //create cube face layer</div><div class=\"line\">    CALayer *face = [CALayer layer];</div><div class=\"line\">    face.bounds = CGRectMake(0, 0, 100, 100);</div><div class=\"line\">    //apply a random color</div><div class=\"line\">    CGFloat red = (rand() / (double)INT_MAX);</div><div class=\"line\">    CGFloat green = (rand() / (double)INT_MAX);</div><div class=\"line\">    CGFloat blue = (rand() / (double)INT_MAX);</div><div class=\"line\">    face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class=\"line\">    face.transform = transform;</div><div class=\"line\">    return face;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用起来就是这么简单，把各个变换后的layer加入到CATransformLayer中就可以了。</p>\n<p>本身CATransformLayer不具有任何其他属性，其实他更像是<code>一个容器</code>。它本身至渲染其子图层，自身没有任何layer的属性。</p>\n<p>最重要的一点是，当图层加入到CATransformLayer中以后，<code>hitTest和convertPoint两个方法就失效了</code>，请注意这点。</p>\n<hr>\n<h3 id=\"CAGradientLayer\"><a href=\"#CAGradientLayer\" class=\"headerlink\" title=\"CAGradientLayer\"></a>CAGradientLayer</h3><p>CAGradientLayer本身的属性也比较少，而且完全是针对于过渡颜色来的。</p>\n<blockquote>\n<ul>\n<li>colors</li>\n</ul>\n<p>图层显示的所有颜色的数组</p>\n<hr>\n<ul>\n<li>locations</li>\n</ul>\n<p>每个颜色对应的位置。注意，这个位置指的是颜色的位置，而不是过渡线的位置。</p>\n<hr>\n<ul>\n<li>startPoint</li>\n<li>endPoint</li>\n</ul>\n<p>是颜色过渡的方向，会沿着起点到终点的向量进行过渡。</p>\n<hr>\n<ul>\n<li>type</li>\n</ul>\n<p>过渡模式，当前苹果给我们暴露的只有一种模式，kCAGradientLayerAxial。</p>\n</blockquote>\n<p>需要说明的是，CAGradientLayer只能做<code>矩形的渐变图层</code>。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ed19e2d814f232f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"你要怎么做？\"></p>\n<p>所以说这个效果要如何实现呢？其实啊，这只是一个错觉，看这个。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-cd67967da4814962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"矩形渐变层\"></p>\n<p>所以说看到这你就知道了吧，两个拼一起的CAGradientLayer，然后用一个shapeLayer做了一个mask就成了环形的过渡层了。这一招老司机早就做了过，还记得么，<a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">歌词显示那一章</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(50, 50) radius:45 startAngle:- 7.0 / 6 * M_PI endAngle:M_PI / 6 clockwise:YES];</div><div class=\"line\">    </div><div class=\"line\">    [self.view.layer addSublayer:[self createShapeLayerWithPath:path]];</div><div class=\"line\">    </div><div class=\"line\">    CAGradientLayer * leftL = [self createGradientLayerWithColors:@[(id)[UIColor redColor].CGColor,(id)[UIColor yellowColor].CGColor]];</div><div class=\"line\">    leftL.position = CGPointMake(25, 40);</div><div class=\"line\">    </div><div class=\"line\">    CAGradientLayer * rightL = [self createGradientLayerWithColors:@[(id)[UIColor greenColor].CGColor,(id)[UIColor yellowColor].CGColor]];</div><div class=\"line\">    rightL.position = CGPointMake(75, 40);</div><div class=\"line\">    </div><div class=\"line\">    CALayer * layer = [CALayer layer];</div><div class=\"line\">    layer.bounds = CGRectMake(0, 0, 100, 80);</div><div class=\"line\">    layer.position = self.view.center;</div><div class=\"line\">    [layer addSublayer:leftL];</div><div class=\"line\">    [layer addSublayer:rightL];</div><div class=\"line\">    [self.view.layer addSublayer:layer];</div><div class=\"line\">    </div><div class=\"line\">    CAShapeLayer * mask = [self createShapeLayerWithPath:path];</div><div class=\"line\">    mask.position = CGPointMake(50, 40);</div><div class=\"line\">    layer.mask = mask;</div><div class=\"line\">    mask.strokeEnd = 0;</div><div class=\"line\">    self.mask = mask;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CAShapeLayer *)createShapeLayerWithPath:(UIBezierPath *)path</div><div class=\"line\">&#123;</div><div class=\"line\">    CAShapeLayer * layer = [CAShapeLayer layer];</div><div class=\"line\">    layer.path = path.CGPath;</div><div class=\"line\">    layer.bounds = CGRectMake(0, 0, 100, 75);</div><div class=\"line\">    layer.position = self.view.center;</div><div class=\"line\">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class=\"line\">    layer.strokeColor = [UIColor colorWithRed:33 / 255.0 green:192 / 255.0 blue:250 / 255.0 alpha:1].CGColor;</div><div class=\"line\">    layer.lineCap = @&quot;round&quot;;</div><div class=\"line\">    layer.lineWidth = 10;</div><div class=\"line\">    return layer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CAGradientLayer *)createGradientLayerWithColors:(NSArray *)colors</div><div class=\"line\">&#123;</div><div class=\"line\">    CAGradientLayer * gradientLayer = [CAGradientLayer layer];</div><div class=\"line\">    gradientLayer.colors = colors;</div><div class=\"line\">    gradientLayer.locations = @[@0,@0.8];</div><div class=\"line\">    gradientLayer.startPoint = CGPointMake(0, 1);</div><div class=\"line\">    gradientLayer.endPoint = CGPointMake(0, 0);</div><div class=\"line\">    gradientLayer.bounds = CGRectMake(0, 0, 50, 80);</div><div class=\"line\">    return gradientLayer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"CAReplicatorLayer\"><a href=\"#CAReplicatorLayer\" class=\"headerlink\" title=\"CAReplicatorLayer\"></a>CAReplicatorLayer</h3><p>CAReplicatorLayer官方的解释是一个<code>高效处理复制图层的中间层</code>。他能复制图层的<code>所有属性</code>，<code>包括动画</code>。</p>\n<p>使用起来很简单，从他的属性一一看：</p>\n<blockquote>\n<ul>\n<li>instanceCount</li>\n</ul>\n<p>实例数，复制后的实例数。</p>\n<ul>\n<li>preservesDepth</li>\n</ul>\n<p>这是一个bool值，默认为No，如果设为Yes，将会具有3维透视效果。</p>\n<ul>\n<li>instanceDelay</li>\n<li>instanceTransform</li>\n<li>instanceColor</li>\n<li>instanceRedOffset</li>\n<li>instanceGreenOffset</li>\n<li>instanceBlueOffset</li>\n<li>instanceAlphaOffset</li>\n</ul>\n<p>这一排属性都是每一个实例与上一个实例对应属性的偏移量。</p>\n</blockquote>\n<p>还是上代码吧，直观点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">//     Do any additional setup after loading the view.</div><div class=\"line\">        CALayer * layer = [CALayer layer];</div><div class=\"line\">        layer.bounds = CGRectMake(0, 0, 30, 30);</div><div class=\"line\">        layer.position = CGPointMake(self.view.center.x - 50, self.view.center.y - 50);</div><div class=\"line\">        layer.backgroundColor = [UIColor redColor].CGColor;</div><div class=\"line\">        layer.cornerRadius = 15;</div><div class=\"line\">        [self.view.layer addSublayer:layer];</div><div class=\"line\">    </div><div class=\"line\">        CABasicAnimation * animation1 = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];</div><div class=\"line\">        animation1.fromValue = @(0);</div><div class=\"line\">        animation1.toValue = @(1);</div><div class=\"line\">        animation1.duration = 1.5;</div><div class=\"line\">    //    animation1.autoreverses = YES;</div><div class=\"line\">    </div><div class=\"line\">        CABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</div><div class=\"line\">        animation2.toValue = @(1.5);</div><div class=\"line\">        animation2.fromValue = @(0.5);</div><div class=\"line\">        animation2.duration = 1.5;</div><div class=\"line\">    //    animation2.autoreverses = YES;</div><div class=\"line\">    </div><div class=\"line\">        CAAnimationGroup * ani = [CAAnimationGroup animation];</div><div class=\"line\">        ani.animations = @[animation1,animation2];</div><div class=\"line\">        ani.duration = 1.5;</div><div class=\"line\">        ani.repeatCount = MAXFLOAT;</div><div class=\"line\">        ani.autoreverses = YES;</div><div class=\"line\">    </div><div class=\"line\">        [layer addAnimation:ani forKey:nil];</div><div class=\"line\">    </div><div class=\"line\">        CAReplicatorLayer * rec = [CAReplicatorLayer layer];</div><div class=\"line\">        [rec addSublayer:layer];</div><div class=\"line\">        rec.instanceCount = 3;</div><div class=\"line\">        rec.instanceDelay = 0.5;</div><div class=\"line\">        rec.instanceTransform = CATransform3DMakeTranslation(50, 0, 0);</div><div class=\"line\">        [self.view.layer addSublayer:rec];</div><div class=\"line\">    </div><div class=\"line\">        CAReplicatorLayer * rec2 = [CAReplicatorLayer layer];</div><div class=\"line\">        [rec2 addSublayer:rec];</div><div class=\"line\">        rec2.instanceCount = 3;</div><div class=\"line\">        rec2.instanceDelay = 0.5;</div><div class=\"line\">        rec2.instanceTransform = CATransform3DMakeTranslation(0, 50, 0);</div><div class=\"line\">        [self.view.layer addSublayer:rec2];</div></pre></td></tr></table></figure>\n<p>正如你所看到的，<code>CAReplicatorLayer支持嵌套使用</code>。它的效果是如下这个样子的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-cdc45f4b556ba1b5.gif?imageMogr2/auto-orient/strip\" alt=\"ReplicatorLayer\"></p>\n<hr>\n<h3 id=\"DWMirrorView\"><a href=\"#DWMirrorView\" class=\"headerlink\" title=\"DWMirrorView\"></a>DWMirrorView</h3><p>啧啧啧，没想到今天的内容就这么讲完了。</p>\n<p>额，内容比较少，的确是今天讲的这几个比较简单。我知道只是这样你们是不会放过我的。那我就放一个这几个属性联合起来的一个小应用吧。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-72af1c07bb22ff51.gif?imageMogr2/auto-orient/strip\" alt=\"Mirror.gif\"></p>\n<p>忽略倒影的层次感吧，截图问题，正常是一个梯度渐变下去的。</p>\n<p>其实拿到一个需求，我们先分析一下想要实现他的步骤，这个过程对于开发其实是很重要的。</p>\n<blockquote>\n<p>首先来说，我们看到的倒影，我们应该可以考虑CAReplicator做一个复制图层，配合instranceTransform属性做出倒影效果</p>\n<p>然后来说，我们看到了倒影渐变效果，我们应该想到的是使用CAGradientLayer去实现过渡效果。</p>\n<p>最后一些细节的参数我们可以根据需求去进行相关设置。</p>\n</blockquote>\n<p>分析过后其实思路还是挺清晰的，一步步实现就好。<br>实现起来很简单，代码量也不多，我就直接放代码就好了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark ---tool method---</div><div class=\"line\"></div><div class=\"line\">-(void)handleMirrorDistant:(CGFloat)distant</div><div class=\"line\">&#123;</div><div class=\"line\">    CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;</div><div class=\"line\">    CATransform3D transform = CATransform3DIdentity;</div><div class=\"line\">    transform = CATransform3DTranslate(transform, 0, distant + self.bounds.size.height, 0);</div><div class=\"line\">    transform = CATransform3DScale(transform, 1, -1, 0);</div><div class=\"line\">    layer.instanceTransform = transform;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSArray *)getMaskLayerLocations</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat height = self.bounds.size.height * 2 + self.mirrorDistant;</div><div class=\"line\">    CGFloat mirrowScale = self.bounds.size.height * (1 + self.mirrorScale) + self.mirrorDistant;</div><div class=\"line\">    return @[@0,@((self.bounds.size.height + self.mirrorDistant) / height),@(mirrowScale / height)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CGFloat)safeValueBetween0And1:(CGFloat)value</div><div class=\"line\">&#123;</div><div class=\"line\">    if (value &gt; 1) &#123;</div><div class=\"line\">        value = 1;</div><div class=\"line\">    &#125; else if (value &lt; 0) &#123;</div><div class=\"line\">        value = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)valueInit</div><div class=\"line\">&#123;</div><div class=\"line\">    self.mirrorDistant = 0;</div><div class=\"line\">    self.mirrorScale = 0.5;</div><div class=\"line\">    self.mirrored = YES;</div><div class=\"line\">    self.dynamic = YES;</div><div class=\"line\">    self.mirrorAlpha = 0.5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark ---override---</div><div class=\"line\"></div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super initWithFrame:frame];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        [self valueInit];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)awakeFromNib</div><div class=\"line\">&#123;</div><div class=\"line\">    [super awakeFromNib];</div><div class=\"line\">    [self valueInit];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(Class)layerClass</div><div class=\"line\">&#123;</div><div class=\"line\">    return [CAReplicatorLayer class];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)drawRect:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    [super drawRect:rect];</div><div class=\"line\">    CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;</div><div class=\"line\">    if (self.mirrored) &#123;</div><div class=\"line\">        if (self.dynamic) &#123;</div><div class=\"line\">            [self.mirrorImageView removeFromSuperview];</div><div class=\"line\">            self.mirrorImageView = nil;</div><div class=\"line\">            layer.instanceCount = 2;</div><div class=\"line\">            if (CATransform3DEqualToTransform(layer.instanceTransform, CATransform3DIdentity)) &#123;</div><div class=\"line\">                [self handleMirrorDistant:self.mirrorDistant];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            layer.instanceCount = 1;</div><div class=\"line\">            CGSize size = CGSizeMake(self.bounds.size.width, self.bounds.size.height * self.mirrorScale);</div><div class=\"line\">            if (size.height &gt; 0.0f &amp;&amp; size.width &gt; 0.0f)</div><div class=\"line\">            &#123;</div><div class=\"line\">                UIGraphicsBeginImageContextWithOptions(size, NO, 0.0f);</div><div class=\"line\">                CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">                CGContextScaleCTM(context, 1.0f, -1.0f);</div><div class=\"line\">                CGContextTranslateCTM(context, 0.0f, -self.bounds.size.height);</div><div class=\"line\">                [self.layer renderInContext:context];</div><div class=\"line\">                self.mirrorImageView.image = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">                UIGraphicsEndImageContext();</div><div class=\"line\">            &#125;</div><div class=\"line\">            self.mirrorImageView.alpha = self.mirrorAlpha;</div><div class=\"line\">            self.mirrorImageView.frame = CGRectMake(0, self.bounds.size.height + self.mirrorDistant, size.width, size.height);</div><div class=\"line\">        &#125;</div><div class=\"line\">        self.layer.mask = self.maskLayer;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        layer.instanceCount = 1;</div><div class=\"line\">        [self.mirrorImageView removeFromSuperview];</div><div class=\"line\">        self.mirrorImageView = nil;</div><div class=\"line\">        self.layer.mask = nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark ---setter/getter---</div><div class=\"line\"></div><div class=\"line\">-(void)setMirrored:(BOOL)mirrored</div><div class=\"line\">&#123;</div><div class=\"line\">    _mirrored = mirrored;</div><div class=\"line\">    [self setNeedsDisplay];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setDynamic:(BOOL)dynamic</div><div class=\"line\">&#123;</div><div class=\"line\">    _dynamic = dynamic;</div><div class=\"line\">    [self setNeedsDisplay];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setMirrorAlpha:(CGFloat)mirrorAlpha</div><div class=\"line\">&#123;</div><div class=\"line\">    _mirrorAlpha = [self safeValueBetween0And1:mirrorAlpha];</div><div class=\"line\">    if (self.mirrored) &#123;</div><div class=\"line\">        if (self.dynamic) &#123;</div><div class=\"line\">            CAReplicatorLayer * layer = (CAReplicatorLayer *)self.layer;</div><div class=\"line\">            layer.instanceAlphaOffset = self.mirrorAlpha - 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            [self setNeedsDisplay];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setMirrorScale:(CGFloat)mirrorScale</div><div class=\"line\">&#123;</div><div class=\"line\">    _mirrorScale = [self safeValueBetween0And1:mirrorScale];</div><div class=\"line\">    if (self.mirrored) &#123;</div><div class=\"line\">        self.maskLayer.locations = [self getMaskLayerLocations];</div><div class=\"line\">        if (!self.dynamic) &#123;</div><div class=\"line\">            [self setNeedsDisplay];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setMirrorDistant:(CGFloat)mirrorDistant</div><div class=\"line\">&#123;</div><div class=\"line\">    _mirrorDistant = mirrorDistant;</div><div class=\"line\">    if (self.mirrored) &#123;</div><div class=\"line\">        self.maskLayer = nil;</div><div class=\"line\">        [self handleMirrorDistant:mirrorDistant];</div><div class=\"line\">        [self setNeedsDisplay];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(CAGradientLayer *)maskLayer</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_maskLayer) &#123;</div><div class=\"line\">        _maskLayer = [CAGradientLayer layer];</div><div class=\"line\">        _maskLayer.frame = CGRectMake(0, 0, self.bounds.size.width, self.bounds.size.height * 2 + self.mirrorDistant);</div><div class=\"line\">        _maskLayer.startPoint = CGPointMake(0, 0);</div><div class=\"line\">        _maskLayer.endPoint = CGPointMake(0, 1);</div><div class=\"line\">        _maskLayer.locations = [self getMaskLayerLocations];</div><div class=\"line\">        _maskLayer.colors = @[(id)[UIColor blackColor].CGColor,(id)[UIColor blackColor].CGColor,(id)[UIColor clearColor].CGColor];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _maskLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(UIImageView *)mirrorImageView</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!_mirrorImageView) &#123;</div><div class=\"line\">        _mirrorImageView = [[UIImageView alloc] initWithFrame:self.bounds];</div><div class=\"line\">        _mirrorImageView.contentMode = UIViewContentModeScaleToFill;</div><div class=\"line\">        _mirrorImageView.userInteractionEnabled = NO;</div><div class=\"line\">        [self addSubview:_mirrorImageView];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _mirrorImageView;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为本身只作为一个容器存在，不需要对外界留一些接口，所以总共才200行代码，不过实现的效果还是可以的。</p>\n<hr>\n<p>今天的内容告一段落了=。=老司机更的速度呢的确是有点慢，忙是一方面，<code>懒</code>是另一方面。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-eb4d9e47069d8be1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"懒\"></p>\n<p>不过老司机会把剩下的几个类在下一期说完的=。=</p>\n<p>demo老司机放在了网盘里，你可以来<a href=\"https://pan.baidu.com/s/1mi9COfm\" target=\"_blank\" rel=\"external\">这里</a>找。</p>\n<p>至于镜像控件，老司机封装好了单独放在了一个仓库，你可以来<a href=\"https://github.com/CodeWicky/Components.git\" target=\"_blank\" rel=\"external\">这里</a>找。</p>\n<p>最后，如果你喜欢老司机的文章，点个关注点个喜欢吧~</p>"},{"title":"老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制","layout":"post","date":"2017-02-11T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://upload-images.jianshu.io/upload_images/1835430-be47acb97de6b6b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n呐，今天给大家打来的将是老司机带你走进CoreAnimation系列的最后一篇了，补充一些其他的特殊的layer。\n\n为什么他们放到最后讲呢，因为他们的`使用率不高`，至少在app方面上。所以呢老司机也没怎么用过，`我也是学完又转述给你们`，仅当做`自己学习的笔记了`，所以如果部分内容与您了解的`有偏差`，请`给我留言`，我一定会`与你探讨`，争取`将最正确的博客留给大家`。当然，老司机写这篇博客之前也是自己查阅了很多资料的，你大可以`不用担心我瞎逼逼`╮(╯_╰)╭\n\n![一脸懵逼](http://upload-images.jianshu.io/upload_images/1835430-43e781a3c34ea941.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n在今天的博客里，你可以看到以下内容：\n\n- CAEmitterLayer\n- CATiledLayer\n- 异步绘制\n\n<!-- more -->\n\n- - -\n\n### CAEmitterLayer\n\nCAEmitter的解决粒子发射而存在的类，你问什么是粒子发射，look。\n\n![粒子](http://upload-images.jianshu.io/upload_images/1835430-dec94675e2aca20c.gif?imageMogr2/auto-orient/strip)\n\n\n你所看到的这一大坨就是粒子系统了。这种效果我们平常app用的还算少点，不过在游戏、直播里面倒是有这不错的应用，所以作为去年两大火热方向之一的直播，你了解一下粒子系统也行。\n\n要想实现这种粒子效果，光有`CAEimmter`还是不够的，他需要`配合着CAEmitterCell进行使用`。要说他们两个的联系呢，就是Layer其实是一个`容器`，而粒子呢就是所谓的`cell`。你可以指定一种粒子样式，也就是一种cell，放在容器layer里面，让容器去控制粒子的发射，就是这样。\n\n东西简单的很，我直接放一下代码，你们看一下就可以懂。\n\n\tCAEmitterLayer *emitter = [CAEmitterLayer layer];\n    emitter.frame = self.bgView.bounds;\n    self.bgView.backgroundColor = [UIColor blackColor];\n    [self.bgView.layer addSublayer:emitter];\n    ///粒子的产生速率，即每秒产生的个数\n    emitter.birthRate = 150;\n    ///每个粒子可以停留，也就是显示的时间\n    emitter.lifetime = 5;\n    ///每个粒子的初速度\n    emitter.velocity = 50;\n    ///每个粒子的缩放比例\n    emitter.scale = 0.5;\n    ///每个粒子的旋转角度\n    emitter.spin = M_PI;\n    ///渲染模式\n    emitter.renderMode = kCAEmitterLayerBackToFront;\n    ///粒子发生器的位置\n    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);\n    ///粒子发生器的大小\n    emitter.emitterSize = CGSizeMake(50, 50);\n    ///粒子发生器的形状\n    emitter.emitterShape = kCAEmitterLayerLine;\n    ///粒子发射的模式\n    emitter.emitterMode = kCAEmitterLayerOutline;\n    self.layer = emitter;\n    \n    //create a particle template\n    CAEmitterCell *cell = [[CAEmitterCell alloc] init];\n    ///粒子内容，也就是你要展示的粒子元素\n    cell.contents = (__bridge id)[UIImage imageNamed:@\"爱心\"].CGImage;\n    ///粒子的初始颜色\n    cell.color = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1].CGColor;\n    \n    ///同emitterLayer提供的属性具有相同含义，不同的是emitterLayer中的属性更像是乘法器中的一个比例系数，也就是说layer中的对应属性与cell中的属性相乘才是这个属性最终的值。因为layer可以盛放多种类型cell，所以layer中的数值会作用于所有cell，而cell中的数值仅影响自身实例。\n    cell.lifetime = 1;\n    cell.birthRate = 1;\n    cell.velocity = 1;\n    cell.scale = 1;\n    cell.spin = 1;\n    \n    ///一些属性的改变速率，设置了对应值后，粒子的属性会按照改变速率进行改变\n    cell.alphaSpeed = -0.1;\n    cell.redSpeed = 0.1;\n    cell.blueSpeed = 0.1;\n    cell.greenSpeed = 0.1;\n    \n    ///一些属性的扰动范围，所谓扰动范围就是在你设置的固定值两端+-扰动值形成一个范围，那所有粒子的对应属性都在扰动这个范围之内随机产生，这样可以方便产生不同的粒子，而不是千篇一律相同的粒子\n    cell.alphaRange = 0.8;\n    cell.scaleRange = 1;\n    cell.emissionRange = M_PI_4;\n    cell.redRange = 1;\n    cell.greenRange = 1;\n    cell.blueRange = 1;\n    \n    ///粒子发射倾斜的角度\n    cell.emissionLongitude = M_PI_4;\n    \n    ///粒子y轴运动方向的加速度，相似的还有xAcceleration，通常用来模拟重力加速度，产生粒子坠落的效果\n    cell.yAcceleration = 100;\n    self.cell = cell;\n    \n    ///初始化cell后将其放在容器内，容器即可自动产生粒子并进行发射。\n    //此处注意是一个数组，也就是说你可以把多个粒子实例传入其中。\n    emitter.emitterCells = @[cell];\n    \n所以说用法还是很简单的，所有属性不同的组合能有一些不错的效果，老司机也就不一一展示了，我的demo里面会抽出几个属性让你能很方便的更改以更快的熟悉CAEmitterLayer。\n\n恩，这里我对发射模式的四个模式讲一下，因为冷不丁一看看不出来头绪\n\n- kCAEmitterLayerPoints \t以端点发射\n- kCAEmitterLayerOutline\t以发射器边界发射\n- kCAEmitterLayerSurface\t以发射器内部区域发射\n- kCAEmitterLayerVolume\t\t不知道╮(╯_╰)╭\n\n恩，这个就结束了，真不是我敷衍。。就这些东西。。\n\n你可以去[这篇博客](http://www.cnblogs.com/densefog/p/5424155.html)看看每种属性调出来的效果，他都做了动图。\n\n\n- - - \n\n### CATiledLayer\n\n这个layer其实你一定见过，至少下面这个效果你一定见过\n\n![Tiled](http://upload-images.jianshu.io/upload_images/1835430-37da6cb408c5a08d.gif?imageMogr2/auto-orient/strip)\n\n\n这个效果相信用过导航的你就一定见到过吧，如果不用让你自己去实现我相信还会费很大的功夫，不过有了CATiledLayer以后你就不用自己考虑了。\n\n他为什么而存在的呢，就是上面演示那种状况，当你要绘制一幅很大的图片的时候，这将十分耗费性能，因为对于图片的处理我们知道CoreAnimation是强制使用CPU的。所以才有了CATiledLayer。\n他将需要绘制的内容`分割成许多小块`，然后再许多线程里`按需异步`绘制相应的小块，这样，就`不会阻塞线程`了。\n\n下面给出部分代码：\n\n```\n+(Class)layerClass\n{\n    return [CATiledLayer class];\n}\n\n-(instancetype)initWithFrame:(CGRect)frame path:(NSString *)path completion:(void (^)(CGSize))completion\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        NSURL *docURL = [NSURL fileURLWithPath:path];\n        CGPDFDocumentRef pdf = CGPDFDocumentCreateWithURL((CFURLRef)docURL);\n        CGPDFPageRef page = CGPDFDocumentGetPage(pdf, 1);\n        self.page = page;\n        CGRect pageRect = CGPDFPageGetBoxRect(page, kCGPDFCropBox);\n        CATiledLayer * layer = (CATiledLayer *)self.layer;\n        layer.levelsOfDetailBias = 5;\n        \n        layer.bounds = pageRect;\n        int w = pageRect.size.width;\n        int h = pageRect.size.height;\n        \n        int levels = 1;\n        while (w > 1 && h > 1) {\n            levels++;\n            w = w >> 1;\n            h = h >> 1;\n        }\n        layer.levelsOfDetail = levels;\n        [self setFrame:pageRect];\n        if (completion) {\n            completion(pageRect.size);\n        }\n    }\n    return self;\n}\n\n-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx\n{\n    CGContextDrawPDFPage(ctx, self.page);\n}\n```\n\n这个就是上面demo中我重写的view类。\n\n有两个属性说一下：\n\n- levelsOfDetail：layer维护的细节层次的个数，就是说你对图像进行2倍缩放而不失真的层次的个数。\n\n- levelsOfDetailBias：layer维护的细节层次放大倍数。\n\n这两个地方很抽象，老司机也用的比较少，老司机一知半解的也不好误导你，所以你可以看看这几个博客，都有介绍这个属性：\n\n- [\nSwift语言iOS开发：CALayer十则示例](http://mobile.51cto.com/iphone-469498.htm)\n\n- [CATiledLayer (Part 2)](http://www.mlsite.net/blog/?p=1884)\n\n- [研究了一下CATiledLayer的levelsOfDetail和levelsOfDetailBias的含义](http://www.cocoachina.com/bbs/read.php?tid-31201-page-1.html)\n\n- - -\n### 异步绘制\n\n下面我会着重讲一下异步绘制。（毕竟这才是最近用到的深入了解过的东西）。\n\n最初这个想法是从`ASDK`来的。\n总的来说`ASDK`是FaceBook`为了解决iOS中由于计算量过多而导致屏幕卡顿`的一个开源库。\n\n我们平时感受到的卡顿，其实专业点叫掉帧（玩游戏的你一定知道）。造成掉帧是因为有垂直同步，当计算量过大导致要刷新帧的时候没有计算结束，就会放弃本帧，造成了所谓了卡顿。（更多关于成像原理的内容去[这里](http://draveness.me/asdk-rendering/)看）。\n\n所以知道了卡顿的原因，我们就要想办法解决这当中的冲突，所以我们应该了解CoreAnimation的`绘制流程`。\n\n我们知道实际上CALayer和UIView都`不是线程安全`的，所以UI操作我们一定要写在主线程（虽然后来苹果也修改了一部分属性使其成为线程安全的，但是苹果仍不建议在子线程中操作UI，因为你无法预知会发生什么。。）\n\n说一下你对UI的改变系统是怎么处理的。\n我们知道，OS及iOS系统中，`负责渲染的类均为CALayer类`，也就是说，你操作的所有UI，layer层也好UI控件也罢，`最后都会映射到CALayer`的改变上。\n\n但是Layer捕捉到需要做的改变后`并不会立即去刷新`，而是`寻找一个合适的实际去进行刷新`。\n\n事实上CoreAnimation在Runloop中注册了一个`观察者`，当runLoop即将进入`休眠或者退出`的时候会回调，这时候CALayer捕捉的到所有变化会开始计算，并刷新UI。\n\n前文说过，早成屏幕卡顿的原因是因为`计算量大`，没算完，掉帧了。那我们为什么不在他接收到需要变化的时候`尽可能的将可以在子线程中做的计算开启一个子线程异步去计算`，其他的回到中线程中计算，这样`减少计算压力`就可以提高性能。\n\n上面说了一下原理以及由原理衍生出来的解决方案，下面就具体放一下代码。这里需要说的是由于ASDK太过庞大，我要讲的是`YYKit`中对于异步绘制这部分的代码，恩，他是参考的ASDK，所以原理一样。以下代码是我参照`YYTextAsyncLayer`改的代码，因为YY大神代码的完备性，所以我也没有什么改善的余地，只是将个人认为不需要的冗余去除，进行了微乎其微的改动，所以这里申明代码`不是我个人代码`啊。。。\n\n```\nstatic dispatch_queue_t DWCoreTextLabelLayerGetDisplayQueue() {\n#define MAX_QUEUE_COUNT 16\n    static int queueCount;\n    static dispatch_queue_t queues[MAX_QUEUE_COUNT];\n    static dispatch_once_t onceToken;\n    static int32_t counter = 0;\n    dispatch_once(&onceToken, ^{\n        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;\n        queueCount = queueCount < 1 ? 1 : queueCount > MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;\n        if ([UIDevice currentDevice].systemVersion.floatValue >= 8.0) {\n            for (NSUInteger i = 0; i < queueCount; i++) {\n                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);\n                queues[i] = dispatch_queue_create(\"com.codeWicky.DWCoreTextLabel.render\", attr);\n            }\n        } else {\n            for (NSUInteger i = 0; i < queueCount; i++) {\n                queues[i] = dispatch_queue_create(\"com.codeWicky.DWCoreTextLabel.render\", DISPATCH_QUEUE_SERIAL);\n                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));\n            }\n        }\n    });\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n    uint32_t cur = (uint32_t)OSAtomicIncrement32(&counter);\n#pragma clang diagnostic pop\n    return queues[(cur) % queueCount];\n#undef MAX_QUEUE_COUNT\n}\n\nstatic dispatch_queue_t DWCoreTextLabelLayerGetReleaseQueue() {\n    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);\n}\n\n@interface DWAsyncLayer ()\n\n@property (atomic, readonly) int32_t signal;\n\n@end\n\n@implementation DWAsyncLayer\n\n-(instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _signal = 0;\n        _displaysAsynchronously = YES;\n    }\n    return self;\n}\n\n-(void)signalIncrease\n{\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n    OSAtomicIncrement32(&_signal);\n#pragma clang diagnostic pop\n}\n\n-(void)setNeedsDisplay\n{\n    [self cancelPreviousDisplayCalculate];\n    [super setNeedsDisplay];\n}\n\n-(void)cancelPreviousDisplayCalculate\n{\n    [self signalIncrease];\n}\n\n-(void)dealloc\n{\n    [self cancelPreviousDisplayCalculate];\n}\n\n-(void)display\n{\n    super.contents = super.contents;\n    [self displayAsync:self.displaysAsynchronously];\n}\n\n-(void)displayAsync:(BOOL)async\n{\n    if (!self.displayBlock) {\n        self.contents = nil;\n        return;\n    }\n    if (async) {\n        int32_t signal = self.signal;\n        BOOL (^isCancelled)() = ^BOOL() {\n            return signal != self.signal;\n        };\n        CGSize size = self.bounds.size;\n        BOOL opaque = self.opaque;\n        CGFloat scale = self.contentsScale;\n        CGColorRef backgroundColor = (opaque && self.backgroundColor) ? CGColorRetain(self.backgroundColor) : NULL;\n        if (size.width < 1 || size.height < 1) {\n            CGImageRef image = (__bridge_retained CGImageRef)(self.contents);\n            self.contents = nil;\n            if (image) {\n                dispatch_async(DWCoreTextLabelLayerGetReleaseQueue(), ^{\n                    CFRelease(image);\n                });\n            }\n            CGColorRelease(backgroundColor);\n            return;\n        }\n        \n        dispatch_async(DWCoreTextLabelLayerGetDisplayQueue(), ^{\n            if (isCancelled()) {\n                CGColorRelease(backgroundColor);\n                return;\n            }\n            UIGraphicsBeginImageContextWithOptions(size, opaque, scale);\n            CGContextRef context = UIGraphicsGetCurrentContext();\n            if (opaque) {\n                fillContextWithColor(context, backgroundColor, size);\n                CGColorRelease(backgroundColor);\n            }\n            self.displayBlock(context,isCancelled);\n            if (isCancelled()) {\n                UIGraphicsEndImageContext();\n                return;\n            }\n            UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n            UIGraphicsEndImageContext();\n            if (isCancelled()) {\n                return;\n            }\n            dispatch_async(dispatch_get_main_queue(), ^{\n                if (!isCancelled()) {\n                    self.contents = (__bridge id)(image.CGImage);\n                }\n            });\n        });\n    } else {\n        [self signalIncrease];\n        UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale);\n        CGContextRef context = UIGraphicsGetCurrentContext();\n        if (self.opaque) {\n            CGSize size = self.bounds.size;\n            size.width *= self.contentsScale;\n            size.height *= self.contentsScale;\n            fillContextWithColor(context, self.backgroundColor,size);\n        }\n        self.displayBlock(context,^{return NO;});\n        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n        UIGraphicsEndImageContext();\n        self.contents = (__bridge id)(image.CGImage);\n    }\n}\n\nstatic inline void fillContextWithColor(CGContextRef context,CGColorRef color,CGSize size){\n    CGContextSaveGState(context); {\n        if (!color || CGColorGetAlpha(color) < 1) {\n            CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor);\n            CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height));\n            CGContextFillPath(context);\n        }\n        if (color) {\n            CGContextSetFillColorWithColor(context, color);\n            CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height));\n            CGContextFillPath(context);\n        }\n    } CGContextRestoreGState(context);\n};\n\n@end\n```\n\n总共不到200行代码，因为我减少了YY里面的将要绘制和完成绘制的回调，仅保留绘制的回调。\n\n大致说一下他的思路：\n\n当一次绘制请求正在进行的时候，如果下一次绘制请求已经开始，那么显然本次请求是无效的，应当放弃，所以这里`一次绘制应该尽可能的及早被取消`。而后就是`将无关的计算移到子线程`中计算`并在context中绘制`，最后从`context中取到绘制的图片`，将其设置为`layer的Contents进而展示画面`。\n\n所以思路在这，实现方式就出来了：\n\n- 1.截获绘制请求，进行自定制实现\n\n- 2.实现过程中，可以取消绘制请求\n\n- 3.将绘制任务在子线程中回调给出去进行绘制，再取context中Image在主线程中设置给contents。\n\n恩，第一条不用说了，绘制任务会调用layer的`display`方法，`重写`就好了。\n\n第二条分两点，`发现`取消请求和`取消任务`。取消任务比较简单，在将要执行的代码前`return`就会导致后面的代码不被执行进而取消。\n\n巧妙地是发现取消请求这里。我们知道`block引入变量的时候会将外界变量copy于栈`中，这样即使外界变量发生改变，block中的变量也不会发生改变。（当然只有基本类型数据传入的是值的，对象都是传指针的。这部分的理解你要参照`传值与传止的区别，以及形参与实参`，真不懂的童靴回头复习一下C吧）。应用这一特性，设置Layer持有一个`基本数据类型的计数量`，`用一个临时变量存储及数量后`，block中比较临时变量与layer持有的计数量的值，因为临时变量是被copy走的，不会随外界改变，所以当外界改变时，`两个值不相等我们就能拿到这个状态了`。\n\n然后就是当我们要`取消任务的时候更改layer持有的计数量`，从而取消任务。\n\n第三条，就是在具体需要绘制的地方，（一般来说为了`降低耦合性都是扔给View去做`，这样所有的View的layer都使用这个layer，而不同的绘制任务交给View中layer的回调即可解耦）把绘制任务都绘制在context，绘制完成后在将context的image在主线程中赋给contents即可。（说到这看不懂的建议看一下这系列的第一篇，一些预备知识都在里面）。\n\n到这里，异步绘制这块也算是结束了。\n- - -\n\n此外，单独说一句，老司机之前借鉴这个思路后想着一些其他实现方式拿到context也可以做这些是，不过都以失败告终，为什么呢，因为`除了drawRect中，UIView里面是拿不到context`的，这是因为drawRect方法是在drawLayer:inContext中进行调用，并且调用之前会执行UIGraphicsPushContext(context)，将当前context压入栈顶，这时你在drawRect中才能通过UIGraphicsGetCurrentContext取到。并且drawRect执行完成后，context紧接着呗pop掉了，所以你只能在drawRect中获取到当前context。\n\n- - -\n本期的demo[在这里](https://pan.baidu.com/s/1hrW8hQs)。\n- - - \n\n恩，到这里终于能结束这个系列了。随着越来越多的人看我的博客，老司机也开始觉得话不能乱说，字不能乱码。所以老司机也正在努力不断的提升自己博客中的内容质量，争取对得起美味粉丝~😯，不，是每位粉丝，毕竟老司机不C粉。\n\n![你猜我笑啥](http://upload-images.jianshu.io/upload_images/1835430-1a72586af69776ec.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- - -\n参考资料\n\n- [iOS粒子系统CAEmitterLayer](http://www.cnblogs.com/densefog/p/5424155.html)\n- [研究了一下CATiledLayer的levelsOfDetail和levelsOfDetailBias的含义](http://www.cocoachina.com/bbs/read.php?tid-31201-page-1.html)\n- [使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能](http://draveness.me/asdk-rendering/)\n- [iOS 保持界面流畅的技巧](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n- [关于drawRect](http://www.jianshu.com/p/c49833c04362)\n\n- - -\n\n\n最后的最后，一般都是软广环节：\n\nDWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。\n\n>version 1.1.0\n>全面支持自动链接支持、定制检测规则、图文混排、响应事件\n>优化大部分算法，提高响应效率及绘制效率\n \n>version 1.1.1\n>高亮取消逻辑优化\n>自动检测逻辑优化\n>部分常用方法改为内联函数，提高运行效率\n \n>version 1.1.2\n>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）\n \n>version 1.1.3\n>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中\n \n>version 1.1.4\n>事务管理类去除，异步绘制文件抽出\n \n>version 1.1.5\n>添加网络图片异步加载库，支持绘制网络图片\n>\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n\n\n![爱你哟](http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/老司机带你走进Core-Animation-之粒子发射、TileLayer与异步绘制.md","raw":"---\n\ntitle: 老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制\nlayout: post\ndate: 2017-02-12 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- CAAnimation \n- 核心动画\n- 粒子效果\n- 大图绘制\n- 异步绘制\ncategories: 核心动画\n\n---\n\n![老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://upload-images.jianshu.io/upload_images/1835430-be47acb97de6b6b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n系列文章：\n\n- [老司机带你走进Core Animation 之CAAnimation](http://www.jianshu.com/p/92a0661a21c6)\n- [老司机带你走进Core Animation 之CADisplayLink](http://www.jianshu.com/p/434ec6911148)\n- [老司机带你走进Core Animation 之几种动画的简单应用](http://www.jianshu.com/p/8e14616679ea)\n- [老司机带你走进Core Animation 之CAShapeLayer和CATextLayer](http://www.jianshu.com/p/3115050b7298)\n- [老司机带你走进Core Animation 之图层的透视、渐变及复制](http://www.jianshu.com/p/dedc44fe8e35)\n- [老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制](http://www.jianshu.com/p/29cbc1744153)\n- - -\n呐，今天给大家打来的将是老司机带你走进CoreAnimation系列的最后一篇了，补充一些其他的特殊的layer。\n\n为什么他们放到最后讲呢，因为他们的`使用率不高`，至少在app方面上。所以呢老司机也没怎么用过，`我也是学完又转述给你们`，仅当做`自己学习的笔记了`，所以如果部分内容与您了解的`有偏差`，请`给我留言`，我一定会`与你探讨`，争取`将最正确的博客留给大家`。当然，老司机写这篇博客之前也是自己查阅了很多资料的，你大可以`不用担心我瞎逼逼`╮(╯_╰)╭\n\n![一脸懵逼](http://upload-images.jianshu.io/upload_images/1835430-43e781a3c34ea941.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n在今天的博客里，你可以看到以下内容：\n\n- CAEmitterLayer\n- CATiledLayer\n- 异步绘制\n\n<!-- more -->\n\n- - -\n\n### CAEmitterLayer\n\nCAEmitter的解决粒子发射而存在的类，你问什么是粒子发射，look。\n\n![粒子](http://upload-images.jianshu.io/upload_images/1835430-dec94675e2aca20c.gif?imageMogr2/auto-orient/strip)\n\n\n你所看到的这一大坨就是粒子系统了。这种效果我们平常app用的还算少点，不过在游戏、直播里面倒是有这不错的应用，所以作为去年两大火热方向之一的直播，你了解一下粒子系统也行。\n\n要想实现这种粒子效果，光有`CAEimmter`还是不够的，他需要`配合着CAEmitterCell进行使用`。要说他们两个的联系呢，就是Layer其实是一个`容器`，而粒子呢就是所谓的`cell`。你可以指定一种粒子样式，也就是一种cell，放在容器layer里面，让容器去控制粒子的发射，就是这样。\n\n东西简单的很，我直接放一下代码，你们看一下就可以懂。\n\n\tCAEmitterLayer *emitter = [CAEmitterLayer layer];\n    emitter.frame = self.bgView.bounds;\n    self.bgView.backgroundColor = [UIColor blackColor];\n    [self.bgView.layer addSublayer:emitter];\n    ///粒子的产生速率，即每秒产生的个数\n    emitter.birthRate = 150;\n    ///每个粒子可以停留，也就是显示的时间\n    emitter.lifetime = 5;\n    ///每个粒子的初速度\n    emitter.velocity = 50;\n    ///每个粒子的缩放比例\n    emitter.scale = 0.5;\n    ///每个粒子的旋转角度\n    emitter.spin = M_PI;\n    ///渲染模式\n    emitter.renderMode = kCAEmitterLayerBackToFront;\n    ///粒子发生器的位置\n    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);\n    ///粒子发生器的大小\n    emitter.emitterSize = CGSizeMake(50, 50);\n    ///粒子发生器的形状\n    emitter.emitterShape = kCAEmitterLayerLine;\n    ///粒子发射的模式\n    emitter.emitterMode = kCAEmitterLayerOutline;\n    self.layer = emitter;\n    \n    //create a particle template\n    CAEmitterCell *cell = [[CAEmitterCell alloc] init];\n    ///粒子内容，也就是你要展示的粒子元素\n    cell.contents = (__bridge id)[UIImage imageNamed:@\"爱心\"].CGImage;\n    ///粒子的初始颜色\n    cell.color = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1].CGColor;\n    \n    ///同emitterLayer提供的属性具有相同含义，不同的是emitterLayer中的属性更像是乘法器中的一个比例系数，也就是说layer中的对应属性与cell中的属性相乘才是这个属性最终的值。因为layer可以盛放多种类型cell，所以layer中的数值会作用于所有cell，而cell中的数值仅影响自身实例。\n    cell.lifetime = 1;\n    cell.birthRate = 1;\n    cell.velocity = 1;\n    cell.scale = 1;\n    cell.spin = 1;\n    \n    ///一些属性的改变速率，设置了对应值后，粒子的属性会按照改变速率进行改变\n    cell.alphaSpeed = -0.1;\n    cell.redSpeed = 0.1;\n    cell.blueSpeed = 0.1;\n    cell.greenSpeed = 0.1;\n    \n    ///一些属性的扰动范围，所谓扰动范围就是在你设置的固定值两端+-扰动值形成一个范围，那所有粒子的对应属性都在扰动这个范围之内随机产生，这样可以方便产生不同的粒子，而不是千篇一律相同的粒子\n    cell.alphaRange = 0.8;\n    cell.scaleRange = 1;\n    cell.emissionRange = M_PI_4;\n    cell.redRange = 1;\n    cell.greenRange = 1;\n    cell.blueRange = 1;\n    \n    ///粒子发射倾斜的角度\n    cell.emissionLongitude = M_PI_4;\n    \n    ///粒子y轴运动方向的加速度，相似的还有xAcceleration，通常用来模拟重力加速度，产生粒子坠落的效果\n    cell.yAcceleration = 100;\n    self.cell = cell;\n    \n    ///初始化cell后将其放在容器内，容器即可自动产生粒子并进行发射。\n    //此处注意是一个数组，也就是说你可以把多个粒子实例传入其中。\n    emitter.emitterCells = @[cell];\n    \n所以说用法还是很简单的，所有属性不同的组合能有一些不错的效果，老司机也就不一一展示了，我的demo里面会抽出几个属性让你能很方便的更改以更快的熟悉CAEmitterLayer。\n\n恩，这里我对发射模式的四个模式讲一下，因为冷不丁一看看不出来头绪\n\n- kCAEmitterLayerPoints \t以端点发射\n- kCAEmitterLayerOutline\t以发射器边界发射\n- kCAEmitterLayerSurface\t以发射器内部区域发射\n- kCAEmitterLayerVolume\t\t不知道╮(╯_╰)╭\n\n恩，这个就结束了，真不是我敷衍。。就这些东西。。\n\n你可以去[这篇博客](http://www.cnblogs.com/densefog/p/5424155.html)看看每种属性调出来的效果，他都做了动图。\n\n\n- - - \n\n### CATiledLayer\n\n这个layer其实你一定见过，至少下面这个效果你一定见过\n\n![Tiled](http://upload-images.jianshu.io/upload_images/1835430-37da6cb408c5a08d.gif?imageMogr2/auto-orient/strip)\n\n\n这个效果相信用过导航的你就一定见到过吧，如果不用让你自己去实现我相信还会费很大的功夫，不过有了CATiledLayer以后你就不用自己考虑了。\n\n他为什么而存在的呢，就是上面演示那种状况，当你要绘制一幅很大的图片的时候，这将十分耗费性能，因为对于图片的处理我们知道CoreAnimation是强制使用CPU的。所以才有了CATiledLayer。\n他将需要绘制的内容`分割成许多小块`，然后再许多线程里`按需异步`绘制相应的小块，这样，就`不会阻塞线程`了。\n\n下面给出部分代码：\n\n```\n+(Class)layerClass\n{\n    return [CATiledLayer class];\n}\n\n-(instancetype)initWithFrame:(CGRect)frame path:(NSString *)path completion:(void (^)(CGSize))completion\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        NSURL *docURL = [NSURL fileURLWithPath:path];\n        CGPDFDocumentRef pdf = CGPDFDocumentCreateWithURL((CFURLRef)docURL);\n        CGPDFPageRef page = CGPDFDocumentGetPage(pdf, 1);\n        self.page = page;\n        CGRect pageRect = CGPDFPageGetBoxRect(page, kCGPDFCropBox);\n        CATiledLayer * layer = (CATiledLayer *)self.layer;\n        layer.levelsOfDetailBias = 5;\n        \n        layer.bounds = pageRect;\n        int w = pageRect.size.width;\n        int h = pageRect.size.height;\n        \n        int levels = 1;\n        while (w > 1 && h > 1) {\n            levels++;\n            w = w >> 1;\n            h = h >> 1;\n        }\n        layer.levelsOfDetail = levels;\n        [self setFrame:pageRect];\n        if (completion) {\n            completion(pageRect.size);\n        }\n    }\n    return self;\n}\n\n-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx\n{\n    CGContextDrawPDFPage(ctx, self.page);\n}\n```\n\n这个就是上面demo中我重写的view类。\n\n有两个属性说一下：\n\n- levelsOfDetail：layer维护的细节层次的个数，就是说你对图像进行2倍缩放而不失真的层次的个数。\n\n- levelsOfDetailBias：layer维护的细节层次放大倍数。\n\n这两个地方很抽象，老司机也用的比较少，老司机一知半解的也不好误导你，所以你可以看看这几个博客，都有介绍这个属性：\n\n- [\nSwift语言iOS开发：CALayer十则示例](http://mobile.51cto.com/iphone-469498.htm)\n\n- [CATiledLayer (Part 2)](http://www.mlsite.net/blog/?p=1884)\n\n- [研究了一下CATiledLayer的levelsOfDetail和levelsOfDetailBias的含义](http://www.cocoachina.com/bbs/read.php?tid-31201-page-1.html)\n\n- - -\n### 异步绘制\n\n下面我会着重讲一下异步绘制。（毕竟这才是最近用到的深入了解过的东西）。\n\n最初这个想法是从`ASDK`来的。\n总的来说`ASDK`是FaceBook`为了解决iOS中由于计算量过多而导致屏幕卡顿`的一个开源库。\n\n我们平时感受到的卡顿，其实专业点叫掉帧（玩游戏的你一定知道）。造成掉帧是因为有垂直同步，当计算量过大导致要刷新帧的时候没有计算结束，就会放弃本帧，造成了所谓了卡顿。（更多关于成像原理的内容去[这里](http://draveness.me/asdk-rendering/)看）。\n\n所以知道了卡顿的原因，我们就要想办法解决这当中的冲突，所以我们应该了解CoreAnimation的`绘制流程`。\n\n我们知道实际上CALayer和UIView都`不是线程安全`的，所以UI操作我们一定要写在主线程（虽然后来苹果也修改了一部分属性使其成为线程安全的，但是苹果仍不建议在子线程中操作UI，因为你无法预知会发生什么。。）\n\n说一下你对UI的改变系统是怎么处理的。\n我们知道，OS及iOS系统中，`负责渲染的类均为CALayer类`，也就是说，你操作的所有UI，layer层也好UI控件也罢，`最后都会映射到CALayer`的改变上。\n\n但是Layer捕捉到需要做的改变后`并不会立即去刷新`，而是`寻找一个合适的实际去进行刷新`。\n\n事实上CoreAnimation在Runloop中注册了一个`观察者`，当runLoop即将进入`休眠或者退出`的时候会回调，这时候CALayer捕捉的到所有变化会开始计算，并刷新UI。\n\n前文说过，早成屏幕卡顿的原因是因为`计算量大`，没算完，掉帧了。那我们为什么不在他接收到需要变化的时候`尽可能的将可以在子线程中做的计算开启一个子线程异步去计算`，其他的回到中线程中计算，这样`减少计算压力`就可以提高性能。\n\n上面说了一下原理以及由原理衍生出来的解决方案，下面就具体放一下代码。这里需要说的是由于ASDK太过庞大，我要讲的是`YYKit`中对于异步绘制这部分的代码，恩，他是参考的ASDK，所以原理一样。以下代码是我参照`YYTextAsyncLayer`改的代码，因为YY大神代码的完备性，所以我也没有什么改善的余地，只是将个人认为不需要的冗余去除，进行了微乎其微的改动，所以这里申明代码`不是我个人代码`啊。。。\n\n```\nstatic dispatch_queue_t DWCoreTextLabelLayerGetDisplayQueue() {\n#define MAX_QUEUE_COUNT 16\n    static int queueCount;\n    static dispatch_queue_t queues[MAX_QUEUE_COUNT];\n    static dispatch_once_t onceToken;\n    static int32_t counter = 0;\n    dispatch_once(&onceToken, ^{\n        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;\n        queueCount = queueCount < 1 ? 1 : queueCount > MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;\n        if ([UIDevice currentDevice].systemVersion.floatValue >= 8.0) {\n            for (NSUInteger i = 0; i < queueCount; i++) {\n                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);\n                queues[i] = dispatch_queue_create(\"com.codeWicky.DWCoreTextLabel.render\", attr);\n            }\n        } else {\n            for (NSUInteger i = 0; i < queueCount; i++) {\n                queues[i] = dispatch_queue_create(\"com.codeWicky.DWCoreTextLabel.render\", DISPATCH_QUEUE_SERIAL);\n                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));\n            }\n        }\n    });\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n    uint32_t cur = (uint32_t)OSAtomicIncrement32(&counter);\n#pragma clang diagnostic pop\n    return queues[(cur) % queueCount];\n#undef MAX_QUEUE_COUNT\n}\n\nstatic dispatch_queue_t DWCoreTextLabelLayerGetReleaseQueue() {\n    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);\n}\n\n@interface DWAsyncLayer ()\n\n@property (atomic, readonly) int32_t signal;\n\n@end\n\n@implementation DWAsyncLayer\n\n-(instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _signal = 0;\n        _displaysAsynchronously = YES;\n    }\n    return self;\n}\n\n-(void)signalIncrease\n{\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n    OSAtomicIncrement32(&_signal);\n#pragma clang diagnostic pop\n}\n\n-(void)setNeedsDisplay\n{\n    [self cancelPreviousDisplayCalculate];\n    [super setNeedsDisplay];\n}\n\n-(void)cancelPreviousDisplayCalculate\n{\n    [self signalIncrease];\n}\n\n-(void)dealloc\n{\n    [self cancelPreviousDisplayCalculate];\n}\n\n-(void)display\n{\n    super.contents = super.contents;\n    [self displayAsync:self.displaysAsynchronously];\n}\n\n-(void)displayAsync:(BOOL)async\n{\n    if (!self.displayBlock) {\n        self.contents = nil;\n        return;\n    }\n    if (async) {\n        int32_t signal = self.signal;\n        BOOL (^isCancelled)() = ^BOOL() {\n            return signal != self.signal;\n        };\n        CGSize size = self.bounds.size;\n        BOOL opaque = self.opaque;\n        CGFloat scale = self.contentsScale;\n        CGColorRef backgroundColor = (opaque && self.backgroundColor) ? CGColorRetain(self.backgroundColor) : NULL;\n        if (size.width < 1 || size.height < 1) {\n            CGImageRef image = (__bridge_retained CGImageRef)(self.contents);\n            self.contents = nil;\n            if (image) {\n                dispatch_async(DWCoreTextLabelLayerGetReleaseQueue(), ^{\n                    CFRelease(image);\n                });\n            }\n            CGColorRelease(backgroundColor);\n            return;\n        }\n        \n        dispatch_async(DWCoreTextLabelLayerGetDisplayQueue(), ^{\n            if (isCancelled()) {\n                CGColorRelease(backgroundColor);\n                return;\n            }\n            UIGraphicsBeginImageContextWithOptions(size, opaque, scale);\n            CGContextRef context = UIGraphicsGetCurrentContext();\n            if (opaque) {\n                fillContextWithColor(context, backgroundColor, size);\n                CGColorRelease(backgroundColor);\n            }\n            self.displayBlock(context,isCancelled);\n            if (isCancelled()) {\n                UIGraphicsEndImageContext();\n                return;\n            }\n            UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n            UIGraphicsEndImageContext();\n            if (isCancelled()) {\n                return;\n            }\n            dispatch_async(dispatch_get_main_queue(), ^{\n                if (!isCancelled()) {\n                    self.contents = (__bridge id)(image.CGImage);\n                }\n            });\n        });\n    } else {\n        [self signalIncrease];\n        UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale);\n        CGContextRef context = UIGraphicsGetCurrentContext();\n        if (self.opaque) {\n            CGSize size = self.bounds.size;\n            size.width *= self.contentsScale;\n            size.height *= self.contentsScale;\n            fillContextWithColor(context, self.backgroundColor,size);\n        }\n        self.displayBlock(context,^{return NO;});\n        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n        UIGraphicsEndImageContext();\n        self.contents = (__bridge id)(image.CGImage);\n    }\n}\n\nstatic inline void fillContextWithColor(CGContextRef context,CGColorRef color,CGSize size){\n    CGContextSaveGState(context); {\n        if (!color || CGColorGetAlpha(color) < 1) {\n            CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor);\n            CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height));\n            CGContextFillPath(context);\n        }\n        if (color) {\n            CGContextSetFillColorWithColor(context, color);\n            CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height));\n            CGContextFillPath(context);\n        }\n    } CGContextRestoreGState(context);\n};\n\n@end\n```\n\n总共不到200行代码，因为我减少了YY里面的将要绘制和完成绘制的回调，仅保留绘制的回调。\n\n大致说一下他的思路：\n\n当一次绘制请求正在进行的时候，如果下一次绘制请求已经开始，那么显然本次请求是无效的，应当放弃，所以这里`一次绘制应该尽可能的及早被取消`。而后就是`将无关的计算移到子线程`中计算`并在context中绘制`，最后从`context中取到绘制的图片`，将其设置为`layer的Contents进而展示画面`。\n\n所以思路在这，实现方式就出来了：\n\n- 1.截获绘制请求，进行自定制实现\n\n- 2.实现过程中，可以取消绘制请求\n\n- 3.将绘制任务在子线程中回调给出去进行绘制，再取context中Image在主线程中设置给contents。\n\n恩，第一条不用说了，绘制任务会调用layer的`display`方法，`重写`就好了。\n\n第二条分两点，`发现`取消请求和`取消任务`。取消任务比较简单，在将要执行的代码前`return`就会导致后面的代码不被执行进而取消。\n\n巧妙地是发现取消请求这里。我们知道`block引入变量的时候会将外界变量copy于栈`中，这样即使外界变量发生改变，block中的变量也不会发生改变。（当然只有基本类型数据传入的是值的，对象都是传指针的。这部分的理解你要参照`传值与传止的区别，以及形参与实参`，真不懂的童靴回头复习一下C吧）。应用这一特性，设置Layer持有一个`基本数据类型的计数量`，`用一个临时变量存储及数量后`，block中比较临时变量与layer持有的计数量的值，因为临时变量是被copy走的，不会随外界改变，所以当外界改变时，`两个值不相等我们就能拿到这个状态了`。\n\n然后就是当我们要`取消任务的时候更改layer持有的计数量`，从而取消任务。\n\n第三条，就是在具体需要绘制的地方，（一般来说为了`降低耦合性都是扔给View去做`，这样所有的View的layer都使用这个layer，而不同的绘制任务交给View中layer的回调即可解耦）把绘制任务都绘制在context，绘制完成后在将context的image在主线程中赋给contents即可。（说到这看不懂的建议看一下这系列的第一篇，一些预备知识都在里面）。\n\n到这里，异步绘制这块也算是结束了。\n- - -\n\n此外，单独说一句，老司机之前借鉴这个思路后想着一些其他实现方式拿到context也可以做这些是，不过都以失败告终，为什么呢，因为`除了drawRect中，UIView里面是拿不到context`的，这是因为drawRect方法是在drawLayer:inContext中进行调用，并且调用之前会执行UIGraphicsPushContext(context)，将当前context压入栈顶，这时你在drawRect中才能通过UIGraphicsGetCurrentContext取到。并且drawRect执行完成后，context紧接着呗pop掉了，所以你只能在drawRect中获取到当前context。\n\n- - -\n本期的demo[在这里](https://pan.baidu.com/s/1hrW8hQs)。\n- - - \n\n恩，到这里终于能结束这个系列了。随着越来越多的人看我的博客，老司机也开始觉得话不能乱说，字不能乱码。所以老司机也正在努力不断的提升自己博客中的内容质量，争取对得起美味粉丝~😯，不，是每位粉丝，毕竟老司机不C粉。\n\n![你猜我笑啥](http://upload-images.jianshu.io/upload_images/1835430-1a72586af69776ec.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- - -\n参考资料\n\n- [iOS粒子系统CAEmitterLayer](http://www.cnblogs.com/densefog/p/5424155.html)\n- [研究了一下CATiledLayer的levelsOfDetail和levelsOfDetailBias的含义](http://www.cocoachina.com/bbs/read.php?tid-31201-page-1.html)\n- [使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能](http://draveness.me/asdk-rendering/)\n- [iOS 保持界面流畅的技巧](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n- [关于drawRect](http://www.jianshu.com/p/c49833c04362)\n\n- - -\n\n\n最后的最后，一般都是软广环节：\n\nDWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。\n\n>version 1.1.0\n>全面支持自动链接支持、定制检测规则、图文混排、响应事件\n>优化大部分算法，提高响应效率及绘制效率\n \n>version 1.1.1\n>高亮取消逻辑优化\n>自动检测逻辑优化\n>部分常用方法改为内联函数，提高运行效率\n \n>version 1.1.2\n>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）\n \n>version 1.1.3\n>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中\n \n>version 1.1.4\n>事务管理类去除，异步绘制文件抽出\n \n>version 1.1.5\n>添加网络图片异步加载库，支持绘制网络图片\n>\n\n![DWCoreTextLabel](http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip)\n\n\n插入图片、绘制图片、添加事件统统一句话实现~\n\n\n![一句话实现](http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n尽可能保持系统Label属性让你可以无缝过渡使用~\n\n\n![无缝过渡](http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n恩，说了这么多，老司机放一下地址：[DWCoreTextLabel](https://github.com/CodeWicky/DWCoreTextLabel)，宝宝们给个star吧~爱你哟~\n\n\n![爱你哟](http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"老司机带你走进Core-Animation-之粒子发射、TileLayer与异步绘制","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htq30018jigbh2w7gbk7","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-be47acb97de6b6b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>呐，今天给大家打来的将是老司机带你走进CoreAnimation系列的最后一篇了，补充一些其他的特殊的layer。</p>\n<p>为什么他们放到最后讲呢，因为他们的<code>使用率不高</code>，至少在app方面上。所以呢老司机也没怎么用过，<code>我也是学完又转述给你们</code>，仅当做<code>自己学习的笔记了</code>，所以如果部分内容与您了解的<code>有偏差</code>，请<code>给我留言</code>，我一定会<code>与你探讨</code>，争取<code>将最正确的博客留给大家</code>。当然，老司机写这篇博客之前也是自己查阅了很多资料的，你大可以<code>不用担心我瞎逼逼</code>╮(╯_╰)╭</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-43e781a3c34ea941.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一脸懵逼\"></p>\n<p>在今天的博客里，你可以看到以下内容：</p>\n<ul>\n<li>CAEmitterLayer</li>\n<li>CATiledLayer</li>\n<li>异步绘制</li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"CAEmitterLayer\"><a href=\"#CAEmitterLayer\" class=\"headerlink\" title=\"CAEmitterLayer\"></a>CAEmitterLayer</h3><p>CAEmitter的解决粒子发射而存在的类，你问什么是粒子发射，look。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-dec94675e2aca20c.gif?imageMogr2/auto-orient/strip\" alt=\"粒子\"></p>\n<p>你所看到的这一大坨就是粒子系统了。这种效果我们平常app用的还算少点，不过在游戏、直播里面倒是有这不错的应用，所以作为去年两大火热方向之一的直播，你了解一下粒子系统也行。</p>\n<p>要想实现这种粒子效果，光有<code>CAEimmter</code>还是不够的，他需要<code>配合着CAEmitterCell进行使用</code>。要说他们两个的联系呢，就是Layer其实是一个<code>容器</code>，而粒子呢就是所谓的<code>cell</code>。你可以指定一种粒子样式，也就是一种cell，放在容器layer里面，让容器去控制粒子的发射，就是这样。</p>\n<p>东西简单的很，我直接放一下代码，你们看一下就可以懂。</p>\n<pre><code>CAEmitterLayer *emitter = [CAEmitterLayer layer];\nemitter.frame = self.bgView.bounds;\nself.bgView.backgroundColor = [UIColor blackColor];\n[self.bgView.layer addSublayer:emitter];\n///粒子的产生速率，即每秒产生的个数\nemitter.birthRate = 150;\n///每个粒子可以停留，也就是显示的时间\nemitter.lifetime = 5;\n///每个粒子的初速度\nemitter.velocity = 50;\n///每个粒子的缩放比例\nemitter.scale = 0.5;\n///每个粒子的旋转角度\nemitter.spin = M_PI;\n///渲染模式\nemitter.renderMode = kCAEmitterLayerBackToFront;\n///粒子发生器的位置\nemitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);\n///粒子发生器的大小\nemitter.emitterSize = CGSizeMake(50, 50);\n///粒子发生器的形状\nemitter.emitterShape = kCAEmitterLayerLine;\n///粒子发射的模式\nemitter.emitterMode = kCAEmitterLayerOutline;\nself.layer = emitter;\n\n//create a particle template\nCAEmitterCell *cell = [[CAEmitterCell alloc] init];\n///粒子内容，也就是你要展示的粒子元素\ncell.contents = (__bridge id)[UIImage imageNamed:@&quot;爱心&quot;].CGImage;\n///粒子的初始颜色\ncell.color = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1].CGColor;\n\n///同emitterLayer提供的属性具有相同含义，不同的是emitterLayer中的属性更像是乘法器中的一个比例系数，也就是说layer中的对应属性与cell中的属性相乘才是这个属性最终的值。因为layer可以盛放多种类型cell，所以layer中的数值会作用于所有cell，而cell中的数值仅影响自身实例。\ncell.lifetime = 1;\ncell.birthRate = 1;\ncell.velocity = 1;\ncell.scale = 1;\ncell.spin = 1;\n\n///一些属性的改变速率，设置了对应值后，粒子的属性会按照改变速率进行改变\ncell.alphaSpeed = -0.1;\ncell.redSpeed = 0.1;\ncell.blueSpeed = 0.1;\ncell.greenSpeed = 0.1;\n\n///一些属性的扰动范围，所谓扰动范围就是在你设置的固定值两端+-扰动值形成一个范围，那所有粒子的对应属性都在扰动这个范围之内随机产生，这样可以方便产生不同的粒子，而不是千篇一律相同的粒子\ncell.alphaRange = 0.8;\ncell.scaleRange = 1;\ncell.emissionRange = M_PI_4;\ncell.redRange = 1;\ncell.greenRange = 1;\ncell.blueRange = 1;\n\n///粒子发射倾斜的角度\ncell.emissionLongitude = M_PI_4;\n\n///粒子y轴运动方向的加速度，相似的还有xAcceleration，通常用来模拟重力加速度，产生粒子坠落的效果\ncell.yAcceleration = 100;\nself.cell = cell;\n\n///初始化cell后将其放在容器内，容器即可自动产生粒子并进行发射。\n//此处注意是一个数组，也就是说你可以把多个粒子实例传入其中。\nemitter.emitterCells = @[cell];\n</code></pre><p>所以说用法还是很简单的，所有属性不同的组合能有一些不错的效果，老司机也就不一一展示了，我的demo里面会抽出几个属性让你能很方便的更改以更快的熟悉CAEmitterLayer。</p>\n<p>恩，这里我对发射模式的四个模式讲一下，因为冷不丁一看看不出来头绪</p>\n<ul>\n<li>kCAEmitterLayerPoints     以端点发射</li>\n<li>kCAEmitterLayerOutline    以发射器边界发射</li>\n<li>kCAEmitterLayerSurface    以发射器内部区域发射</li>\n<li>kCAEmitterLayerVolume        不知道╮(╯_╰)╭</li>\n</ul>\n<p>恩，这个就结束了，真不是我敷衍。。就这些东西。。</p>\n<p>你可以去<a href=\"http://www.cnblogs.com/densefog/p/5424155.html\" target=\"_blank\" rel=\"external\">这篇博客</a>看看每种属性调出来的效果，他都做了动图。</p>\n<hr>\n<h3 id=\"CATiledLayer\"><a href=\"#CATiledLayer\" class=\"headerlink\" title=\"CATiledLayer\"></a>CATiledLayer</h3><p>这个layer其实你一定见过，至少下面这个效果你一定见过</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-37da6cb408c5a08d.gif?imageMogr2/auto-orient/strip\" alt=\"Tiled\"></p>\n<p>这个效果相信用过导航的你就一定见到过吧，如果不用让你自己去实现我相信还会费很大的功夫，不过有了CATiledLayer以后你就不用自己考虑了。</p>\n<p>他为什么而存在的呢，就是上面演示那种状况，当你要绘制一幅很大的图片的时候，这将十分耗费性能，因为对于图片的处理我们知道CoreAnimation是强制使用CPU的。所以才有了CATiledLayer。<br>他将需要绘制的内容<code>分割成许多小块</code>，然后再许多线程里<code>按需异步</code>绘制相应的小块，这样，就<code>不会阻塞线程</code>了。</p>\n<p>下面给出部分代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(Class)layerClass</div><div class=\"line\">&#123;</div><div class=\"line\">    return [CATiledLayer class];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame path:(NSString *)path completion:(void (^)(CGSize))completion</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super initWithFrame:frame];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        NSURL *docURL = [NSURL fileURLWithPath:path];</div><div class=\"line\">        CGPDFDocumentRef pdf = CGPDFDocumentCreateWithURL((CFURLRef)docURL);</div><div class=\"line\">        CGPDFPageRef page = CGPDFDocumentGetPage(pdf, 1);</div><div class=\"line\">        self.page = page;</div><div class=\"line\">        CGRect pageRect = CGPDFPageGetBoxRect(page, kCGPDFCropBox);</div><div class=\"line\">        CATiledLayer * layer = (CATiledLayer *)self.layer;</div><div class=\"line\">        layer.levelsOfDetailBias = 5;</div><div class=\"line\">        </div><div class=\"line\">        layer.bounds = pageRect;</div><div class=\"line\">        int w = pageRect.size.width;</div><div class=\"line\">        int h = pageRect.size.height;</div><div class=\"line\">        </div><div class=\"line\">        int levels = 1;</div><div class=\"line\">        while (w &gt; 1 &amp;&amp; h &gt; 1) &#123;</div><div class=\"line\">            levels++;</div><div class=\"line\">            w = w &gt;&gt; 1;</div><div class=\"line\">            h = h &gt;&gt; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        layer.levelsOfDetail = levels;</div><div class=\"line\">        [self setFrame:pageRect];</div><div class=\"line\">        if (completion) &#123;</div><div class=\"line\">            completion(pageRect.size);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</div><div class=\"line\">&#123;</div><div class=\"line\">    CGContextDrawPDFPage(ctx, self.page);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个就是上面demo中我重写的view类。</p>\n<p>有两个属性说一下：</p>\n<ul>\n<li><p>levelsOfDetail：layer维护的细节层次的个数，就是说你对图像进行2倍缩放而不失真的层次的个数。</p>\n</li>\n<li><p>levelsOfDetailBias：layer维护的细节层次放大倍数。</p>\n</li>\n</ul>\n<p>这两个地方很抽象，老司机也用的比较少，老司机一知半解的也不好误导你，所以你可以看看这几个博客，都有介绍这个属性：</p>\n<ul>\n<li><p><a href=\"http://mobile.51cto.com/iphone-469498.htm\" target=\"_blank\" rel=\"external\"><br>Swift语言iOS开发：CALayer十则示例</a></p>\n</li>\n<li><p><a href=\"http://www.mlsite.net/blog/?p=1884\" target=\"_blank\" rel=\"external\">CATiledLayer (Part 2)</a></p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/bbs/read.php?tid-31201-page-1.html\" target=\"_blank\" rel=\"external\">研究了一下CATiledLayer的levelsOfDetail和levelsOfDetailBias的含义</a></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"异步绘制\"><a href=\"#异步绘制\" class=\"headerlink\" title=\"异步绘制\"></a>异步绘制</h3><p>下面我会着重讲一下异步绘制。（毕竟这才是最近用到的深入了解过的东西）。</p>\n<p>最初这个想法是从<code>ASDK</code>来的。<br>总的来说<code>ASDK</code>是FaceBook<code>为了解决iOS中由于计算量过多而导致屏幕卡顿</code>的一个开源库。</p>\n<p>我们平时感受到的卡顿，其实专业点叫掉帧（玩游戏的你一定知道）。造成掉帧是因为有垂直同步，当计算量过大导致要刷新帧的时候没有计算结束，就会放弃本帧，造成了所谓了卡顿。（更多关于成像原理的内容去<a href=\"http://draveness.me/asdk-rendering/\" target=\"_blank\" rel=\"external\">这里</a>看）。</p>\n<p>所以知道了卡顿的原因，我们就要想办法解决这当中的冲突，所以我们应该了解CoreAnimation的<code>绘制流程</code>。</p>\n<p>我们知道实际上CALayer和UIView都<code>不是线程安全</code>的，所以UI操作我们一定要写在主线程（虽然后来苹果也修改了一部分属性使其成为线程安全的，但是苹果仍不建议在子线程中操作UI，因为你无法预知会发生什么。。）</p>\n<p>说一下你对UI的改变系统是怎么处理的。<br>我们知道，OS及iOS系统中，<code>负责渲染的类均为CALayer类</code>，也就是说，你操作的所有UI，layer层也好UI控件也罢，<code>最后都会映射到CALayer</code>的改变上。</p>\n<p>但是Layer捕捉到需要做的改变后<code>并不会立即去刷新</code>，而是<code>寻找一个合适的实际去进行刷新</code>。</p>\n<p>事实上CoreAnimation在Runloop中注册了一个<code>观察者</code>，当runLoop即将进入<code>休眠或者退出</code>的时候会回调，这时候CALayer捕捉的到所有变化会开始计算，并刷新UI。</p>\n<p>前文说过，早成屏幕卡顿的原因是因为<code>计算量大</code>，没算完，掉帧了。那我们为什么不在他接收到需要变化的时候<code>尽可能的将可以在子线程中做的计算开启一个子线程异步去计算</code>，其他的回到中线程中计算，这样<code>减少计算压力</code>就可以提高性能。</p>\n<p>上面说了一下原理以及由原理衍生出来的解决方案，下面就具体放一下代码。这里需要说的是由于ASDK太过庞大，我要讲的是<code>YYKit</code>中对于异步绘制这部分的代码，恩，他是参考的ASDK，所以原理一样。以下代码是我参照<code>YYTextAsyncLayer</code>改的代码，因为YY大神代码的完备性，所以我也没有什么改善的余地，只是将个人认为不需要的冗余去除，进行了微乎其微的改动，所以这里申明代码<code>不是我个人代码</code>啊。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div></pre></td><td class=\"code\"><pre><div class=\"line\">static dispatch_queue_t DWCoreTextLabelLayerGetDisplayQueue() &#123;</div><div class=\"line\">#define MAX_QUEUE_COUNT 16</div><div class=\"line\">    static int queueCount;</div><div class=\"line\">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    static int32_t counter = 0;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</div><div class=\"line\">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</div><div class=\"line\">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</div><div class=\"line\">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</div><div class=\"line\">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</div><div class=\"line\">                queues[i] = dispatch_queue_create(&quot;com.codeWicky.DWCoreTextLabel.render&quot;, attr);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</div><div class=\"line\">                queues[i] = dispatch_queue_create(&quot;com.codeWicky.DWCoreTextLabel.render&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class=\"line\">    uint32_t cur = (uint32_t)OSAtomicIncrement32(&amp;counter);</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">    return queues[(cur) % queueCount];</div><div class=\"line\">#undef MAX_QUEUE_COUNT</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static dispatch_queue_t DWCoreTextLabelLayerGetReleaseQueue() &#123;</div><div class=\"line\">    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@interface DWAsyncLayer ()</div><div class=\"line\"></div><div class=\"line\">@property (atomic, readonly) int32_t signal;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation DWAsyncLayer</div><div class=\"line\"></div><div class=\"line\">-(instancetype)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        _signal = 0;</div><div class=\"line\">        _displaysAsynchronously = YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)signalIncrease</div><div class=\"line\">&#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class=\"line\">    OSAtomicIncrement32(&amp;_signal);</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setNeedsDisplay</div><div class=\"line\">&#123;</div><div class=\"line\">    [self cancelPreviousDisplayCalculate];</div><div class=\"line\">    [super setNeedsDisplay];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancelPreviousDisplayCalculate</div><div class=\"line\">&#123;</div><div class=\"line\">    [self signalIncrease];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)dealloc</div><div class=\"line\">&#123;</div><div class=\"line\">    [self cancelPreviousDisplayCalculate];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)display</div><div class=\"line\">&#123;</div><div class=\"line\">    super.contents = super.contents;</div><div class=\"line\">    [self displayAsync:self.displaysAsynchronously];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)displayAsync:(BOOL)async</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!self.displayBlock) &#123;</div><div class=\"line\">        self.contents = nil;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (async) &#123;</div><div class=\"line\">        int32_t signal = self.signal;</div><div class=\"line\">        BOOL (^isCancelled)() = ^BOOL() &#123;</div><div class=\"line\">            return signal != self.signal;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        CGSize size = self.bounds.size;</div><div class=\"line\">        BOOL opaque = self.opaque;</div><div class=\"line\">        CGFloat scale = self.contentsScale;</div><div class=\"line\">        CGColorRef backgroundColor = (opaque &amp;&amp; self.backgroundColor) ? CGColorRetain(self.backgroundColor) : NULL;</div><div class=\"line\">        if (size.width &lt; 1 || size.height &lt; 1) &#123;</div><div class=\"line\">            CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</div><div class=\"line\">            self.contents = nil;</div><div class=\"line\">            if (image) &#123;</div><div class=\"line\">                dispatch_async(DWCoreTextLabelLayerGetReleaseQueue(), ^&#123;</div><div class=\"line\">                    CFRelease(image);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            CGColorRelease(backgroundColor);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        dispatch_async(DWCoreTextLabelLayerGetDisplayQueue(), ^&#123;</div><div class=\"line\">            if (isCancelled()) &#123;</div><div class=\"line\">                CGColorRelease(backgroundColor);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            UIGraphicsBeginImageContextWithOptions(size, opaque, scale);</div><div class=\"line\">            CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">            if (opaque) &#123;</div><div class=\"line\">                fillContextWithColor(context, backgroundColor, size);</div><div class=\"line\">                CGColorRelease(backgroundColor);</div><div class=\"line\">            &#125;</div><div class=\"line\">            self.displayBlock(context,isCancelled);</div><div class=\"line\">            if (isCancelled()) &#123;</div><div class=\"line\">                UIGraphicsEndImageContext();</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">            UIGraphicsEndImageContext();</div><div class=\"line\">            if (isCancelled()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">                if (!isCancelled()) &#123;</div><div class=\"line\">                    self.contents = (__bridge id)(image.CGImage);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [self signalIncrease];</div><div class=\"line\">        UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale);</div><div class=\"line\">        CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">        if (self.opaque) &#123;</div><div class=\"line\">            CGSize size = self.bounds.size;</div><div class=\"line\">            size.width *= self.contentsScale;</div><div class=\"line\">            size.height *= self.contentsScale;</div><div class=\"line\">            fillContextWithColor(context, self.backgroundColor,size);</div><div class=\"line\">        &#125;</div><div class=\"line\">        self.displayBlock(context,^&#123;return NO;&#125;);</div><div class=\"line\">        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">        UIGraphicsEndImageContext();</div><div class=\"line\">        self.contents = (__bridge id)(image.CGImage);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static inline void fillContextWithColor(CGContextRef context,CGColorRef color,CGSize size)&#123;</div><div class=\"line\">    CGContextSaveGState(context); &#123;</div><div class=\"line\">        if (!color || CGColorGetAlpha(color) &lt; 1) &#123;</div><div class=\"line\">            CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor);</div><div class=\"line\">            CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height));</div><div class=\"line\">            CGContextFillPath(context);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (color) &#123;</div><div class=\"line\">            CGContextSetFillColorWithColor(context, color);</div><div class=\"line\">            CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height));</div><div class=\"line\">            CGContextFillPath(context);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; CGContextRestoreGState(context);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>总共不到200行代码，因为我减少了YY里面的将要绘制和完成绘制的回调，仅保留绘制的回调。</p>\n<p>大致说一下他的思路：</p>\n<p>当一次绘制请求正在进行的时候，如果下一次绘制请求已经开始，那么显然本次请求是无效的，应当放弃，所以这里<code>一次绘制应该尽可能的及早被取消</code>。而后就是<code>将无关的计算移到子线程</code>中计算<code>并在context中绘制</code>，最后从<code>context中取到绘制的图片</code>，将其设置为<code>layer的Contents进而展示画面</code>。</p>\n<p>所以思路在这，实现方式就出来了：</p>\n<ul>\n<li><p>1.截获绘制请求，进行自定制实现</p>\n</li>\n<li><p>2.实现过程中，可以取消绘制请求</p>\n</li>\n<li><p>3.将绘制任务在子线程中回调给出去进行绘制，再取context中Image在主线程中设置给contents。</p>\n</li>\n</ul>\n<p>恩，第一条不用说了，绘制任务会调用layer的<code>display</code>方法，<code>重写</code>就好了。</p>\n<p>第二条分两点，<code>发现</code>取消请求和<code>取消任务</code>。取消任务比较简单，在将要执行的代码前<code>return</code>就会导致后面的代码不被执行进而取消。</p>\n<p>巧妙地是发现取消请求这里。我们知道<code>block引入变量的时候会将外界变量copy于栈</code>中，这样即使外界变量发生改变，block中的变量也不会发生改变。（当然只有基本类型数据传入的是值的，对象都是传指针的。这部分的理解你要参照<code>传值与传止的区别，以及形参与实参</code>，真不懂的童靴回头复习一下C吧）。应用这一特性，设置Layer持有一个<code>基本数据类型的计数量</code>，<code>用一个临时变量存储及数量后</code>，block中比较临时变量与layer持有的计数量的值，因为临时变量是被copy走的，不会随外界改变，所以当外界改变时，<code>两个值不相等我们就能拿到这个状态了</code>。</p>\n<p>然后就是当我们要<code>取消任务的时候更改layer持有的计数量</code>，从而取消任务。</p>\n<p>第三条，就是在具体需要绘制的地方，（一般来说为了<code>降低耦合性都是扔给View去做</code>，这样所有的View的layer都使用这个layer，而不同的绘制任务交给View中layer的回调即可解耦）把绘制任务都绘制在context，绘制完成后在将context的image在主线程中赋给contents即可。（说到这看不懂的建议看一下这系列的第一篇，一些预备知识都在里面）。</p>\n<p>到这里，异步绘制这块也算是结束了。</p>\n<hr>\n<p>此外，单独说一句，老司机之前借鉴这个思路后想着一些其他实现方式拿到context也可以做这些是，不过都以失败告终，为什么呢，因为<code>除了drawRect中，UIView里面是拿不到context</code>的，这是因为drawRect方法是在drawLayer:inContext中进行调用，并且调用之前会执行UIGraphicsPushContext(context)，将当前context压入栈顶，这时你在drawRect中才能通过UIGraphicsGetCurrentContext取到。并且drawRect执行完成后，context紧接着呗pop掉了，所以你只能在drawRect中获取到当前context。</p>\n<hr>\n<p>本期的demo<a href=\"https://pan.baidu.com/s/1hrW8hQs\" target=\"_blank\" rel=\"external\">在这里</a>。</p>\n<hr>\n<p>恩，到这里终于能结束这个系列了。随着越来越多的人看我的博客，老司机也开始觉得话不能乱说，字不能乱码。所以老司机也正在努力不断的提升自己博客中的内容质量，争取对得起美味粉丝~😯，不，是每位粉丝，毕竟老司机不C粉。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a72586af69776ec.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"你猜我笑啥\"></p>\n<hr>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/densefog/p/5424155.html\" target=\"_blank\" rel=\"external\">iOS粒子系统CAEmitterLayer</a></li>\n<li><a href=\"http://www.cocoachina.com/bbs/read.php?tid-31201-page-1.html\" target=\"_blank\" rel=\"external\">研究了一下CATiledLayer的levelsOfDetail和levelsOfDetailBias的含义</a></li>\n<li><a href=\"http://draveness.me/asdk-rendering/\" target=\"_blank\" rel=\"external\">使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</a></li>\n<li><a href=\"http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"external\">iOS 保持界面流畅的技巧</a></li>\n<li><a href=\"http://www.jianshu.com/p/c49833c04362\" target=\"_blank\" rel=\"external\">关于drawRect</a></li>\n</ul>\n<hr>\n<p>最后的最后，一般都是软广环节：</p>\n<p>DWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。</p>\n<blockquote>\n<p>version 1.1.0<br>全面支持自动链接支持、定制检测规则、图文混排、响应事件<br>优化大部分算法，提高响应效率及绘制效率</p>\n<p>version 1.1.1<br>高亮取消逻辑优化<br>自动检测逻辑优化<br>部分常用方法改为内联函数，提高运行效率</p>\n<p>version 1.1.2<br>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）</p>\n<p>version 1.1.3<br>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中</p>\n<p>version 1.1.4<br>事务管理类去除，异步绘制文件抽出</p>\n<p>version 1.1.5<br>添加网络图片异步加载库，支持绘制网络图片</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你哟\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-be47acb97de6b6b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制\"></p>\n<p>系列文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/92a0661a21c6\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAAnimation</a></li>\n<li><a href=\"http://www.jianshu.com/p/434ec6911148\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CADisplayLink</a></li>\n<li><a href=\"http://www.jianshu.com/p/8e14616679ea\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之几种动画的简单应用</a></li>\n<li><a href=\"http://www.jianshu.com/p/3115050b7298\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之CAShapeLayer和CATextLayer</a></li>\n<li><a href=\"http://www.jianshu.com/p/dedc44fe8e35\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之图层的透视、渐变及复制</a></li>\n<li><a href=\"http://www.jianshu.com/p/29cbc1744153\" target=\"_blank\" rel=\"external\">老司机带你走进Core Animation 之粒子发射、TileLayer与异步绘制</a></li>\n</ul>\n<hr>\n<p>呐，今天给大家打来的将是老司机带你走进CoreAnimation系列的最后一篇了，补充一些其他的特殊的layer。</p>\n<p>为什么他们放到最后讲呢，因为他们的<code>使用率不高</code>，至少在app方面上。所以呢老司机也没怎么用过，<code>我也是学完又转述给你们</code>，仅当做<code>自己学习的笔记了</code>，所以如果部分内容与您了解的<code>有偏差</code>，请<code>给我留言</code>，我一定会<code>与你探讨</code>，争取<code>将最正确的博客留给大家</code>。当然，老司机写这篇博客之前也是自己查阅了很多资料的，你大可以<code>不用担心我瞎逼逼</code>╮(╯_╰)╭</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-43e781a3c34ea941.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一脸懵逼\"></p>\n<p>在今天的博客里，你可以看到以下内容：</p>\n<ul>\n<li>CAEmitterLayer</li>\n<li>CATiledLayer</li>\n<li>异步绘制</li>\n</ul>","more":"<hr>\n<h3 id=\"CAEmitterLayer\"><a href=\"#CAEmitterLayer\" class=\"headerlink\" title=\"CAEmitterLayer\"></a>CAEmitterLayer</h3><p>CAEmitter的解决粒子发射而存在的类，你问什么是粒子发射，look。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-dec94675e2aca20c.gif?imageMogr2/auto-orient/strip\" alt=\"粒子\"></p>\n<p>你所看到的这一大坨就是粒子系统了。这种效果我们平常app用的还算少点，不过在游戏、直播里面倒是有这不错的应用，所以作为去年两大火热方向之一的直播，你了解一下粒子系统也行。</p>\n<p>要想实现这种粒子效果，光有<code>CAEimmter</code>还是不够的，他需要<code>配合着CAEmitterCell进行使用</code>。要说他们两个的联系呢，就是Layer其实是一个<code>容器</code>，而粒子呢就是所谓的<code>cell</code>。你可以指定一种粒子样式，也就是一种cell，放在容器layer里面，让容器去控制粒子的发射，就是这样。</p>\n<p>东西简单的很，我直接放一下代码，你们看一下就可以懂。</p>\n<pre><code>CAEmitterLayer *emitter = [CAEmitterLayer layer];\nemitter.frame = self.bgView.bounds;\nself.bgView.backgroundColor = [UIColor blackColor];\n[self.bgView.layer addSublayer:emitter];\n///粒子的产生速率，即每秒产生的个数\nemitter.birthRate = 150;\n///每个粒子可以停留，也就是显示的时间\nemitter.lifetime = 5;\n///每个粒子的初速度\nemitter.velocity = 50;\n///每个粒子的缩放比例\nemitter.scale = 0.5;\n///每个粒子的旋转角度\nemitter.spin = M_PI;\n///渲染模式\nemitter.renderMode = kCAEmitterLayerBackToFront;\n///粒子发生器的位置\nemitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);\n///粒子发生器的大小\nemitter.emitterSize = CGSizeMake(50, 50);\n///粒子发生器的形状\nemitter.emitterShape = kCAEmitterLayerLine;\n///粒子发射的模式\nemitter.emitterMode = kCAEmitterLayerOutline;\nself.layer = emitter;\n\n//create a particle template\nCAEmitterCell *cell = [[CAEmitterCell alloc] init];\n///粒子内容，也就是你要展示的粒子元素\ncell.contents = (__bridge id)[UIImage imageNamed:@&quot;爱心&quot;].CGImage;\n///粒子的初始颜色\ncell.color = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1].CGColor;\n\n///同emitterLayer提供的属性具有相同含义，不同的是emitterLayer中的属性更像是乘法器中的一个比例系数，也就是说layer中的对应属性与cell中的属性相乘才是这个属性最终的值。因为layer可以盛放多种类型cell，所以layer中的数值会作用于所有cell，而cell中的数值仅影响自身实例。\ncell.lifetime = 1;\ncell.birthRate = 1;\ncell.velocity = 1;\ncell.scale = 1;\ncell.spin = 1;\n\n///一些属性的改变速率，设置了对应值后，粒子的属性会按照改变速率进行改变\ncell.alphaSpeed = -0.1;\ncell.redSpeed = 0.1;\ncell.blueSpeed = 0.1;\ncell.greenSpeed = 0.1;\n\n///一些属性的扰动范围，所谓扰动范围就是在你设置的固定值两端+-扰动值形成一个范围，那所有粒子的对应属性都在扰动这个范围之内随机产生，这样可以方便产生不同的粒子，而不是千篇一律相同的粒子\ncell.alphaRange = 0.8;\ncell.scaleRange = 1;\ncell.emissionRange = M_PI_4;\ncell.redRange = 1;\ncell.greenRange = 1;\ncell.blueRange = 1;\n\n///粒子发射倾斜的角度\ncell.emissionLongitude = M_PI_4;\n\n///粒子y轴运动方向的加速度，相似的还有xAcceleration，通常用来模拟重力加速度，产生粒子坠落的效果\ncell.yAcceleration = 100;\nself.cell = cell;\n\n///初始化cell后将其放在容器内，容器即可自动产生粒子并进行发射。\n//此处注意是一个数组，也就是说你可以把多个粒子实例传入其中。\nemitter.emitterCells = @[cell];\n</code></pre><p>所以说用法还是很简单的，所有属性不同的组合能有一些不错的效果，老司机也就不一一展示了，我的demo里面会抽出几个属性让你能很方便的更改以更快的熟悉CAEmitterLayer。</p>\n<p>恩，这里我对发射模式的四个模式讲一下，因为冷不丁一看看不出来头绪</p>\n<ul>\n<li>kCAEmitterLayerPoints     以端点发射</li>\n<li>kCAEmitterLayerOutline    以发射器边界发射</li>\n<li>kCAEmitterLayerSurface    以发射器内部区域发射</li>\n<li>kCAEmitterLayerVolume        不知道╮(╯_╰)╭</li>\n</ul>\n<p>恩，这个就结束了，真不是我敷衍。。就这些东西。。</p>\n<p>你可以去<a href=\"http://www.cnblogs.com/densefog/p/5424155.html\" target=\"_blank\" rel=\"external\">这篇博客</a>看看每种属性调出来的效果，他都做了动图。</p>\n<hr>\n<h3 id=\"CATiledLayer\"><a href=\"#CATiledLayer\" class=\"headerlink\" title=\"CATiledLayer\"></a>CATiledLayer</h3><p>这个layer其实你一定见过，至少下面这个效果你一定见过</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-37da6cb408c5a08d.gif?imageMogr2/auto-orient/strip\" alt=\"Tiled\"></p>\n<p>这个效果相信用过导航的你就一定见到过吧，如果不用让你自己去实现我相信还会费很大的功夫，不过有了CATiledLayer以后你就不用自己考虑了。</p>\n<p>他为什么而存在的呢，就是上面演示那种状况，当你要绘制一幅很大的图片的时候，这将十分耗费性能，因为对于图片的处理我们知道CoreAnimation是强制使用CPU的。所以才有了CATiledLayer。<br>他将需要绘制的内容<code>分割成许多小块</code>，然后再许多线程里<code>按需异步</code>绘制相应的小块，这样，就<code>不会阻塞线程</code>了。</p>\n<p>下面给出部分代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(Class)layerClass</div><div class=\"line\">&#123;</div><div class=\"line\">    return [CATiledLayer class];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame path:(NSString *)path completion:(void (^)(CGSize))completion</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super initWithFrame:frame];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        NSURL *docURL = [NSURL fileURLWithPath:path];</div><div class=\"line\">        CGPDFDocumentRef pdf = CGPDFDocumentCreateWithURL((CFURLRef)docURL);</div><div class=\"line\">        CGPDFPageRef page = CGPDFDocumentGetPage(pdf, 1);</div><div class=\"line\">        self.page = page;</div><div class=\"line\">        CGRect pageRect = CGPDFPageGetBoxRect(page, kCGPDFCropBox);</div><div class=\"line\">        CATiledLayer * layer = (CATiledLayer *)self.layer;</div><div class=\"line\">        layer.levelsOfDetailBias = 5;</div><div class=\"line\">        </div><div class=\"line\">        layer.bounds = pageRect;</div><div class=\"line\">        int w = pageRect.size.width;</div><div class=\"line\">        int h = pageRect.size.height;</div><div class=\"line\">        </div><div class=\"line\">        int levels = 1;</div><div class=\"line\">        while (w &gt; 1 &amp;&amp; h &gt; 1) &#123;</div><div class=\"line\">            levels++;</div><div class=\"line\">            w = w &gt;&gt; 1;</div><div class=\"line\">            h = h &gt;&gt; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        layer.levelsOfDetail = levels;</div><div class=\"line\">        [self setFrame:pageRect];</div><div class=\"line\">        if (completion) &#123;</div><div class=\"line\">            completion(pageRect.size);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</div><div class=\"line\">&#123;</div><div class=\"line\">    CGContextDrawPDFPage(ctx, self.page);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个就是上面demo中我重写的view类。</p>\n<p>有两个属性说一下：</p>\n<ul>\n<li><p>levelsOfDetail：layer维护的细节层次的个数，就是说你对图像进行2倍缩放而不失真的层次的个数。</p>\n</li>\n<li><p>levelsOfDetailBias：layer维护的细节层次放大倍数。</p>\n</li>\n</ul>\n<p>这两个地方很抽象，老司机也用的比较少，老司机一知半解的也不好误导你，所以你可以看看这几个博客，都有介绍这个属性：</p>\n<ul>\n<li><p><a href=\"http://mobile.51cto.com/iphone-469498.htm\" target=\"_blank\" rel=\"external\"><br>Swift语言iOS开发：CALayer十则示例</a></p>\n</li>\n<li><p><a href=\"http://www.mlsite.net/blog/?p=1884\" target=\"_blank\" rel=\"external\">CATiledLayer (Part 2)</a></p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/bbs/read.php?tid-31201-page-1.html\" target=\"_blank\" rel=\"external\">研究了一下CATiledLayer的levelsOfDetail和levelsOfDetailBias的含义</a></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"异步绘制\"><a href=\"#异步绘制\" class=\"headerlink\" title=\"异步绘制\"></a>异步绘制</h3><p>下面我会着重讲一下异步绘制。（毕竟这才是最近用到的深入了解过的东西）。</p>\n<p>最初这个想法是从<code>ASDK</code>来的。<br>总的来说<code>ASDK</code>是FaceBook<code>为了解决iOS中由于计算量过多而导致屏幕卡顿</code>的一个开源库。</p>\n<p>我们平时感受到的卡顿，其实专业点叫掉帧（玩游戏的你一定知道）。造成掉帧是因为有垂直同步，当计算量过大导致要刷新帧的时候没有计算结束，就会放弃本帧，造成了所谓了卡顿。（更多关于成像原理的内容去<a href=\"http://draveness.me/asdk-rendering/\" target=\"_blank\" rel=\"external\">这里</a>看）。</p>\n<p>所以知道了卡顿的原因，我们就要想办法解决这当中的冲突，所以我们应该了解CoreAnimation的<code>绘制流程</code>。</p>\n<p>我们知道实际上CALayer和UIView都<code>不是线程安全</code>的，所以UI操作我们一定要写在主线程（虽然后来苹果也修改了一部分属性使其成为线程安全的，但是苹果仍不建议在子线程中操作UI，因为你无法预知会发生什么。。）</p>\n<p>说一下你对UI的改变系统是怎么处理的。<br>我们知道，OS及iOS系统中，<code>负责渲染的类均为CALayer类</code>，也就是说，你操作的所有UI，layer层也好UI控件也罢，<code>最后都会映射到CALayer</code>的改变上。</p>\n<p>但是Layer捕捉到需要做的改变后<code>并不会立即去刷新</code>，而是<code>寻找一个合适的实际去进行刷新</code>。</p>\n<p>事实上CoreAnimation在Runloop中注册了一个<code>观察者</code>，当runLoop即将进入<code>休眠或者退出</code>的时候会回调，这时候CALayer捕捉的到所有变化会开始计算，并刷新UI。</p>\n<p>前文说过，早成屏幕卡顿的原因是因为<code>计算量大</code>，没算完，掉帧了。那我们为什么不在他接收到需要变化的时候<code>尽可能的将可以在子线程中做的计算开启一个子线程异步去计算</code>，其他的回到中线程中计算，这样<code>减少计算压力</code>就可以提高性能。</p>\n<p>上面说了一下原理以及由原理衍生出来的解决方案，下面就具体放一下代码。这里需要说的是由于ASDK太过庞大，我要讲的是<code>YYKit</code>中对于异步绘制这部分的代码，恩，他是参考的ASDK，所以原理一样。以下代码是我参照<code>YYTextAsyncLayer</code>改的代码，因为YY大神代码的完备性，所以我也没有什么改善的余地，只是将个人认为不需要的冗余去除，进行了微乎其微的改动，所以这里申明代码<code>不是我个人代码</code>啊。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div></pre></td><td class=\"code\"><pre><div class=\"line\">static dispatch_queue_t DWCoreTextLabelLayerGetDisplayQueue() &#123;</div><div class=\"line\">#define MAX_QUEUE_COUNT 16</div><div class=\"line\">    static int queueCount;</div><div class=\"line\">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    static int32_t counter = 0;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</div><div class=\"line\">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</div><div class=\"line\">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</div><div class=\"line\">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</div><div class=\"line\">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</div><div class=\"line\">                queues[i] = dispatch_queue_create(&quot;com.codeWicky.DWCoreTextLabel.render&quot;, attr);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</div><div class=\"line\">                queues[i] = dispatch_queue_create(&quot;com.codeWicky.DWCoreTextLabel.render&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class=\"line\">    uint32_t cur = (uint32_t)OSAtomicIncrement32(&amp;counter);</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">    return queues[(cur) % queueCount];</div><div class=\"line\">#undef MAX_QUEUE_COUNT</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static dispatch_queue_t DWCoreTextLabelLayerGetReleaseQueue() &#123;</div><div class=\"line\">    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@interface DWAsyncLayer ()</div><div class=\"line\"></div><div class=\"line\">@property (atomic, readonly) int32_t signal;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation DWAsyncLayer</div><div class=\"line\"></div><div class=\"line\">-(instancetype)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">        _signal = 0;</div><div class=\"line\">        _displaysAsynchronously = YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)signalIncrease</div><div class=\"line\">&#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class=\"line\">    OSAtomicIncrement32(&amp;_signal);</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setNeedsDisplay</div><div class=\"line\">&#123;</div><div class=\"line\">    [self cancelPreviousDisplayCalculate];</div><div class=\"line\">    [super setNeedsDisplay];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)cancelPreviousDisplayCalculate</div><div class=\"line\">&#123;</div><div class=\"line\">    [self signalIncrease];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)dealloc</div><div class=\"line\">&#123;</div><div class=\"line\">    [self cancelPreviousDisplayCalculate];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)display</div><div class=\"line\">&#123;</div><div class=\"line\">    super.contents = super.contents;</div><div class=\"line\">    [self displayAsync:self.displaysAsynchronously];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)displayAsync:(BOOL)async</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!self.displayBlock) &#123;</div><div class=\"line\">        self.contents = nil;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (async) &#123;</div><div class=\"line\">        int32_t signal = self.signal;</div><div class=\"line\">        BOOL (^isCancelled)() = ^BOOL() &#123;</div><div class=\"line\">            return signal != self.signal;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        CGSize size = self.bounds.size;</div><div class=\"line\">        BOOL opaque = self.opaque;</div><div class=\"line\">        CGFloat scale = self.contentsScale;</div><div class=\"line\">        CGColorRef backgroundColor = (opaque &amp;&amp; self.backgroundColor) ? CGColorRetain(self.backgroundColor) : NULL;</div><div class=\"line\">        if (size.width &lt; 1 || size.height &lt; 1) &#123;</div><div class=\"line\">            CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</div><div class=\"line\">            self.contents = nil;</div><div class=\"line\">            if (image) &#123;</div><div class=\"line\">                dispatch_async(DWCoreTextLabelLayerGetReleaseQueue(), ^&#123;</div><div class=\"line\">                    CFRelease(image);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            CGColorRelease(backgroundColor);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        dispatch_async(DWCoreTextLabelLayerGetDisplayQueue(), ^&#123;</div><div class=\"line\">            if (isCancelled()) &#123;</div><div class=\"line\">                CGColorRelease(backgroundColor);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            UIGraphicsBeginImageContextWithOptions(size, opaque, scale);</div><div class=\"line\">            CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">            if (opaque) &#123;</div><div class=\"line\">                fillContextWithColor(context, backgroundColor, size);</div><div class=\"line\">                CGColorRelease(backgroundColor);</div><div class=\"line\">            &#125;</div><div class=\"line\">            self.displayBlock(context,isCancelled);</div><div class=\"line\">            if (isCancelled()) &#123;</div><div class=\"line\">                UIGraphicsEndImageContext();</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">            UIGraphicsEndImageContext();</div><div class=\"line\">            if (isCancelled()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">                if (!isCancelled()) &#123;</div><div class=\"line\">                    self.contents = (__bridge id)(image.CGImage);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [self signalIncrease];</div><div class=\"line\">        UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale);</div><div class=\"line\">        CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">        if (self.opaque) &#123;</div><div class=\"line\">            CGSize size = self.bounds.size;</div><div class=\"line\">            size.width *= self.contentsScale;</div><div class=\"line\">            size.height *= self.contentsScale;</div><div class=\"line\">            fillContextWithColor(context, self.backgroundColor,size);</div><div class=\"line\">        &#125;</div><div class=\"line\">        self.displayBlock(context,^&#123;return NO;&#125;);</div><div class=\"line\">        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">        UIGraphicsEndImageContext();</div><div class=\"line\">        self.contents = (__bridge id)(image.CGImage);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static inline void fillContextWithColor(CGContextRef context,CGColorRef color,CGSize size)&#123;</div><div class=\"line\">    CGContextSaveGState(context); &#123;</div><div class=\"line\">        if (!color || CGColorGetAlpha(color) &lt; 1) &#123;</div><div class=\"line\">            CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor);</div><div class=\"line\">            CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height));</div><div class=\"line\">            CGContextFillPath(context);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (color) &#123;</div><div class=\"line\">            CGContextSetFillColorWithColor(context, color);</div><div class=\"line\">            CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height));</div><div class=\"line\">            CGContextFillPath(context);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; CGContextRestoreGState(context);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>总共不到200行代码，因为我减少了YY里面的将要绘制和完成绘制的回调，仅保留绘制的回调。</p>\n<p>大致说一下他的思路：</p>\n<p>当一次绘制请求正在进行的时候，如果下一次绘制请求已经开始，那么显然本次请求是无效的，应当放弃，所以这里<code>一次绘制应该尽可能的及早被取消</code>。而后就是<code>将无关的计算移到子线程</code>中计算<code>并在context中绘制</code>，最后从<code>context中取到绘制的图片</code>，将其设置为<code>layer的Contents进而展示画面</code>。</p>\n<p>所以思路在这，实现方式就出来了：</p>\n<ul>\n<li><p>1.截获绘制请求，进行自定制实现</p>\n</li>\n<li><p>2.实现过程中，可以取消绘制请求</p>\n</li>\n<li><p>3.将绘制任务在子线程中回调给出去进行绘制，再取context中Image在主线程中设置给contents。</p>\n</li>\n</ul>\n<p>恩，第一条不用说了，绘制任务会调用layer的<code>display</code>方法，<code>重写</code>就好了。</p>\n<p>第二条分两点，<code>发现</code>取消请求和<code>取消任务</code>。取消任务比较简单，在将要执行的代码前<code>return</code>就会导致后面的代码不被执行进而取消。</p>\n<p>巧妙地是发现取消请求这里。我们知道<code>block引入变量的时候会将外界变量copy于栈</code>中，这样即使外界变量发生改变，block中的变量也不会发生改变。（当然只有基本类型数据传入的是值的，对象都是传指针的。这部分的理解你要参照<code>传值与传止的区别，以及形参与实参</code>，真不懂的童靴回头复习一下C吧）。应用这一特性，设置Layer持有一个<code>基本数据类型的计数量</code>，<code>用一个临时变量存储及数量后</code>，block中比较临时变量与layer持有的计数量的值，因为临时变量是被copy走的，不会随外界改变，所以当外界改变时，<code>两个值不相等我们就能拿到这个状态了</code>。</p>\n<p>然后就是当我们要<code>取消任务的时候更改layer持有的计数量</code>，从而取消任务。</p>\n<p>第三条，就是在具体需要绘制的地方，（一般来说为了<code>降低耦合性都是扔给View去做</code>，这样所有的View的layer都使用这个layer，而不同的绘制任务交给View中layer的回调即可解耦）把绘制任务都绘制在context，绘制完成后在将context的image在主线程中赋给contents即可。（说到这看不懂的建议看一下这系列的第一篇，一些预备知识都在里面）。</p>\n<p>到这里，异步绘制这块也算是结束了。</p>\n<hr>\n<p>此外，单独说一句，老司机之前借鉴这个思路后想着一些其他实现方式拿到context也可以做这些是，不过都以失败告终，为什么呢，因为<code>除了drawRect中，UIView里面是拿不到context</code>的，这是因为drawRect方法是在drawLayer:inContext中进行调用，并且调用之前会执行UIGraphicsPushContext(context)，将当前context压入栈顶，这时你在drawRect中才能通过UIGraphicsGetCurrentContext取到。并且drawRect执行完成后，context紧接着呗pop掉了，所以你只能在drawRect中获取到当前context。</p>\n<hr>\n<p>本期的demo<a href=\"https://pan.baidu.com/s/1hrW8hQs\" target=\"_blank\" rel=\"external\">在这里</a>。</p>\n<hr>\n<p>恩，到这里终于能结束这个系列了。随着越来越多的人看我的博客，老司机也开始觉得话不能乱说，字不能乱码。所以老司机也正在努力不断的提升自己博客中的内容质量，争取对得起美味粉丝~😯，不，是每位粉丝，毕竟老司机不C粉。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a72586af69776ec.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"你猜我笑啥\"></p>\n<hr>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/densefog/p/5424155.html\" target=\"_blank\" rel=\"external\">iOS粒子系统CAEmitterLayer</a></li>\n<li><a href=\"http://www.cocoachina.com/bbs/read.php?tid-31201-page-1.html\" target=\"_blank\" rel=\"external\">研究了一下CATiledLayer的levelsOfDetail和levelsOfDetailBias的含义</a></li>\n<li><a href=\"http://draveness.me/asdk-rendering/\" target=\"_blank\" rel=\"external\">使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</a></li>\n<li><a href=\"http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"external\">iOS 保持界面流畅的技巧</a></li>\n<li><a href=\"http://www.jianshu.com/p/c49833c04362\" target=\"_blank\" rel=\"external\">关于drawRect</a></li>\n</ul>\n<hr>\n<p>最后的最后，一般都是软广环节：</p>\n<p>DWCoreTextLabel更新到现在已经1.1.6版本了，现在除了图文混排功能，还支持文本类型的自动检测，异步绘制减少系统的卡顿，异步加载并缓存图片的功能。</p>\n<blockquote>\n<p>version 1.1.0<br>全面支持自动链接支持、定制检测规则、图文混排、响应事件<br>优化大部分算法，提高响应效率及绘制效率</p>\n<p>version 1.1.1<br>高亮取消逻辑优化<br>自动检测逻辑优化<br>部分常用方法改为内联函数，提高运行效率</p>\n<p>version 1.1.2<br>绘制逻辑优化，改为异步绘制（源码修改自YYTextAsyncLayer）</p>\n<p>version 1.1.3<br>异步绘制改造完成、去除事务管理类，事务管理类仍可改进，进行中</p>\n<p>version 1.1.4<br>事务管理类去除，异步绘制文件抽出</p>\n<p>version 1.1.5<br>添加网络图片异步加载库，支持绘制网络图片</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-bc004dc959f7b675.gif?imageMogr2/auto-orient/strip\" alt=\"DWCoreTextLabel\"></p>\n<p>插入图片、绘制图片、添加事件统统一句话实现~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-456beaed3f710b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一句话实现\"></p>\n<p>尽可能保持系统Label属性让你可以无缝过渡使用~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-e7706ffe827b1ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无缝过渡\"></p>\n<p>恩，说了这么多，老司机放一下地址：<a href=\"https://github.com/CodeWicky/DWCoreTextLabel\" target=\"_blank\" rel=\"external\">DWCoreTextLabel</a>，宝宝们给个star吧~爱你哟~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1a477250d897b4b1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"爱你哟\"></p>"},{"title":"老司机踩坑系列————中文排序","layout":"post","date":"2017-05-20T23:33:44.000Z","updated":"2017-06-04T23:33:44.000Z","_content":"\n![中文排序](http://upload-images.jianshu.io/upload_images/1835430-ab6ed3784c197392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n仅以此文，祭奠线上无限crash的61位用户。\n\n恩，先放重点：\n~~中文字符串比较，请使用`-localizedCompare:`方法。这一个系统方法足矣！~~\n\n> 2017.05.24更新\n-localizedCompare:这个方法能保证排序结果与系统通讯录排序结果相同，基本符合拼音顺序，但偶尔有偏差。\n感谢 @半江瑟瑟 提供的测试数据**立冬、李东、李Dong**\n想做到与系统排序方式保持一致请使用-localizedCompare:方法，想做到完美拼音排序请使用老司机文中提到的逐字比较方式。\n\n\n\n恩，重点说完开始讲故事，这篇文章主要用来总结几种中文字符串比较的方法，以防以后我那次遇到什么特殊的需求。\n\n这个故事中你将会看到：\n- 字符串转拼音\n- -caseInsensitiveCompare:\n- UILocalizedIndexedCollation\n- 逐字比较\n- GB_18030编码\n- -localizedCompare:\n\n然而知识点只有：\n- 字符串转拼音\n- -localizedCompare:\n\n<!-- more -->\n\n- - -\n那个手机浏览的同志注意了，**看到字符串转拼音后就可以打住了**，下面的内容多图杀猫费流量=。=\n\n事情是这样的，需求要求自定义通讯录选择流程，故无法直接调用系统通讯录。老司机自告奋勇的接下了活，毕竟脑袋一想还不难，可老司机低估了中文排序的坑=。=\n\n### 最初的想法\n最开始老司机想，首先所有联系人都会按姓名首字母分组，似乎需要转拼音。有了拼音就可以根据拼音排序，很顺畅的思路。Too young，Too naive。\n\n```\n///汉字转拼音\n-(NSString *)transferChineseToPinYin:(NSString *)string {\n    NSMutableString *mutableString = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);\n    return [mutableString stringByFoldingWithOptions:NSDiacriticInsensitiveSearch locale:[NSLocale currentLocale]];\n}\n```\n转拼音老司机没有引用第三方库，用了三行代码就搞定了。（这样的方式转换出来的拼音是没有音调的，如果想要带着音调，请将**NSDiacriticInsensitiveSearch**替换为**NSCaseInsensitiveSearch**）。\n\n转完拼音后，就可以调用`-caseInsensitiveCompare:`进行比较了，老司机当时真是美滋滋。\n\n与`-caseInsensitiveCompare:`效果相同的还有一个专门为了TableView而存在的排序的类，叫做UILocalizedIndexedCollation。他也可以用来排序，使用起来也挺简单：\n\n```\nNSArray *arr = [self getName];///只是将几个字符串分别包装成对象\nUILocalizedIndexedCollation *localized =  [UILocalizedIndexedCollation currentCollation];\nNSArray *temparr = [localized sortedArrayFromArray:arr collationStringSelector:@selector(fullName)];\n```\n不过他是基于对象的，你要把字符串当做某个对象的属性才能排序。并且它存在下面两个问题中的第一个问题。\n\n不过有两个问题：\n- 同音不同字\n表现是什么呢？比如说三个人，请看图示：\n\n![转拼音后比较拼音](http://upload-images.jianshu.io/upload_images/1835430-a57ab15ed771948a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个结果明显是不我们可以接受的。\n\n\n\n\n恩，上面转拼音的方法会在两个字之间自动加上一个空格。所以老司机发现可以把拼音分开。所以老司机在这里的想法是逐字比较。\n\n\n![逐字比较](http://upload-images.jianshu.io/upload_images/1835430-1520bf1ee5c692a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的话，结果就是理想结果了。不过还有第二个问题。。\n\n- 中英结合的字符串\n中英结合的字符串转换成拼音以后效果跟预想的有一定偏差。什么表现呢？\n\n![中英结合](http://upload-images.jianshu.io/upload_images/1835430-d438d2fbdafe899e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n为什么这样呢？我们看到转拼音的时候中英结合的是没有空格的。\n\n老司机遇到错误平错误，想到因为中英结合有问题，我处理一下字符串把中英文分开不就好了么？\n\n\n![添加空格](http://upload-images.jianshu.io/upload_images/1835430-b6d4e0c918a38bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的话`张Wicky`就变成`张 Wicky`转成拼音就变成`zhang wicky`。排序完成。\n\n然而我的61位用户就是因为我这一时大意而受到了无限crash的折磨。。。\n\n矛盾点在这，比如用户本来存的名字叫做`张 啊`。没错，就是名字里面本身就有一个空格（这61位用户你们为毛要存空格啊。。。其他用户怎么就不存呢。。一定是你不会用），经过上面的添加空格就会变成`张   啊`(名字中间变成了3个空格)。其实到这里还好，最可气的是`-componentsSeparatedByString:`这个方法的行为跟老司机想的不一致啊。（敲黑板，重点了啊）\n\n同学们，`张   啊`这个字符串调用`-componentsSeparatedByString:`这个方法，传参`@\" \"`，你们的理想结果是什么？\n\n![实际结果](http://upload-images.jianshu.io/upload_images/1835430-d0053a677481506c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n是的，比预想的多了两个空字符串。。。问题很严重，原本`张 啊`字符串长度为3，拼音数组元素个数为4。然而后面有调用了`-substringWithRange:`方法。。。是的你没猜错，**越界了**。。。\n\n到这想填坑其实还可以，只要在添加空格以后再检验是否有连续空格，替换成一个空格就好了。。。不过这种打补丁，让代码越来越失去可维护性的做法老司机觉得是个隐患。。。所以老司机不得不想出第二个方法。\n\n### 逐字比较时确保字与拼音一一对应\n最初的想法因为越界出问题，那么我是否让字与拼音一一对应上就好了呢？\n那么首先要把字符串分成一个字一个字的，但是单词还要保证是单词而不是字母。\n\n\n![分字](http://upload-images.jianshu.io/upload_images/1835430-6a8b714d1a68b84a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n事实上老司机到这已经有了些许抗拒，为什么一个字符串排序就这么难。。。\n到了这里思路大概就是这个样子的：\n\n![拆字](http://upload-images.jianshu.io/upload_images/1835430-fe190f43f82589ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到了这里，因为先拆字，所以不需要手动添加空格，也避免了`-substringWithRange:`方法，所以根本就不存在越界了。看起来似乎比最初的想法省了很多事，老司机心里美滋滋。\n\n多说一嘴，`-enumerateSubstringsInRange:`这个方法的行为很诡异，不知道是bug还是什么原理，表现如下：\n\n![奇怪的行为](http://upload-images.jianshu.io/upload_images/1835430-61f70215ce1c04e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n当第一个可见字符为汉字且紧跟着一个单词的时候，这里面的子串都中文和英文是不会分开的，且后面的子串不熟影响。其他情况下都可以正常返回子串。\n\n> 2017.05.25更新\n有同学问具体是怎么实现的？老司机将中文拼音比较写在了字符串的扩展中。以下是.m中相关代码：\n\n```\n#define replaceIfContain(string,target,replacement,tone) \\\ndo {\\\nif ([string containsString:target]) {\\\nstring = [string stringByReplacingOccurrencesOfString:target withString:replacement];\\\nstring = [NSString stringWithFormat:@\"%@%d\",string,tone];\\\n}\\\n} while(0)\n\n@interface NSString ()\n@property (nonatomic ,strong) NSArray * wordArray;\n@property (nonatomic ,copy) NSString * wordPinyinWithTone;\n@property (nonatomic ,copy) NSString * wordPinyinWithoutTone;\n@end\n\n@implementation NSString (DWStringSortUtils)\n-(NSComparisonResult)dw_ComparedInPinyinWithString:(NSString *)string considerTone:(BOOL)tone {\n    if ([self isEqualToString:string]) {\n        return NSOrderedSame;\n    }\n    NSArray <NSString *>* arr1 = self.wordArray;\n    NSArray <NSString *>* arr2 = string.wordArray;\n    NSUInteger minL = MIN(arr1.count, arr2.count);\n    for (int i = 0; i < minL; i ++) {\n        if ([arr1[i] isEqualToString:arr2[i]]) {\n            continue;\n        }\n        NSString * pinyin1 = [arr1[i] transferWordToPinYinWithTone:tone];\n        NSString * pinyin2 = [arr2[i] transferWordToPinYinWithTone:tone];\n        if (tone) {\n            pinyin1 = transformPinyinTone(pinyin1);\n            pinyin2 = transformPinyinTone(pinyin2);\n        }\n        NSComparisonResult result = [pinyin1 caseInsensitiveCompare:pinyin2];\n        if (result != NSOrderedSame) {\n            return result;\n        } else {\n            result = [arr1[i] localizedCompare:arr2[i]];\n            if (result != NSOrderedSame) {\n                return result;\n            }\n        }\n    }\n    if (arr1.count < arr2.count) {\n        return NSOrderedAscending;\n    } else if (arr1.count > arr2.count) {\n        return NSOrderedDescending;\n    } else {\n        return NSOrderedSame;\n    }\n}\n#pragma mark --- tool method ---\n-(NSString *)transferWordToPinYinWithTone:(BOOL)tone {\n    if (tone && self.wordPinyinWithTone) {\n        return self.wordPinyinWithTone;\n    } else if (!tone && self.wordPinyinWithoutTone) {\n        return self.wordPinyinWithoutTone;\n    }\n    NSMutableString * mutableString = [[NSMutableString alloc] initWithString:self];\n    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);\n    NSStringCompareOptions toneOption = tone ?NSCaseInsensitiveSearch:NSDiacriticInsensitiveSearch;\n    NSString * pinyin = [mutableString stringByFoldingWithOptions:toneOption locale:[NSLocale currentLocale]];\n    if (tone) {\n        self.wordPinyinWithTone = pinyin;\n    } else {\n        self.wordPinyinWithoutTone = pinyin;\n    }\n    return pinyin;\n}\n-(BOOL)dw_StringIsChinese {\n    if (self.length == 0) {\n        return NO;\n    }\n    NSPredicate * predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",@\"[\\\\u4E00-\\\\u9FA5]+\"];\n    return [predicate evaluateWithObject:self];\n}\n-(NSArray *)dw_TrimStringToWord {\n    if (self.length) {\n        NSMutableArray * temp = [NSMutableArray array];\n        [self enumerateSubstringsInRange:NSMakeRange(0, self.length) options:NSStringEnumerationByWords usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {\n            if (substring.length > 1 && temp.count == 0 && ![substring dw_StringIsChinese] && [substring dw_SubStringConfirmToPattern:@\"[\\\\u4E00-\\\\u9FA5]+\"].count > 0) {///为防止第一个字与英文连在一起\n                [temp addObject:[substring substringToIndex:1]];\n                [temp addObject:[substring substringFromIndex:1]];\n            } else {\n                if (substring.length > 1 && [substring dw_StringIsChinese]) {\n                    [substring enumerateSubstringsInRange:NSMakeRange(0, substring.length) options:(NSStringEnumerationByComposedCharacterSequences) usingBlock:^(NSString * _Nullable substring2, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {\n                        [temp addObject:substring2];\n                    }];\n                } else {\n                    if (substring.length) {\n                        [temp addObject:substring];\n                    }\n                }\n            }\n        }];\n        return [temp copy];\n    }\n    return nil;\n}\n#pragma mark --- inline method ---\nstatic inline NSString * transformPinyinTone(NSString * pinyin) {\n    replaceIfContain(pinyin, @\"ā\", @\"a\",1);\n    replaceIfContain(pinyin, @\"á\", @\"a\",2);\n    replaceIfContain(pinyin, @\"ǎ\", @\"a\",3);\n    replaceIfContain(pinyin, @\"à\", @\"a\",4);\n    replaceIfContain(pinyin, @\"ō\", @\"o\",1);\n    replaceIfContain(pinyin, @\"ó\", @\"o\",2);\n    replaceIfContain(pinyin, @\"ǒ\", @\"o\",3);\n    replaceIfContain(pinyin, @\"ò\", @\"o\",4);\n    replaceIfContain(pinyin, @\"ē\", @\"e\",1);\n    replaceIfContain(pinyin, @\"é\", @\"e\",2);\n    replaceIfContain(pinyin, @\"ě\", @\"e\",3);\n    replaceIfContain(pinyin, @\"è\", @\"e\",4);\n    replaceIfContain(pinyin, @\"ī\", @\"i\",1);\n    replaceIfContain(pinyin, @\"í\", @\"i\",2);\n    replaceIfContain(pinyin, @\"ǐ\", @\"i\",3);\n    replaceIfContain(pinyin, @\"ì\", @\"i\",4);\n    replaceIfContain(pinyin, @\"ū\", @\"u\",1);\n    replaceIfContain(pinyin, @\"ú\", @\"u\",2);\n    replaceIfContain(pinyin, @\"ǔ\", @\"u\",3);\n    replaceIfContain(pinyin, @\"ù\", @\"u\",4);\n    return pinyin;\n}\n#pragma mark ---setter/getter ---\n-(void)setWordPinyinWithTone:(NSString *)wordPinyinWithTone {\n    objc_setAssociatedObject(self, @selector(wordPinyinWithTone), wordPinyinWithTone, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n-(NSString *)wordPinyinWithTone {\n    return objc_getAssociatedObject(self, _cmd);\n}\n\n-(void)setWordPinyinWithoutTone:(NSString *)wordPinyinWithoutTone {\n    objc_setAssociatedObject(self, @selector(wordPinyinWithoutTone), wordPinyinWithoutTone, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n-(NSString *)wordPinyinWithoutTone {\n    return objc_getAssociatedObject(self, _cmd);\n}\n\n-(void)setWordArray:(NSArray *)wordArray {\n    objc_setAssociatedObject(self, @selector(wordArray), wordArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n-(NSArray *)wordArray {\n    NSArray * array = objc_getAssociatedObject(self, _cmd);\n    if (!array) {\n        array = [self dw_TrimStringToWord];\n        objc_setAssociatedObject(self, @selector(wordArray), array, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    }\n    return array;\n}\n@end\n```\n\n### 带音调的拼音排序\n上面的排序老司机都是在排没有音调的拼音。老司机在上面也有介绍过如果转换带音调的拼音方法，老司机又开始美滋滋的优化自己的代码了。想想不过是转拼音的时候转成带音调的然后源代码比较呗。结果。。。\n\n![什么鬼顺序](http://upload-images.jianshu.io/upload_images/1835430-9e17c5932013e14c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系统这是什么鬼顺序，开始怀疑小学老师教的`āáǎà`是假的了都。。老司机都快疯了，妈妈，不要再让我给字符串排序了。。。\n\n又开始翻阅博客如何排序啊。。。\n\n>之前考虑过这个方法 但问题是不能对首字母之后的拼音排序 而且需要引用额外的文件 比较麻烦。\n\n>后来查到gb编码本来就是用拼音排序的就hack了一下：在stringByAddingPercentEscapesUsingEncoding:后面用16位编码 将中文转为ascii来比较 更简洁。\n\n>引自[按照拼音对数组中的中文字符串排序的算法中Lunar川小槑的回复](http://bbs.9ria.com/thread-230144-1-1.html)\n\n```\n\\#define GB18030_ENCODING CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000)\n \n// 其他代码...\n \nNSComparator comparator = ^(NSString *obj1, NSString *obj2){\n \n        NSString *str1 = [obj1 stringByAddingPercentEscapesUsingEncoding:GB18030_ENCODING];\n        NSString *str2 = [obj2 stringByAddingPercentEscapesUsingEncoding:GB18030_ENCODING];\n \n        return [str1 compare:str2];\n};\n```\n\n试了一下，诶，果然好使！顺序对的！也不用逐字比较了！一级棒！不过老司机真的有做测试的潜质，我也不知道为什么，我就随便改了一下数据，我都不知道怎么想的把往字改成了彺字结果就又错了。。。想想可能GB_18030这个标准也不都是按照拼音排的吧。。。\n\n### -localizedCompare:\n最后的，也是最简单的，系统放在那我就一直没用的。。。\n最后的最后我又找到了这个方法，`-localizedCompare:`。真的是比什么都简单，又比什么都对啊。这个方法没什么bug也没什么风险。。。简单的不要不要的。。。\n\n\n扣个题：\n~~中文字符串比较，请使用`-localizedCompare:`方法。这一个系统方法足矣！~~\n~~中文字符串比较，请使用`-localizedCompare:`方法。这一个系统方法足矣！~~\n~~中文字符串比较，请使用`-localizedCompare:`方法。这一个系统方法足矣！~~\n**扣题改了，看下文章开头的更新**\n想想自己因为要按拼音分组所以转了拼音，之后就一直再以拼音排序，快要被自己蠢哭了。。。\n![蠢哭了](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1495363026&di=1c167ccfccb027ec1e36df10b36e2ccf&src=http://wanzao2.b0.upaiyun.com/system/pictures/33086994/original/1455272971_500x500.png)\n","source":"_posts/老司机踩坑系列————中文排序.md","raw":"---\n\ntitle: 老司机踩坑系列————中文排序\nlayout: post\ndate: 2017-05-21 07:33:44\nupdated: 2017-06-05 07:33:44\ntags: \n- 中文排序 \ncategories: 踩坑系列\n\n---\n\n![中文排序](http://upload-images.jianshu.io/upload_images/1835430-ab6ed3784c197392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n仅以此文，祭奠线上无限crash的61位用户。\n\n恩，先放重点：\n~~中文字符串比较，请使用`-localizedCompare:`方法。这一个系统方法足矣！~~\n\n> 2017.05.24更新\n-localizedCompare:这个方法能保证排序结果与系统通讯录排序结果相同，基本符合拼音顺序，但偶尔有偏差。\n感谢 @半江瑟瑟 提供的测试数据**立冬、李东、李Dong**\n想做到与系统排序方式保持一致请使用-localizedCompare:方法，想做到完美拼音排序请使用老司机文中提到的逐字比较方式。\n\n\n\n恩，重点说完开始讲故事，这篇文章主要用来总结几种中文字符串比较的方法，以防以后我那次遇到什么特殊的需求。\n\n这个故事中你将会看到：\n- 字符串转拼音\n- -caseInsensitiveCompare:\n- UILocalizedIndexedCollation\n- 逐字比较\n- GB_18030编码\n- -localizedCompare:\n\n然而知识点只有：\n- 字符串转拼音\n- -localizedCompare:\n\n<!-- more -->\n\n- - -\n那个手机浏览的同志注意了，**看到字符串转拼音后就可以打住了**，下面的内容多图杀猫费流量=。=\n\n事情是这样的，需求要求自定义通讯录选择流程，故无法直接调用系统通讯录。老司机自告奋勇的接下了活，毕竟脑袋一想还不难，可老司机低估了中文排序的坑=。=\n\n### 最初的想法\n最开始老司机想，首先所有联系人都会按姓名首字母分组，似乎需要转拼音。有了拼音就可以根据拼音排序，很顺畅的思路。Too young，Too naive。\n\n```\n///汉字转拼音\n-(NSString *)transferChineseToPinYin:(NSString *)string {\n    NSMutableString *mutableString = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);\n    return [mutableString stringByFoldingWithOptions:NSDiacriticInsensitiveSearch locale:[NSLocale currentLocale]];\n}\n```\n转拼音老司机没有引用第三方库，用了三行代码就搞定了。（这样的方式转换出来的拼音是没有音调的，如果想要带着音调，请将**NSDiacriticInsensitiveSearch**替换为**NSCaseInsensitiveSearch**）。\n\n转完拼音后，就可以调用`-caseInsensitiveCompare:`进行比较了，老司机当时真是美滋滋。\n\n与`-caseInsensitiveCompare:`效果相同的还有一个专门为了TableView而存在的排序的类，叫做UILocalizedIndexedCollation。他也可以用来排序，使用起来也挺简单：\n\n```\nNSArray *arr = [self getName];///只是将几个字符串分别包装成对象\nUILocalizedIndexedCollation *localized =  [UILocalizedIndexedCollation currentCollation];\nNSArray *temparr = [localized sortedArrayFromArray:arr collationStringSelector:@selector(fullName)];\n```\n不过他是基于对象的，你要把字符串当做某个对象的属性才能排序。并且它存在下面两个问题中的第一个问题。\n\n不过有两个问题：\n- 同音不同字\n表现是什么呢？比如说三个人，请看图示：\n\n![转拼音后比较拼音](http://upload-images.jianshu.io/upload_images/1835430-a57ab15ed771948a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个结果明显是不我们可以接受的。\n\n\n\n\n恩，上面转拼音的方法会在两个字之间自动加上一个空格。所以老司机发现可以把拼音分开。所以老司机在这里的想法是逐字比较。\n\n\n![逐字比较](http://upload-images.jianshu.io/upload_images/1835430-1520bf1ee5c692a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的话，结果就是理想结果了。不过还有第二个问题。。\n\n- 中英结合的字符串\n中英结合的字符串转换成拼音以后效果跟预想的有一定偏差。什么表现呢？\n\n![中英结合](http://upload-images.jianshu.io/upload_images/1835430-d438d2fbdafe899e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n为什么这样呢？我们看到转拼音的时候中英结合的是没有空格的。\n\n老司机遇到错误平错误，想到因为中英结合有问题，我处理一下字符串把中英文分开不就好了么？\n\n\n![添加空格](http://upload-images.jianshu.io/upload_images/1835430-b6d4e0c918a38bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的话`张Wicky`就变成`张 Wicky`转成拼音就变成`zhang wicky`。排序完成。\n\n然而我的61位用户就是因为我这一时大意而受到了无限crash的折磨。。。\n\n矛盾点在这，比如用户本来存的名字叫做`张 啊`。没错，就是名字里面本身就有一个空格（这61位用户你们为毛要存空格啊。。。其他用户怎么就不存呢。。一定是你不会用），经过上面的添加空格就会变成`张   啊`(名字中间变成了3个空格)。其实到这里还好，最可气的是`-componentsSeparatedByString:`这个方法的行为跟老司机想的不一致啊。（敲黑板，重点了啊）\n\n同学们，`张   啊`这个字符串调用`-componentsSeparatedByString:`这个方法，传参`@\" \"`，你们的理想结果是什么？\n\n![实际结果](http://upload-images.jianshu.io/upload_images/1835430-d0053a677481506c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n是的，比预想的多了两个空字符串。。。问题很严重，原本`张 啊`字符串长度为3，拼音数组元素个数为4。然而后面有调用了`-substringWithRange:`方法。。。是的你没猜错，**越界了**。。。\n\n到这想填坑其实还可以，只要在添加空格以后再检验是否有连续空格，替换成一个空格就好了。。。不过这种打补丁，让代码越来越失去可维护性的做法老司机觉得是个隐患。。。所以老司机不得不想出第二个方法。\n\n### 逐字比较时确保字与拼音一一对应\n最初的想法因为越界出问题，那么我是否让字与拼音一一对应上就好了呢？\n那么首先要把字符串分成一个字一个字的，但是单词还要保证是单词而不是字母。\n\n\n![分字](http://upload-images.jianshu.io/upload_images/1835430-6a8b714d1a68b84a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n事实上老司机到这已经有了些许抗拒，为什么一个字符串排序就这么难。。。\n到了这里思路大概就是这个样子的：\n\n![拆字](http://upload-images.jianshu.io/upload_images/1835430-fe190f43f82589ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到了这里，因为先拆字，所以不需要手动添加空格，也避免了`-substringWithRange:`方法，所以根本就不存在越界了。看起来似乎比最初的想法省了很多事，老司机心里美滋滋。\n\n多说一嘴，`-enumerateSubstringsInRange:`这个方法的行为很诡异，不知道是bug还是什么原理，表现如下：\n\n![奇怪的行为](http://upload-images.jianshu.io/upload_images/1835430-61f70215ce1c04e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n当第一个可见字符为汉字且紧跟着一个单词的时候，这里面的子串都中文和英文是不会分开的，且后面的子串不熟影响。其他情况下都可以正常返回子串。\n\n> 2017.05.25更新\n有同学问具体是怎么实现的？老司机将中文拼音比较写在了字符串的扩展中。以下是.m中相关代码：\n\n```\n#define replaceIfContain(string,target,replacement,tone) \\\ndo {\\\nif ([string containsString:target]) {\\\nstring = [string stringByReplacingOccurrencesOfString:target withString:replacement];\\\nstring = [NSString stringWithFormat:@\"%@%d\",string,tone];\\\n}\\\n} while(0)\n\n@interface NSString ()\n@property (nonatomic ,strong) NSArray * wordArray;\n@property (nonatomic ,copy) NSString * wordPinyinWithTone;\n@property (nonatomic ,copy) NSString * wordPinyinWithoutTone;\n@end\n\n@implementation NSString (DWStringSortUtils)\n-(NSComparisonResult)dw_ComparedInPinyinWithString:(NSString *)string considerTone:(BOOL)tone {\n    if ([self isEqualToString:string]) {\n        return NSOrderedSame;\n    }\n    NSArray <NSString *>* arr1 = self.wordArray;\n    NSArray <NSString *>* arr2 = string.wordArray;\n    NSUInteger minL = MIN(arr1.count, arr2.count);\n    for (int i = 0; i < minL; i ++) {\n        if ([arr1[i] isEqualToString:arr2[i]]) {\n            continue;\n        }\n        NSString * pinyin1 = [arr1[i] transferWordToPinYinWithTone:tone];\n        NSString * pinyin2 = [arr2[i] transferWordToPinYinWithTone:tone];\n        if (tone) {\n            pinyin1 = transformPinyinTone(pinyin1);\n            pinyin2 = transformPinyinTone(pinyin2);\n        }\n        NSComparisonResult result = [pinyin1 caseInsensitiveCompare:pinyin2];\n        if (result != NSOrderedSame) {\n            return result;\n        } else {\n            result = [arr1[i] localizedCompare:arr2[i]];\n            if (result != NSOrderedSame) {\n                return result;\n            }\n        }\n    }\n    if (arr1.count < arr2.count) {\n        return NSOrderedAscending;\n    } else if (arr1.count > arr2.count) {\n        return NSOrderedDescending;\n    } else {\n        return NSOrderedSame;\n    }\n}\n#pragma mark --- tool method ---\n-(NSString *)transferWordToPinYinWithTone:(BOOL)tone {\n    if (tone && self.wordPinyinWithTone) {\n        return self.wordPinyinWithTone;\n    } else if (!tone && self.wordPinyinWithoutTone) {\n        return self.wordPinyinWithoutTone;\n    }\n    NSMutableString * mutableString = [[NSMutableString alloc] initWithString:self];\n    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);\n    NSStringCompareOptions toneOption = tone ?NSCaseInsensitiveSearch:NSDiacriticInsensitiveSearch;\n    NSString * pinyin = [mutableString stringByFoldingWithOptions:toneOption locale:[NSLocale currentLocale]];\n    if (tone) {\n        self.wordPinyinWithTone = pinyin;\n    } else {\n        self.wordPinyinWithoutTone = pinyin;\n    }\n    return pinyin;\n}\n-(BOOL)dw_StringIsChinese {\n    if (self.length == 0) {\n        return NO;\n    }\n    NSPredicate * predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",@\"[\\\\u4E00-\\\\u9FA5]+\"];\n    return [predicate evaluateWithObject:self];\n}\n-(NSArray *)dw_TrimStringToWord {\n    if (self.length) {\n        NSMutableArray * temp = [NSMutableArray array];\n        [self enumerateSubstringsInRange:NSMakeRange(0, self.length) options:NSStringEnumerationByWords usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {\n            if (substring.length > 1 && temp.count == 0 && ![substring dw_StringIsChinese] && [substring dw_SubStringConfirmToPattern:@\"[\\\\u4E00-\\\\u9FA5]+\"].count > 0) {///为防止第一个字与英文连在一起\n                [temp addObject:[substring substringToIndex:1]];\n                [temp addObject:[substring substringFromIndex:1]];\n            } else {\n                if (substring.length > 1 && [substring dw_StringIsChinese]) {\n                    [substring enumerateSubstringsInRange:NSMakeRange(0, substring.length) options:(NSStringEnumerationByComposedCharacterSequences) usingBlock:^(NSString * _Nullable substring2, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {\n                        [temp addObject:substring2];\n                    }];\n                } else {\n                    if (substring.length) {\n                        [temp addObject:substring];\n                    }\n                }\n            }\n        }];\n        return [temp copy];\n    }\n    return nil;\n}\n#pragma mark --- inline method ---\nstatic inline NSString * transformPinyinTone(NSString * pinyin) {\n    replaceIfContain(pinyin, @\"ā\", @\"a\",1);\n    replaceIfContain(pinyin, @\"á\", @\"a\",2);\n    replaceIfContain(pinyin, @\"ǎ\", @\"a\",3);\n    replaceIfContain(pinyin, @\"à\", @\"a\",4);\n    replaceIfContain(pinyin, @\"ō\", @\"o\",1);\n    replaceIfContain(pinyin, @\"ó\", @\"o\",2);\n    replaceIfContain(pinyin, @\"ǒ\", @\"o\",3);\n    replaceIfContain(pinyin, @\"ò\", @\"o\",4);\n    replaceIfContain(pinyin, @\"ē\", @\"e\",1);\n    replaceIfContain(pinyin, @\"é\", @\"e\",2);\n    replaceIfContain(pinyin, @\"ě\", @\"e\",3);\n    replaceIfContain(pinyin, @\"è\", @\"e\",4);\n    replaceIfContain(pinyin, @\"ī\", @\"i\",1);\n    replaceIfContain(pinyin, @\"í\", @\"i\",2);\n    replaceIfContain(pinyin, @\"ǐ\", @\"i\",3);\n    replaceIfContain(pinyin, @\"ì\", @\"i\",4);\n    replaceIfContain(pinyin, @\"ū\", @\"u\",1);\n    replaceIfContain(pinyin, @\"ú\", @\"u\",2);\n    replaceIfContain(pinyin, @\"ǔ\", @\"u\",3);\n    replaceIfContain(pinyin, @\"ù\", @\"u\",4);\n    return pinyin;\n}\n#pragma mark ---setter/getter ---\n-(void)setWordPinyinWithTone:(NSString *)wordPinyinWithTone {\n    objc_setAssociatedObject(self, @selector(wordPinyinWithTone), wordPinyinWithTone, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n-(NSString *)wordPinyinWithTone {\n    return objc_getAssociatedObject(self, _cmd);\n}\n\n-(void)setWordPinyinWithoutTone:(NSString *)wordPinyinWithoutTone {\n    objc_setAssociatedObject(self, @selector(wordPinyinWithoutTone), wordPinyinWithoutTone, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n-(NSString *)wordPinyinWithoutTone {\n    return objc_getAssociatedObject(self, _cmd);\n}\n\n-(void)setWordArray:(NSArray *)wordArray {\n    objc_setAssociatedObject(self, @selector(wordArray), wordArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n-(NSArray *)wordArray {\n    NSArray * array = objc_getAssociatedObject(self, _cmd);\n    if (!array) {\n        array = [self dw_TrimStringToWord];\n        objc_setAssociatedObject(self, @selector(wordArray), array, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    }\n    return array;\n}\n@end\n```\n\n### 带音调的拼音排序\n上面的排序老司机都是在排没有音调的拼音。老司机在上面也有介绍过如果转换带音调的拼音方法，老司机又开始美滋滋的优化自己的代码了。想想不过是转拼音的时候转成带音调的然后源代码比较呗。结果。。。\n\n![什么鬼顺序](http://upload-images.jianshu.io/upload_images/1835430-9e17c5932013e14c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系统这是什么鬼顺序，开始怀疑小学老师教的`āáǎà`是假的了都。。老司机都快疯了，妈妈，不要再让我给字符串排序了。。。\n\n又开始翻阅博客如何排序啊。。。\n\n>之前考虑过这个方法 但问题是不能对首字母之后的拼音排序 而且需要引用额外的文件 比较麻烦。\n\n>后来查到gb编码本来就是用拼音排序的就hack了一下：在stringByAddingPercentEscapesUsingEncoding:后面用16位编码 将中文转为ascii来比较 更简洁。\n\n>引自[按照拼音对数组中的中文字符串排序的算法中Lunar川小槑的回复](http://bbs.9ria.com/thread-230144-1-1.html)\n\n```\n\\#define GB18030_ENCODING CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000)\n \n// 其他代码...\n \nNSComparator comparator = ^(NSString *obj1, NSString *obj2){\n \n        NSString *str1 = [obj1 stringByAddingPercentEscapesUsingEncoding:GB18030_ENCODING];\n        NSString *str2 = [obj2 stringByAddingPercentEscapesUsingEncoding:GB18030_ENCODING];\n \n        return [str1 compare:str2];\n};\n```\n\n试了一下，诶，果然好使！顺序对的！也不用逐字比较了！一级棒！不过老司机真的有做测试的潜质，我也不知道为什么，我就随便改了一下数据，我都不知道怎么想的把往字改成了彺字结果就又错了。。。想想可能GB_18030这个标准也不都是按照拼音排的吧。。。\n\n### -localizedCompare:\n最后的，也是最简单的，系统放在那我就一直没用的。。。\n最后的最后我又找到了这个方法，`-localizedCompare:`。真的是比什么都简单，又比什么都对啊。这个方法没什么bug也没什么风险。。。简单的不要不要的。。。\n\n\n扣个题：\n~~中文字符串比较，请使用`-localizedCompare:`方法。这一个系统方法足矣！~~\n~~中文字符串比较，请使用`-localizedCompare:`方法。这一个系统方法足矣！~~\n~~中文字符串比较，请使用`-localizedCompare:`方法。这一个系统方法足矣！~~\n**扣题改了，看下文章开头的更新**\n想想自己因为要按拼音分组所以转了拼音，之后就一直再以拼音排序，快要被自己蠢哭了。。。\n![蠢哭了](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1495363026&di=1c167ccfccb027ec1e36df10b36e2ccf&src=http://wanzao2.b0.upaiyun.com/system/pictures/33086994/original/1455272971_500x500.png)\n","slug":"老司机踩坑系列————中文排序","published":1,"comments":1,"photos":[],"link":"","_id":"cj3r8htq4001ajigb060urlgv","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ab6ed3784c197392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"中文排序\"></p>\n<p>仅以此文，祭奠线上无限crash的61位用户。</p>\n<p>恩，先放重点：<br><del>中文字符串比较，请使用<code>-localizedCompare:</code>方法。这一个系统方法足矣！</del></p>\n<blockquote>\n<p>2017.05.24更新<br>-localizedCompare:这个方法能保证排序结果与系统通讯录排序结果相同，基本符合拼音顺序，但偶尔有偏差。<br>感谢 @半江瑟瑟 提供的测试数据<strong>立冬、李东、李Dong</strong><br>想做到与系统排序方式保持一致请使用-localizedCompare:方法，想做到完美拼音排序请使用老司机文中提到的逐字比较方式。</p>\n</blockquote>\n<p>恩，重点说完开始讲故事，这篇文章主要用来总结几种中文字符串比较的方法，以防以后我那次遇到什么特殊的需求。</p>\n<p>这个故事中你将会看到：</p>\n<ul>\n<li>字符串转拼音</li>\n<li>-caseInsensitiveCompare:</li>\n<li>UILocalizedIndexedCollation</li>\n<li>逐字比较</li>\n<li>GB_18030编码</li>\n<li>-localizedCompare:</li>\n</ul>\n<p>然而知识点只有：</p>\n<ul>\n<li>字符串转拼音</li>\n<li>-localizedCompare:</li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<p>那个手机浏览的同志注意了，<strong>看到字符串转拼音后就可以打住了</strong>，下面的内容多图杀猫费流量=。=</p>\n<p>事情是这样的，需求要求自定义通讯录选择流程，故无法直接调用系统通讯录。老司机自告奋勇的接下了活，毕竟脑袋一想还不难，可老司机低估了中文排序的坑=。=</p>\n<h3 id=\"最初的想法\"><a href=\"#最初的想法\" class=\"headerlink\" title=\"最初的想法\"></a>最初的想法</h3><p>最开始老司机想，首先所有联系人都会按姓名首字母分组，似乎需要转拼音。有了拼音就可以根据拼音排序，很顺畅的思路。Too young，Too naive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">///汉字转拼音</div><div class=\"line\">-(NSString *)transferChineseToPinYin:(NSString *)string &#123;</div><div class=\"line\">    NSMutableString *mutableString = [NSMutableString stringWithString:string];</div><div class=\"line\">    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);</div><div class=\"line\">    return [mutableString stringByFoldingWithOptions:NSDiacriticInsensitiveSearch locale:[NSLocale currentLocale]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>转拼音老司机没有引用第三方库，用了三行代码就搞定了。（这样的方式转换出来的拼音是没有音调的，如果想要带着音调，请将<strong>NSDiacriticInsensitiveSearch</strong>替换为<strong>NSCaseInsensitiveSearch</strong>）。</p>\n<p>转完拼音后，就可以调用<code>-caseInsensitiveCompare:</code>进行比较了，老司机当时真是美滋滋。</p>\n<p>与<code>-caseInsensitiveCompare:</code>效果相同的还有一个专门为了TableView而存在的排序的类，叫做UILocalizedIndexedCollation。他也可以用来排序，使用起来也挺简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray *arr = [self getName];///只是将几个字符串分别包装成对象</div><div class=\"line\">UILocalizedIndexedCollation *localized =  [UILocalizedIndexedCollation currentCollation];</div><div class=\"line\">NSArray *temparr = [localized sortedArrayFromArray:arr collationStringSelector:@selector(fullName)];</div></pre></td></tr></table></figure>\n<p>不过他是基于对象的，你要把字符串当做某个对象的属性才能排序。并且它存在下面两个问题中的第一个问题。</p>\n<p>不过有两个问题：</p>\n<ul>\n<li>同音不同字<br>表现是什么呢？比如说三个人，请看图示：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a57ab15ed771948a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"转拼音后比较拼音\"></p>\n<p>这个结果明显是不我们可以接受的。</p>\n<p>恩，上面转拼音的方法会在两个字之间自动加上一个空格。所以老司机发现可以把拼音分开。所以老司机在这里的想法是逐字比较。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1520bf1ee5c692a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"逐字比较\"></p>\n<p>这样的话，结果就是理想结果了。不过还有第二个问题。。</p>\n<ul>\n<li>中英结合的字符串<br>中英结合的字符串转换成拼音以后效果跟预想的有一定偏差。什么表现呢？</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d438d2fbdafe899e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"中英结合\"></p>\n<p>为什么这样呢？我们看到转拼音的时候中英结合的是没有空格的。</p>\n<p>老司机遇到错误平错误，想到因为中英结合有问题，我处理一下字符串把中英文分开不就好了么？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b6d4e0c918a38bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加空格\"></p>\n<p>这样的话<code>张Wicky</code>就变成<code>张 Wicky</code>转成拼音就变成<code>zhang wicky</code>。排序完成。</p>\n<p>然而我的61位用户就是因为我这一时大意而受到了无限crash的折磨。。。</p>\n<p>矛盾点在这，比如用户本来存的名字叫做<code>张 啊</code>。没错，就是名字里面本身就有一个空格（这61位用户你们为毛要存空格啊。。。其他用户怎么就不存呢。。一定是你不会用），经过上面的添加空格就会变成<code>张   啊</code>(名字中间变成了3个空格)。其实到这里还好，最可气的是<code>-componentsSeparatedByString:</code>这个方法的行为跟老司机想的不一致啊。（敲黑板，重点了啊）</p>\n<p>同学们，<code>张   啊</code>这个字符串调用<code>-componentsSeparatedByString:</code>这个方法，传参<code>@&quot; &quot;</code>，你们的理想结果是什么？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d0053a677481506c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"实际结果\"></p>\n<p>是的，比预想的多了两个空字符串。。。问题很严重，原本<code>张 啊</code>字符串长度为3，拼音数组元素个数为4。然而后面有调用了<code>-substringWithRange:</code>方法。。。是的你没猜错，<strong>越界了</strong>。。。</p>\n<p>到这想填坑其实还可以，只要在添加空格以后再检验是否有连续空格，替换成一个空格就好了。。。不过这种打补丁，让代码越来越失去可维护性的做法老司机觉得是个隐患。。。所以老司机不得不想出第二个方法。</p>\n<h3 id=\"逐字比较时确保字与拼音一一对应\"><a href=\"#逐字比较时确保字与拼音一一对应\" class=\"headerlink\" title=\"逐字比较时确保字与拼音一一对应\"></a>逐字比较时确保字与拼音一一对应</h3><p>最初的想法因为越界出问题，那么我是否让字与拼音一一对应上就好了呢？<br>那么首先要把字符串分成一个字一个字的，但是单词还要保证是单词而不是字母。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6a8b714d1a68b84a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"分字\"></p>\n<p>事实上老司机到这已经有了些许抗拒，为什么一个字符串排序就这么难。。。<br>到了这里思路大概就是这个样子的：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-fe190f43f82589ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"拆字\"></p>\n<p>到了这里，因为先拆字，所以不需要手动添加空格，也避免了<code>-substringWithRange:</code>方法，所以根本就不存在越界了。看起来似乎比最初的想法省了很多事，老司机心里美滋滋。</p>\n<p>多说一嘴，<code>-enumerateSubstringsInRange:</code>这个方法的行为很诡异，不知道是bug还是什么原理，表现如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-61f70215ce1c04e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"奇怪的行为\"><br>当第一个可见字符为汉字且紧跟着一个单词的时候，这里面的子串都中文和英文是不会分开的，且后面的子串不熟影响。其他情况下都可以正常返回子串。</p>\n<blockquote>\n<p>2017.05.25更新<br>有同学问具体是怎么实现的？老司机将中文拼音比较写在了字符串的扩展中。以下是.m中相关代码：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define replaceIfContain(string,target,replacement,tone) \\</div><div class=\"line\">do &#123;\\</div><div class=\"line\">if ([string containsString:target]) &#123;\\</div><div class=\"line\">string = [string stringByReplacingOccurrencesOfString:target withString:replacement];\\</div><div class=\"line\">string = [NSString stringWithFormat:@&quot;%@%d&quot;,string,tone];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">&#125; while(0)</div><div class=\"line\"></div><div class=\"line\">@interface NSString ()</div><div class=\"line\">@property (nonatomic ,strong) NSArray * wordArray;</div><div class=\"line\">@property (nonatomic ,copy) NSString * wordPinyinWithTone;</div><div class=\"line\">@property (nonatomic ,copy) NSString * wordPinyinWithoutTone;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation NSString (DWStringSortUtils)</div><div class=\"line\">-(NSComparisonResult)dw_ComparedInPinyinWithString:(NSString *)string considerTone:(BOOL)tone &#123;</div><div class=\"line\">    if ([self isEqualToString:string]) &#123;</div><div class=\"line\">        return NSOrderedSame;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSArray &lt;NSString *&gt;* arr1 = self.wordArray;</div><div class=\"line\">    NSArray &lt;NSString *&gt;* arr2 = string.wordArray;</div><div class=\"line\">    NSUInteger minL = MIN(arr1.count, arr2.count);</div><div class=\"line\">    for (int i = 0; i &lt; minL; i ++) &#123;</div><div class=\"line\">        if ([arr1[i] isEqualToString:arr2[i]]) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSString * pinyin1 = [arr1[i] transferWordToPinYinWithTone:tone];</div><div class=\"line\">        NSString * pinyin2 = [arr2[i] transferWordToPinYinWithTone:tone];</div><div class=\"line\">        if (tone) &#123;</div><div class=\"line\">            pinyin1 = transformPinyinTone(pinyin1);</div><div class=\"line\">            pinyin2 = transformPinyinTone(pinyin2);</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSComparisonResult result = [pinyin1 caseInsensitiveCompare:pinyin2];</div><div class=\"line\">        if (result != NSOrderedSame) &#123;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            result = [arr1[i] localizedCompare:arr2[i]];</div><div class=\"line\">            if (result != NSOrderedSame) &#123;</div><div class=\"line\">                return result;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (arr1.count &lt; arr2.count) &#123;</div><div class=\"line\">        return NSOrderedAscending;</div><div class=\"line\">    &#125; else if (arr1.count &gt; arr2.count) &#123;</div><div class=\"line\">        return NSOrderedDescending;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return NSOrderedSame;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark --- tool method ---</div><div class=\"line\">-(NSString *)transferWordToPinYinWithTone:(BOOL)tone &#123;</div><div class=\"line\">    if (tone &amp;&amp; self.wordPinyinWithTone) &#123;</div><div class=\"line\">        return self.wordPinyinWithTone;</div><div class=\"line\">    &#125; else if (!tone &amp;&amp; self.wordPinyinWithoutTone) &#123;</div><div class=\"line\">        return self.wordPinyinWithoutTone;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSMutableString * mutableString = [[NSMutableString alloc] initWithString:self];</div><div class=\"line\">    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);</div><div class=\"line\">    NSStringCompareOptions toneOption = tone ?NSCaseInsensitiveSearch:NSDiacriticInsensitiveSearch;</div><div class=\"line\">    NSString * pinyin = [mutableString stringByFoldingWithOptions:toneOption locale:[NSLocale currentLocale]];</div><div class=\"line\">    if (tone) &#123;</div><div class=\"line\">        self.wordPinyinWithTone = pinyin;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        self.wordPinyinWithoutTone = pinyin;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return pinyin;</div><div class=\"line\">&#125;</div><div class=\"line\">-(BOOL)dw_StringIsChinese &#123;</div><div class=\"line\">    if (self.length == 0) &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSPredicate * predicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,@&quot;[\\\\u4E00-\\\\u9FA5]+&quot;];</div><div class=\"line\">    return [predicate evaluateWithObject:self];</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSArray *)dw_TrimStringToWord &#123;</div><div class=\"line\">    if (self.length) &#123;</div><div class=\"line\">        NSMutableArray * temp = [NSMutableArray array];</div><div class=\"line\">        [self enumerateSubstringsInRange:NSMakeRange(0, self.length) options:NSStringEnumerationByWords usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">            if (substring.length &gt; 1 &amp;&amp; temp.count == 0 &amp;&amp; ![substring dw_StringIsChinese] &amp;&amp; [substring dw_SubStringConfirmToPattern:@&quot;[\\\\u4E00-\\\\u9FA5]+&quot;].count &gt; 0) &#123;///为防止第一个字与英文连在一起</div><div class=\"line\">                [temp addObject:[substring substringToIndex:1]];</div><div class=\"line\">                [temp addObject:[substring substringFromIndex:1]];</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if (substring.length &gt; 1 &amp;&amp; [substring dw_StringIsChinese]) &#123;</div><div class=\"line\">                    [substring enumerateSubstringsInRange:NSMakeRange(0, substring.length) options:(NSStringEnumerationByComposedCharacterSequences) usingBlock:^(NSString * _Nullable substring2, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">                        [temp addObject:substring2];</div><div class=\"line\">                    &#125;];</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (substring.length) &#123;</div><div class=\"line\">                        [temp addObject:substring];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;];</div><div class=\"line\">        return [temp copy];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark --- inline method ---</div><div class=\"line\">static inline NSString * transformPinyinTone(NSString * pinyin) &#123;</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ā&quot;, @&quot;a&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;á&quot;, @&quot;a&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ǎ&quot;, @&quot;a&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;à&quot;, @&quot;a&quot;,4);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ō&quot;, @&quot;o&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ó&quot;, @&quot;o&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ǒ&quot;, @&quot;o&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ò&quot;, @&quot;o&quot;,4);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ē&quot;, @&quot;e&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;é&quot;, @&quot;e&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ě&quot;, @&quot;e&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;è&quot;, @&quot;e&quot;,4);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ī&quot;, @&quot;i&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;í&quot;, @&quot;i&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ǐ&quot;, @&quot;i&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ì&quot;, @&quot;i&quot;,4);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ū&quot;, @&quot;u&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ú&quot;, @&quot;u&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ǔ&quot;, @&quot;u&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ù&quot;, @&quot;u&quot;,4);</div><div class=\"line\">    return pinyin;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark ---setter/getter ---</div><div class=\"line\">-(void)setWordPinyinWithTone:(NSString *)wordPinyinWithTone &#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(wordPinyinWithTone), wordPinyinWithTone, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSString *)wordPinyinWithTone &#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setWordPinyinWithoutTone:(NSString *)wordPinyinWithoutTone &#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(wordPinyinWithoutTone), wordPinyinWithoutTone, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSString *)wordPinyinWithoutTone &#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setWordArray:(NSArray *)wordArray &#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(wordArray), wordArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSArray *)wordArray &#123;</div><div class=\"line\">    NSArray * array = objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">    if (!array) &#123;</div><div class=\"line\">        array = [self dw_TrimStringToWord];</div><div class=\"line\">        objc_setAssociatedObject(self, @selector(wordArray), array, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"带音调的拼音排序\"><a href=\"#带音调的拼音排序\" class=\"headerlink\" title=\"带音调的拼音排序\"></a>带音调的拼音排序</h3><p>上面的排序老司机都是在排没有音调的拼音。老司机在上面也有介绍过如果转换带音调的拼音方法，老司机又开始美滋滋的优化自己的代码了。想想不过是转拼音的时候转成带音调的然后源代码比较呗。结果。。。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-9e17c5932013e14c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"什么鬼顺序\"></p>\n<p>系统这是什么鬼顺序，开始怀疑小学老师教的<code>āáǎà</code>是假的了都。。老司机都快疯了，妈妈，不要再让我给字符串排序了。。。</p>\n<p>又开始翻阅博客如何排序啊。。。</p>\n<blockquote>\n<p>之前考虑过这个方法 但问题是不能对首字母之后的拼音排序 而且需要引用额外的文件 比较麻烦。</p>\n<p>后来查到gb编码本来就是用拼音排序的就hack了一下：在stringByAddingPercentEscapesUsingEncoding:后面用16位编码 将中文转为ascii来比较 更简洁。</p>\n<p>引自<a href=\"http://bbs.9ria.com/thread-230144-1-1.html\" target=\"_blank\" rel=\"external\">按照拼音对数组中的中文字符串排序的算法中Lunar川小槑的回复</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\#define GB18030_ENCODING CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000)</div><div class=\"line\"> </div><div class=\"line\">// 其他代码...</div><div class=\"line\"> </div><div class=\"line\">NSComparator comparator = ^(NSString *obj1, NSString *obj2)&#123;</div><div class=\"line\"> </div><div class=\"line\">        NSString *str1 = [obj1 stringByAddingPercentEscapesUsingEncoding:GB18030_ENCODING];</div><div class=\"line\">        NSString *str2 = [obj2 stringByAddingPercentEscapesUsingEncoding:GB18030_ENCODING];</div><div class=\"line\"> </div><div class=\"line\">        return [str1 compare:str2];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>试了一下，诶，果然好使！顺序对的！也不用逐字比较了！一级棒！不过老司机真的有做测试的潜质，我也不知道为什么，我就随便改了一下数据，我都不知道怎么想的把往字改成了彺字结果就又错了。。。想想可能GB_18030这个标准也不都是按照拼音排的吧。。。</p>\n<h3 id=\"localizedCompare\"><a href=\"#localizedCompare\" class=\"headerlink\" title=\"-localizedCompare:\"></a>-localizedCompare:</h3><p>最后的，也是最简单的，系统放在那我就一直没用的。。。<br>最后的最后我又找到了这个方法，<code>-localizedCompare:</code>。真的是比什么都简单，又比什么都对啊。这个方法没什么bug也没什么风险。。。简单的不要不要的。。。</p>\n<p>扣个题：<br><del>中文字符串比较，请使用<code>-localizedCompare:</code>方法。这一个系统方法足矣！</del><br><del>中文字符串比较，请使用<code>-localizedCompare:</code>方法。这一个系统方法足矣！</del><br><del>中文字符串比较，请使用<code>-localizedCompare:</code>方法。这一个系统方法足矣！</del><br><strong>扣题改了，看下文章开头的更新</strong><br>想想自己因为要按拼音分组所以转了拼音，之后就一直再以拼音排序，快要被自己蠢哭了。。。<br><img src=\"https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1495363026&amp;di=1c167ccfccb027ec1e36df10b36e2ccf&amp;src=http://wanzao2.b0.upaiyun.com/system/pictures/33086994/original/1455272971_500x500.png\" alt=\"蠢哭了\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-ab6ed3784c197392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"中文排序\"></p>\n<p>仅以此文，祭奠线上无限crash的61位用户。</p>\n<p>恩，先放重点：<br><del>中文字符串比较，请使用<code>-localizedCompare:</code>方法。这一个系统方法足矣！</del></p>\n<blockquote>\n<p>2017.05.24更新<br>-localizedCompare:这个方法能保证排序结果与系统通讯录排序结果相同，基本符合拼音顺序，但偶尔有偏差。<br>感谢 @半江瑟瑟 提供的测试数据<strong>立冬、李东、李Dong</strong><br>想做到与系统排序方式保持一致请使用-localizedCompare:方法，想做到完美拼音排序请使用老司机文中提到的逐字比较方式。</p>\n</blockquote>\n<p>恩，重点说完开始讲故事，这篇文章主要用来总结几种中文字符串比较的方法，以防以后我那次遇到什么特殊的需求。</p>\n<p>这个故事中你将会看到：</p>\n<ul>\n<li>字符串转拼音</li>\n<li>-caseInsensitiveCompare:</li>\n<li>UILocalizedIndexedCollation</li>\n<li>逐字比较</li>\n<li>GB_18030编码</li>\n<li>-localizedCompare:</li>\n</ul>\n<p>然而知识点只有：</p>\n<ul>\n<li>字符串转拼音</li>\n<li>-localizedCompare:</li>\n</ul>","more":"<hr>\n<p>那个手机浏览的同志注意了，<strong>看到字符串转拼音后就可以打住了</strong>，下面的内容多图杀猫费流量=。=</p>\n<p>事情是这样的，需求要求自定义通讯录选择流程，故无法直接调用系统通讯录。老司机自告奋勇的接下了活，毕竟脑袋一想还不难，可老司机低估了中文排序的坑=。=</p>\n<h3 id=\"最初的想法\"><a href=\"#最初的想法\" class=\"headerlink\" title=\"最初的想法\"></a>最初的想法</h3><p>最开始老司机想，首先所有联系人都会按姓名首字母分组，似乎需要转拼音。有了拼音就可以根据拼音排序，很顺畅的思路。Too young，Too naive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">///汉字转拼音</div><div class=\"line\">-(NSString *)transferChineseToPinYin:(NSString *)string &#123;</div><div class=\"line\">    NSMutableString *mutableString = [NSMutableString stringWithString:string];</div><div class=\"line\">    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);</div><div class=\"line\">    return [mutableString stringByFoldingWithOptions:NSDiacriticInsensitiveSearch locale:[NSLocale currentLocale]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>转拼音老司机没有引用第三方库，用了三行代码就搞定了。（这样的方式转换出来的拼音是没有音调的，如果想要带着音调，请将<strong>NSDiacriticInsensitiveSearch</strong>替换为<strong>NSCaseInsensitiveSearch</strong>）。</p>\n<p>转完拼音后，就可以调用<code>-caseInsensitiveCompare:</code>进行比较了，老司机当时真是美滋滋。</p>\n<p>与<code>-caseInsensitiveCompare:</code>效果相同的还有一个专门为了TableView而存在的排序的类，叫做UILocalizedIndexedCollation。他也可以用来排序，使用起来也挺简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray *arr = [self getName];///只是将几个字符串分别包装成对象</div><div class=\"line\">UILocalizedIndexedCollation *localized =  [UILocalizedIndexedCollation currentCollation];</div><div class=\"line\">NSArray *temparr = [localized sortedArrayFromArray:arr collationStringSelector:@selector(fullName)];</div></pre></td></tr></table></figure>\n<p>不过他是基于对象的，你要把字符串当做某个对象的属性才能排序。并且它存在下面两个问题中的第一个问题。</p>\n<p>不过有两个问题：</p>\n<ul>\n<li>同音不同字<br>表现是什么呢？比如说三个人，请看图示：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-a57ab15ed771948a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"转拼音后比较拼音\"></p>\n<p>这个结果明显是不我们可以接受的。</p>\n<p>恩，上面转拼音的方法会在两个字之间自动加上一个空格。所以老司机发现可以把拼音分开。所以老司机在这里的想法是逐字比较。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-1520bf1ee5c692a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"逐字比较\"></p>\n<p>这样的话，结果就是理想结果了。不过还有第二个问题。。</p>\n<ul>\n<li>中英结合的字符串<br>中英结合的字符串转换成拼音以后效果跟预想的有一定偏差。什么表现呢？</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d438d2fbdafe899e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"中英结合\"></p>\n<p>为什么这样呢？我们看到转拼音的时候中英结合的是没有空格的。</p>\n<p>老司机遇到错误平错误，想到因为中英结合有问题，我处理一下字符串把中英文分开不就好了么？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-b6d4e0c918a38bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加空格\"></p>\n<p>这样的话<code>张Wicky</code>就变成<code>张 Wicky</code>转成拼音就变成<code>zhang wicky</code>。排序完成。</p>\n<p>然而我的61位用户就是因为我这一时大意而受到了无限crash的折磨。。。</p>\n<p>矛盾点在这，比如用户本来存的名字叫做<code>张 啊</code>。没错，就是名字里面本身就有一个空格（这61位用户你们为毛要存空格啊。。。其他用户怎么就不存呢。。一定是你不会用），经过上面的添加空格就会变成<code>张   啊</code>(名字中间变成了3个空格)。其实到这里还好，最可气的是<code>-componentsSeparatedByString:</code>这个方法的行为跟老司机想的不一致啊。（敲黑板，重点了啊）</p>\n<p>同学们，<code>张   啊</code>这个字符串调用<code>-componentsSeparatedByString:</code>这个方法，传参<code>@&quot; &quot;</code>，你们的理想结果是什么？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-d0053a677481506c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"实际结果\"></p>\n<p>是的，比预想的多了两个空字符串。。。问题很严重，原本<code>张 啊</code>字符串长度为3，拼音数组元素个数为4。然而后面有调用了<code>-substringWithRange:</code>方法。。。是的你没猜错，<strong>越界了</strong>。。。</p>\n<p>到这想填坑其实还可以，只要在添加空格以后再检验是否有连续空格，替换成一个空格就好了。。。不过这种打补丁，让代码越来越失去可维护性的做法老司机觉得是个隐患。。。所以老司机不得不想出第二个方法。</p>\n<h3 id=\"逐字比较时确保字与拼音一一对应\"><a href=\"#逐字比较时确保字与拼音一一对应\" class=\"headerlink\" title=\"逐字比较时确保字与拼音一一对应\"></a>逐字比较时确保字与拼音一一对应</h3><p>最初的想法因为越界出问题，那么我是否让字与拼音一一对应上就好了呢？<br>那么首先要把字符串分成一个字一个字的，但是单词还要保证是单词而不是字母。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-6a8b714d1a68b84a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"分字\"></p>\n<p>事实上老司机到这已经有了些许抗拒，为什么一个字符串排序就这么难。。。<br>到了这里思路大概就是这个样子的：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-fe190f43f82589ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"拆字\"></p>\n<p>到了这里，因为先拆字，所以不需要手动添加空格，也避免了<code>-substringWithRange:</code>方法，所以根本就不存在越界了。看起来似乎比最初的想法省了很多事，老司机心里美滋滋。</p>\n<p>多说一嘴，<code>-enumerateSubstringsInRange:</code>这个方法的行为很诡异，不知道是bug还是什么原理，表现如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-61f70215ce1c04e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"奇怪的行为\"><br>当第一个可见字符为汉字且紧跟着一个单词的时候，这里面的子串都中文和英文是不会分开的，且后面的子串不熟影响。其他情况下都可以正常返回子串。</p>\n<blockquote>\n<p>2017.05.25更新<br>有同学问具体是怎么实现的？老司机将中文拼音比较写在了字符串的扩展中。以下是.m中相关代码：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define replaceIfContain(string,target,replacement,tone) \\</div><div class=\"line\">do &#123;\\</div><div class=\"line\">if ([string containsString:target]) &#123;\\</div><div class=\"line\">string = [string stringByReplacingOccurrencesOfString:target withString:replacement];\\</div><div class=\"line\">string = [NSString stringWithFormat:@&quot;%@%d&quot;,string,tone];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">&#125; while(0)</div><div class=\"line\"></div><div class=\"line\">@interface NSString ()</div><div class=\"line\">@property (nonatomic ,strong) NSArray * wordArray;</div><div class=\"line\">@property (nonatomic ,copy) NSString * wordPinyinWithTone;</div><div class=\"line\">@property (nonatomic ,copy) NSString * wordPinyinWithoutTone;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation NSString (DWStringSortUtils)</div><div class=\"line\">-(NSComparisonResult)dw_ComparedInPinyinWithString:(NSString *)string considerTone:(BOOL)tone &#123;</div><div class=\"line\">    if ([self isEqualToString:string]) &#123;</div><div class=\"line\">        return NSOrderedSame;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSArray &lt;NSString *&gt;* arr1 = self.wordArray;</div><div class=\"line\">    NSArray &lt;NSString *&gt;* arr2 = string.wordArray;</div><div class=\"line\">    NSUInteger minL = MIN(arr1.count, arr2.count);</div><div class=\"line\">    for (int i = 0; i &lt; minL; i ++) &#123;</div><div class=\"line\">        if ([arr1[i] isEqualToString:arr2[i]]) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSString * pinyin1 = [arr1[i] transferWordToPinYinWithTone:tone];</div><div class=\"line\">        NSString * pinyin2 = [arr2[i] transferWordToPinYinWithTone:tone];</div><div class=\"line\">        if (tone) &#123;</div><div class=\"line\">            pinyin1 = transformPinyinTone(pinyin1);</div><div class=\"line\">            pinyin2 = transformPinyinTone(pinyin2);</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSComparisonResult result = [pinyin1 caseInsensitiveCompare:pinyin2];</div><div class=\"line\">        if (result != NSOrderedSame) &#123;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            result = [arr1[i] localizedCompare:arr2[i]];</div><div class=\"line\">            if (result != NSOrderedSame) &#123;</div><div class=\"line\">                return result;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (arr1.count &lt; arr2.count) &#123;</div><div class=\"line\">        return NSOrderedAscending;</div><div class=\"line\">    &#125; else if (arr1.count &gt; arr2.count) &#123;</div><div class=\"line\">        return NSOrderedDescending;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return NSOrderedSame;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark --- tool method ---</div><div class=\"line\">-(NSString *)transferWordToPinYinWithTone:(BOOL)tone &#123;</div><div class=\"line\">    if (tone &amp;&amp; self.wordPinyinWithTone) &#123;</div><div class=\"line\">        return self.wordPinyinWithTone;</div><div class=\"line\">    &#125; else if (!tone &amp;&amp; self.wordPinyinWithoutTone) &#123;</div><div class=\"line\">        return self.wordPinyinWithoutTone;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSMutableString * mutableString = [[NSMutableString alloc] initWithString:self];</div><div class=\"line\">    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);</div><div class=\"line\">    NSStringCompareOptions toneOption = tone ?NSCaseInsensitiveSearch:NSDiacriticInsensitiveSearch;</div><div class=\"line\">    NSString * pinyin = [mutableString stringByFoldingWithOptions:toneOption locale:[NSLocale currentLocale]];</div><div class=\"line\">    if (tone) &#123;</div><div class=\"line\">        self.wordPinyinWithTone = pinyin;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        self.wordPinyinWithoutTone = pinyin;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return pinyin;</div><div class=\"line\">&#125;</div><div class=\"line\">-(BOOL)dw_StringIsChinese &#123;</div><div class=\"line\">    if (self.length == 0) &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSPredicate * predicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,@&quot;[\\\\u4E00-\\\\u9FA5]+&quot;];</div><div class=\"line\">    return [predicate evaluateWithObject:self];</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSArray *)dw_TrimStringToWord &#123;</div><div class=\"line\">    if (self.length) &#123;</div><div class=\"line\">        NSMutableArray * temp = [NSMutableArray array];</div><div class=\"line\">        [self enumerateSubstringsInRange:NSMakeRange(0, self.length) options:NSStringEnumerationByWords usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">            if (substring.length &gt; 1 &amp;&amp; temp.count == 0 &amp;&amp; ![substring dw_StringIsChinese] &amp;&amp; [substring dw_SubStringConfirmToPattern:@&quot;[\\\\u4E00-\\\\u9FA5]+&quot;].count &gt; 0) &#123;///为防止第一个字与英文连在一起</div><div class=\"line\">                [temp addObject:[substring substringToIndex:1]];</div><div class=\"line\">                [temp addObject:[substring substringFromIndex:1]];</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if (substring.length &gt; 1 &amp;&amp; [substring dw_StringIsChinese]) &#123;</div><div class=\"line\">                    [substring enumerateSubstringsInRange:NSMakeRange(0, substring.length) options:(NSStringEnumerationByComposedCharacterSequences) usingBlock:^(NSString * _Nullable substring2, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">                        [temp addObject:substring2];</div><div class=\"line\">                    &#125;];</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (substring.length) &#123;</div><div class=\"line\">                        [temp addObject:substring];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;];</div><div class=\"line\">        return [temp copy];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark --- inline method ---</div><div class=\"line\">static inline NSString * transformPinyinTone(NSString * pinyin) &#123;</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ā&quot;, @&quot;a&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;á&quot;, @&quot;a&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ǎ&quot;, @&quot;a&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;à&quot;, @&quot;a&quot;,4);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ō&quot;, @&quot;o&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ó&quot;, @&quot;o&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ǒ&quot;, @&quot;o&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ò&quot;, @&quot;o&quot;,4);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ē&quot;, @&quot;e&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;é&quot;, @&quot;e&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ě&quot;, @&quot;e&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;è&quot;, @&quot;e&quot;,4);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ī&quot;, @&quot;i&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;í&quot;, @&quot;i&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ǐ&quot;, @&quot;i&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ì&quot;, @&quot;i&quot;,4);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ū&quot;, @&quot;u&quot;,1);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ú&quot;, @&quot;u&quot;,2);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ǔ&quot;, @&quot;u&quot;,3);</div><div class=\"line\">    replaceIfContain(pinyin, @&quot;ù&quot;, @&quot;u&quot;,4);</div><div class=\"line\">    return pinyin;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark ---setter/getter ---</div><div class=\"line\">-(void)setWordPinyinWithTone:(NSString *)wordPinyinWithTone &#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(wordPinyinWithTone), wordPinyinWithTone, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSString *)wordPinyinWithTone &#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setWordPinyinWithoutTone:(NSString *)wordPinyinWithoutTone &#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(wordPinyinWithoutTone), wordPinyinWithoutTone, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSString *)wordPinyinWithoutTone &#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)setWordArray:(NSArray *)wordArray &#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(wordArray), wordArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(NSArray *)wordArray &#123;</div><div class=\"line\">    NSArray * array = objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">    if (!array) &#123;</div><div class=\"line\">        array = [self dw_TrimStringToWord];</div><div class=\"line\">        objc_setAssociatedObject(self, @selector(wordArray), array, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"带音调的拼音排序\"><a href=\"#带音调的拼音排序\" class=\"headerlink\" title=\"带音调的拼音排序\"></a>带音调的拼音排序</h3><p>上面的排序老司机都是在排没有音调的拼音。老司机在上面也有介绍过如果转换带音调的拼音方法，老司机又开始美滋滋的优化自己的代码了。想想不过是转拼音的时候转成带音调的然后源代码比较呗。结果。。。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1835430-9e17c5932013e14c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"什么鬼顺序\"></p>\n<p>系统这是什么鬼顺序，开始怀疑小学老师教的<code>āáǎà</code>是假的了都。。老司机都快疯了，妈妈，不要再让我给字符串排序了。。。</p>\n<p>又开始翻阅博客如何排序啊。。。</p>\n<blockquote>\n<p>之前考虑过这个方法 但问题是不能对首字母之后的拼音排序 而且需要引用额外的文件 比较麻烦。</p>\n<p>后来查到gb编码本来就是用拼音排序的就hack了一下：在stringByAddingPercentEscapesUsingEncoding:后面用16位编码 将中文转为ascii来比较 更简洁。</p>\n<p>引自<a href=\"http://bbs.9ria.com/thread-230144-1-1.html\" target=\"_blank\" rel=\"external\">按照拼音对数组中的中文字符串排序的算法中Lunar川小槑的回复</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\#define GB18030_ENCODING CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000)</div><div class=\"line\"> </div><div class=\"line\">// 其他代码...</div><div class=\"line\"> </div><div class=\"line\">NSComparator comparator = ^(NSString *obj1, NSString *obj2)&#123;</div><div class=\"line\"> </div><div class=\"line\">        NSString *str1 = [obj1 stringByAddingPercentEscapesUsingEncoding:GB18030_ENCODING];</div><div class=\"line\">        NSString *str2 = [obj2 stringByAddingPercentEscapesUsingEncoding:GB18030_ENCODING];</div><div class=\"line\"> </div><div class=\"line\">        return [str1 compare:str2];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>试了一下，诶，果然好使！顺序对的！也不用逐字比较了！一级棒！不过老司机真的有做测试的潜质，我也不知道为什么，我就随便改了一下数据，我都不知道怎么想的把往字改成了彺字结果就又错了。。。想想可能GB_18030这个标准也不都是按照拼音排的吧。。。</p>\n<h3 id=\"localizedCompare\"><a href=\"#localizedCompare\" class=\"headerlink\" title=\"-localizedCompare:\"></a>-localizedCompare:</h3><p>最后的，也是最简单的，系统放在那我就一直没用的。。。<br>最后的最后我又找到了这个方法，<code>-localizedCompare:</code>。真的是比什么都简单，又比什么都对啊。这个方法没什么bug也没什么风险。。。简单的不要不要的。。。</p>\n<p>扣个题：<br><del>中文字符串比较，请使用<code>-localizedCompare:</code>方法。这一个系统方法足矣！</del><br><del>中文字符串比较，请使用<code>-localizedCompare:</code>方法。这一个系统方法足矣！</del><br><del>中文字符串比较，请使用<code>-localizedCompare:</code>方法。这一个系统方法足矣！</del><br><strong>扣题改了，看下文章开头的更新</strong><br>想想自己因为要按拼音分组所以转了拼音，之后就一直再以拼音排序，快要被自己蠢哭了。。。<br><img src=\"https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1495363026&amp;di=1c167ccfccb027ec1e36df10b36e2ccf&amp;src=http://wanzao2.b0.upaiyun.com/system/pictures/33086994/original/1455272971_500x500.png\" alt=\"蠢哭了\"></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj3r8htoy0008jigbfqfg2x7z","category_id":"cj3r8htos0004jigb6cx4s2vs","_id":"cj3r8htp6000djigbsp0dh851"},{"post_id":"cj3r8htoh0000jigbmprt3xdn","category_id":"cj3r8htos0004jigb6cx4s2vs","_id":"cj3r8htpb000hjigb92fafbv5"},{"post_id":"cj3r8htp5000cjigbshjuf7wu","category_id":"cj3r8htp3000ajigb985be3w3","_id":"cj3r8htpg000kjigb9bbp1ht1"},{"post_id":"cj3r8htop0002jigbo556pkai","category_id":"cj3r8htp3000ajigb985be3w3","_id":"cj3r8htpl000pjigbghfuypex"},{"post_id":"cj3r8htov0006jigb4lvtsvtn","category_id":"cj3r8htos0004jigb6cx4s2vs","_id":"cj3r8htpp000sjigb7b415rpy"},{"post_id":"cj3r8htp20009jigbp4ieevfp","category_id":"cj3r8htp3000ajigb985be3w3","_id":"cj3r8htps000yjigbjdjoqnwp"},{"post_id":"cj3r8htp6000ejigbval1itul","category_id":"cj3r8htpp000tjigbip8jhg4s","_id":"cj3r8htq00014jigbrn60qf4t"},{"post_id":"cj3r8htpe000ijigbhj075jie","category_id":"cj3r8htpt000zjigbz7peari8","_id":"cj3r8htq30019jigb3bqdjxnq"},{"post_id":"cj3r8htph000ljigbyf2ubrcl","category_id":"cj3r8htq10015jigbn6ojj78t","_id":"cj3r8htq8001ejigbqprzqjn5"},{"post_id":"cj3r8htpl000qjigb94mw3dum","category_id":"cj3r8htpp000tjigbip8jhg4s","_id":"cj3r8htqa001jjigbntpu1wfl"},{"post_id":"cj3r8htpo000rjigbnmolqqda","category_id":"cj3r8htpp000tjigbip8jhg4s","_id":"cj3r8htqb001mjigb12xavzpy"},{"post_id":"cj3r8htpq000vjigbf1yqccu0","category_id":"cj3r8htqa001kjigbs4w4b5un","_id":"cj3r8htqc001qjigbkjvkwla8"},{"post_id":"cj3r8htps000xjigb3zm8ifk6","category_id":"cj3r8htqa001kjigbs4w4b5un","_id":"cj3r8htqe001vjigbkt4dhkvc"},{"post_id":"cj3r8htpt0012jigbgcli384k","category_id":"cj3r8htqa001kjigbs4w4b5un","_id":"cj3r8htqi0020jigbwvx5fm7s"},{"post_id":"cj3r8htpu0013jigbi23glves","category_id":"cj3r8htqa001kjigbs4w4b5un","_id":"cj3r8htqj0024jigbequ7m4nc"},{"post_id":"cj3r8htq20017jigbj3vjdba2","category_id":"cj3r8htqa001kjigbs4w4b5un","_id":"cj3r8htqk0028jigb3zt7t1f1"},{"post_id":"cj3r8htq30018jigbh2w7gbk7","category_id":"cj3r8htqa001kjigbs4w4b5un","_id":"cj3r8htqm002cjigbvh3b4ivf"},{"post_id":"cj3r8htq4001ajigb060urlgv","category_id":"cj3r8htqk0029jigbgiwe4lcm","_id":"cj3r8htqm002fjigb3hlgh7k8"}],"PostTag":[{"post_id":"cj3r8htoh0000jigbmprt3xdn","tag_id":"cj3r8htov0005jigbtoswt7uu","_id":"cj3r8htpg000jjigbbly2omix"},{"post_id":"cj3r8htoh0000jigbmprt3xdn","tag_id":"cj3r8htp3000bjigbanoc6j0n","_id":"cj3r8htpj000mjigbdi4yf0cn"},{"post_id":"cj3r8htop0002jigbo556pkai","tag_id":"cj3r8htp7000gjigbe2hlvv1m","_id":"cj3r8htpr000wjigb1ozgzzw8"},{"post_id":"cj3r8htop0002jigbo556pkai","tag_id":"cj3r8htpk000ojigb0v8hrqdd","_id":"cj3r8htpt0010jigb36el9xgu"},{"post_id":"cj3r8htov0006jigb4lvtsvtn","tag_id":"cj3r8htov0005jigbtoswt7uu","_id":"cj3r8htq7001djigb6m7xnzv9"},{"post_id":"cj3r8htov0006jigb4lvtsvtn","tag_id":"cj3r8htp3000bjigbanoc6j0n","_id":"cj3r8htq8001fjigbg4ue6bnv"},{"post_id":"cj3r8htov0006jigb4lvtsvtn","tag_id":"cj3r8htq10016jigbj5h7p728","_id":"cj3r8htqa001ijigb38vw5l1b"},{"post_id":"cj3r8htoy0008jigbfqfg2x7z","tag_id":"cj3r8htov0005jigbtoswt7uu","_id":"cj3r8htqc001pjigbbkm300wb"},{"post_id":"cj3r8htoy0008jigbfqfg2x7z","tag_id":"cj3r8htp3000bjigbanoc6j0n","_id":"cj3r8htqc001rjigbhcgi2y00"},{"post_id":"cj3r8htoy0008jigbfqfg2x7z","tag_id":"cj3r8htq10016jigbj5h7p728","_id":"cj3r8htqe001ujigbsiftctv6"},{"post_id":"cj3r8htoy0008jigbfqfg2x7z","tag_id":"cj3r8htqa001ljigbf6vg98hg","_id":"cj3r8htqe001wjigbq5vq34hs"},{"post_id":"cj3r8htp20009jigbp4ieevfp","tag_id":"cj3r8htp7000gjigbe2hlvv1m","_id":"cj3r8htqh001zjigb7unf7g3o"},{"post_id":"cj3r8htp20009jigbp4ieevfp","tag_id":"cj3r8htqd001tjigbnol21ver","_id":"cj3r8htqi0022jigbm69bfswb"},{"post_id":"cj3r8htp5000cjigbshjuf7wu","tag_id":"cj3r8htp7000gjigbe2hlvv1m","_id":"cj3r8htqk0027jigbuthhvtqh"},{"post_id":"cj3r8htp5000cjigbshjuf7wu","tag_id":"cj3r8htqj0023jigbgd44jeem","_id":"cj3r8htqk002ajigbrnjdec5l"},{"post_id":"cj3r8htp6000ejigbval1itul","tag_id":"cj3r8htqk0026jigb2dxm2qeg","_id":"cj3r8htqm002ejigbby8c77cg"},{"post_id":"cj3r8htp6000ejigbval1itul","tag_id":"cj3r8htql002bjigb8mkuk0l2","_id":"cj3r8htqm002gjigbvz3t46rs"},{"post_id":"cj3r8htpe000ijigbhj075jie","tag_id":"cj3r8htqm002djigbiuqg55rx","_id":"cj3r8htqn002ijigbgcdtkzm8"},{"post_id":"cj3r8htph000ljigbyf2ubrcl","tag_id":"cj3r8htqm002hjigbuo5n18lb","_id":"cj3r8htqo002kjigbrvxlzq0y"},{"post_id":"cj3r8htpl000qjigb94mw3dum","tag_id":"cj3r8htqn002jjigb5frpmjw1","_id":"cj3r8htqp002mjigbbqwd6g8u"},{"post_id":"cj3r8htpo000rjigbnmolqqda","tag_id":"cj3r8htqo002ljigbzne3q7cc","_id":"cj3r8htqq002pjigbzivyvqvz"},{"post_id":"cj3r8htpo000rjigbnmolqqda","tag_id":"cj3r8htqp002njigbqx8ya082","_id":"cj3r8htqq002qjigbggwbsdjh"},{"post_id":"cj3r8htpq000vjigbf1yqccu0","tag_id":"cj3r8htqp002ojigbhbgt0x2d","_id":"cj3r8htqt002tjigbe2nj93m5"},{"post_id":"cj3r8htpq000vjigbf1yqccu0","tag_id":"cj3r8htqq002rjigblpqbtzrj","_id":"cj3r8htqt002ujigbsqxq0b3n"},{"post_id":"cj3r8htps000xjigb3zm8ifk6","tag_id":"cj3r8htqp002ojigbhbgt0x2d","_id":"cj3r8htqv002yjigbvgsktydf"},{"post_id":"cj3r8htps000xjigb3zm8ifk6","tag_id":"cj3r8htqq002rjigblpqbtzrj","_id":"cj3r8htqv002zjigbcx35rpzh"},{"post_id":"cj3r8htps000xjigb3zm8ifk6","tag_id":"cj3r8htqt002wjigbdm025jwh","_id":"cj3r8htqv0031jigb2ak27vsg"},{"post_id":"cj3r8htpt0012jigbgcli384k","tag_id":"cj3r8htqp002ojigbhbgt0x2d","_id":"cj3r8htqy0035jigb7kbaitwk"},{"post_id":"cj3r8htpt0012jigbgcli384k","tag_id":"cj3r8htqq002rjigblpqbtzrj","_id":"cj3r8htqy0036jigbb02owscq"},{"post_id":"cj3r8htpt0012jigbgcli384k","tag_id":"cj3r8htqw0032jigbtcgvfoma","_id":"cj3r8htr10038jigbnv1k1gue"},{"post_id":"cj3r8htpt0012jigbgcli384k","tag_id":"cj3r8htqx0033jigbr6wbchiy","_id":"cj3r8htr10039jigb0f4akvav"},{"post_id":"cj3r8htpu0013jigbi23glves","tag_id":"cj3r8htqp002ojigbhbgt0x2d","_id":"cj3r8htr3003cjigbu2czdwv9"},{"post_id":"cj3r8htpu0013jigbi23glves","tag_id":"cj3r8htqq002rjigblpqbtzrj","_id":"cj3r8htr3003djigb4bi34wta"},{"post_id":"cj3r8htpu0013jigbi23glves","tag_id":"cj3r8htr1003ajigbjublhphj","_id":"cj3r8htr4003fjigbxp5j9g17"},{"post_id":"cj3r8htq20017jigbj3vjdba2","tag_id":"cj3r8htqp002ojigbhbgt0x2d","_id":"cj3r8htr6003ijigbwfndptp8"},{"post_id":"cj3r8htq20017jigbj3vjdba2","tag_id":"cj3r8htqq002rjigblpqbtzrj","_id":"cj3r8htr6003jjigbq0b6mk6a"},{"post_id":"cj3r8htq20017jigbj3vjdba2","tag_id":"cj3r8htr5003gjigbrrzb7br5","_id":"cj3r8htr7003ljigb39qxwkz3"},{"post_id":"cj3r8htq30018jigbh2w7gbk7","tag_id":"cj3r8htqp002ojigbhbgt0x2d","_id":"cj3r8htr9003qjigbz8ahntxz"},{"post_id":"cj3r8htq30018jigbh2w7gbk7","tag_id":"cj3r8htqq002rjigblpqbtzrj","_id":"cj3r8htra003rjigbk3f75tp6"},{"post_id":"cj3r8htq30018jigbh2w7gbk7","tag_id":"cj3r8htr7003mjigbt9bna3m5","_id":"cj3r8htra003sjigbp4t9gj61"},{"post_id":"cj3r8htq30018jigbh2w7gbk7","tag_id":"cj3r8htr8003njigb56hso7i3","_id":"cj3r8htra003tjigbtpsb9qdv"},{"post_id":"cj3r8htq30018jigbh2w7gbk7","tag_id":"cj3r8htr8003ojigbwv0hhb4e","_id":"cj3r8htra003ujigb1zt4873m"},{"post_id":"cj3r8htq4001ajigb060urlgv","tag_id":"cj3r8htr9003pjigbgjbz45c4","_id":"cj3r8htra003vjigbgv2czpub"}],"Tag":[{"name":"CoreText","_id":"cj3r8htov0005jigbtoswt7uu"},{"name":"图文混排","_id":"cj3r8htp3000bjigbanoc6j0n"},{"name":"TableView优化","_id":"cj3r8htp7000gjigbe2hlvv1m"},{"name":"忽略加载","_id":"cj3r8htpk000ojigb0v8hrqdd"},{"name":"点击事件","_id":"cj3r8htq10016jigbj5h7p728"},{"name":"图片环绕","_id":"cj3r8htqa001ljigbf6vg98hg"},{"name":"高度缓存","_id":"cj3r8htqd001tjigbnol21ver"},{"name":"TableView图片加载","_id":"cj3r8htqj0023jigbgd44jeem"},{"name":"异步下载","_id":"cj3r8htqk0026jigb2dxm2qeg"},{"name":"SDWebImage","_id":"cj3r8htql002bjigb8mkuk0l2"},{"name":"滑动验证码","_id":"cj3r8htqm002djigbiuqg55rx"},{"name":"正则表达式","_id":"cj3r8htqm002hjigbuo5n18lb"},{"name":"RunLoop","_id":"cj3r8htqn002jjigb5frpmjw1"},{"name":"Block","_id":"cj3r8htqo002ljigbzne3q7cc"},{"name":"循环引用","_id":"cj3r8htqp002njigbqx8ya082"},{"name":"CAAnimation","_id":"cj3r8htqp002ojigbhbgt0x2d"},{"name":"核心动画","_id":"cj3r8htqq002rjigblpqbtzrj"},{"name":"计时器","_id":"cj3r8htqt002wjigbdm025jwh"},{"name":"CAShapeLayer","_id":"cj3r8htqw0032jigbtcgvfoma"},{"name":"CATextLayer","_id":"cj3r8htqx0033jigbr6wbchiy"},{"name":"动画","_id":"cj3r8htr1003ajigbjublhphj"},{"name":"图层效果","_id":"cj3r8htr5003gjigbrrzb7br5"},{"name":"粒子效果","_id":"cj3r8htr7003mjigbt9bna3m5"},{"name":"大图绘制","_id":"cj3r8htr8003njigb56hso7i3"},{"name":"异步绘制","_id":"cj3r8htr8003ojigbwv0hhb4e"},{"name":"中文排序","_id":"cj3r8htr9003pjigbgjbz45c4"}]}}